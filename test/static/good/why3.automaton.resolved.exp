State 0:
## Known stack suffix:
##
## LR(1) items:
ident_comma_list_eof' -> . ident_comma_list_eof [ # ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 40
-- On separated_nonempty_list(COMMA,ident) shift to state 41
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident_comma_list_eof shift to state 45
-- On ident shift to state 46
-- On comma_list1(ident) shift to state 49
## Reductions:

State 1:
## Known stack suffix:
## UIDENT
## LR(1) items:
uident -> UIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL GHOST FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production uident -> UIDENT
-- On WITH reduce production uident -> UIDENT
-- On VARIANT reduce production uident -> UIDENT
-- On VAL reduce production uident -> UIDENT
-- On USE reduce production uident -> UIDENT
-- On UNDERSCORE reduce production uident -> UIDENT
-- On UIDENT reduce production uident -> UIDENT
-- On TYPE reduce production uident -> UIDENT
-- On TRUE reduce production uident -> UIDENT
-- On TO reduce production uident -> UIDENT
-- On THEN reduce production uident -> UIDENT
-- On STRING reduce production uident -> UIDENT
-- On SO reduce production uident -> UIDENT
-- On SEMICOLON reduce production uident -> UIDENT
-- On SCOPE reduce production uident -> UIDENT
-- On RIGHTSQ_QUOTE reduce production uident -> UIDENT
-- On RIGHTSQ reduce production uident -> UIDENT
-- On RIGHTPAR reduce production uident -> UIDENT
-- On RIGHTBRC reduce production uident -> UIDENT
-- On RETURNS reduce production uident -> UIDENT
-- On REQUIRES reduce production uident -> UIDENT
-- On REAL reduce production uident -> UIDENT
-- On READS reduce production uident -> UIDENT
-- On RANGE reduce production uident -> UIDENT
-- On RAISES reduce production uident -> UIDENT
-- On QUOTE_LIDENT reduce production uident -> UIDENT
-- On PURE reduce production uident -> UIDENT
-- On PREDICATE reduce production uident -> UIDENT
-- On POSITION reduce production uident -> UIDENT
-- On OR reduce production uident -> UIDENT
-- On OPPREF reduce production uident -> UIDENT
-- On OP4 reduce production uident -> UIDENT
-- On OP3 reduce production uident -> UIDENT
-- On OP2 reduce production uident -> UIDENT
-- On OP1 reduce production uident -> UIDENT
-- On MINUS reduce production uident -> UIDENT
-- On META reduce production uident -> UIDENT
-- On LTGT reduce production uident -> UIDENT
-- On LT reduce production uident -> UIDENT
-- On LRARROW reduce production uident -> UIDENT
-- On LIDENT reduce production uident -> UIDENT
-- On LET reduce production uident -> UIDENT
-- On LEMMA reduce production uident -> UIDENT
-- On LEFTSQ reduce production uident -> UIDENT
-- On LEFTPAR reduce production uident -> UIDENT
-- On LEFTBRC reduce production uident -> UIDENT
-- On LARROW reduce production uident -> UIDENT
-- On INTEGER reduce production uident -> UIDENT
-- On INDUCTIVE reduce production uident -> UIDENT
-- On IN reduce production uident -> UIDENT
-- On IMPORT reduce production uident -> UIDENT
-- On GT reduce production uident -> UIDENT
-- On GOAL reduce production uident -> UIDENT
-- On GHOST reduce production uident -> UIDENT
-- On FUNCTION reduce production uident -> UIDENT
-- On FLOAT reduce production uident -> UIDENT
-- On FALSE reduce production uident -> UIDENT
-- On EXCEPTION reduce production uident -> UIDENT
-- On EQUAL reduce production uident -> UIDENT
-- On EOF reduce production uident -> UIDENT
-- On ENSURES reduce production uident -> UIDENT
-- On END reduce production uident -> UIDENT
-- On ELSE reduce production uident -> UIDENT
-- On DOWNTO reduce production uident -> UIDENT
-- On DOTDOT reduce production uident -> UIDENT
-- On DOT reduce production uident -> UIDENT
-- On DONE reduce production uident -> UIDENT
-- On DO reduce production uident -> UIDENT
-- On DIVERGES reduce production uident -> UIDENT
-- On CORE_UIDENT reduce production uident -> UIDENT
-- On CORE_LIDENT reduce production uident -> UIDENT
-- On CONSTANT reduce production uident -> UIDENT
-- On COMMA reduce production uident -> UIDENT
-- On COLON reduce production uident -> UIDENT
-- On COINDUCTIVE reduce production uident -> UIDENT
-- On CLONE reduce production uident -> UIDENT
-- On BY reduce production uident -> UIDENT
-- On BEGIN reduce production uident -> UIDENT
-- On BARBAR reduce production uident -> UIDENT
-- On BAR reduce production uident -> UIDENT
-- On AXIOM reduce production uident -> UIDENT
-- On ATTRIBUTE reduce production uident -> UIDENT
-- On AT reduce production uident -> UIDENT
-- On AS reduce production uident -> UIDENT
-- On ARROW reduce production uident -> UIDENT
-- On AND reduce production uident -> UIDENT
-- On AMPAMP reduce production uident -> UIDENT
-- On ALIAS reduce production uident -> UIDENT

State 2:
## Known stack suffix:
## RANGE
## LR(1) items:
lident_keyword -> RANGE . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_keyword -> RANGE
-- On WITH reduce production lident_keyword -> RANGE
-- On VARIANT reduce production lident_keyword -> RANGE
-- On VAL reduce production lident_keyword -> RANGE
-- On USE reduce production lident_keyword -> RANGE
-- On UNDERSCORE reduce production lident_keyword -> RANGE
-- On UIDENT reduce production lident_keyword -> RANGE
-- On TYPE reduce production lident_keyword -> RANGE
-- On TRUE reduce production lident_keyword -> RANGE
-- On TO reduce production lident_keyword -> RANGE
-- On THEN reduce production lident_keyword -> RANGE
-- On STRING reduce production lident_keyword -> RANGE
-- On SO reduce production lident_keyword -> RANGE
-- On SEMICOLON reduce production lident_keyword -> RANGE
-- On SCOPE reduce production lident_keyword -> RANGE
-- On RIGHTSQ_QUOTE reduce production lident_keyword -> RANGE
-- On RIGHTSQ reduce production lident_keyword -> RANGE
-- On RIGHTPAR reduce production lident_keyword -> RANGE
-- On RIGHTBRC reduce production lident_keyword -> RANGE
-- On RETURNS reduce production lident_keyword -> RANGE
-- On REQUIRES reduce production lident_keyword -> RANGE
-- On REAL reduce production lident_keyword -> RANGE
-- On READS reduce production lident_keyword -> RANGE
-- On RANGE reduce production lident_keyword -> RANGE
-- On RAISES reduce production lident_keyword -> RANGE
-- On QUOTE_LIDENT reduce production lident_keyword -> RANGE
-- On PURE reduce production lident_keyword -> RANGE
-- On PREDICATE reduce production lident_keyword -> RANGE
-- On POSITION reduce production lident_keyword -> RANGE
-- On OR reduce production lident_keyword -> RANGE
-- On OPPREF reduce production lident_keyword -> RANGE
-- On OP4 reduce production lident_keyword -> RANGE
-- On OP3 reduce production lident_keyword -> RANGE
-- On OP2 reduce production lident_keyword -> RANGE
-- On OP1 reduce production lident_keyword -> RANGE
-- On MINUS reduce production lident_keyword -> RANGE
-- On META reduce production lident_keyword -> RANGE
-- On LTGT reduce production lident_keyword -> RANGE
-- On LT reduce production lident_keyword -> RANGE
-- On LRARROW reduce production lident_keyword -> RANGE
-- On LIDENT reduce production lident_keyword -> RANGE
-- On LET reduce production lident_keyword -> RANGE
-- On LEMMA reduce production lident_keyword -> RANGE
-- On LEFTSQ reduce production lident_keyword -> RANGE
-- On LEFTPAR reduce production lident_keyword -> RANGE
-- On LEFTBRC reduce production lident_keyword -> RANGE
-- On LARROW reduce production lident_keyword -> RANGE
-- On INVARIANT reduce production lident_keyword -> RANGE
-- On INTEGER reduce production lident_keyword -> RANGE
-- On INDUCTIVE reduce production lident_keyword -> RANGE
-- On IN reduce production lident_keyword -> RANGE
-- On IMPORT reduce production lident_keyword -> RANGE
-- On GT reduce production lident_keyword -> RANGE
-- On GOAL reduce production lident_keyword -> RANGE
-- On FUNCTION reduce production lident_keyword -> RANGE
-- On FLOAT reduce production lident_keyword -> RANGE
-- On FALSE reduce production lident_keyword -> RANGE
-- On EXCEPTION reduce production lident_keyword -> RANGE
-- On EQUAL reduce production lident_keyword -> RANGE
-- On EOF reduce production lident_keyword -> RANGE
-- On ENSURES reduce production lident_keyword -> RANGE
-- On END reduce production lident_keyword -> RANGE
-- On ELSE reduce production lident_keyword -> RANGE
-- On DOWNTO reduce production lident_keyword -> RANGE
-- On DOTDOT reduce production lident_keyword -> RANGE
-- On DOT reduce production lident_keyword -> RANGE
-- On DONE reduce production lident_keyword -> RANGE
-- On DO reduce production lident_keyword -> RANGE
-- On DIVERGES reduce production lident_keyword -> RANGE
-- On CORE_UIDENT reduce production lident_keyword -> RANGE
-- On CORE_LIDENT reduce production lident_keyword -> RANGE
-- On CONSTANT reduce production lident_keyword -> RANGE
-- On COMMA reduce production lident_keyword -> RANGE
-- On COLON reduce production lident_keyword -> RANGE
-- On COINDUCTIVE reduce production lident_keyword -> RANGE
-- On CLONE reduce production lident_keyword -> RANGE
-- On BY reduce production lident_keyword -> RANGE
-- On BEGIN reduce production lident_keyword -> RANGE
-- On BARBAR reduce production lident_keyword -> RANGE
-- On BAR reduce production lident_keyword -> RANGE
-- On AXIOM reduce production lident_keyword -> RANGE
-- On ATTRIBUTE reduce production lident_keyword -> RANGE
-- On AT reduce production lident_keyword -> RANGE
-- On AS reduce production lident_keyword -> RANGE
-- On ARROW reduce production lident_keyword -> RANGE
-- On AND reduce production lident_keyword -> RANGE
-- On AMPAMP reduce production lident_keyword -> RANGE
-- On ALIAS reduce production lident_keyword -> RANGE

State 3:
## Known stack suffix:
## LIDENT
## LR(1) items:
lident -> LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident -> LIDENT
-- On WITH reduce production lident -> LIDENT
-- On VARIANT reduce production lident -> LIDENT
-- On VAL reduce production lident -> LIDENT
-- On USE reduce production lident -> LIDENT
-- On UNDERSCORE reduce production lident -> LIDENT
-- On UIDENT reduce production lident -> LIDENT
-- On TYPE reduce production lident -> LIDENT
-- On TRUE reduce production lident -> LIDENT
-- On TO reduce production lident -> LIDENT
-- On THEN reduce production lident -> LIDENT
-- On STRING reduce production lident -> LIDENT
-- On SO reduce production lident -> LIDENT
-- On SEMICOLON reduce production lident -> LIDENT
-- On SCOPE reduce production lident -> LIDENT
-- On RIGHTSQ_QUOTE reduce production lident -> LIDENT
-- On RIGHTSQ reduce production lident -> LIDENT
-- On RIGHTPAR reduce production lident -> LIDENT
-- On RIGHTBRC reduce production lident -> LIDENT
-- On RETURNS reduce production lident -> LIDENT
-- On REQUIRES reduce production lident -> LIDENT
-- On REAL reduce production lident -> LIDENT
-- On READS reduce production lident -> LIDENT
-- On RANGE reduce production lident -> LIDENT
-- On RAISES reduce production lident -> LIDENT
-- On QUOTE_LIDENT reduce production lident -> LIDENT
-- On PURE reduce production lident -> LIDENT
-- On PREDICATE reduce production lident -> LIDENT
-- On POSITION reduce production lident -> LIDENT
-- On OR reduce production lident -> LIDENT
-- On OPPREF reduce production lident -> LIDENT
-- On OP4 reduce production lident -> LIDENT
-- On OP3 reduce production lident -> LIDENT
-- On OP2 reduce production lident -> LIDENT
-- On OP1 reduce production lident -> LIDENT
-- On MINUS reduce production lident -> LIDENT
-- On META reduce production lident -> LIDENT
-- On LTGT reduce production lident -> LIDENT
-- On LT reduce production lident -> LIDENT
-- On LRARROW reduce production lident -> LIDENT
-- On LIDENT reduce production lident -> LIDENT
-- On LET reduce production lident -> LIDENT
-- On LEMMA reduce production lident -> LIDENT
-- On LEFTSQ reduce production lident -> LIDENT
-- On LEFTPAR reduce production lident -> LIDENT
-- On LEFTBRC reduce production lident -> LIDENT
-- On LARROW reduce production lident -> LIDENT
-- On INVARIANT reduce production lident -> LIDENT
-- On INTEGER reduce production lident -> LIDENT
-- On INDUCTIVE reduce production lident -> LIDENT
-- On IN reduce production lident -> LIDENT
-- On IMPORT reduce production lident -> LIDENT
-- On GT reduce production lident -> LIDENT
-- On GOAL reduce production lident -> LIDENT
-- On FUNCTION reduce production lident -> LIDENT
-- On FLOAT reduce production lident -> LIDENT
-- On FALSE reduce production lident -> LIDENT
-- On EXCEPTION reduce production lident -> LIDENT
-- On EQUAL reduce production lident -> LIDENT
-- On EOF reduce production lident -> LIDENT
-- On ENSURES reduce production lident -> LIDENT
-- On END reduce production lident -> LIDENT
-- On ELSE reduce production lident -> LIDENT
-- On DOWNTO reduce production lident -> LIDENT
-- On DOTDOT reduce production lident -> LIDENT
-- On DOT reduce production lident -> LIDENT
-- On DONE reduce production lident -> LIDENT
-- On DO reduce production lident -> LIDENT
-- On DIVERGES reduce production lident -> LIDENT
-- On CORE_UIDENT reduce production lident -> LIDENT
-- On CORE_LIDENT reduce production lident -> LIDENT
-- On CONSTANT reduce production lident -> LIDENT
-- On COMMA reduce production lident -> LIDENT
-- On COLON reduce production lident -> LIDENT
-- On COINDUCTIVE reduce production lident -> LIDENT
-- On CLONE reduce production lident -> LIDENT
-- On BY reduce production lident -> LIDENT
-- On BEGIN reduce production lident -> LIDENT
-- On BARBAR reduce production lident -> LIDENT
-- On BAR reduce production lident -> LIDENT
-- On AXIOM reduce production lident -> LIDENT
-- On ATTRIBUTE reduce production lident -> LIDENT
-- On AT reduce production lident -> LIDENT
-- On AS reduce production lident -> LIDENT
-- On ARROW reduce production lident -> LIDENT
-- On AND reduce production lident -> LIDENT
-- On AMPAMP reduce production lident -> LIDENT
-- On ALIAS reduce production lident -> LIDENT

State 4:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
lident_op -> LEFTPAR . lident_op_str RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR_USCORE [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR_QUOTE [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On OPPREF shift to state 5
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On MINUS shift to state 12
-- On LT shift to state 14
-- On LEFTSQ shift to state 15
-- On GT shift to state 29
-- On EQUAL shift to state 30
-- On op_symbol shift to state 31
-- On lident_op_str shift to state 33
## Reductions:

State 5:
## Known stack suffix:
## OPPREF
## LR(1) items:
lident_op_str -> OPPREF . option(UNDERSCORE) [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 6
-- On option(UNDERSCORE) shift to state 7
## Reductions:
-- On RIGHTPAR_USCORE reduce production option(UNDERSCORE) ->
-- On RIGHTPAR_QUOTE reduce production option(UNDERSCORE) ->
-- On RIGHTPAR reduce production option(UNDERSCORE) ->

State 6:
## Known stack suffix:
## UNDERSCORE
## LR(1) items:
option(UNDERSCORE) -> UNDERSCORE . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE reduce production option(UNDERSCORE) -> UNDERSCORE
-- On RIGHTPAR_QUOTE reduce production option(UNDERSCORE) -> UNDERSCORE
-- On RIGHTPAR reduce production option(UNDERSCORE) -> UNDERSCORE

State 7:
## Known stack suffix:
## OPPREF option(UNDERSCORE)
## LR(1) items:
lident_op_str -> OPPREF option(UNDERSCORE) . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE reduce production lident_op_str -> OPPREF option(UNDERSCORE)
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> OPPREF option(UNDERSCORE)
-- On RIGHTPAR reduce production lident_op_str -> OPPREF option(UNDERSCORE)

State 8:
## Known stack suffix:
## OP4
## LR(1) items:
op_symbol -> OP4 . [ WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE reduce production op_symbol -> OP4
-- On VAL reduce production op_symbol -> OP4
-- On UNDERSCORE reduce production op_symbol -> OP4
-- On UIDENT reduce production op_symbol -> OP4
-- On TRY reduce production op_symbol -> OP4
-- On TRUE reduce production op_symbol -> OP4
-- On RIGHTPAR_USCORE reduce production op_symbol -> OP4
-- On RIGHTPAR_QUOTE reduce production op_symbol -> OP4
-- On RIGHTPAR reduce production op_symbol -> OP4
-- On RETURN reduce production op_symbol -> OP4
-- On REAL reduce production op_symbol -> OP4
-- On RANGE reduce production op_symbol -> OP4
-- On RAISE reduce production op_symbol -> OP4
-- On PURE reduce production op_symbol -> OP4
-- On POSITION reduce production op_symbol -> OP4
-- On OPPREF reduce production op_symbol -> OP4
-- On OP4 reduce production op_symbol -> OP4
-- On OP3 reduce production op_symbol -> OP4
-- On OP2 reduce production op_symbol -> OP4
-- On OP1 reduce production op_symbol -> OP4
-- On OLD reduce production op_symbol -> OP4
-- On NOT reduce production op_symbol -> OP4
-- On MINUS reduce production op_symbol -> OP4
-- On MATCH reduce production op_symbol -> OP4
-- On LT reduce production op_symbol -> OP4
-- On LIDENT reduce production op_symbol -> OP4
-- On LET reduce production op_symbol -> OP4
-- On LEFTPAR reduce production op_symbol -> OP4
-- On LEFTBRC reduce production op_symbol -> OP4
-- On LABEL reduce production op_symbol -> OP4
-- On INTEGER reduce production op_symbol -> OP4
-- On IF reduce production op_symbol -> OP4
-- On GT reduce production op_symbol -> OP4
-- On GHOST reduce production op_symbol -> OP4
-- On FUN reduce production op_symbol -> OP4
-- On FORALL reduce production op_symbol -> OP4
-- On FOR reduce production op_symbol -> OP4
-- On FLOAT reduce production op_symbol -> OP4
-- On FALSE reduce production op_symbol -> OP4
-- On EXISTS reduce production op_symbol -> OP4
-- On EXCEPTION reduce production op_symbol -> OP4
-- On EPSILON reduce production op_symbol -> OP4
-- On CORE_UIDENT reduce production op_symbol -> OP4
-- On CORE_LIDENT reduce production op_symbol -> OP4
-- On CONTINUE reduce production op_symbol -> OP4
-- On CHECK reduce production op_symbol -> OP4
-- On BREAK reduce production op_symbol -> OP4
-- On BEGIN reduce production op_symbol -> OP4
-- On ATTRIBUTE reduce production op_symbol -> OP4
-- On ASSUME reduce production op_symbol -> OP4
-- On ASSERT reduce production op_symbol -> OP4
-- On ANY reduce production op_symbol -> OP4
-- On ABSURD reduce production op_symbol -> OP4

State 9:
## Known stack suffix:
## OP3
## LR(1) items:
op_symbol -> OP3 . [ WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE reduce production op_symbol -> OP3
-- On VAL reduce production op_symbol -> OP3
-- On UNDERSCORE reduce production op_symbol -> OP3
-- On UIDENT reduce production op_symbol -> OP3
-- On TRY reduce production op_symbol -> OP3
-- On TRUE reduce production op_symbol -> OP3
-- On RIGHTPAR_USCORE reduce production op_symbol -> OP3
-- On RIGHTPAR_QUOTE reduce production op_symbol -> OP3
-- On RIGHTPAR reduce production op_symbol -> OP3
-- On RETURN reduce production op_symbol -> OP3
-- On REAL reduce production op_symbol -> OP3
-- On RANGE reduce production op_symbol -> OP3
-- On RAISE reduce production op_symbol -> OP3
-- On PURE reduce production op_symbol -> OP3
-- On POSITION reduce production op_symbol -> OP3
-- On OPPREF reduce production op_symbol -> OP3
-- On OP4 reduce production op_symbol -> OP3
-- On OP3 reduce production op_symbol -> OP3
-- On OP2 reduce production op_symbol -> OP3
-- On OP1 reduce production op_symbol -> OP3
-- On OLD reduce production op_symbol -> OP3
-- On NOT reduce production op_symbol -> OP3
-- On MINUS reduce production op_symbol -> OP3
-- On MATCH reduce production op_symbol -> OP3
-- On LT reduce production op_symbol -> OP3
-- On LIDENT reduce production op_symbol -> OP3
-- On LET reduce production op_symbol -> OP3
-- On LEFTPAR reduce production op_symbol -> OP3
-- On LEFTBRC reduce production op_symbol -> OP3
-- On LABEL reduce production op_symbol -> OP3
-- On INTEGER reduce production op_symbol -> OP3
-- On IF reduce production op_symbol -> OP3
-- On GT reduce production op_symbol -> OP3
-- On GHOST reduce production op_symbol -> OP3
-- On FUN reduce production op_symbol -> OP3
-- On FORALL reduce production op_symbol -> OP3
-- On FOR reduce production op_symbol -> OP3
-- On FLOAT reduce production op_symbol -> OP3
-- On FALSE reduce production op_symbol -> OP3
-- On EXISTS reduce production op_symbol -> OP3
-- On EXCEPTION reduce production op_symbol -> OP3
-- On EPSILON reduce production op_symbol -> OP3
-- On CORE_UIDENT reduce production op_symbol -> OP3
-- On CORE_LIDENT reduce production op_symbol -> OP3
-- On CONTINUE reduce production op_symbol -> OP3
-- On CHECK reduce production op_symbol -> OP3
-- On BREAK reduce production op_symbol -> OP3
-- On BEGIN reduce production op_symbol -> OP3
-- On ATTRIBUTE reduce production op_symbol -> OP3
-- On ASSUME reduce production op_symbol -> OP3
-- On ASSERT reduce production op_symbol -> OP3
-- On ANY reduce production op_symbol -> OP3
-- On ABSURD reduce production op_symbol -> OP3

State 10:
## Known stack suffix:
## OP2
## LR(1) items:
op_symbol -> OP2 . [ WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE reduce production op_symbol -> OP2
-- On VAL reduce production op_symbol -> OP2
-- On UNDERSCORE reduce production op_symbol -> OP2
-- On UIDENT reduce production op_symbol -> OP2
-- On TRY reduce production op_symbol -> OP2
-- On TRUE reduce production op_symbol -> OP2
-- On RIGHTPAR_USCORE reduce production op_symbol -> OP2
-- On RIGHTPAR_QUOTE reduce production op_symbol -> OP2
-- On RIGHTPAR reduce production op_symbol -> OP2
-- On RETURN reduce production op_symbol -> OP2
-- On REAL reduce production op_symbol -> OP2
-- On RANGE reduce production op_symbol -> OP2
-- On RAISE reduce production op_symbol -> OP2
-- On PURE reduce production op_symbol -> OP2
-- On POSITION reduce production op_symbol -> OP2
-- On OPPREF reduce production op_symbol -> OP2
-- On OP4 reduce production op_symbol -> OP2
-- On OP3 reduce production op_symbol -> OP2
-- On OP2 reduce production op_symbol -> OP2
-- On OP1 reduce production op_symbol -> OP2
-- On OLD reduce production op_symbol -> OP2
-- On NOT reduce production op_symbol -> OP2
-- On MINUS reduce production op_symbol -> OP2
-- On MATCH reduce production op_symbol -> OP2
-- On LT reduce production op_symbol -> OP2
-- On LIDENT reduce production op_symbol -> OP2
-- On LET reduce production op_symbol -> OP2
-- On LEFTPAR reduce production op_symbol -> OP2
-- On LEFTBRC reduce production op_symbol -> OP2
-- On LABEL reduce production op_symbol -> OP2
-- On INTEGER reduce production op_symbol -> OP2
-- On IF reduce production op_symbol -> OP2
-- On GT reduce production op_symbol -> OP2
-- On GHOST reduce production op_symbol -> OP2
-- On FUN reduce production op_symbol -> OP2
-- On FORALL reduce production op_symbol -> OP2
-- On FOR reduce production op_symbol -> OP2
-- On FLOAT reduce production op_symbol -> OP2
-- On FALSE reduce production op_symbol -> OP2
-- On EXISTS reduce production op_symbol -> OP2
-- On EXCEPTION reduce production op_symbol -> OP2
-- On EPSILON reduce production op_symbol -> OP2
-- On CORE_UIDENT reduce production op_symbol -> OP2
-- On CORE_LIDENT reduce production op_symbol -> OP2
-- On CONTINUE reduce production op_symbol -> OP2
-- On CHECK reduce production op_symbol -> OP2
-- On BREAK reduce production op_symbol -> OP2
-- On BEGIN reduce production op_symbol -> OP2
-- On ATTRIBUTE reduce production op_symbol -> OP2
-- On ASSUME reduce production op_symbol -> OP2
-- On ASSERT reduce production op_symbol -> OP2
-- On ANY reduce production op_symbol -> OP2
-- On ABSURD reduce production op_symbol -> OP2

State 11:
## Known stack suffix:
## OP1
## LR(1) items:
op_symbol -> OP1 . [ WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE reduce production op_symbol -> OP1
-- On VAL reduce production op_symbol -> OP1
-- On UNDERSCORE reduce production op_symbol -> OP1
-- On UIDENT reduce production op_symbol -> OP1
-- On TRY reduce production op_symbol -> OP1
-- On TRUE reduce production op_symbol -> OP1
-- On RIGHTPAR_USCORE reduce production op_symbol -> OP1
-- On RIGHTPAR_QUOTE reduce production op_symbol -> OP1
-- On RIGHTPAR reduce production op_symbol -> OP1
-- On RETURN reduce production op_symbol -> OP1
-- On REAL reduce production op_symbol -> OP1
-- On RANGE reduce production op_symbol -> OP1
-- On RAISE reduce production op_symbol -> OP1
-- On PURE reduce production op_symbol -> OP1
-- On POSITION reduce production op_symbol -> OP1
-- On OPPREF reduce production op_symbol -> OP1
-- On OP4 reduce production op_symbol -> OP1
-- On OP3 reduce production op_symbol -> OP1
-- On OP2 reduce production op_symbol -> OP1
-- On OP1 reduce production op_symbol -> OP1
-- On OLD reduce production op_symbol -> OP1
-- On NOT reduce production op_symbol -> OP1
-- On MINUS reduce production op_symbol -> OP1
-- On MATCH reduce production op_symbol -> OP1
-- On LT reduce production op_symbol -> OP1
-- On LIDENT reduce production op_symbol -> OP1
-- On LET reduce production op_symbol -> OP1
-- On LEFTPAR reduce production op_symbol -> OP1
-- On LEFTBRC reduce production op_symbol -> OP1
-- On LABEL reduce production op_symbol -> OP1
-- On INTEGER reduce production op_symbol -> OP1
-- On IF reduce production op_symbol -> OP1
-- On GT reduce production op_symbol -> OP1
-- On GHOST reduce production op_symbol -> OP1
-- On FUN reduce production op_symbol -> OP1
-- On FORALL reduce production op_symbol -> OP1
-- On FOR reduce production op_symbol -> OP1
-- On FLOAT reduce production op_symbol -> OP1
-- On FALSE reduce production op_symbol -> OP1
-- On EXISTS reduce production op_symbol -> OP1
-- On EXCEPTION reduce production op_symbol -> OP1
-- On EPSILON reduce production op_symbol -> OP1
-- On CORE_UIDENT reduce production op_symbol -> OP1
-- On CORE_LIDENT reduce production op_symbol -> OP1
-- On CONTINUE reduce production op_symbol -> OP1
-- On CHECK reduce production op_symbol -> OP1
-- On BREAK reduce production op_symbol -> OP1
-- On BEGIN reduce production op_symbol -> OP1
-- On ATTRIBUTE reduce production op_symbol -> OP1
-- On ASSUME reduce production op_symbol -> OP1
-- On ASSERT reduce production op_symbol -> OP1
-- On ANY reduce production op_symbol -> OP1
-- On ABSURD reduce production op_symbol -> OP1

State 12:
## Known stack suffix:
## MINUS
## LR(1) items:
lident_op_str -> MINUS . UNDERSCORE [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> MINUS . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 13
## Reductions:
-- On RIGHTPAR_USCORE reduce production lident_op_str -> MINUS
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> MINUS
-- On RIGHTPAR reduce production lident_op_str -> MINUS

State 13:
## Known stack suffix:
## MINUS UNDERSCORE
## LR(1) items:
lident_op_str -> MINUS UNDERSCORE . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE reduce production lident_op_str -> MINUS UNDERSCORE
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> MINUS UNDERSCORE
-- On RIGHTPAR reduce production lident_op_str -> MINUS UNDERSCORE

State 14:
## Known stack suffix:
## LT
## LR(1) items:
op_symbol -> LT . [ WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE reduce production op_symbol -> LT
-- On VAL reduce production op_symbol -> LT
-- On UNDERSCORE reduce production op_symbol -> LT
-- On UIDENT reduce production op_symbol -> LT
-- On TRY reduce production op_symbol -> LT
-- On TRUE reduce production op_symbol -> LT
-- On RIGHTPAR_USCORE reduce production op_symbol -> LT
-- On RIGHTPAR_QUOTE reduce production op_symbol -> LT
-- On RIGHTPAR reduce production op_symbol -> LT
-- On RETURN reduce production op_symbol -> LT
-- On REAL reduce production op_symbol -> LT
-- On RANGE reduce production op_symbol -> LT
-- On RAISE reduce production op_symbol -> LT
-- On PURE reduce production op_symbol -> LT
-- On POSITION reduce production op_symbol -> LT
-- On OPPREF reduce production op_symbol -> LT
-- On OP4 reduce production op_symbol -> LT
-- On OP3 reduce production op_symbol -> LT
-- On OP2 reduce production op_symbol -> LT
-- On OP1 reduce production op_symbol -> LT
-- On OLD reduce production op_symbol -> LT
-- On NOT reduce production op_symbol -> LT
-- On MINUS reduce production op_symbol -> LT
-- On MATCH reduce production op_symbol -> LT
-- On LT reduce production op_symbol -> LT
-- On LIDENT reduce production op_symbol -> LT
-- On LET reduce production op_symbol -> LT
-- On LEFTPAR reduce production op_symbol -> LT
-- On LEFTBRC reduce production op_symbol -> LT
-- On LABEL reduce production op_symbol -> LT
-- On INTEGER reduce production op_symbol -> LT
-- On IF reduce production op_symbol -> LT
-- On GT reduce production op_symbol -> LT
-- On GHOST reduce production op_symbol -> LT
-- On FUN reduce production op_symbol -> LT
-- On FORALL reduce production op_symbol -> LT
-- On FOR reduce production op_symbol -> LT
-- On FLOAT reduce production op_symbol -> LT
-- On FALSE reduce production op_symbol -> LT
-- On EXISTS reduce production op_symbol -> LT
-- On EXCEPTION reduce production op_symbol -> LT
-- On EPSILON reduce production op_symbol -> LT
-- On CORE_UIDENT reduce production op_symbol -> LT
-- On CORE_LIDENT reduce production op_symbol -> LT
-- On CONTINUE reduce production op_symbol -> LT
-- On CHECK reduce production op_symbol -> LT
-- On BREAK reduce production op_symbol -> LT
-- On BEGIN reduce production op_symbol -> LT
-- On ATTRIBUTE reduce production op_symbol -> LT
-- On ASSUME reduce production op_symbol -> LT
-- On ASSERT reduce production op_symbol -> LT
-- On ANY reduce production op_symbol -> LT
-- On ABSURD reduce production op_symbol -> LT

State 15:
## Known stack suffix:
## LEFTSQ
## LR(1) items:
lident_op_str -> LEFTSQ . rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ . rightsq LARROW [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ . LARROW rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ . DOTDOT rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ . UNDERSCORE DOTDOT rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ . DOTDOT UNDERSCORE rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 16
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On LARROW shift to state 21
-- On DOTDOT shift to state 23
-- On rightsq shift to state 27
## Reductions:

State 16:
## Known stack suffix:
## LEFTSQ UNDERSCORE
## LR(1) items:
lident_op_str -> LEFTSQ UNDERSCORE . DOTDOT rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On DOTDOT shift to state 17
## Reductions:

State 17:
## Known stack suffix:
## LEFTSQ UNDERSCORE DOTDOT
## LR(1) items:
lident_op_str -> LEFTSQ UNDERSCORE DOTDOT . rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 20
## Reductions:

State 18:
## Known stack suffix:
## RIGHTSQ_QUOTE
## LR(1) items:
rightsq -> RIGHTSQ_QUOTE . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production rightsq -> RIGHTSQ_QUOTE
-- On WITH reduce production rightsq -> RIGHTSQ_QUOTE
-- On VARIANT reduce production rightsq -> RIGHTSQ_QUOTE
-- On VAL reduce production rightsq -> RIGHTSQ_QUOTE
-- On USE reduce production rightsq -> RIGHTSQ_QUOTE
-- On UIDENT reduce production rightsq -> RIGHTSQ_QUOTE
-- On TYPE reduce production rightsq -> RIGHTSQ_QUOTE
-- On TRUE reduce production rightsq -> RIGHTSQ_QUOTE
-- On TO reduce production rightsq -> RIGHTSQ_QUOTE
-- On THEN reduce production rightsq -> RIGHTSQ_QUOTE
-- On SO reduce production rightsq -> RIGHTSQ_QUOTE
-- On SEMICOLON reduce production rightsq -> RIGHTSQ_QUOTE
-- On SCOPE reduce production rightsq -> RIGHTSQ_QUOTE
-- On RIGHTSQ_QUOTE reduce production rightsq -> RIGHTSQ_QUOTE
-- On RIGHTSQ reduce production rightsq -> RIGHTSQ_QUOTE
-- On RIGHTPAR_USCORE reduce production rightsq -> RIGHTSQ_QUOTE
-- On RIGHTPAR_QUOTE reduce production rightsq -> RIGHTSQ_QUOTE
-- On RIGHTPAR reduce production rightsq -> RIGHTSQ_QUOTE
-- On RIGHTBRC reduce production rightsq -> RIGHTSQ_QUOTE
-- On RETURNS reduce production rightsq -> RIGHTSQ_QUOTE
-- On REQUIRES reduce production rightsq -> RIGHTSQ_QUOTE
-- On REAL reduce production rightsq -> RIGHTSQ_QUOTE
-- On READS reduce production rightsq -> RIGHTSQ_QUOTE
-- On RANGE reduce production rightsq -> RIGHTSQ_QUOTE
-- On RAISES reduce production rightsq -> RIGHTSQ_QUOTE
-- On PURE reduce production rightsq -> RIGHTSQ_QUOTE
-- On PREDICATE reduce production rightsq -> RIGHTSQ_QUOTE
-- On OR reduce production rightsq -> RIGHTSQ_QUOTE
-- On OPPREF reduce production rightsq -> RIGHTSQ_QUOTE
-- On OP4 reduce production rightsq -> RIGHTSQ_QUOTE
-- On OP3 reduce production rightsq -> RIGHTSQ_QUOTE
-- On OP2 reduce production rightsq -> RIGHTSQ_QUOTE
-- On OP1 reduce production rightsq -> RIGHTSQ_QUOTE
-- On MINUS reduce production rightsq -> RIGHTSQ_QUOTE
-- On META reduce production rightsq -> RIGHTSQ_QUOTE
-- On LTGT reduce production rightsq -> RIGHTSQ_QUOTE
-- On LT reduce production rightsq -> RIGHTSQ_QUOTE
-- On LRARROW reduce production rightsq -> RIGHTSQ_QUOTE
-- On LIDENT reduce production rightsq -> RIGHTSQ_QUOTE
-- On LET reduce production rightsq -> RIGHTSQ_QUOTE
-- On LEMMA reduce production rightsq -> RIGHTSQ_QUOTE
-- On LEFTSQ reduce production rightsq -> RIGHTSQ_QUOTE
-- On LEFTPAR reduce production rightsq -> RIGHTSQ_QUOTE
-- On LEFTBRC reduce production rightsq -> RIGHTSQ_QUOTE
-- On LARROW reduce production rightsq -> RIGHTSQ_QUOTE
-- On INTEGER reduce production rightsq -> RIGHTSQ_QUOTE
-- On INDUCTIVE reduce production rightsq -> RIGHTSQ_QUOTE
-- On IN reduce production rightsq -> RIGHTSQ_QUOTE
-- On IMPORT reduce production rightsq -> RIGHTSQ_QUOTE
-- On GT reduce production rightsq -> RIGHTSQ_QUOTE
-- On GOAL reduce production rightsq -> RIGHTSQ_QUOTE
-- On FUNCTION reduce production rightsq -> RIGHTSQ_QUOTE
-- On FLOAT reduce production rightsq -> RIGHTSQ_QUOTE
-- On FALSE reduce production rightsq -> RIGHTSQ_QUOTE
-- On EXCEPTION reduce production rightsq -> RIGHTSQ_QUOTE
-- On EQUAL reduce production rightsq -> RIGHTSQ_QUOTE
-- On EOF reduce production rightsq -> RIGHTSQ_QUOTE
-- On ENSURES reduce production rightsq -> RIGHTSQ_QUOTE
-- On END reduce production rightsq -> RIGHTSQ_QUOTE
-- On ELSE reduce production rightsq -> RIGHTSQ_QUOTE
-- On DOWNTO reduce production rightsq -> RIGHTSQ_QUOTE
-- On DOTDOT reduce production rightsq -> RIGHTSQ_QUOTE
-- On DOT reduce production rightsq -> RIGHTSQ_QUOTE
-- On DONE reduce production rightsq -> RIGHTSQ_QUOTE
-- On DO reduce production rightsq -> RIGHTSQ_QUOTE
-- On DIVERGES reduce production rightsq -> RIGHTSQ_QUOTE
-- On CORE_UIDENT reduce production rightsq -> RIGHTSQ_QUOTE
-- On CORE_LIDENT reduce production rightsq -> RIGHTSQ_QUOTE
-- On CONSTANT reduce production rightsq -> RIGHTSQ_QUOTE
-- On COMMA reduce production rightsq -> RIGHTSQ_QUOTE
-- On COLON reduce production rightsq -> RIGHTSQ_QUOTE
-- On COINDUCTIVE reduce production rightsq -> RIGHTSQ_QUOTE
-- On CLONE reduce production rightsq -> RIGHTSQ_QUOTE
-- On BY reduce production rightsq -> RIGHTSQ_QUOTE
-- On BEGIN reduce production rightsq -> RIGHTSQ_QUOTE
-- On BARBAR reduce production rightsq -> RIGHTSQ_QUOTE
-- On BAR reduce production rightsq -> RIGHTSQ_QUOTE
-- On AXIOM reduce production rightsq -> RIGHTSQ_QUOTE
-- On AT reduce production rightsq -> RIGHTSQ_QUOTE
-- On ARROW reduce production rightsq -> RIGHTSQ_QUOTE
-- On AND reduce production rightsq -> RIGHTSQ_QUOTE
-- On AMPAMP reduce production rightsq -> RIGHTSQ_QUOTE
-- On ALIAS reduce production rightsq -> RIGHTSQ_QUOTE

State 19:
## Known stack suffix:
## RIGHTSQ
## LR(1) items:
rightsq -> RIGHTSQ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production rightsq -> RIGHTSQ
-- On WITH reduce production rightsq -> RIGHTSQ
-- On VARIANT reduce production rightsq -> RIGHTSQ
-- On VAL reduce production rightsq -> RIGHTSQ
-- On USE reduce production rightsq -> RIGHTSQ
-- On UIDENT reduce production rightsq -> RIGHTSQ
-- On TYPE reduce production rightsq -> RIGHTSQ
-- On TRUE reduce production rightsq -> RIGHTSQ
-- On TO reduce production rightsq -> RIGHTSQ
-- On THEN reduce production rightsq -> RIGHTSQ
-- On SO reduce production rightsq -> RIGHTSQ
-- On SEMICOLON reduce production rightsq -> RIGHTSQ
-- On SCOPE reduce production rightsq -> RIGHTSQ
-- On RIGHTSQ_QUOTE reduce production rightsq -> RIGHTSQ
-- On RIGHTSQ reduce production rightsq -> RIGHTSQ
-- On RIGHTPAR_USCORE reduce production rightsq -> RIGHTSQ
-- On RIGHTPAR_QUOTE reduce production rightsq -> RIGHTSQ
-- On RIGHTPAR reduce production rightsq -> RIGHTSQ
-- On RIGHTBRC reduce production rightsq -> RIGHTSQ
-- On RETURNS reduce production rightsq -> RIGHTSQ
-- On REQUIRES reduce production rightsq -> RIGHTSQ
-- On REAL reduce production rightsq -> RIGHTSQ
-- On READS reduce production rightsq -> RIGHTSQ
-- On RANGE reduce production rightsq -> RIGHTSQ
-- On RAISES reduce production rightsq -> RIGHTSQ
-- On PURE reduce production rightsq -> RIGHTSQ
-- On PREDICATE reduce production rightsq -> RIGHTSQ
-- On OR reduce production rightsq -> RIGHTSQ
-- On OPPREF reduce production rightsq -> RIGHTSQ
-- On OP4 reduce production rightsq -> RIGHTSQ
-- On OP3 reduce production rightsq -> RIGHTSQ
-- On OP2 reduce production rightsq -> RIGHTSQ
-- On OP1 reduce production rightsq -> RIGHTSQ
-- On MINUS reduce production rightsq -> RIGHTSQ
-- On META reduce production rightsq -> RIGHTSQ
-- On LTGT reduce production rightsq -> RIGHTSQ
-- On LT reduce production rightsq -> RIGHTSQ
-- On LRARROW reduce production rightsq -> RIGHTSQ
-- On LIDENT reduce production rightsq -> RIGHTSQ
-- On LET reduce production rightsq -> RIGHTSQ
-- On LEMMA reduce production rightsq -> RIGHTSQ
-- On LEFTSQ reduce production rightsq -> RIGHTSQ
-- On LEFTPAR reduce production rightsq -> RIGHTSQ
-- On LEFTBRC reduce production rightsq -> RIGHTSQ
-- On LARROW reduce production rightsq -> RIGHTSQ
-- On INTEGER reduce production rightsq -> RIGHTSQ
-- On INDUCTIVE reduce production rightsq -> RIGHTSQ
-- On IN reduce production rightsq -> RIGHTSQ
-- On IMPORT reduce production rightsq -> RIGHTSQ
-- On GT reduce production rightsq -> RIGHTSQ
-- On GOAL reduce production rightsq -> RIGHTSQ
-- On FUNCTION reduce production rightsq -> RIGHTSQ
-- On FLOAT reduce production rightsq -> RIGHTSQ
-- On FALSE reduce production rightsq -> RIGHTSQ
-- On EXCEPTION reduce production rightsq -> RIGHTSQ
-- On EQUAL reduce production rightsq -> RIGHTSQ
-- On EOF reduce production rightsq -> RIGHTSQ
-- On ENSURES reduce production rightsq -> RIGHTSQ
-- On END reduce production rightsq -> RIGHTSQ
-- On ELSE reduce production rightsq -> RIGHTSQ
-- On DOWNTO reduce production rightsq -> RIGHTSQ
-- On DOTDOT reduce production rightsq -> RIGHTSQ
-- On DOT reduce production rightsq -> RIGHTSQ
-- On DONE reduce production rightsq -> RIGHTSQ
-- On DO reduce production rightsq -> RIGHTSQ
-- On DIVERGES reduce production rightsq -> RIGHTSQ
-- On CORE_UIDENT reduce production rightsq -> RIGHTSQ
-- On CORE_LIDENT reduce production rightsq -> RIGHTSQ
-- On CONSTANT reduce production rightsq -> RIGHTSQ
-- On COMMA reduce production rightsq -> RIGHTSQ
-- On COLON reduce production rightsq -> RIGHTSQ
-- On COINDUCTIVE reduce production rightsq -> RIGHTSQ
-- On CLONE reduce production rightsq -> RIGHTSQ
-- On BY reduce production rightsq -> RIGHTSQ
-- On BEGIN reduce production rightsq -> RIGHTSQ
-- On BARBAR reduce production rightsq -> RIGHTSQ
-- On BAR reduce production rightsq -> RIGHTSQ
-- On AXIOM reduce production rightsq -> RIGHTSQ
-- On AT reduce production rightsq -> RIGHTSQ
-- On ARROW reduce production rightsq -> RIGHTSQ
-- On AND reduce production rightsq -> RIGHTSQ
-- On AMPAMP reduce production rightsq -> RIGHTSQ
-- On ALIAS reduce production rightsq -> RIGHTSQ

State 20:
## Known stack suffix:
## LEFTSQ UNDERSCORE DOTDOT rightsq
## LR(1) items:
lident_op_str -> LEFTSQ UNDERSCORE DOTDOT rightsq . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE reduce production lident_op_str -> LEFTSQ UNDERSCORE DOTDOT rightsq
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> LEFTSQ UNDERSCORE DOTDOT rightsq
-- On RIGHTPAR reduce production lident_op_str -> LEFTSQ UNDERSCORE DOTDOT rightsq

State 21:
## Known stack suffix:
## LEFTSQ LARROW
## LR(1) items:
lident_op_str -> LEFTSQ LARROW . rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 22
## Reductions:

State 22:
## Known stack suffix:
## LEFTSQ LARROW rightsq
## LR(1) items:
lident_op_str -> LEFTSQ LARROW rightsq . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE reduce production lident_op_str -> LEFTSQ LARROW rightsq
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> LEFTSQ LARROW rightsq
-- On RIGHTPAR reduce production lident_op_str -> LEFTSQ LARROW rightsq

State 23:
## Known stack suffix:
## LEFTSQ DOTDOT
## LR(1) items:
lident_op_str -> LEFTSQ DOTDOT . rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ DOTDOT . UNDERSCORE rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 24
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 26
## Reductions:

State 24:
## Known stack suffix:
## LEFTSQ DOTDOT UNDERSCORE
## LR(1) items:
lident_op_str -> LEFTSQ DOTDOT UNDERSCORE . rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 25
## Reductions:

State 25:
## Known stack suffix:
## LEFTSQ DOTDOT UNDERSCORE rightsq
## LR(1) items:
lident_op_str -> LEFTSQ DOTDOT UNDERSCORE rightsq . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE reduce production lident_op_str -> LEFTSQ DOTDOT UNDERSCORE rightsq
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> LEFTSQ DOTDOT UNDERSCORE rightsq
-- On RIGHTPAR reduce production lident_op_str -> LEFTSQ DOTDOT UNDERSCORE rightsq

State 26:
## Known stack suffix:
## LEFTSQ DOTDOT rightsq
## LR(1) items:
lident_op_str -> LEFTSQ DOTDOT rightsq . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE reduce production lident_op_str -> LEFTSQ DOTDOT rightsq
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> LEFTSQ DOTDOT rightsq
-- On RIGHTPAR reduce production lident_op_str -> LEFTSQ DOTDOT rightsq

State 27:
## Known stack suffix:
## LEFTSQ rightsq
## LR(1) items:
lident_op_str -> LEFTSQ rightsq . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ rightsq . LARROW [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On LARROW shift to state 28
## Reductions:
-- On RIGHTPAR_USCORE reduce production lident_op_str -> LEFTSQ rightsq
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> LEFTSQ rightsq
-- On RIGHTPAR reduce production lident_op_str -> LEFTSQ rightsq

State 28:
## Known stack suffix:
## LEFTSQ rightsq LARROW
## LR(1) items:
lident_op_str -> LEFTSQ rightsq LARROW . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE reduce production lident_op_str -> LEFTSQ rightsq LARROW
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> LEFTSQ rightsq LARROW
-- On RIGHTPAR reduce production lident_op_str -> LEFTSQ rightsq LARROW

State 29:
## Known stack suffix:
## GT
## LR(1) items:
op_symbol -> GT . [ WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE reduce production op_symbol -> GT
-- On VAL reduce production op_symbol -> GT
-- On UNDERSCORE reduce production op_symbol -> GT
-- On UIDENT reduce production op_symbol -> GT
-- On TRY reduce production op_symbol -> GT
-- On TRUE reduce production op_symbol -> GT
-- On RIGHTPAR_USCORE reduce production op_symbol -> GT
-- On RIGHTPAR_QUOTE reduce production op_symbol -> GT
-- On RIGHTPAR reduce production op_symbol -> GT
-- On RETURN reduce production op_symbol -> GT
-- On REAL reduce production op_symbol -> GT
-- On RANGE reduce production op_symbol -> GT
-- On RAISE reduce production op_symbol -> GT
-- On PURE reduce production op_symbol -> GT
-- On POSITION reduce production op_symbol -> GT
-- On OPPREF reduce production op_symbol -> GT
-- On OP4 reduce production op_symbol -> GT
-- On OP3 reduce production op_symbol -> GT
-- On OP2 reduce production op_symbol -> GT
-- On OP1 reduce production op_symbol -> GT
-- On OLD reduce production op_symbol -> GT
-- On NOT reduce production op_symbol -> GT
-- On MINUS reduce production op_symbol -> GT
-- On MATCH reduce production op_symbol -> GT
-- On LT reduce production op_symbol -> GT
-- On LIDENT reduce production op_symbol -> GT
-- On LET reduce production op_symbol -> GT
-- On LEFTPAR reduce production op_symbol -> GT
-- On LEFTBRC reduce production op_symbol -> GT
-- On LABEL reduce production op_symbol -> GT
-- On INTEGER reduce production op_symbol -> GT
-- On IF reduce production op_symbol -> GT
-- On GT reduce production op_symbol -> GT
-- On GHOST reduce production op_symbol -> GT
-- On FUN reduce production op_symbol -> GT
-- On FORALL reduce production op_symbol -> GT
-- On FOR reduce production op_symbol -> GT
-- On FLOAT reduce production op_symbol -> GT
-- On FALSE reduce production op_symbol -> GT
-- On EXISTS reduce production op_symbol -> GT
-- On EXCEPTION reduce production op_symbol -> GT
-- On EPSILON reduce production op_symbol -> GT
-- On CORE_UIDENT reduce production op_symbol -> GT
-- On CORE_LIDENT reduce production op_symbol -> GT
-- On CONTINUE reduce production op_symbol -> GT
-- On CHECK reduce production op_symbol -> GT
-- On BREAK reduce production op_symbol -> GT
-- On BEGIN reduce production op_symbol -> GT
-- On ATTRIBUTE reduce production op_symbol -> GT
-- On ASSUME reduce production op_symbol -> GT
-- On ASSERT reduce production op_symbol -> GT
-- On ANY reduce production op_symbol -> GT
-- On ABSURD reduce production op_symbol -> GT

State 30:
## Known stack suffix:
## EQUAL
## LR(1) items:
lident_op_str -> EQUAL . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE reduce production lident_op_str -> EQUAL
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> EQUAL
-- On RIGHTPAR reduce production lident_op_str -> EQUAL

State 31:
## Known stack suffix:
## op_symbol
## LR(1) items:
lident_op_str -> op_symbol . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> op_symbol . UNDERSCORE [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 32
## Reductions:
-- On RIGHTPAR_USCORE reduce production lident_op_str -> op_symbol
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> op_symbol
-- On RIGHTPAR reduce production lident_op_str -> op_symbol

State 32:
## Known stack suffix:
## op_symbol UNDERSCORE
## LR(1) items:
lident_op_str -> op_symbol UNDERSCORE . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE reduce production lident_op_str -> op_symbol UNDERSCORE
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> op_symbol UNDERSCORE
-- On RIGHTPAR reduce production lident_op_str -> op_symbol UNDERSCORE

State 33:
## Known stack suffix:
## LEFTPAR lident_op_str
## LR(1) items:
lident_op -> LEFTPAR lident_op_str . RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
lident_op -> LEFTPAR lident_op_str . RIGHTPAR_USCORE [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
lident_op -> LEFTPAR lident_op_str . RIGHTPAR_QUOTE [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR_USCORE shift to state 34
-- On RIGHTPAR_QUOTE shift to state 35
-- On RIGHTPAR shift to state 36
## Reductions:

State 34:
## Known stack suffix:
## LEFTPAR lident_op_str RIGHTPAR_USCORE
## LR(1) items:
lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On WITH reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On VARIANT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On VAL reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On USE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On UIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On TYPE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On TRUE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On TO reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On THEN reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On SO reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On SEMICOLON reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On SCOPE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On RIGHTSQ_QUOTE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On RIGHTSQ reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On RIGHTPAR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On RIGHTBRC reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On RETURNS reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On REQUIRES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On REAL reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On READS reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On RANGE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On RAISES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On QUOTE_LIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On PURE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On PREDICATE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On OR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On OPPREF reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On OP4 reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On OP3 reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On OP2 reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On OP1 reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On MINUS reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On META reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LTGT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LRARROW reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LET reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LEMMA reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LEFTSQ reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LEFTPAR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LEFTBRC reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LARROW reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On INTEGER reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On INDUCTIVE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On IN reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On IMPORT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On GT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On GOAL reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On FUNCTION reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On FLOAT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On FALSE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On EXCEPTION reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On EQUAL reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On EOF reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On ENSURES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On END reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On ELSE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On DOWNTO reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On DOTDOT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On DOT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On DONE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On DO reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On DIVERGES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On CORE_UIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On CORE_LIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On CONSTANT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On COMMA reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On COLON reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On COINDUCTIVE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On CLONE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On BY reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On BEGIN reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On BARBAR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On BAR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On AXIOM reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On AT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On ARROW reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On AND reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On AMPAMP reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On ALIAS reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE

State 35:
## Known stack suffix:
## LEFTPAR lident_op_str RIGHTPAR_QUOTE
## LR(1) items:
lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On WITH reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On VARIANT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On VAL reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On USE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On UIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On TYPE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On TRUE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On TO reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On THEN reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On SO reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On SEMICOLON reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On SCOPE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On RIGHTSQ_QUOTE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On RIGHTSQ reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On RIGHTPAR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On RIGHTBRC reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On RETURNS reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On REQUIRES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On REAL reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On READS reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On RANGE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On RAISES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On QUOTE_LIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On PURE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On PREDICATE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On OR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On OPPREF reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On OP4 reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On OP3 reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On OP2 reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On OP1 reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On MINUS reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On META reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LTGT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LRARROW reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LET reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LEMMA reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LEFTSQ reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LEFTPAR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LEFTBRC reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LARROW reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On INTEGER reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On INDUCTIVE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On IN reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On IMPORT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On GT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On GOAL reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On FUNCTION reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On FLOAT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On FALSE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On EXCEPTION reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On EQUAL reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On EOF reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On ENSURES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On END reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On ELSE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On DOWNTO reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On DOTDOT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On DOT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On DONE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On DO reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On DIVERGES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On CORE_UIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On CORE_LIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On CONSTANT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On COMMA reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On COLON reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On COINDUCTIVE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On CLONE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On BY reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On BEGIN reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On BARBAR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On BAR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On AXIOM reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On AT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On ARROW reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On AND reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On AMPAMP reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On ALIAS reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE

State 36:
## Known stack suffix:
## LEFTPAR lident_op_str RIGHTPAR
## LR(1) items:
lident_op -> LEFTPAR lident_op_str RIGHTPAR . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On WITH reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On VARIANT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On VAL reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On USE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On UIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On TYPE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On TRUE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On TO reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On THEN reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On SO reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On SEMICOLON reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On SCOPE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On RIGHTSQ reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On RIGHTPAR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On RIGHTBRC reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On RETURNS reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On REQUIRES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On REAL reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On READS reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On RANGE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On RAISES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On QUOTE_LIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On PURE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On PREDICATE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On OR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On OPPREF reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On OP4 reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On OP3 reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On OP2 reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On OP1 reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On MINUS reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On META reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On LTGT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On LT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On LRARROW reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On LIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On LET reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On LEMMA reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On LEFTSQ reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On LEFTPAR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On LEFTBRC reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On LARROW reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On INTEGER reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On INDUCTIVE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On IN reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On IMPORT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On GT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On GOAL reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On FUNCTION reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On FLOAT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On FALSE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On EXCEPTION reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On EQUAL reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On EOF reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On ENSURES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On END reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On ELSE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On DOWNTO reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On DOTDOT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On DOT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On DONE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On DO reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On DIVERGES reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On CORE_UIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On CORE_LIDENT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On CONSTANT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On COMMA reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On COLON reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On COINDUCTIVE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On CLONE reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On BY reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On BEGIN reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On BARBAR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On BAR reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On AXIOM reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On AT reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On ARROW reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On AND reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On AMPAMP reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR
-- On ALIAS reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR

State 37:
## Known stack suffix:
## FLOAT
## LR(1) items:
lident_keyword -> FLOAT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_keyword -> FLOAT
-- On WITH reduce production lident_keyword -> FLOAT
-- On VARIANT reduce production lident_keyword -> FLOAT
-- On VAL reduce production lident_keyword -> FLOAT
-- On USE reduce production lident_keyword -> FLOAT
-- On UNDERSCORE reduce production lident_keyword -> FLOAT
-- On UIDENT reduce production lident_keyword -> FLOAT
-- On TYPE reduce production lident_keyword -> FLOAT
-- On TRUE reduce production lident_keyword -> FLOAT
-- On TO reduce production lident_keyword -> FLOAT
-- On THEN reduce production lident_keyword -> FLOAT
-- On STRING reduce production lident_keyword -> FLOAT
-- On SO reduce production lident_keyword -> FLOAT
-- On SEMICOLON reduce production lident_keyword -> FLOAT
-- On SCOPE reduce production lident_keyword -> FLOAT
-- On RIGHTSQ_QUOTE reduce production lident_keyword -> FLOAT
-- On RIGHTSQ reduce production lident_keyword -> FLOAT
-- On RIGHTPAR reduce production lident_keyword -> FLOAT
-- On RIGHTBRC reduce production lident_keyword -> FLOAT
-- On RETURNS reduce production lident_keyword -> FLOAT
-- On REQUIRES reduce production lident_keyword -> FLOAT
-- On REAL reduce production lident_keyword -> FLOAT
-- On READS reduce production lident_keyword -> FLOAT
-- On RANGE reduce production lident_keyword -> FLOAT
-- On RAISES reduce production lident_keyword -> FLOAT
-- On QUOTE_LIDENT reduce production lident_keyword -> FLOAT
-- On PURE reduce production lident_keyword -> FLOAT
-- On PREDICATE reduce production lident_keyword -> FLOAT
-- On POSITION reduce production lident_keyword -> FLOAT
-- On OR reduce production lident_keyword -> FLOAT
-- On OPPREF reduce production lident_keyword -> FLOAT
-- On OP4 reduce production lident_keyword -> FLOAT
-- On OP3 reduce production lident_keyword -> FLOAT
-- On OP2 reduce production lident_keyword -> FLOAT
-- On OP1 reduce production lident_keyword -> FLOAT
-- On MINUS reduce production lident_keyword -> FLOAT
-- On META reduce production lident_keyword -> FLOAT
-- On LTGT reduce production lident_keyword -> FLOAT
-- On LT reduce production lident_keyword -> FLOAT
-- On LRARROW reduce production lident_keyword -> FLOAT
-- On LIDENT reduce production lident_keyword -> FLOAT
-- On LET reduce production lident_keyword -> FLOAT
-- On LEMMA reduce production lident_keyword -> FLOAT
-- On LEFTSQ reduce production lident_keyword -> FLOAT
-- On LEFTPAR reduce production lident_keyword -> FLOAT
-- On LEFTBRC reduce production lident_keyword -> FLOAT
-- On LARROW reduce production lident_keyword -> FLOAT
-- On INVARIANT reduce production lident_keyword -> FLOAT
-- On INTEGER reduce production lident_keyword -> FLOAT
-- On INDUCTIVE reduce production lident_keyword -> FLOAT
-- On IN reduce production lident_keyword -> FLOAT
-- On IMPORT reduce production lident_keyword -> FLOAT
-- On GT reduce production lident_keyword -> FLOAT
-- On GOAL reduce production lident_keyword -> FLOAT
-- On FUNCTION reduce production lident_keyword -> FLOAT
-- On FLOAT reduce production lident_keyword -> FLOAT
-- On FALSE reduce production lident_keyword -> FLOAT
-- On EXCEPTION reduce production lident_keyword -> FLOAT
-- On EQUAL reduce production lident_keyword -> FLOAT
-- On EOF reduce production lident_keyword -> FLOAT
-- On ENSURES reduce production lident_keyword -> FLOAT
-- On END reduce production lident_keyword -> FLOAT
-- On ELSE reduce production lident_keyword -> FLOAT
-- On DOWNTO reduce production lident_keyword -> FLOAT
-- On DOTDOT reduce production lident_keyword -> FLOAT
-- On DOT reduce production lident_keyword -> FLOAT
-- On DONE reduce production lident_keyword -> FLOAT
-- On DO reduce production lident_keyword -> FLOAT
-- On DIVERGES reduce production lident_keyword -> FLOAT
-- On CORE_UIDENT reduce production lident_keyword -> FLOAT
-- On CORE_LIDENT reduce production lident_keyword -> FLOAT
-- On CONSTANT reduce production lident_keyword -> FLOAT
-- On COMMA reduce production lident_keyword -> FLOAT
-- On COLON reduce production lident_keyword -> FLOAT
-- On COINDUCTIVE reduce production lident_keyword -> FLOAT
-- On CLONE reduce production lident_keyword -> FLOAT
-- On BY reduce production lident_keyword -> FLOAT
-- On BEGIN reduce production lident_keyword -> FLOAT
-- On BARBAR reduce production lident_keyword -> FLOAT
-- On BAR reduce production lident_keyword -> FLOAT
-- On AXIOM reduce production lident_keyword -> FLOAT
-- On ATTRIBUTE reduce production lident_keyword -> FLOAT
-- On AT reduce production lident_keyword -> FLOAT
-- On AS reduce production lident_keyword -> FLOAT
-- On ARROW reduce production lident_keyword -> FLOAT
-- On AND reduce production lident_keyword -> FLOAT
-- On AMPAMP reduce production lident_keyword -> FLOAT
-- On ALIAS reduce production lident_keyword -> FLOAT

State 38:
## Known stack suffix:
## CORE_UIDENT
## LR(1) items:
uident -> CORE_UIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL GHOST FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production uident -> CORE_UIDENT
-- On WITH reduce production uident -> CORE_UIDENT
-- On VARIANT reduce production uident -> CORE_UIDENT
-- On VAL reduce production uident -> CORE_UIDENT
-- On USE reduce production uident -> CORE_UIDENT
-- On UNDERSCORE reduce production uident -> CORE_UIDENT
-- On UIDENT reduce production uident -> CORE_UIDENT
-- On TYPE reduce production uident -> CORE_UIDENT
-- On TRUE reduce production uident -> CORE_UIDENT
-- On TO reduce production uident -> CORE_UIDENT
-- On THEN reduce production uident -> CORE_UIDENT
-- On STRING reduce production uident -> CORE_UIDENT
-- On SO reduce production uident -> CORE_UIDENT
-- On SEMICOLON reduce production uident -> CORE_UIDENT
-- On SCOPE reduce production uident -> CORE_UIDENT
-- On RIGHTSQ_QUOTE reduce production uident -> CORE_UIDENT
-- On RIGHTSQ reduce production uident -> CORE_UIDENT
-- On RIGHTPAR reduce production uident -> CORE_UIDENT
-- On RIGHTBRC reduce production uident -> CORE_UIDENT
-- On RETURNS reduce production uident -> CORE_UIDENT
-- On REQUIRES reduce production uident -> CORE_UIDENT
-- On REAL reduce production uident -> CORE_UIDENT
-- On READS reduce production uident -> CORE_UIDENT
-- On RANGE reduce production uident -> CORE_UIDENT
-- On RAISES reduce production uident -> CORE_UIDENT
-- On QUOTE_LIDENT reduce production uident -> CORE_UIDENT
-- On PURE reduce production uident -> CORE_UIDENT
-- On PREDICATE reduce production uident -> CORE_UIDENT
-- On POSITION reduce production uident -> CORE_UIDENT
-- On OR reduce production uident -> CORE_UIDENT
-- On OPPREF reduce production uident -> CORE_UIDENT
-- On OP4 reduce production uident -> CORE_UIDENT
-- On OP3 reduce production uident -> CORE_UIDENT
-- On OP2 reduce production uident -> CORE_UIDENT
-- On OP1 reduce production uident -> CORE_UIDENT
-- On MINUS reduce production uident -> CORE_UIDENT
-- On META reduce production uident -> CORE_UIDENT
-- On LTGT reduce production uident -> CORE_UIDENT
-- On LT reduce production uident -> CORE_UIDENT
-- On LRARROW reduce production uident -> CORE_UIDENT
-- On LIDENT reduce production uident -> CORE_UIDENT
-- On LET reduce production uident -> CORE_UIDENT
-- On LEMMA reduce production uident -> CORE_UIDENT
-- On LEFTSQ reduce production uident -> CORE_UIDENT
-- On LEFTPAR reduce production uident -> CORE_UIDENT
-- On LEFTBRC reduce production uident -> CORE_UIDENT
-- On LARROW reduce production uident -> CORE_UIDENT
-- On INTEGER reduce production uident -> CORE_UIDENT
-- On INDUCTIVE reduce production uident -> CORE_UIDENT
-- On IN reduce production uident -> CORE_UIDENT
-- On IMPORT reduce production uident -> CORE_UIDENT
-- On GT reduce production uident -> CORE_UIDENT
-- On GOAL reduce production uident -> CORE_UIDENT
-- On GHOST reduce production uident -> CORE_UIDENT
-- On FUNCTION reduce production uident -> CORE_UIDENT
-- On FLOAT reduce production uident -> CORE_UIDENT
-- On FALSE reduce production uident -> CORE_UIDENT
-- On EXCEPTION reduce production uident -> CORE_UIDENT
-- On EQUAL reduce production uident -> CORE_UIDENT
-- On EOF reduce production uident -> CORE_UIDENT
-- On ENSURES reduce production uident -> CORE_UIDENT
-- On END reduce production uident -> CORE_UIDENT
-- On ELSE reduce production uident -> CORE_UIDENT
-- On DOWNTO reduce production uident -> CORE_UIDENT
-- On DOTDOT reduce production uident -> CORE_UIDENT
-- On DOT reduce production uident -> CORE_UIDENT
-- On DONE reduce production uident -> CORE_UIDENT
-- On DO reduce production uident -> CORE_UIDENT
-- On DIVERGES reduce production uident -> CORE_UIDENT
-- On CORE_UIDENT reduce production uident -> CORE_UIDENT
-- On CORE_LIDENT reduce production uident -> CORE_UIDENT
-- On CONSTANT reduce production uident -> CORE_UIDENT
-- On COMMA reduce production uident -> CORE_UIDENT
-- On COLON reduce production uident -> CORE_UIDENT
-- On COINDUCTIVE reduce production uident -> CORE_UIDENT
-- On CLONE reduce production uident -> CORE_UIDENT
-- On BY reduce production uident -> CORE_UIDENT
-- On BEGIN reduce production uident -> CORE_UIDENT
-- On BARBAR reduce production uident -> CORE_UIDENT
-- On BAR reduce production uident -> CORE_UIDENT
-- On AXIOM reduce production uident -> CORE_UIDENT
-- On ATTRIBUTE reduce production uident -> CORE_UIDENT
-- On AT reduce production uident -> CORE_UIDENT
-- On AS reduce production uident -> CORE_UIDENT
-- On ARROW reduce production uident -> CORE_UIDENT
-- On AND reduce production uident -> CORE_UIDENT
-- On AMPAMP reduce production uident -> CORE_UIDENT
-- On ALIAS reduce production uident -> CORE_UIDENT

State 39:
## Known stack suffix:
## CORE_LIDENT
## LR(1) items:
lident -> CORE_LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident -> CORE_LIDENT
-- On WITH reduce production lident -> CORE_LIDENT
-- On VARIANT reduce production lident -> CORE_LIDENT
-- On VAL reduce production lident -> CORE_LIDENT
-- On USE reduce production lident -> CORE_LIDENT
-- On UNDERSCORE reduce production lident -> CORE_LIDENT
-- On UIDENT reduce production lident -> CORE_LIDENT
-- On TYPE reduce production lident -> CORE_LIDENT
-- On TRUE reduce production lident -> CORE_LIDENT
-- On TO reduce production lident -> CORE_LIDENT
-- On THEN reduce production lident -> CORE_LIDENT
-- On STRING reduce production lident -> CORE_LIDENT
-- On SO reduce production lident -> CORE_LIDENT
-- On SEMICOLON reduce production lident -> CORE_LIDENT
-- On SCOPE reduce production lident -> CORE_LIDENT
-- On RIGHTSQ_QUOTE reduce production lident -> CORE_LIDENT
-- On RIGHTSQ reduce production lident -> CORE_LIDENT
-- On RIGHTPAR reduce production lident -> CORE_LIDENT
-- On RIGHTBRC reduce production lident -> CORE_LIDENT
-- On RETURNS reduce production lident -> CORE_LIDENT
-- On REQUIRES reduce production lident -> CORE_LIDENT
-- On REAL reduce production lident -> CORE_LIDENT
-- On READS reduce production lident -> CORE_LIDENT
-- On RANGE reduce production lident -> CORE_LIDENT
-- On RAISES reduce production lident -> CORE_LIDENT
-- On QUOTE_LIDENT reduce production lident -> CORE_LIDENT
-- On PURE reduce production lident -> CORE_LIDENT
-- On PREDICATE reduce production lident -> CORE_LIDENT
-- On POSITION reduce production lident -> CORE_LIDENT
-- On OR reduce production lident -> CORE_LIDENT
-- On OPPREF reduce production lident -> CORE_LIDENT
-- On OP4 reduce production lident -> CORE_LIDENT
-- On OP3 reduce production lident -> CORE_LIDENT
-- On OP2 reduce production lident -> CORE_LIDENT
-- On OP1 reduce production lident -> CORE_LIDENT
-- On MINUS reduce production lident -> CORE_LIDENT
-- On META reduce production lident -> CORE_LIDENT
-- On LTGT reduce production lident -> CORE_LIDENT
-- On LT reduce production lident -> CORE_LIDENT
-- On LRARROW reduce production lident -> CORE_LIDENT
-- On LIDENT reduce production lident -> CORE_LIDENT
-- On LET reduce production lident -> CORE_LIDENT
-- On LEMMA reduce production lident -> CORE_LIDENT
-- On LEFTSQ reduce production lident -> CORE_LIDENT
-- On LEFTPAR reduce production lident -> CORE_LIDENT
-- On LEFTBRC reduce production lident -> CORE_LIDENT
-- On LARROW reduce production lident -> CORE_LIDENT
-- On INVARIANT reduce production lident -> CORE_LIDENT
-- On INTEGER reduce production lident -> CORE_LIDENT
-- On INDUCTIVE reduce production lident -> CORE_LIDENT
-- On IN reduce production lident -> CORE_LIDENT
-- On IMPORT reduce production lident -> CORE_LIDENT
-- On GT reduce production lident -> CORE_LIDENT
-- On GOAL reduce production lident -> CORE_LIDENT
-- On FUNCTION reduce production lident -> CORE_LIDENT
-- On FLOAT reduce production lident -> CORE_LIDENT
-- On FALSE reduce production lident -> CORE_LIDENT
-- On EXCEPTION reduce production lident -> CORE_LIDENT
-- On EQUAL reduce production lident -> CORE_LIDENT
-- On EOF reduce production lident -> CORE_LIDENT
-- On ENSURES reduce production lident -> CORE_LIDENT
-- On END reduce production lident -> CORE_LIDENT
-- On ELSE reduce production lident -> CORE_LIDENT
-- On DOWNTO reduce production lident -> CORE_LIDENT
-- On DOTDOT reduce production lident -> CORE_LIDENT
-- On DOT reduce production lident -> CORE_LIDENT
-- On DONE reduce production lident -> CORE_LIDENT
-- On DO reduce production lident -> CORE_LIDENT
-- On DIVERGES reduce production lident -> CORE_LIDENT
-- On CORE_UIDENT reduce production lident -> CORE_LIDENT
-- On CORE_LIDENT reduce production lident -> CORE_LIDENT
-- On CONSTANT reduce production lident -> CORE_LIDENT
-- On COMMA reduce production lident -> CORE_LIDENT
-- On COLON reduce production lident -> CORE_LIDENT
-- On COINDUCTIVE reduce production lident -> CORE_LIDENT
-- On CLONE reduce production lident -> CORE_LIDENT
-- On BY reduce production lident -> CORE_LIDENT
-- On BEGIN reduce production lident -> CORE_LIDENT
-- On BARBAR reduce production lident -> CORE_LIDENT
-- On BAR reduce production lident -> CORE_LIDENT
-- On AXIOM reduce production lident -> CORE_LIDENT
-- On ATTRIBUTE reduce production lident -> CORE_LIDENT
-- On AT reduce production lident -> CORE_LIDENT
-- On AS reduce production lident -> CORE_LIDENT
-- On ARROW reduce production lident -> CORE_LIDENT
-- On AND reduce production lident -> CORE_LIDENT
-- On AMPAMP reduce production lident -> CORE_LIDENT
-- On ALIAS reduce production lident -> CORE_LIDENT

State 40:
## Known stack suffix:
## uident
## LR(1) items:
ident -> uident . [ RIGHTBRC EOF COMMA ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production ident -> uident
-- On EOF reduce production ident -> uident
-- On COMMA reduce production ident -> uident

State 41:
## Known stack suffix:
## separated_nonempty_list(COMMA,ident)
## LR(1) items:
comma_list1(ident) -> separated_nonempty_list(COMMA,ident) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF reduce production comma_list1(ident) -> separated_nonempty_list(COMMA,ident)

State 42:
## Known stack suffix:
## lident_op
## LR(1) items:
ident -> lident_op . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production ident -> lident_op
-- On WITH reduce production ident -> lident_op
-- On VARIANT reduce production ident -> lident_op
-- On VAL reduce production ident -> lident_op
-- On USE reduce production ident -> lident_op
-- On UIDENT reduce production ident -> lident_op
-- On TYPE reduce production ident -> lident_op
-- On TRUE reduce production ident -> lident_op
-- On TO reduce production ident -> lident_op
-- On THEN reduce production ident -> lident_op
-- On SO reduce production ident -> lident_op
-- On SEMICOLON reduce production ident -> lident_op
-- On SCOPE reduce production ident -> lident_op
-- On RIGHTSQ_QUOTE reduce production ident -> lident_op
-- On RIGHTSQ reduce production ident -> lident_op
-- On RIGHTPAR reduce production ident -> lident_op
-- On RIGHTBRC reduce production ident -> lident_op
-- On RETURNS reduce production ident -> lident_op
-- On REQUIRES reduce production ident -> lident_op
-- On REAL reduce production ident -> lident_op
-- On READS reduce production ident -> lident_op
-- On RANGE reduce production ident -> lident_op
-- On RAISES reduce production ident -> lident_op
-- On QUOTE_LIDENT reduce production ident -> lident_op
-- On PURE reduce production ident -> lident_op
-- On PREDICATE reduce production ident -> lident_op
-- On OR reduce production ident -> lident_op
-- On OPPREF reduce production ident -> lident_op
-- On OP4 reduce production ident -> lident_op
-- On OP3 reduce production ident -> lident_op
-- On OP2 reduce production ident -> lident_op
-- On OP1 reduce production ident -> lident_op
-- On MINUS reduce production ident -> lident_op
-- On META reduce production ident -> lident_op
-- On LTGT reduce production ident -> lident_op
-- On LT reduce production ident -> lident_op
-- On LRARROW reduce production ident -> lident_op
-- On LIDENT reduce production ident -> lident_op
-- On LET reduce production ident -> lident_op
-- On LEMMA reduce production ident -> lident_op
-- On LEFTSQ reduce production ident -> lident_op
-- On LEFTPAR reduce production ident -> lident_op
-- On LEFTBRC reduce production ident -> lident_op
-- On LARROW reduce production ident -> lident_op
-- On INTEGER reduce production ident -> lident_op
-- On INDUCTIVE reduce production ident -> lident_op
-- On IN reduce production ident -> lident_op
-- On IMPORT reduce production ident -> lident_op
-- On GT reduce production ident -> lident_op
-- On GOAL reduce production ident -> lident_op
-- On FUNCTION reduce production ident -> lident_op
-- On FLOAT reduce production ident -> lident_op
-- On FALSE reduce production ident -> lident_op
-- On EXCEPTION reduce production ident -> lident_op
-- On EQUAL reduce production ident -> lident_op
-- On EOF reduce production ident -> lident_op
-- On ENSURES reduce production ident -> lident_op
-- On END reduce production ident -> lident_op
-- On ELSE reduce production ident -> lident_op
-- On DOWNTO reduce production ident -> lident_op
-- On DOTDOT reduce production ident -> lident_op
-- On DONE reduce production ident -> lident_op
-- On DO reduce production ident -> lident_op
-- On DIVERGES reduce production ident -> lident_op
-- On CORE_UIDENT reduce production ident -> lident_op
-- On CORE_LIDENT reduce production ident -> lident_op
-- On CONSTANT reduce production ident -> lident_op
-- On COMMA reduce production ident -> lident_op
-- On COLON reduce production ident -> lident_op
-- On COINDUCTIVE reduce production ident -> lident_op
-- On CLONE reduce production ident -> lident_op
-- On BY reduce production ident -> lident_op
-- On BEGIN reduce production ident -> lident_op
-- On BARBAR reduce production ident -> lident_op
-- On BAR reduce production ident -> lident_op
-- On AXIOM reduce production ident -> lident_op
-- On AT reduce production ident -> lident_op
-- On ARROW reduce production ident -> lident_op
-- On AND reduce production ident -> lident_op
-- On AMPAMP reduce production ident -> lident_op
-- On ALIAS reduce production ident -> lident_op

State 43:
## Known stack suffix:
## lident_keyword
## LR(1) items:
lident -> lident_keyword . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident -> lident_keyword
-- On WITH reduce production lident -> lident_keyword
-- On VARIANT reduce production lident -> lident_keyword
-- On VAL reduce production lident -> lident_keyword
-- On USE reduce production lident -> lident_keyword
-- On UNDERSCORE reduce production lident -> lident_keyword
-- On UIDENT reduce production lident -> lident_keyword
-- On TYPE reduce production lident -> lident_keyword
-- On TRUE reduce production lident -> lident_keyword
-- On TO reduce production lident -> lident_keyword
-- On THEN reduce production lident -> lident_keyword
-- On STRING reduce production lident -> lident_keyword
-- On SO reduce production lident -> lident_keyword
-- On SEMICOLON reduce production lident -> lident_keyword
-- On SCOPE reduce production lident -> lident_keyword
-- On RIGHTSQ_QUOTE reduce production lident -> lident_keyword
-- On RIGHTSQ reduce production lident -> lident_keyword
-- On RIGHTPAR reduce production lident -> lident_keyword
-- On RIGHTBRC reduce production lident -> lident_keyword
-- On RETURNS reduce production lident -> lident_keyword
-- On REQUIRES reduce production lident -> lident_keyword
-- On REAL reduce production lident -> lident_keyword
-- On READS reduce production lident -> lident_keyword
-- On RANGE reduce production lident -> lident_keyword
-- On RAISES reduce production lident -> lident_keyword
-- On QUOTE_LIDENT reduce production lident -> lident_keyword
-- On PURE reduce production lident -> lident_keyword
-- On PREDICATE reduce production lident -> lident_keyword
-- On POSITION reduce production lident -> lident_keyword
-- On OR reduce production lident -> lident_keyword
-- On OPPREF reduce production lident -> lident_keyword
-- On OP4 reduce production lident -> lident_keyword
-- On OP3 reduce production lident -> lident_keyword
-- On OP2 reduce production lident -> lident_keyword
-- On OP1 reduce production lident -> lident_keyword
-- On MINUS reduce production lident -> lident_keyword
-- On META reduce production lident -> lident_keyword
-- On LTGT reduce production lident -> lident_keyword
-- On LT reduce production lident -> lident_keyword
-- On LRARROW reduce production lident -> lident_keyword
-- On LIDENT reduce production lident -> lident_keyword
-- On LET reduce production lident -> lident_keyword
-- On LEMMA reduce production lident -> lident_keyword
-- On LEFTSQ reduce production lident -> lident_keyword
-- On LEFTPAR reduce production lident -> lident_keyword
-- On LEFTBRC reduce production lident -> lident_keyword
-- On LARROW reduce production lident -> lident_keyword
-- On INVARIANT reduce production lident -> lident_keyword
-- On INTEGER reduce production lident -> lident_keyword
-- On INDUCTIVE reduce production lident -> lident_keyword
-- On IN reduce production lident -> lident_keyword
-- On IMPORT reduce production lident -> lident_keyword
-- On GT reduce production lident -> lident_keyword
-- On GOAL reduce production lident -> lident_keyword
-- On FUNCTION reduce production lident -> lident_keyword
-- On FLOAT reduce production lident -> lident_keyword
-- On FALSE reduce production lident -> lident_keyword
-- On EXCEPTION reduce production lident -> lident_keyword
-- On EQUAL reduce production lident -> lident_keyword
-- On EOF reduce production lident -> lident_keyword
-- On ENSURES reduce production lident -> lident_keyword
-- On END reduce production lident -> lident_keyword
-- On ELSE reduce production lident -> lident_keyword
-- On DOWNTO reduce production lident -> lident_keyword
-- On DOTDOT reduce production lident -> lident_keyword
-- On DOT reduce production lident -> lident_keyword
-- On DONE reduce production lident -> lident_keyword
-- On DO reduce production lident -> lident_keyword
-- On DIVERGES reduce production lident -> lident_keyword
-- On CORE_UIDENT reduce production lident -> lident_keyword
-- On CORE_LIDENT reduce production lident -> lident_keyword
-- On CONSTANT reduce production lident -> lident_keyword
-- On COMMA reduce production lident -> lident_keyword
-- On COLON reduce production lident -> lident_keyword
-- On COINDUCTIVE reduce production lident -> lident_keyword
-- On CLONE reduce production lident -> lident_keyword
-- On BY reduce production lident -> lident_keyword
-- On BEGIN reduce production lident -> lident_keyword
-- On BARBAR reduce production lident -> lident_keyword
-- On BAR reduce production lident -> lident_keyword
-- On AXIOM reduce production lident -> lident_keyword
-- On ATTRIBUTE reduce production lident -> lident_keyword
-- On AT reduce production lident -> lident_keyword
-- On AS reduce production lident -> lident_keyword
-- On ARROW reduce production lident -> lident_keyword
-- On AND reduce production lident -> lident_keyword
-- On AMPAMP reduce production lident -> lident_keyword
-- On ALIAS reduce production lident -> lident_keyword

State 44:
## Known stack suffix:
## lident
## LR(1) items:
ident -> lident . [ VAL USE TYPE SCOPE RIGHTBRC QUOTE_LIDENT PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production ident -> lident
-- On USE reduce production ident -> lident
-- On TYPE reduce production ident -> lident
-- On SCOPE reduce production ident -> lident
-- On RIGHTBRC reduce production ident -> lident
-- On QUOTE_LIDENT reduce production ident -> lident
-- On PREDICATE reduce production ident -> lident
-- On META reduce production ident -> lident
-- On LET reduce production ident -> lident
-- On LEMMA reduce production ident -> lident
-- On INDUCTIVE reduce production ident -> lident
-- On IMPORT reduce production ident -> lident
-- On GOAL reduce production ident -> lident
-- On FUNCTION reduce production ident -> lident
-- On EXCEPTION reduce production ident -> lident
-- On EQUAL reduce production ident -> lident
-- On EOF reduce production ident -> lident
-- On END reduce production ident -> lident
-- On CONSTANT reduce production ident -> lident
-- On COMMA reduce production ident -> lident
-- On COINDUCTIVE reduce production ident -> lident
-- On CLONE reduce production ident -> lident
-- On AXIOM reduce production ident -> lident

State 45:
## Known stack suffix:
## ident_comma_list_eof
## LR(1) items:
ident_comma_list_eof' -> ident_comma_list_eof . [ # ]
## Transitions:
## Reductions:
-- On # accept ident_comma_list_eof

State 46:
## Known stack suffix:
## ident
## LR(1) items:
separated_nonempty_list(COMMA,ident) -> ident . [ EOF ]
separated_nonempty_list(COMMA,ident) -> ident . COMMA separated_nonempty_list(COMMA,ident) [ EOF ]
## Transitions:
-- On COMMA shift to state 47
## Reductions:
-- On EOF reduce production separated_nonempty_list(COMMA,ident) -> ident

State 47:
## Known stack suffix:
## ident COMMA
## LR(1) items:
separated_nonempty_list(COMMA,ident) -> ident COMMA . separated_nonempty_list(COMMA,ident) [ EOF ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 40
-- On separated_nonempty_list(COMMA,ident) shift to state 48
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 46
## Reductions:

State 48:
## Known stack suffix:
## ident COMMA separated_nonempty_list(COMMA,ident)
## LR(1) items:
separated_nonempty_list(COMMA,ident) -> ident COMMA separated_nonempty_list(COMMA,ident) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF reduce production separated_nonempty_list(COMMA,ident) -> ident COMMA separated_nonempty_list(COMMA,ident)

State 49:
## Known stack suffix:
## comma_list1(ident)
## LR(1) items:
ident_comma_list_eof -> comma_list1(ident) . EOF [ # ]
## Transitions:
-- On EOF shift to state 50
## Reductions:

State 50:
## Known stack suffix:
## comma_list1(ident) EOF
## LR(1) items:
ident_comma_list_eof -> comma_list1(ident) EOF . [ # ]
## Transitions:
## Reductions:
-- On # reduce production ident_comma_list_eof -> comma_list1(ident) EOF

State 51:
## Known stack suffix:
##
## LR(1) items:
mlw_file' -> . mlw_file [ # ]
## Transitions:
-- On VAL shift to state 52
-- On USE shift to state 576
-- On TYPE shift to state 598
-- On THEORY shift to state 995
-- On SCOPE shift to state 997
-- On PREDICATE shift to state 1000
-- On MODULE shift to state 1015
-- On META shift to state 1017
-- On LET shift to state 1041
-- On LEMMA shift to state 1054
-- On INDUCTIVE shift to state 1063
-- On IMPORT shift to state 1083
-- On GOAL shift to state 1085
-- On FUNCTION shift to state 1089
-- On EXCEPTION shift to state 1096
-- On CONSTANT shift to state 1099
-- On COINDUCTIVE shift to state 1104
-- On CLONE shift to state 1106
-- On AXIOM shift to state 1154
-- On use_clone shift to state 1158
-- On scope_head shift to state 1159
-- On pure_decl shift to state 1160
-- On prog_decl shift to state 1161
-- On nonempty_list(module_decl) shift to state 1167
-- On module_head shift to state 1169
-- On module_decl shift to state 1172
-- On mlw_module shift to state 1174
-- On mlw_file shift to state 1176
-- On meta_decl shift to state 1163
-- On list(mlw_module) shift to state 1177
## Reductions:
-- On EOF reduce production list(mlw_module) ->

State 52:
## Known stack suffix:
## VAL
## LR(1) items:
prog_decl -> VAL . ghost kind attrs(lident_rich) mk_expr(val_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On GHOST shift to state 53
-- On ghost shift to state 54
## Reductions:
-- On RANGE reduce production ghost ->
-- On PREDICATE reduce production ghost ->
-- On LIDENT reduce production ghost ->
-- On LEMMA reduce production ghost ->
-- On LEFTPAR reduce production ghost ->
-- On FUNCTION reduce production ghost ->
-- On FLOAT reduce production ghost ->
-- On CORE_LIDENT reduce production ghost ->
-- On CONSTANT reduce production ghost ->

State 53:
## Known stack suffix:
## GHOST
## LR(1) items:
ghost -> GHOST . [ UNDERSCORE UIDENT RANGE PREDICATE LIDENT LEMMA LEFTPAR LEFTBRC FUNCTION FLOAT CORE_UIDENT CORE_LIDENT CONSTANT ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production ghost -> GHOST
-- On UIDENT reduce production ghost -> GHOST
-- On RANGE reduce production ghost -> GHOST
-- On PREDICATE reduce production ghost -> GHOST
-- On LIDENT reduce production ghost -> GHOST
-- On LEMMA reduce production ghost -> GHOST
-- On LEFTPAR reduce production ghost -> GHOST
-- On LEFTBRC reduce production ghost -> GHOST
-- On FUNCTION reduce production ghost -> GHOST
-- On FLOAT reduce production ghost -> GHOST
-- On CORE_UIDENT reduce production ghost -> GHOST
-- On CORE_LIDENT reduce production ghost -> GHOST
-- On CONSTANT reduce production ghost -> GHOST

State 54:
## Known stack suffix:
## VAL ghost
## LR(1) items:
prog_decl -> VAL ghost . kind attrs(lident_rich) mk_expr(val_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On PREDICATE shift to state 55
-- On LEMMA shift to state 56
-- On FUNCTION shift to state 57
-- On CONSTANT shift to state 58
-- On kind shift to state 59
## Reductions:
-- On RANGE reduce production kind ->
-- On LIDENT reduce production kind ->
-- On LEFTPAR reduce production kind ->
-- On FLOAT reduce production kind ->
-- On CORE_LIDENT reduce production kind ->

State 55:
## Known stack suffix:
## PREDICATE
## LR(1) items:
kind -> PREDICATE . [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production kind -> PREDICATE
-- On UIDENT reduce production kind -> PREDICATE
-- On RANGE reduce production kind -> PREDICATE
-- On LIDENT reduce production kind -> PREDICATE
-- On LEFTPAR reduce production kind -> PREDICATE
-- On LEFTBRC reduce production kind -> PREDICATE
-- On FLOAT reduce production kind -> PREDICATE
-- On CORE_UIDENT reduce production kind -> PREDICATE
-- On CORE_LIDENT reduce production kind -> PREDICATE

State 56:
## Known stack suffix:
## LEMMA
## LR(1) items:
kind -> LEMMA . [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production kind -> LEMMA
-- On UIDENT reduce production kind -> LEMMA
-- On RANGE reduce production kind -> LEMMA
-- On LIDENT reduce production kind -> LEMMA
-- On LEFTPAR reduce production kind -> LEMMA
-- On LEFTBRC reduce production kind -> LEMMA
-- On FLOAT reduce production kind -> LEMMA
-- On CORE_UIDENT reduce production kind -> LEMMA
-- On CORE_LIDENT reduce production kind -> LEMMA

State 57:
## Known stack suffix:
## FUNCTION
## LR(1) items:
kind -> FUNCTION . [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production kind -> FUNCTION
-- On UIDENT reduce production kind -> FUNCTION
-- On RANGE reduce production kind -> FUNCTION
-- On LIDENT reduce production kind -> FUNCTION
-- On LEFTPAR reduce production kind -> FUNCTION
-- On LEFTBRC reduce production kind -> FUNCTION
-- On FLOAT reduce production kind -> FUNCTION
-- On CORE_UIDENT reduce production kind -> FUNCTION
-- On CORE_LIDENT reduce production kind -> FUNCTION

State 58:
## Known stack suffix:
## CONSTANT
## LR(1) items:
kind -> CONSTANT . [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production kind -> CONSTANT
-- On UIDENT reduce production kind -> CONSTANT
-- On RANGE reduce production kind -> CONSTANT
-- On LIDENT reduce production kind -> CONSTANT
-- On LEFTPAR reduce production kind -> CONSTANT
-- On LEFTBRC reduce production kind -> CONSTANT
-- On FLOAT reduce production kind -> CONSTANT
-- On CORE_UIDENT reduce production kind -> CONSTANT
-- On CORE_LIDENT reduce production kind -> CONSTANT

State 59:
## Known stack suffix:
## VAL ghost kind
## LR(1) items:
prog_decl -> VAL ghost kind . attrs(lident_rich) mk_expr(val_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On attrs(lident_rich) shift to state 76
## Reductions:

State 60:
## Known stack suffix:
## LIDENT
## LR(1) items:
lident_nq -> LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE AS ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_nq -> LIDENT
-- On WITH reduce production lident_nq -> LIDENT
-- On VARIANT reduce production lident_nq -> LIDENT
-- On VAL reduce production lident_nq -> LIDENT
-- On USE reduce production lident_nq -> LIDENT
-- On UNDERSCORE reduce production lident_nq -> LIDENT
-- On UIDENT reduce production lident_nq -> LIDENT
-- On TYPE reduce production lident_nq -> LIDENT
-- On SEMICOLON reduce production lident_nq -> LIDENT
-- On SCOPE reduce production lident_nq -> LIDENT
-- On RIGHTPAR reduce production lident_nq -> LIDENT
-- On RIGHTBRC reduce production lident_nq -> LIDENT
-- On RETURNS reduce production lident_nq -> LIDENT
-- On REQUIRES reduce production lident_nq -> LIDENT
-- On READS reduce production lident_nq -> LIDENT
-- On RANGE reduce production lident_nq -> LIDENT
-- On RAISES reduce production lident_nq -> LIDENT
-- On QUOTE_LIDENT reduce production lident_nq -> LIDENT
-- On PREDICATE reduce production lident_nq -> LIDENT
-- On POSITION reduce production lident_nq -> LIDENT
-- On META reduce production lident_nq -> LIDENT
-- On LIDENT reduce production lident_nq -> LIDENT
-- On LET reduce production lident_nq -> LIDENT
-- On LEMMA reduce production lident_nq -> LIDENT
-- On LEFTSQ reduce production lident_nq -> LIDENT
-- On LEFTPAR reduce production lident_nq -> LIDENT
-- On LEFTBRC reduce production lident_nq -> LIDENT
-- On INVARIANT reduce production lident_nq -> LIDENT
-- On INDUCTIVE reduce production lident_nq -> LIDENT
-- On IN reduce production lident_nq -> LIDENT
-- On IMPORT reduce production lident_nq -> LIDENT
-- On GOAL reduce production lident_nq -> LIDENT
-- On FUNCTION reduce production lident_nq -> LIDENT
-- On FLOAT reduce production lident_nq -> LIDENT
-- On EXCEPTION reduce production lident_nq -> LIDENT
-- On EQUAL reduce production lident_nq -> LIDENT
-- On EOF reduce production lident_nq -> LIDENT
-- On ENSURES reduce production lident_nq -> LIDENT
-- On END reduce production lident_nq -> LIDENT
-- On DOT reduce production lident_nq -> LIDENT
-- On DIVERGES reduce production lident_nq -> LIDENT
-- On CORE_UIDENT reduce production lident_nq -> LIDENT
-- On CORE_LIDENT reduce production lident_nq -> LIDENT
-- On CONSTANT reduce production lident_nq -> LIDENT
-- On COMMA reduce production lident_nq -> LIDENT
-- On COLON reduce production lident_nq -> LIDENT
-- On COINDUCTIVE reduce production lident_nq -> LIDENT
-- On CLONE reduce production lident_nq -> LIDENT
-- On BY reduce production lident_nq -> LIDENT
-- On BAR reduce production lident_nq -> LIDENT
-- On AXIOM reduce production lident_nq -> LIDENT
-- On ATTRIBUTE reduce production lident_nq -> LIDENT
-- On AS reduce production lident_nq -> LIDENT
-- On ARROW reduce production lident_nq -> LIDENT
-- On ALIAS reduce production lident_nq -> LIDENT

State 61:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
lident_op_nq -> LEFTPAR . lident_op_str RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
lident_op_nq -> LEFTPAR . lident_op_str RIGHTPAR_USCORE [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
lident_op_nq -> LEFTPAR . lident_op_str RIGHTPAR_QUOTE [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
-- On OPPREF shift to state 5
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On MINUS shift to state 12
-- On LT shift to state 14
-- On LEFTSQ shift to state 15
-- On GT shift to state 29
-- On EQUAL shift to state 30
-- On op_symbol shift to state 31
-- On lident_op_str shift to state 62
## Reductions:

State 62:
## Known stack suffix:
## LEFTPAR lident_op_str
## LR(1) items:
lident_op_nq -> LEFTPAR lident_op_str . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
lident_op_nq -> LEFTPAR lident_op_str . RIGHTPAR_USCORE [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
lident_op_nq -> LEFTPAR lident_op_str . RIGHTPAR_QUOTE [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
-- On RIGHTPAR_USCORE shift to state 63
-- On RIGHTPAR_QUOTE shift to state 64
-- On RIGHTPAR shift to state 65
## Reductions:

State 63:
## Known stack suffix:
## LEFTPAR lident_op_str RIGHTPAR_USCORE
## LR(1) items:
lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On WITH reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On VARIANT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On VAL reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On USE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On UNDERSCORE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On UIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On TYPE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On SCOPE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On RETURNS reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On REQUIRES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On READS reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On RANGE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On RAISES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On QUOTE_LIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On PREDICATE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On POSITION reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On META reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LET reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LEMMA reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LEFTPAR reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On LEFTBRC reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On INDUCTIVE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On IN reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On IMPORT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On GOAL reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On FUNCTION reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On FLOAT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On EXCEPTION reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On EQUAL reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On EOF reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On ENSURES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On END reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On DIVERGES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On CORE_UIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On CORE_LIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On CONSTANT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On COLON reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On COINDUCTIVE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On CLONE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On AXIOM reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On ATTRIBUTE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE
-- On ALIAS reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE

State 64:
## Known stack suffix:
## LEFTPAR lident_op_str RIGHTPAR_QUOTE
## LR(1) items:
lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On WITH reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On VARIANT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On VAL reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On USE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On UNDERSCORE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On UIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On TYPE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On SCOPE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On RETURNS reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On REQUIRES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On READS reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On RANGE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On RAISES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On QUOTE_LIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On PREDICATE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On POSITION reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On META reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LET reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LEMMA reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LEFTPAR reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On LEFTBRC reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On INDUCTIVE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On IN reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On IMPORT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On GOAL reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On FUNCTION reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On FLOAT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On EXCEPTION reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On EQUAL reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On EOF reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On ENSURES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On END reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On DIVERGES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On CORE_UIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On CORE_LIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On CONSTANT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On COLON reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On COINDUCTIVE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On CLONE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On AXIOM reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On ATTRIBUTE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE
-- On ALIAS reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE

State 65:
## Known stack suffix:
## LEFTPAR lident_op_str RIGHTPAR
## LR(1) items:
lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On WITH reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On VARIANT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On VAL reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On USE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On UNDERSCORE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On UIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On TYPE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On SCOPE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On RETURNS reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On REQUIRES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On READS reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On RANGE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On RAISES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On QUOTE_LIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On PREDICATE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On POSITION reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On META reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On LIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On LET reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On LEMMA reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On LEFTPAR reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On LEFTBRC reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On INDUCTIVE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On IN reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On IMPORT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On GOAL reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On FUNCTION reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On FLOAT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On EXCEPTION reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On EQUAL reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On EOF reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On ENSURES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On END reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On DIVERGES reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On CORE_UIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On CORE_LIDENT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On CONSTANT reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On COLON reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On COINDUCTIVE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On CLONE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On AXIOM reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On ATTRIBUTE reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR
-- On ALIAS reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR

State 66:
## Known stack suffix:
## CORE_LIDENT
## LR(1) items:
lident_nq -> CORE_LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE AS ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_nq -> CORE_LIDENT
-- On WITH reduce production lident_nq -> CORE_LIDENT
-- On VARIANT reduce production lident_nq -> CORE_LIDENT
-- On VAL reduce production lident_nq -> CORE_LIDENT
-- On USE reduce production lident_nq -> CORE_LIDENT
-- On UNDERSCORE reduce production lident_nq -> CORE_LIDENT
-- On UIDENT reduce production lident_nq -> CORE_LIDENT
-- On TYPE reduce production lident_nq -> CORE_LIDENT
-- On SEMICOLON reduce production lident_nq -> CORE_LIDENT
-- On SCOPE reduce production lident_nq -> CORE_LIDENT
-- On RIGHTPAR reduce production lident_nq -> CORE_LIDENT
-- On RIGHTBRC reduce production lident_nq -> CORE_LIDENT
-- On RETURNS reduce production lident_nq -> CORE_LIDENT
-- On REQUIRES reduce production lident_nq -> CORE_LIDENT
-- On READS reduce production lident_nq -> CORE_LIDENT
-- On RANGE reduce production lident_nq -> CORE_LIDENT
-- On RAISES reduce production lident_nq -> CORE_LIDENT
-- On QUOTE_LIDENT reduce production lident_nq -> CORE_LIDENT
-- On PREDICATE reduce production lident_nq -> CORE_LIDENT
-- On POSITION reduce production lident_nq -> CORE_LIDENT
-- On META reduce production lident_nq -> CORE_LIDENT
-- On LIDENT reduce production lident_nq -> CORE_LIDENT
-- On LET reduce production lident_nq -> CORE_LIDENT
-- On LEMMA reduce production lident_nq -> CORE_LIDENT
-- On LEFTSQ reduce production lident_nq -> CORE_LIDENT
-- On LEFTPAR reduce production lident_nq -> CORE_LIDENT
-- On LEFTBRC reduce production lident_nq -> CORE_LIDENT
-- On INVARIANT reduce production lident_nq -> CORE_LIDENT
-- On INDUCTIVE reduce production lident_nq -> CORE_LIDENT
-- On IN reduce production lident_nq -> CORE_LIDENT
-- On IMPORT reduce production lident_nq -> CORE_LIDENT
-- On GOAL reduce production lident_nq -> CORE_LIDENT
-- On FUNCTION reduce production lident_nq -> CORE_LIDENT
-- On FLOAT reduce production lident_nq -> CORE_LIDENT
-- On EXCEPTION reduce production lident_nq -> CORE_LIDENT
-- On EQUAL reduce production lident_nq -> CORE_LIDENT
-- On EOF reduce production lident_nq -> CORE_LIDENT
-- On ENSURES reduce production lident_nq -> CORE_LIDENT
-- On END reduce production lident_nq -> CORE_LIDENT
-- On DOT reduce production lident_nq -> CORE_LIDENT
-- On DIVERGES reduce production lident_nq -> CORE_LIDENT
-- On CORE_UIDENT reduce production lident_nq -> CORE_LIDENT
-- On CORE_LIDENT reduce production lident_nq -> CORE_LIDENT
-- On CONSTANT reduce production lident_nq -> CORE_LIDENT
-- On COMMA reduce production lident_nq -> CORE_LIDENT
-- On COLON reduce production lident_nq -> CORE_LIDENT
-- On COINDUCTIVE reduce production lident_nq -> CORE_LIDENT
-- On CLONE reduce production lident_nq -> CORE_LIDENT
-- On BY reduce production lident_nq -> CORE_LIDENT
-- On BAR reduce production lident_nq -> CORE_LIDENT
-- On AXIOM reduce production lident_nq -> CORE_LIDENT
-- On ATTRIBUTE reduce production lident_nq -> CORE_LIDENT
-- On AS reduce production lident_nq -> CORE_LIDENT
-- On ARROW reduce production lident_nq -> CORE_LIDENT
-- On ALIAS reduce production lident_nq -> CORE_LIDENT

State 67:
## Known stack suffix:
## lident_rich
## LR(1) items:
attrs(lident_rich) -> lident_rich . list(attr) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ALIAS ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 70
-- On attr shift to state 71
## Reductions:
-- On WRITES reduce production list(attr) ->
-- On WITH reduce production list(attr) ->
-- On VARIANT reduce production list(attr) ->
-- On VAL reduce production list(attr) ->
-- On USE reduce production list(attr) ->
-- On UNDERSCORE reduce production list(attr) ->
-- On UIDENT reduce production list(attr) ->
-- On TYPE reduce production list(attr) ->
-- On SCOPE reduce production list(attr) ->
-- On RETURNS reduce production list(attr) ->
-- On REQUIRES reduce production list(attr) ->
-- On READS reduce production list(attr) ->
-- On RANGE reduce production list(attr) ->
-- On RAISES reduce production list(attr) ->
-- On QUOTE_LIDENT reduce production list(attr) ->
-- On PREDICATE reduce production list(attr) ->
-- On META reduce production list(attr) ->
-- On LIDENT reduce production list(attr) ->
-- On LET reduce production list(attr) ->
-- On LEMMA reduce production list(attr) ->
-- On LEFTPAR reduce production list(attr) ->
-- On LEFTBRC reduce production list(attr) ->
-- On INDUCTIVE reduce production list(attr) ->
-- On IN reduce production list(attr) ->
-- On IMPORT reduce production list(attr) ->
-- On GOAL reduce production list(attr) ->
-- On FUNCTION reduce production list(attr) ->
-- On FLOAT reduce production list(attr) ->
-- On EXCEPTION reduce production list(attr) ->
-- On EQUAL reduce production list(attr) ->
-- On EOF reduce production list(attr) ->
-- On ENSURES reduce production list(attr) ->
-- On END reduce production list(attr) ->
-- On DIVERGES reduce production list(attr) ->
-- On CORE_UIDENT reduce production list(attr) ->
-- On CORE_LIDENT reduce production list(attr) ->
-- On CONSTANT reduce production list(attr) ->
-- On COLON reduce production list(attr) ->
-- On COINDUCTIVE reduce production list(attr) ->
-- On CLONE reduce production list(attr) ->
-- On AXIOM reduce production list(attr) ->
-- On ALIAS reduce production list(attr) ->

State 68:
## Known stack suffix:
## POSITION
## LR(1) items:
attr -> POSITION . [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT TYPE TRY TRUE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE QUOTE_LIDENT PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EQUAL EPSILON EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BY BREAK BEGIN BAR AXIOM ATTRIBUTE ASSUME ASSERT AS ARROW ANY ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production attr -> POSITION
-- On WITH reduce production attr -> POSITION
-- On WHILE reduce production attr -> POSITION
-- On VARIANT reduce production attr -> POSITION
-- On VAL reduce production attr -> POSITION
-- On USE reduce production attr -> POSITION
-- On UNDERSCORE reduce production attr -> POSITION
-- On UIDENT reduce production attr -> POSITION
-- On TYPE reduce production attr -> POSITION
-- On TRY reduce production attr -> POSITION
-- On TRUE reduce production attr -> POSITION
-- On SEMICOLON reduce production attr -> POSITION
-- On SCOPE reduce production attr -> POSITION
-- On RIGHTPAR reduce production attr -> POSITION
-- On RIGHTBRC reduce production attr -> POSITION
-- On RETURNS reduce production attr -> POSITION
-- On RETURN reduce production attr -> POSITION
-- On REQUIRES reduce production attr -> POSITION
-- On REAL reduce production attr -> POSITION
-- On READS reduce production attr -> POSITION
-- On RANGE reduce production attr -> POSITION
-- On RAISES reduce production attr -> POSITION
-- On RAISE reduce production attr -> POSITION
-- On QUOTE_LIDENT reduce production attr -> POSITION
-- On PURE reduce production attr -> POSITION
-- On PREDICATE reduce production attr -> POSITION
-- On POSITION reduce production attr -> POSITION
-- On OPPREF reduce production attr -> POSITION
-- On OP4 reduce production attr -> POSITION
-- On OP3 reduce production attr -> POSITION
-- On OP2 reduce production attr -> POSITION
-- On OP1 reduce production attr -> POSITION
-- On OLD reduce production attr -> POSITION
-- On NOT reduce production attr -> POSITION
-- On MINUS reduce production attr -> POSITION
-- On META reduce production attr -> POSITION
-- On MATCH reduce production attr -> POSITION
-- On LT reduce production attr -> POSITION
-- On LIDENT reduce production attr -> POSITION
-- On LET reduce production attr -> POSITION
-- On LEMMA reduce production attr -> POSITION
-- On LEFTSQ reduce production attr -> POSITION
-- On LEFTPAR reduce production attr -> POSITION
-- On LEFTBRC reduce production attr -> POSITION
-- On LABEL reduce production attr -> POSITION
-- On INVARIANT reduce production attr -> POSITION
-- On INTEGER reduce production attr -> POSITION
-- On INDUCTIVE reduce production attr -> POSITION
-- On IN reduce production attr -> POSITION
-- On IMPORT reduce production attr -> POSITION
-- On IF reduce production attr -> POSITION
-- On GT reduce production attr -> POSITION
-- On GOAL reduce production attr -> POSITION
-- On GHOST reduce production attr -> POSITION
-- On FUNCTION reduce production attr -> POSITION
-- On FUN reduce production attr -> POSITION
-- On FORALL reduce production attr -> POSITION
-- On FOR reduce production attr -> POSITION
-- On FLOAT reduce production attr -> POSITION
-- On FALSE reduce production attr -> POSITION
-- On EXISTS reduce production attr -> POSITION
-- On EXCEPTION reduce production attr -> POSITION
-- On EQUAL reduce production attr -> POSITION
-- On EPSILON reduce production attr -> POSITION
-- On EOF reduce production attr -> POSITION
-- On ENSURES reduce production attr -> POSITION
-- On END reduce production attr -> POSITION
-- On DOT reduce production attr -> POSITION
-- On DIVERGES reduce production attr -> POSITION
-- On CORE_UIDENT reduce production attr -> POSITION
-- On CORE_LIDENT reduce production attr -> POSITION
-- On CONTINUE reduce production attr -> POSITION
-- On CONSTANT reduce production attr -> POSITION
-- On COMMA reduce production attr -> POSITION
-- On COLON reduce production attr -> POSITION
-- On COINDUCTIVE reduce production attr -> POSITION
-- On CLONE reduce production attr -> POSITION
-- On CHECK reduce production attr -> POSITION
-- On BY reduce production attr -> POSITION
-- On BREAK reduce production attr -> POSITION
-- On BEGIN reduce production attr -> POSITION
-- On BAR reduce production attr -> POSITION
-- On AXIOM reduce production attr -> POSITION
-- On ATTRIBUTE reduce production attr -> POSITION
-- On ASSUME reduce production attr -> POSITION
-- On ASSERT reduce production attr -> POSITION
-- On AS reduce production attr -> POSITION
-- On ARROW reduce production attr -> POSITION
-- On ANY reduce production attr -> POSITION
-- On ALIAS reduce production attr -> POSITION
-- On ABSURD reduce production attr -> POSITION

State 69:
## Known stack suffix:
## ATTRIBUTE
## LR(1) items:
attr -> ATTRIBUTE . [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT TYPE TRY TRUE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE QUOTE_LIDENT PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EQUAL EPSILON EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BY BREAK BEGIN BAR AXIOM ATTRIBUTE ASSUME ASSERT AS ARROW ANY ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production attr -> ATTRIBUTE
-- On WITH reduce production attr -> ATTRIBUTE
-- On WHILE reduce production attr -> ATTRIBUTE
-- On VARIANT reduce production attr -> ATTRIBUTE
-- On VAL reduce production attr -> ATTRIBUTE
-- On USE reduce production attr -> ATTRIBUTE
-- On UNDERSCORE reduce production attr -> ATTRIBUTE
-- On UIDENT reduce production attr -> ATTRIBUTE
-- On TYPE reduce production attr -> ATTRIBUTE
-- On TRY reduce production attr -> ATTRIBUTE
-- On TRUE reduce production attr -> ATTRIBUTE
-- On SEMICOLON reduce production attr -> ATTRIBUTE
-- On SCOPE reduce production attr -> ATTRIBUTE
-- On RIGHTPAR reduce production attr -> ATTRIBUTE
-- On RIGHTBRC reduce production attr -> ATTRIBUTE
-- On RETURNS reduce production attr -> ATTRIBUTE
-- On RETURN reduce production attr -> ATTRIBUTE
-- On REQUIRES reduce production attr -> ATTRIBUTE
-- On REAL reduce production attr -> ATTRIBUTE
-- On READS reduce production attr -> ATTRIBUTE
-- On RANGE reduce production attr -> ATTRIBUTE
-- On RAISES reduce production attr -> ATTRIBUTE
-- On RAISE reduce production attr -> ATTRIBUTE
-- On QUOTE_LIDENT reduce production attr -> ATTRIBUTE
-- On PURE reduce production attr -> ATTRIBUTE
-- On PREDICATE reduce production attr -> ATTRIBUTE
-- On POSITION reduce production attr -> ATTRIBUTE
-- On OPPREF reduce production attr -> ATTRIBUTE
-- On OP4 reduce production attr -> ATTRIBUTE
-- On OP3 reduce production attr -> ATTRIBUTE
-- On OP2 reduce production attr -> ATTRIBUTE
-- On OP1 reduce production attr -> ATTRIBUTE
-- On OLD reduce production attr -> ATTRIBUTE
-- On NOT reduce production attr -> ATTRIBUTE
-- On MINUS reduce production attr -> ATTRIBUTE
-- On META reduce production attr -> ATTRIBUTE
-- On MATCH reduce production attr -> ATTRIBUTE
-- On LT reduce production attr -> ATTRIBUTE
-- On LIDENT reduce production attr -> ATTRIBUTE
-- On LET reduce production attr -> ATTRIBUTE
-- On LEMMA reduce production attr -> ATTRIBUTE
-- On LEFTSQ reduce production attr -> ATTRIBUTE
-- On LEFTPAR reduce production attr -> ATTRIBUTE
-- On LEFTBRC reduce production attr -> ATTRIBUTE
-- On LABEL reduce production attr -> ATTRIBUTE
-- On INVARIANT reduce production attr -> ATTRIBUTE
-- On INTEGER reduce production attr -> ATTRIBUTE
-- On INDUCTIVE reduce production attr -> ATTRIBUTE
-- On IN reduce production attr -> ATTRIBUTE
-- On IMPORT reduce production attr -> ATTRIBUTE
-- On IF reduce production attr -> ATTRIBUTE
-- On GT reduce production attr -> ATTRIBUTE
-- On GOAL reduce production attr -> ATTRIBUTE
-- On GHOST reduce production attr -> ATTRIBUTE
-- On FUNCTION reduce production attr -> ATTRIBUTE
-- On FUN reduce production attr -> ATTRIBUTE
-- On FORALL reduce production attr -> ATTRIBUTE
-- On FOR reduce production attr -> ATTRIBUTE
-- On FLOAT reduce production attr -> ATTRIBUTE
-- On FALSE reduce production attr -> ATTRIBUTE
-- On EXISTS reduce production attr -> ATTRIBUTE
-- On EXCEPTION reduce production attr -> ATTRIBUTE
-- On EQUAL reduce production attr -> ATTRIBUTE
-- On EPSILON reduce production attr -> ATTRIBUTE
-- On EOF reduce production attr -> ATTRIBUTE
-- On ENSURES reduce production attr -> ATTRIBUTE
-- On END reduce production attr -> ATTRIBUTE
-- On DOT reduce production attr -> ATTRIBUTE
-- On DIVERGES reduce production attr -> ATTRIBUTE
-- On CORE_UIDENT reduce production attr -> ATTRIBUTE
-- On CORE_LIDENT reduce production attr -> ATTRIBUTE
-- On CONTINUE reduce production attr -> ATTRIBUTE
-- On CONSTANT reduce production attr -> ATTRIBUTE
-- On COMMA reduce production attr -> ATTRIBUTE
-- On COLON reduce production attr -> ATTRIBUTE
-- On COINDUCTIVE reduce production attr -> ATTRIBUTE
-- On CLONE reduce production attr -> ATTRIBUTE
-- On CHECK reduce production attr -> ATTRIBUTE
-- On BY reduce production attr -> ATTRIBUTE
-- On BREAK reduce production attr -> ATTRIBUTE
-- On BEGIN reduce production attr -> ATTRIBUTE
-- On BAR reduce production attr -> ATTRIBUTE
-- On AXIOM reduce production attr -> ATTRIBUTE
-- On ATTRIBUTE reduce production attr -> ATTRIBUTE
-- On ASSUME reduce production attr -> ATTRIBUTE
-- On ASSERT reduce production attr -> ATTRIBUTE
-- On AS reduce production attr -> ATTRIBUTE
-- On ARROW reduce production attr -> ATTRIBUTE
-- On ANY reduce production attr -> ATTRIBUTE
-- On ALIAS reduce production attr -> ATTRIBUTE
-- On ABSURD reduce production attr -> ATTRIBUTE

State 70:
## Known stack suffix:
## lident_rich list(attr)
## LR(1) items:
attrs(lident_rich) -> lident_rich list(attr) . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On WITH reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On VARIANT reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On VAL reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On USE reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On UNDERSCORE reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On UIDENT reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On TYPE reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On SCOPE reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On RETURNS reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On REQUIRES reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On READS reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On RANGE reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On RAISES reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On QUOTE_LIDENT reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On PREDICATE reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On META reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On LIDENT reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On LET reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On LEMMA reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On LEFTPAR reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On LEFTBRC reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On INDUCTIVE reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On IN reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On IMPORT reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On GOAL reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On FUNCTION reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On FLOAT reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On EXCEPTION reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On EQUAL reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On EOF reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On ENSURES reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On END reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On DIVERGES reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On CORE_UIDENT reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On CORE_LIDENT reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On CONSTANT reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On COLON reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On COINDUCTIVE reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On CLONE reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On AXIOM reduce production attrs(lident_rich) -> lident_rich list(attr)
-- On ALIAS reduce production attrs(lident_rich) -> lident_rich list(attr)

State 71:
## Known stack suffix:
## attr
## LR(1) items:
list(attr) -> attr . list(attr) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ALIAS ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 72
-- On attr shift to state 71
## Reductions:
-- On WRITES reduce production list(attr) ->
-- On WITH reduce production list(attr) ->
-- On VARIANT reduce production list(attr) ->
-- On VAL reduce production list(attr) ->
-- On USE reduce production list(attr) ->
-- On UNDERSCORE reduce production list(attr) ->
-- On UIDENT reduce production list(attr) ->
-- On TYPE reduce production list(attr) ->
-- On SEMICOLON reduce production list(attr) ->
-- On SCOPE reduce production list(attr) ->
-- On RIGHTPAR reduce production list(attr) ->
-- On RIGHTBRC reduce production list(attr) ->
-- On RETURNS reduce production list(attr) ->
-- On REQUIRES reduce production list(attr) ->
-- On READS reduce production list(attr) ->
-- On RANGE reduce production list(attr) ->
-- On RAISES reduce production list(attr) ->
-- On QUOTE_LIDENT reduce production list(attr) ->
-- On PREDICATE reduce production list(attr) ->
-- On META reduce production list(attr) ->
-- On LIDENT reduce production list(attr) ->
-- On LET reduce production list(attr) ->
-- On LEMMA reduce production list(attr) ->
-- On LEFTSQ reduce production list(attr) ->
-- On LEFTPAR reduce production list(attr) ->
-- On LEFTBRC reduce production list(attr) ->
-- On INVARIANT reduce production list(attr) ->
-- On INDUCTIVE reduce production list(attr) ->
-- On IN reduce production list(attr) ->
-- On IMPORT reduce production list(attr) ->
-- On GOAL reduce production list(attr) ->
-- On GHOST reduce production list(attr) ->
-- On FUNCTION reduce production list(attr) ->
-- On FLOAT reduce production list(attr) ->
-- On EXCEPTION reduce production list(attr) ->
-- On EQUAL reduce production list(attr) ->
-- On EOF reduce production list(attr) ->
-- On ENSURES reduce production list(attr) ->
-- On END reduce production list(attr) ->
-- On DOT reduce production list(attr) ->
-- On DIVERGES reduce production list(attr) ->
-- On CORE_UIDENT reduce production list(attr) ->
-- On CORE_LIDENT reduce production list(attr) ->
-- On CONSTANT reduce production list(attr) ->
-- On COMMA reduce production list(attr) ->
-- On COLON reduce production list(attr) ->
-- On COINDUCTIVE reduce production list(attr) ->
-- On CLONE reduce production list(attr) ->
-- On BY reduce production list(attr) ->
-- On BAR reduce production list(attr) ->
-- On AXIOM reduce production list(attr) ->
-- On AS reduce production list(attr) ->
-- On ARROW reduce production list(attr) ->
-- On ALIAS reduce production list(attr) ->

State 72:
## Known stack suffix:
## attr list(attr)
## LR(1) items:
list(attr) -> attr list(attr) . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production list(attr) -> attr list(attr)
-- On WITH reduce production list(attr) -> attr list(attr)
-- On VARIANT reduce production list(attr) -> attr list(attr)
-- On VAL reduce production list(attr) -> attr list(attr)
-- On USE reduce production list(attr) -> attr list(attr)
-- On UNDERSCORE reduce production list(attr) -> attr list(attr)
-- On UIDENT reduce production list(attr) -> attr list(attr)
-- On TYPE reduce production list(attr) -> attr list(attr)
-- On SEMICOLON reduce production list(attr) -> attr list(attr)
-- On SCOPE reduce production list(attr) -> attr list(attr)
-- On RIGHTPAR reduce production list(attr) -> attr list(attr)
-- On RIGHTBRC reduce production list(attr) -> attr list(attr)
-- On RETURNS reduce production list(attr) -> attr list(attr)
-- On REQUIRES reduce production list(attr) -> attr list(attr)
-- On READS reduce production list(attr) -> attr list(attr)
-- On RANGE reduce production list(attr) -> attr list(attr)
-- On RAISES reduce production list(attr) -> attr list(attr)
-- On QUOTE_LIDENT reduce production list(attr) -> attr list(attr)
-- On PREDICATE reduce production list(attr) -> attr list(attr)
-- On META reduce production list(attr) -> attr list(attr)
-- On LIDENT reduce production list(attr) -> attr list(attr)
-- On LET reduce production list(attr) -> attr list(attr)
-- On LEMMA reduce production list(attr) -> attr list(attr)
-- On LEFTSQ reduce production list(attr) -> attr list(attr)
-- On LEFTPAR reduce production list(attr) -> attr list(attr)
-- On LEFTBRC reduce production list(attr) -> attr list(attr)
-- On INVARIANT reduce production list(attr) -> attr list(attr)
-- On INDUCTIVE reduce production list(attr) -> attr list(attr)
-- On IN reduce production list(attr) -> attr list(attr)
-- On IMPORT reduce production list(attr) -> attr list(attr)
-- On GOAL reduce production list(attr) -> attr list(attr)
-- On GHOST reduce production list(attr) -> attr list(attr)
-- On FUNCTION reduce production list(attr) -> attr list(attr)
-- On FLOAT reduce production list(attr) -> attr list(attr)
-- On EXCEPTION reduce production list(attr) -> attr list(attr)
-- On EQUAL reduce production list(attr) -> attr list(attr)
-- On EOF reduce production list(attr) -> attr list(attr)
-- On ENSURES reduce production list(attr) -> attr list(attr)
-- On END reduce production list(attr) -> attr list(attr)
-- On DOT reduce production list(attr) -> attr list(attr)
-- On DIVERGES reduce production list(attr) -> attr list(attr)
-- On CORE_UIDENT reduce production list(attr) -> attr list(attr)
-- On CORE_LIDENT reduce production list(attr) -> attr list(attr)
-- On CONSTANT reduce production list(attr) -> attr list(attr)
-- On COMMA reduce production list(attr) -> attr list(attr)
-- On COLON reduce production list(attr) -> attr list(attr)
-- On COINDUCTIVE reduce production list(attr) -> attr list(attr)
-- On CLONE reduce production list(attr) -> attr list(attr)
-- On BY reduce production list(attr) -> attr list(attr)
-- On BAR reduce production list(attr) -> attr list(attr)
-- On AXIOM reduce production list(attr) -> attr list(attr)
-- On AS reduce production list(attr) -> attr list(attr)
-- On ARROW reduce production list(attr) -> attr list(attr)
-- On ALIAS reduce production list(attr) -> attr list(attr)

State 73:
## Known stack suffix:
## lident_op_nq
## LR(1) items:
lident_rich -> lident_op_nq . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_rich -> lident_op_nq
-- On WITH reduce production lident_rich -> lident_op_nq
-- On VARIANT reduce production lident_rich -> lident_op_nq
-- On VAL reduce production lident_rich -> lident_op_nq
-- On USE reduce production lident_rich -> lident_op_nq
-- On UNDERSCORE reduce production lident_rich -> lident_op_nq
-- On UIDENT reduce production lident_rich -> lident_op_nq
-- On TYPE reduce production lident_rich -> lident_op_nq
-- On SCOPE reduce production lident_rich -> lident_op_nq
-- On RETURNS reduce production lident_rich -> lident_op_nq
-- On REQUIRES reduce production lident_rich -> lident_op_nq
-- On READS reduce production lident_rich -> lident_op_nq
-- On RANGE reduce production lident_rich -> lident_op_nq
-- On RAISES reduce production lident_rich -> lident_op_nq
-- On QUOTE_LIDENT reduce production lident_rich -> lident_op_nq
-- On PREDICATE reduce production lident_rich -> lident_op_nq
-- On POSITION reduce production lident_rich -> lident_op_nq
-- On META reduce production lident_rich -> lident_op_nq
-- On LIDENT reduce production lident_rich -> lident_op_nq
-- On LET reduce production lident_rich -> lident_op_nq
-- On LEMMA reduce production lident_rich -> lident_op_nq
-- On LEFTPAR reduce production lident_rich -> lident_op_nq
-- On LEFTBRC reduce production lident_rich -> lident_op_nq
-- On INDUCTIVE reduce production lident_rich -> lident_op_nq
-- On IN reduce production lident_rich -> lident_op_nq
-- On IMPORT reduce production lident_rich -> lident_op_nq
-- On GOAL reduce production lident_rich -> lident_op_nq
-- On FUNCTION reduce production lident_rich -> lident_op_nq
-- On FLOAT reduce production lident_rich -> lident_op_nq
-- On EXCEPTION reduce production lident_rich -> lident_op_nq
-- On EQUAL reduce production lident_rich -> lident_op_nq
-- On EOF reduce production lident_rich -> lident_op_nq
-- On ENSURES reduce production lident_rich -> lident_op_nq
-- On END reduce production lident_rich -> lident_op_nq
-- On DIVERGES reduce production lident_rich -> lident_op_nq
-- On CORE_UIDENT reduce production lident_rich -> lident_op_nq
-- On CORE_LIDENT reduce production lident_rich -> lident_op_nq
-- On CONSTANT reduce production lident_rich -> lident_op_nq
-- On COLON reduce production lident_rich -> lident_op_nq
-- On COINDUCTIVE reduce production lident_rich -> lident_op_nq
-- On CLONE reduce production lident_rich -> lident_op_nq
-- On AXIOM reduce production lident_rich -> lident_op_nq
-- On ATTRIBUTE reduce production lident_rich -> lident_op_nq
-- On ALIAS reduce production lident_rich -> lident_op_nq

State 74:
## Known stack suffix:
## lident_nq
## LR(1) items:
lident_rich -> lident_nq . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_rich -> lident_nq
-- On WITH reduce production lident_rich -> lident_nq
-- On VARIANT reduce production lident_rich -> lident_nq
-- On VAL reduce production lident_rich -> lident_nq
-- On USE reduce production lident_rich -> lident_nq
-- On UNDERSCORE reduce production lident_rich -> lident_nq
-- On UIDENT reduce production lident_rich -> lident_nq
-- On TYPE reduce production lident_rich -> lident_nq
-- On SCOPE reduce production lident_rich -> lident_nq
-- On RETURNS reduce production lident_rich -> lident_nq
-- On REQUIRES reduce production lident_rich -> lident_nq
-- On READS reduce production lident_rich -> lident_nq
-- On RANGE reduce production lident_rich -> lident_nq
-- On RAISES reduce production lident_rich -> lident_nq
-- On QUOTE_LIDENT reduce production lident_rich -> lident_nq
-- On PREDICATE reduce production lident_rich -> lident_nq
-- On POSITION reduce production lident_rich -> lident_nq
-- On META reduce production lident_rich -> lident_nq
-- On LIDENT reduce production lident_rich -> lident_nq
-- On LET reduce production lident_rich -> lident_nq
-- On LEMMA reduce production lident_rich -> lident_nq
-- On LEFTPAR reduce production lident_rich -> lident_nq
-- On LEFTBRC reduce production lident_rich -> lident_nq
-- On INDUCTIVE reduce production lident_rich -> lident_nq
-- On IN reduce production lident_rich -> lident_nq
-- On IMPORT reduce production lident_rich -> lident_nq
-- On GOAL reduce production lident_rich -> lident_nq
-- On FUNCTION reduce production lident_rich -> lident_nq
-- On FLOAT reduce production lident_rich -> lident_nq
-- On EXCEPTION reduce production lident_rich -> lident_nq
-- On EQUAL reduce production lident_rich -> lident_nq
-- On EOF reduce production lident_rich -> lident_nq
-- On ENSURES reduce production lident_rich -> lident_nq
-- On END reduce production lident_rich -> lident_nq
-- On DIVERGES reduce production lident_rich -> lident_nq
-- On CORE_UIDENT reduce production lident_rich -> lident_nq
-- On CORE_LIDENT reduce production lident_rich -> lident_nq
-- On CONSTANT reduce production lident_rich -> lident_nq
-- On COLON reduce production lident_rich -> lident_nq
-- On COINDUCTIVE reduce production lident_rich -> lident_nq
-- On CLONE reduce production lident_rich -> lident_nq
-- On AXIOM reduce production lident_rich -> lident_nq
-- On ATTRIBUTE reduce production lident_rich -> lident_nq
-- On ALIAS reduce production lident_rich -> lident_nq

State 75:
## Known stack suffix:
## lident_keyword
## LR(1) items:
lident_nq -> lident_keyword . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE AS ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident_nq -> lident_keyword
-- On WITH reduce production lident_nq -> lident_keyword
-- On VARIANT reduce production lident_nq -> lident_keyword
-- On VAL reduce production lident_nq -> lident_keyword
-- On USE reduce production lident_nq -> lident_keyword
-- On UNDERSCORE reduce production lident_nq -> lident_keyword
-- On UIDENT reduce production lident_nq -> lident_keyword
-- On TYPE reduce production lident_nq -> lident_keyword
-- On SEMICOLON reduce production lident_nq -> lident_keyword
-- On SCOPE reduce production lident_nq -> lident_keyword
-- On RIGHTPAR reduce production lident_nq -> lident_keyword
-- On RIGHTBRC reduce production lident_nq -> lident_keyword
-- On RETURNS reduce production lident_nq -> lident_keyword
-- On REQUIRES reduce production lident_nq -> lident_keyword
-- On READS reduce production lident_nq -> lident_keyword
-- On RANGE reduce production lident_nq -> lident_keyword
-- On RAISES reduce production lident_nq -> lident_keyword
-- On QUOTE_LIDENT reduce production lident_nq -> lident_keyword
-- On PREDICATE reduce production lident_nq -> lident_keyword
-- On POSITION reduce production lident_nq -> lident_keyword
-- On META reduce production lident_nq -> lident_keyword
-- On LIDENT reduce production lident_nq -> lident_keyword
-- On LET reduce production lident_nq -> lident_keyword
-- On LEMMA reduce production lident_nq -> lident_keyword
-- On LEFTSQ reduce production lident_nq -> lident_keyword
-- On LEFTPAR reduce production lident_nq -> lident_keyword
-- On LEFTBRC reduce production lident_nq -> lident_keyword
-- On INVARIANT reduce production lident_nq -> lident_keyword
-- On INDUCTIVE reduce production lident_nq -> lident_keyword
-- On IN reduce production lident_nq -> lident_keyword
-- On IMPORT reduce production lident_nq -> lident_keyword
-- On GOAL reduce production lident_nq -> lident_keyword
-- On FUNCTION reduce production lident_nq -> lident_keyword
-- On FLOAT reduce production lident_nq -> lident_keyword
-- On EXCEPTION reduce production lident_nq -> lident_keyword
-- On EQUAL reduce production lident_nq -> lident_keyword
-- On EOF reduce production lident_nq -> lident_keyword
-- On ENSURES reduce production lident_nq -> lident_keyword
-- On END reduce production lident_nq -> lident_keyword
-- On DOT reduce production lident_nq -> lident_keyword
-- On DIVERGES reduce production lident_nq -> lident_keyword
-- On CORE_UIDENT reduce production lident_nq -> lident_keyword
-- On CORE_LIDENT reduce production lident_nq -> lident_keyword
-- On CONSTANT reduce production lident_nq -> lident_keyword
-- On COMMA reduce production lident_nq -> lident_keyword
-- On COLON reduce production lident_nq -> lident_keyword
-- On COINDUCTIVE reduce production lident_nq -> lident_keyword
-- On CLONE reduce production lident_nq -> lident_keyword
-- On BY reduce production lident_nq -> lident_keyword
-- On BAR reduce production lident_nq -> lident_keyword
-- On AXIOM reduce production lident_nq -> lident_keyword
-- On ATTRIBUTE reduce production lident_nq -> lident_keyword
-- On AS reduce production lident_nq -> lident_keyword
-- On ARROW reduce production lident_nq -> lident_keyword
-- On ALIAS reduce production lident_nq -> lident_keyword

State 76:
## Known stack suffix:
## VAL ghost kind attrs(lident_rich)
## LR(1) items:
prog_decl -> VAL ghost kind attrs(lident_rich) . mk_expr(val_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On val_defn shift to state 145
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 147
-- On param shift to state 569
-- On mk_expr(val_defn) shift to state 574
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WRITES reduce production list(param) ->
-- On VARIANT reduce production list(param) ->
-- On VAL reduce production list(param) ->
-- On USE reduce production list(param) ->
-- On TYPE reduce production list(param) ->
-- On SCOPE reduce production list(param) ->
-- On RETURNS reduce production list(param) ->
-- On REQUIRES reduce production list(param) ->
-- On READS reduce production list(param) ->
-- On RAISES reduce production list(param) ->
-- On PREDICATE reduce production list(param) ->
-- On META reduce production list(param) ->
-- On LET reduce production list(param) ->
-- On LEMMA reduce production list(param) ->
-- On INDUCTIVE reduce production list(param) ->
-- On IMPORT reduce production list(param) ->
-- On GOAL reduce production list(param) ->
-- On FUNCTION reduce production list(param) ->
-- On EXCEPTION reduce production list(param) ->
-- On EOF reduce production list(param) ->
-- On ENSURES reduce production list(param) ->
-- On END reduce production list(param) ->
-- On DIVERGES reduce production list(param) ->
-- On CONSTANT reduce production list(param) ->
-- On COLON reduce production list(param) ->
-- On COINDUCTIVE reduce production list(param) ->
-- On CLONE reduce production list(param) ->
-- On AXIOM reduce production list(param) ->
-- On ALIAS reduce production list(param) ->

State 77:
## Known stack suffix:
## UNDERSCORE
## LR(1) items:
anon_binder -> UNDERSCORE . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production anon_binder -> UNDERSCORE
-- On WITH reduce production anon_binder -> UNDERSCORE
-- On VARIANT reduce production anon_binder -> UNDERSCORE
-- On VAL reduce production anon_binder -> UNDERSCORE
-- On USE reduce production anon_binder -> UNDERSCORE
-- On UNDERSCORE reduce production anon_binder -> UNDERSCORE
-- On UIDENT reduce production anon_binder -> UNDERSCORE
-- On TYPE reduce production anon_binder -> UNDERSCORE
-- On SCOPE reduce production anon_binder -> UNDERSCORE
-- On RIGHTPAR reduce production anon_binder -> UNDERSCORE
-- On RETURNS reduce production anon_binder -> UNDERSCORE
-- On REQUIRES reduce production anon_binder -> UNDERSCORE
-- On READS reduce production anon_binder -> UNDERSCORE
-- On RANGE reduce production anon_binder -> UNDERSCORE
-- On RAISES reduce production anon_binder -> UNDERSCORE
-- On QUOTE_LIDENT reduce production anon_binder -> UNDERSCORE
-- On PREDICATE reduce production anon_binder -> UNDERSCORE
-- On META reduce production anon_binder -> UNDERSCORE
-- On LIDENT reduce production anon_binder -> UNDERSCORE
-- On LET reduce production anon_binder -> UNDERSCORE
-- On LEMMA reduce production anon_binder -> UNDERSCORE
-- On LEFTSQ reduce production anon_binder -> UNDERSCORE
-- On LEFTPAR reduce production anon_binder -> UNDERSCORE
-- On LEFTBRC reduce production anon_binder -> UNDERSCORE
-- On INVARIANT reduce production anon_binder -> UNDERSCORE
-- On INDUCTIVE reduce production anon_binder -> UNDERSCORE
-- On IN reduce production anon_binder -> UNDERSCORE
-- On IMPORT reduce production anon_binder -> UNDERSCORE
-- On GOAL reduce production anon_binder -> UNDERSCORE
-- On FUNCTION reduce production anon_binder -> UNDERSCORE
-- On FLOAT reduce production anon_binder -> UNDERSCORE
-- On EXCEPTION reduce production anon_binder -> UNDERSCORE
-- On EQUAL reduce production anon_binder -> UNDERSCORE
-- On EOF reduce production anon_binder -> UNDERSCORE
-- On ENSURES reduce production anon_binder -> UNDERSCORE
-- On END reduce production anon_binder -> UNDERSCORE
-- On DOT reduce production anon_binder -> UNDERSCORE
-- On DIVERGES reduce production anon_binder -> UNDERSCORE
-- On CORE_UIDENT reduce production anon_binder -> UNDERSCORE
-- On CORE_LIDENT reduce production anon_binder -> UNDERSCORE
-- On CONSTANT reduce production anon_binder -> UNDERSCORE
-- On COMMA reduce production anon_binder -> UNDERSCORE
-- On COLON reduce production anon_binder -> UNDERSCORE
-- On COINDUCTIVE reduce production anon_binder -> UNDERSCORE
-- On CLONE reduce production anon_binder -> UNDERSCORE
-- On BY reduce production anon_binder -> UNDERSCORE
-- On BAR reduce production anon_binder -> UNDERSCORE
-- On AXIOM reduce production anon_binder -> UNDERSCORE
-- On ARROW reduce production anon_binder -> UNDERSCORE
-- On ALIAS reduce production anon_binder -> UNDERSCORE

State 78:
## Known stack suffix:
## QUOTE_LIDENT
## LR(1) items:
quote_lident -> QUOTE_LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production quote_lident -> QUOTE_LIDENT
-- On WITH reduce production quote_lident -> QUOTE_LIDENT
-- On VARIANT reduce production quote_lident -> QUOTE_LIDENT
-- On VAL reduce production quote_lident -> QUOTE_LIDENT
-- On USE reduce production quote_lident -> QUOTE_LIDENT
-- On UNDERSCORE reduce production quote_lident -> QUOTE_LIDENT
-- On UIDENT reduce production quote_lident -> QUOTE_LIDENT
-- On TYPE reduce production quote_lident -> QUOTE_LIDENT
-- On TO reduce production quote_lident -> QUOTE_LIDENT
-- On THEN reduce production quote_lident -> QUOTE_LIDENT
-- On SO reduce production quote_lident -> QUOTE_LIDENT
-- On SEMICOLON reduce production quote_lident -> QUOTE_LIDENT
-- On SCOPE reduce production quote_lident -> QUOTE_LIDENT
-- On RIGHTSQ_QUOTE reduce production quote_lident -> QUOTE_LIDENT
-- On RIGHTSQ reduce production quote_lident -> QUOTE_LIDENT
-- On RIGHTPAR reduce production quote_lident -> QUOTE_LIDENT
-- On RIGHTBRC reduce production quote_lident -> QUOTE_LIDENT
-- On RETURNS reduce production quote_lident -> QUOTE_LIDENT
-- On REQUIRES reduce production quote_lident -> QUOTE_LIDENT
-- On READS reduce production quote_lident -> QUOTE_LIDENT
-- On RANGE reduce production quote_lident -> QUOTE_LIDENT
-- On RAISES reduce production quote_lident -> QUOTE_LIDENT
-- On QUOTE_LIDENT reduce production quote_lident -> QUOTE_LIDENT
-- On PREDICATE reduce production quote_lident -> QUOTE_LIDENT
-- On POSITION reduce production quote_lident -> QUOTE_LIDENT
-- On OR reduce production quote_lident -> QUOTE_LIDENT
-- On OP4 reduce production quote_lident -> QUOTE_LIDENT
-- On OP3 reduce production quote_lident -> QUOTE_LIDENT
-- On OP2 reduce production quote_lident -> QUOTE_LIDENT
-- On OP1 reduce production quote_lident -> QUOTE_LIDENT
-- On MINUS reduce production quote_lident -> QUOTE_LIDENT
-- On META reduce production quote_lident -> QUOTE_LIDENT
-- On LTGT reduce production quote_lident -> QUOTE_LIDENT
-- On LT reduce production quote_lident -> QUOTE_LIDENT
-- On LRARROW reduce production quote_lident -> QUOTE_LIDENT
-- On LIDENT reduce production quote_lident -> QUOTE_LIDENT
-- On LET reduce production quote_lident -> QUOTE_LIDENT
-- On LEMMA reduce production quote_lident -> QUOTE_LIDENT
-- On LEFTSQ reduce production quote_lident -> QUOTE_LIDENT
-- On LEFTPAR reduce production quote_lident -> QUOTE_LIDENT
-- On LEFTBRC reduce production quote_lident -> QUOTE_LIDENT
-- On LARROW reduce production quote_lident -> QUOTE_LIDENT
-- On INVARIANT reduce production quote_lident -> QUOTE_LIDENT
-- On INDUCTIVE reduce production quote_lident -> QUOTE_LIDENT
-- On IN reduce production quote_lident -> QUOTE_LIDENT
-- On IMPORT reduce production quote_lident -> QUOTE_LIDENT
-- On GT reduce production quote_lident -> QUOTE_LIDENT
-- On GOAL reduce production quote_lident -> QUOTE_LIDENT
-- On FUNCTION reduce production quote_lident -> QUOTE_LIDENT
-- On FLOAT reduce production quote_lident -> QUOTE_LIDENT
-- On EXCEPTION reduce production quote_lident -> QUOTE_LIDENT
-- On EQUAL reduce production quote_lident -> QUOTE_LIDENT
-- On EOF reduce production quote_lident -> QUOTE_LIDENT
-- On ENSURES reduce production quote_lident -> QUOTE_LIDENT
-- On END reduce production quote_lident -> QUOTE_LIDENT
-- On ELSE reduce production quote_lident -> QUOTE_LIDENT
-- On DOWNTO reduce production quote_lident -> QUOTE_LIDENT
-- On DOTDOT reduce production quote_lident -> QUOTE_LIDENT
-- On DOT reduce production quote_lident -> QUOTE_LIDENT
-- On DONE reduce production quote_lident -> QUOTE_LIDENT
-- On DO reduce production quote_lident -> QUOTE_LIDENT
-- On DIVERGES reduce production quote_lident -> QUOTE_LIDENT
-- On CORE_UIDENT reduce production quote_lident -> QUOTE_LIDENT
-- On CORE_LIDENT reduce production quote_lident -> QUOTE_LIDENT
-- On CONSTANT reduce production quote_lident -> QUOTE_LIDENT
-- On COMMA reduce production quote_lident -> QUOTE_LIDENT
-- On COLON reduce production quote_lident -> QUOTE_LIDENT
-- On COINDUCTIVE reduce production quote_lident -> QUOTE_LIDENT
-- On CLONE reduce production quote_lident -> QUOTE_LIDENT
-- On BY reduce production quote_lident -> QUOTE_LIDENT
-- On BARBAR reduce production quote_lident -> QUOTE_LIDENT
-- On BAR reduce production quote_lident -> QUOTE_LIDENT
-- On AXIOM reduce production quote_lident -> QUOTE_LIDENT
-- On ATTRIBUTE reduce production quote_lident -> QUOTE_LIDENT
-- On AT reduce production quote_lident -> QUOTE_LIDENT
-- On AS reduce production quote_lident -> QUOTE_LIDENT
-- On ARROW reduce production quote_lident -> QUOTE_LIDENT
-- On AND reduce production quote_lident -> QUOTE_LIDENT
-- On AMPAMP reduce production quote_lident -> QUOTE_LIDENT
-- On ALIAS reduce production quote_lident -> QUOTE_LIDENT

State 79:
## Known stack suffix:
## LIDENT
## LR(1) items:
lident -> LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
lident_nq -> LIDENT . [ POSITION ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident -> LIDENT
-- On WITH reduce production lident -> LIDENT
-- On VARIANT reduce production lident -> LIDENT
-- On VAL reduce production lident -> LIDENT
-- On USE reduce production lident -> LIDENT
-- On UNDERSCORE reduce production lident -> LIDENT
-- On UIDENT reduce production lident -> LIDENT
-- On TYPE reduce production lident -> LIDENT
-- On SCOPE reduce production lident -> LIDENT
-- On RETURNS reduce production lident -> LIDENT
-- On REQUIRES reduce production lident -> LIDENT
-- On READS reduce production lident -> LIDENT
-- On RANGE reduce production lident -> LIDENT
-- On RAISES reduce production lident -> LIDENT
-- On QUOTE_LIDENT reduce production lident -> LIDENT
-- On PREDICATE reduce production lident -> LIDENT
-- On POSITION reduce production lident_nq -> LIDENT
-- On META reduce production lident -> LIDENT
-- On LIDENT reduce production lident -> LIDENT
-- On LET reduce production lident -> LIDENT
-- On LEMMA reduce production lident -> LIDENT
-- On LEFTPAR reduce production lident -> LIDENT
-- On LEFTBRC reduce production lident -> LIDENT
-- On INVARIANT reduce production lident -> LIDENT
-- On INDUCTIVE reduce production lident -> LIDENT
-- On IN reduce production lident -> LIDENT
-- On IMPORT reduce production lident -> LIDENT
-- On GOAL reduce production lident -> LIDENT
-- On FUNCTION reduce production lident -> LIDENT
-- On FLOAT reduce production lident -> LIDENT
-- On EXCEPTION reduce production lident -> LIDENT
-- On EQUAL reduce production lident -> LIDENT
-- On EOF reduce production lident -> LIDENT
-- On ENSURES reduce production lident -> LIDENT
-- On END reduce production lident -> LIDENT
-- On DIVERGES reduce production lident -> LIDENT
-- On CORE_UIDENT reduce production lident -> LIDENT
-- On CORE_LIDENT reduce production lident -> LIDENT
-- On CONSTANT reduce production lident -> LIDENT
-- On COLON reduce production lident -> LIDENT
-- On COINDUCTIVE reduce production lident -> LIDENT
-- On CLONE reduce production lident -> LIDENT
-- On BY reduce production lident -> LIDENT
-- On BAR reduce production lident -> LIDENT
-- On AXIOM reduce production lident -> LIDENT
-- On ATTRIBUTE reduce production lident_nq -> LIDENT
-- On ARROW reduce production lident -> LIDENT
-- On ALIAS reduce production lident -> LIDENT

State 80:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
param -> LEFTPAR . GHOST ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
param -> LEFTPAR . binder_vars_rest RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
param -> LEFTPAR . GHOST binder_vars_rest RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
param -> LEFTPAR . binder_vars cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
param -> LEFTPAR . GHOST binder_vars cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
ty_block -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
ty_block -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
ty_block -> LEFTPAR . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 81
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 113
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 138
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list2(ty) shift to state 111
-- On binder_vars_rest shift to state 139
-- On binder_vars_head shift to state 118
-- On binder_vars shift to state 141
-- On anon_binder shift to state 136
## Reductions:

State 81:
## Known stack suffix:
## LEFTPAR RIGHTPAR
## LR(1) items:
ty_block -> LEFTPAR RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production ty_block -> LEFTPAR RIGHTPAR
-- On WITH reduce production ty_block -> LEFTPAR RIGHTPAR
-- On VARIANT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On VAL reduce production ty_block -> LEFTPAR RIGHTPAR
-- On USE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On UNDERSCORE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On UIDENT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On TYPE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On TO reduce production ty_block -> LEFTPAR RIGHTPAR
-- On THEN reduce production ty_block -> LEFTPAR RIGHTPAR
-- On SO reduce production ty_block -> LEFTPAR RIGHTPAR
-- On SEMICOLON reduce production ty_block -> LEFTPAR RIGHTPAR
-- On SCOPE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On RIGHTSQ reduce production ty_block -> LEFTPAR RIGHTPAR
-- On RIGHTPAR reduce production ty_block -> LEFTPAR RIGHTPAR
-- On RIGHTBRC reduce production ty_block -> LEFTPAR RIGHTPAR
-- On RETURNS reduce production ty_block -> LEFTPAR RIGHTPAR
-- On REQUIRES reduce production ty_block -> LEFTPAR RIGHTPAR
-- On READS reduce production ty_block -> LEFTPAR RIGHTPAR
-- On RANGE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On RAISES reduce production ty_block -> LEFTPAR RIGHTPAR
-- On QUOTE_LIDENT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On PREDICATE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On POSITION reduce production ty_block -> LEFTPAR RIGHTPAR
-- On OR reduce production ty_block -> LEFTPAR RIGHTPAR
-- On OP4 reduce production ty_block -> LEFTPAR RIGHTPAR
-- On OP3 reduce production ty_block -> LEFTPAR RIGHTPAR
-- On OP2 reduce production ty_block -> LEFTPAR RIGHTPAR
-- On OP1 reduce production ty_block -> LEFTPAR RIGHTPAR
-- On MINUS reduce production ty_block -> LEFTPAR RIGHTPAR
-- On META reduce production ty_block -> LEFTPAR RIGHTPAR
-- On LTGT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On LT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On LRARROW reduce production ty_block -> LEFTPAR RIGHTPAR
-- On LIDENT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On LET reduce production ty_block -> LEFTPAR RIGHTPAR
-- On LEMMA reduce production ty_block -> LEFTPAR RIGHTPAR
-- On LEFTSQ reduce production ty_block -> LEFTPAR RIGHTPAR
-- On LEFTPAR reduce production ty_block -> LEFTPAR RIGHTPAR
-- On LEFTBRC reduce production ty_block -> LEFTPAR RIGHTPAR
-- On LARROW reduce production ty_block -> LEFTPAR RIGHTPAR
-- On INVARIANT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On INDUCTIVE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On IN reduce production ty_block -> LEFTPAR RIGHTPAR
-- On IMPORT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On GT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On GOAL reduce production ty_block -> LEFTPAR RIGHTPAR
-- On FUNCTION reduce production ty_block -> LEFTPAR RIGHTPAR
-- On FLOAT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On EXCEPTION reduce production ty_block -> LEFTPAR RIGHTPAR
-- On EQUAL reduce production ty_block -> LEFTPAR RIGHTPAR
-- On EOF reduce production ty_block -> LEFTPAR RIGHTPAR
-- On ENSURES reduce production ty_block -> LEFTPAR RIGHTPAR
-- On END reduce production ty_block -> LEFTPAR RIGHTPAR
-- On ELSE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On DOWNTO reduce production ty_block -> LEFTPAR RIGHTPAR
-- On DOTDOT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On DOT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On DONE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On DO reduce production ty_block -> LEFTPAR RIGHTPAR
-- On DIVERGES reduce production ty_block -> LEFTPAR RIGHTPAR
-- On CORE_UIDENT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On CORE_LIDENT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On CONSTANT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On COMMA reduce production ty_block -> LEFTPAR RIGHTPAR
-- On COLON reduce production ty_block -> LEFTPAR RIGHTPAR
-- On COINDUCTIVE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On CLONE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On BY reduce production ty_block -> LEFTPAR RIGHTPAR
-- On BARBAR reduce production ty_block -> LEFTPAR RIGHTPAR
-- On BAR reduce production ty_block -> LEFTPAR RIGHTPAR
-- On AXIOM reduce production ty_block -> LEFTPAR RIGHTPAR
-- On ATTRIBUTE reduce production ty_block -> LEFTPAR RIGHTPAR
-- On AT reduce production ty_block -> LEFTPAR RIGHTPAR
-- On AS reduce production ty_block -> LEFTPAR RIGHTPAR
-- On ARROW reduce production ty_block -> LEFTPAR RIGHTPAR
-- On AND reduce production ty_block -> LEFTPAR RIGHTPAR
-- On AMPAMP reduce production ty_block -> LEFTPAR RIGHTPAR
-- On ALIAS reduce production ty_block -> LEFTPAR RIGHTPAR

State 82:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
ty_block -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
ty_block -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
ty_block -> LEFTPAR . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 81
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 103
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list2(ty) shift to state 111
## Reductions:

State 83:
## Known stack suffix:
## LEFTBRC
## LR(1) items:
ty_block -> LEFTBRC . ty RIGHTBRC [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 92
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 84:
## Known stack suffix:
## uqualid
## LR(1) items:
lqualid -> uqualid . DOT lident [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
ty_arg -> uqualid . DOT ty_block [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 85
## Reductions:

State 85:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
lqualid -> uqualid DOT . lident [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
ty_arg -> uqualid DOT . ty_block [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 86
-- On ty_block shift to state 87
-- On lident_keyword shift to state 43
-- On lident shift to state 88
## Reductions:

State 86:
## Known stack suffix:
## uqualid DOT uident
## LR(1) items:
uqualid -> uqualid DOT uident . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AS ARROW AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production uqualid -> uqualid DOT uident
-- On WITH reduce production uqualid -> uqualid DOT uident
-- On VARIANT reduce production uqualid -> uqualid DOT uident
-- On VAL reduce production uqualid -> uqualid DOT uident
-- On USE reduce production uqualid -> uqualid DOT uident
-- On UNDERSCORE reduce production uqualid -> uqualid DOT uident
-- On UIDENT reduce production uqualid -> uqualid DOT uident
-- On TYPE reduce production uqualid -> uqualid DOT uident
-- On TRUE reduce production uqualid -> uqualid DOT uident
-- On TO reduce production uqualid -> uqualid DOT uident
-- On THEN reduce production uqualid -> uqualid DOT uident
-- On SEMICOLON reduce production uqualid -> uqualid DOT uident
-- On SCOPE reduce production uqualid -> uqualid DOT uident
-- On RIGHTSQ_QUOTE reduce production uqualid -> uqualid DOT uident
-- On RIGHTSQ reduce production uqualid -> uqualid DOT uident
-- On RIGHTPAR reduce production uqualid -> uqualid DOT uident
-- On RIGHTBRC reduce production uqualid -> uqualid DOT uident
-- On RETURNS reduce production uqualid -> uqualid DOT uident
-- On REQUIRES reduce production uqualid -> uqualid DOT uident
-- On REAL reduce production uqualid -> uqualid DOT uident
-- On READS reduce production uqualid -> uqualid DOT uident
-- On RANGE reduce production uqualid -> uqualid DOT uident
-- On RAISES reduce production uqualid -> uqualid DOT uident
-- On PURE reduce production uqualid -> uqualid DOT uident
-- On PREDICATE reduce production uqualid -> uqualid DOT uident
-- On OPPREF reduce production uqualid -> uqualid DOT uident
-- On OP4 reduce production uqualid -> uqualid DOT uident
-- On OP3 reduce production uqualid -> uqualid DOT uident
-- On OP2 reduce production uqualid -> uqualid DOT uident
-- On OP1 reduce production uqualid -> uqualid DOT uident
-- On MINUS reduce production uqualid -> uqualid DOT uident
-- On META reduce production uqualid -> uqualid DOT uident
-- On LTGT reduce production uqualid -> uqualid DOT uident
-- On LT reduce production uqualid -> uqualid DOT uident
-- On LIDENT reduce production uqualid -> uqualid DOT uident
-- On LET reduce production uqualid -> uqualid DOT uident
-- On LEMMA reduce production uqualid -> uqualid DOT uident
-- On LEFTPAR reduce production uqualid -> uqualid DOT uident
-- On LEFTBRC reduce production uqualid -> uqualid DOT uident
-- On LARROW reduce production uqualid -> uqualid DOT uident
-- On INTEGER reduce production uqualid -> uqualid DOT uident
-- On INDUCTIVE reduce production uqualid -> uqualid DOT uident
-- On IN reduce production uqualid -> uqualid DOT uident
-- On IMPORT reduce production uqualid -> uqualid DOT uident
-- On GT reduce production uqualid -> uqualid DOT uident
-- On GOAL reduce production uqualid -> uqualid DOT uident
-- On FUNCTION reduce production uqualid -> uqualid DOT uident
-- On FLOAT reduce production uqualid -> uqualid DOT uident
-- On FALSE reduce production uqualid -> uqualid DOT uident
-- On EXCEPTION reduce production uqualid -> uqualid DOT uident
-- On EQUAL reduce production uqualid -> uqualid DOT uident
-- On EOF reduce production uqualid -> uqualid DOT uident
-- On ENSURES reduce production uqualid -> uqualid DOT uident
-- On END reduce production uqualid -> uqualid DOT uident
-- On ELSE reduce production uqualid -> uqualid DOT uident
-- On DOWNTO reduce production uqualid -> uqualid DOT uident
-- On DOTDOT reduce production uqualid -> uqualid DOT uident
-- On DOT reduce production uqualid -> uqualid DOT uident
-- On DONE reduce production uqualid -> uqualid DOT uident
-- On DO reduce production uqualid -> uqualid DOT uident
-- On DIVERGES reduce production uqualid -> uqualid DOT uident
-- On CORE_UIDENT reduce production uqualid -> uqualid DOT uident
-- On CORE_LIDENT reduce production uqualid -> uqualid DOT uident
-- On CONSTANT reduce production uqualid -> uqualid DOT uident
-- On COMMA reduce production uqualid -> uqualid DOT uident
-- On COLON reduce production uqualid -> uqualid DOT uident
-- On COINDUCTIVE reduce production uqualid -> uqualid DOT uident
-- On CLONE reduce production uqualid -> uqualid DOT uident
-- On BEGIN reduce production uqualid -> uqualid DOT uident
-- On BARBAR reduce production uqualid -> uqualid DOT uident
-- On BAR reduce production uqualid -> uqualid DOT uident
-- On AXIOM reduce production uqualid -> uqualid DOT uident
-- On AS reduce production uqualid -> uqualid DOT uident
-- On ARROW reduce production uqualid -> uqualid DOT uident
-- On AMPAMP reduce production uqualid -> uqualid DOT uident
-- On ALIAS reduce production uqualid -> uqualid DOT uident

State 87:
## Known stack suffix:
## uqualid DOT ty_block
## LR(1) items:
ty_arg -> uqualid DOT ty_block . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production ty_arg -> uqualid DOT ty_block
-- On WITH reduce production ty_arg -> uqualid DOT ty_block
-- On VARIANT reduce production ty_arg -> uqualid DOT ty_block
-- On VAL reduce production ty_arg -> uqualid DOT ty_block
-- On USE reduce production ty_arg -> uqualid DOT ty_block
-- On UNDERSCORE reduce production ty_arg -> uqualid DOT ty_block
-- On UIDENT reduce production ty_arg -> uqualid DOT ty_block
-- On TYPE reduce production ty_arg -> uqualid DOT ty_block
-- On TO reduce production ty_arg -> uqualid DOT ty_block
-- On THEN reduce production ty_arg -> uqualid DOT ty_block
-- On SO reduce production ty_arg -> uqualid DOT ty_block
-- On SEMICOLON reduce production ty_arg -> uqualid DOT ty_block
-- On SCOPE reduce production ty_arg -> uqualid DOT ty_block
-- On RIGHTSQ_QUOTE reduce production ty_arg -> uqualid DOT ty_block
-- On RIGHTSQ reduce production ty_arg -> uqualid DOT ty_block
-- On RIGHTPAR reduce production ty_arg -> uqualid DOT ty_block
-- On RIGHTBRC reduce production ty_arg -> uqualid DOT ty_block
-- On RETURNS reduce production ty_arg -> uqualid DOT ty_block
-- On REQUIRES reduce production ty_arg -> uqualid DOT ty_block
-- On READS reduce production ty_arg -> uqualid DOT ty_block
-- On RANGE reduce production ty_arg -> uqualid DOT ty_block
-- On RAISES reduce production ty_arg -> uqualid DOT ty_block
-- On QUOTE_LIDENT reduce production ty_arg -> uqualid DOT ty_block
-- On PREDICATE reduce production ty_arg -> uqualid DOT ty_block
-- On POSITION reduce production ty_arg -> uqualid DOT ty_block
-- On OR reduce production ty_arg -> uqualid DOT ty_block
-- On OP4 reduce production ty_arg -> uqualid DOT ty_block
-- On OP3 reduce production ty_arg -> uqualid DOT ty_block
-- On OP2 reduce production ty_arg -> uqualid DOT ty_block
-- On OP1 reduce production ty_arg -> uqualid DOT ty_block
-- On MINUS reduce production ty_arg -> uqualid DOT ty_block
-- On META reduce production ty_arg -> uqualid DOT ty_block
-- On LTGT reduce production ty_arg -> uqualid DOT ty_block
-- On LT reduce production ty_arg -> uqualid DOT ty_block
-- On LRARROW reduce production ty_arg -> uqualid DOT ty_block
-- On LIDENT reduce production ty_arg -> uqualid DOT ty_block
-- On LET reduce production ty_arg -> uqualid DOT ty_block
-- On LEMMA reduce production ty_arg -> uqualid DOT ty_block
-- On LEFTSQ reduce production ty_arg -> uqualid DOT ty_block
-- On LEFTPAR reduce production ty_arg -> uqualid DOT ty_block
-- On LEFTBRC reduce production ty_arg -> uqualid DOT ty_block
-- On LARROW reduce production ty_arg -> uqualid DOT ty_block
-- On INVARIANT reduce production ty_arg -> uqualid DOT ty_block
-- On INDUCTIVE reduce production ty_arg -> uqualid DOT ty_block
-- On IN reduce production ty_arg -> uqualid DOT ty_block
-- On IMPORT reduce production ty_arg -> uqualid DOT ty_block
-- On GT reduce production ty_arg -> uqualid DOT ty_block
-- On GOAL reduce production ty_arg -> uqualid DOT ty_block
-- On FUNCTION reduce production ty_arg -> uqualid DOT ty_block
-- On FLOAT reduce production ty_arg -> uqualid DOT ty_block
-- On EXCEPTION reduce production ty_arg -> uqualid DOT ty_block
-- On EQUAL reduce production ty_arg -> uqualid DOT ty_block
-- On EOF reduce production ty_arg -> uqualid DOT ty_block
-- On ENSURES reduce production ty_arg -> uqualid DOT ty_block
-- On END reduce production ty_arg -> uqualid DOT ty_block
-- On ELSE reduce production ty_arg -> uqualid DOT ty_block
-- On DOWNTO reduce production ty_arg -> uqualid DOT ty_block
-- On DOTDOT reduce production ty_arg -> uqualid DOT ty_block
-- On DOT reduce production ty_arg -> uqualid DOT ty_block
-- On DONE reduce production ty_arg -> uqualid DOT ty_block
-- On DO reduce production ty_arg -> uqualid DOT ty_block
-- On DIVERGES reduce production ty_arg -> uqualid DOT ty_block
-- On CORE_UIDENT reduce production ty_arg -> uqualid DOT ty_block
-- On CORE_LIDENT reduce production ty_arg -> uqualid DOT ty_block
-- On CONSTANT reduce production ty_arg -> uqualid DOT ty_block
-- On COMMA reduce production ty_arg -> uqualid DOT ty_block
-- On COLON reduce production ty_arg -> uqualid DOT ty_block
-- On COINDUCTIVE reduce production ty_arg -> uqualid DOT ty_block
-- On CLONE reduce production ty_arg -> uqualid DOT ty_block
-- On BY reduce production ty_arg -> uqualid DOT ty_block
-- On BARBAR reduce production ty_arg -> uqualid DOT ty_block
-- On BAR reduce production ty_arg -> uqualid DOT ty_block
-- On AXIOM reduce production ty_arg -> uqualid DOT ty_block
-- On ATTRIBUTE reduce production ty_arg -> uqualid DOT ty_block
-- On AT reduce production ty_arg -> uqualid DOT ty_block
-- On AS reduce production ty_arg -> uqualid DOT ty_block
-- On ARROW reduce production ty_arg -> uqualid DOT ty_block
-- On AND reduce production ty_arg -> uqualid DOT ty_block
-- On AMPAMP reduce production ty_arg -> uqualid DOT ty_block
-- On ALIAS reduce production ty_arg -> uqualid DOT ty_block

State 88:
## Known stack suffix:
## uqualid DOT lident
## LR(1) items:
lqualid -> uqualid DOT lident . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lqualid -> uqualid DOT lident
-- On WITH reduce production lqualid -> uqualid DOT lident
-- On VARIANT reduce production lqualid -> uqualid DOT lident
-- On VAL reduce production lqualid -> uqualid DOT lident
-- On USE reduce production lqualid -> uqualid DOT lident
-- On UNDERSCORE reduce production lqualid -> uqualid DOT lident
-- On UIDENT reduce production lqualid -> uqualid DOT lident
-- On TYPE reduce production lqualid -> uqualid DOT lident
-- On TO reduce production lqualid -> uqualid DOT lident
-- On THEN reduce production lqualid -> uqualid DOT lident
-- On SO reduce production lqualid -> uqualid DOT lident
-- On SEMICOLON reduce production lqualid -> uqualid DOT lident
-- On SCOPE reduce production lqualid -> uqualid DOT lident
-- On RIGHTSQ_QUOTE reduce production lqualid -> uqualid DOT lident
-- On RIGHTSQ reduce production lqualid -> uqualid DOT lident
-- On RIGHTPAR reduce production lqualid -> uqualid DOT lident
-- On RIGHTBRC reduce production lqualid -> uqualid DOT lident
-- On RETURNS reduce production lqualid -> uqualid DOT lident
-- On REQUIRES reduce production lqualid -> uqualid DOT lident
-- On READS reduce production lqualid -> uqualid DOT lident
-- On RANGE reduce production lqualid -> uqualid DOT lident
-- On RAISES reduce production lqualid -> uqualid DOT lident
-- On QUOTE_LIDENT reduce production lqualid -> uqualid DOT lident
-- On PREDICATE reduce production lqualid -> uqualid DOT lident
-- On POSITION reduce production lqualid -> uqualid DOT lident
-- On OR reduce production lqualid -> uqualid DOT lident
-- On OP4 reduce production lqualid -> uqualid DOT lident
-- On OP3 reduce production lqualid -> uqualid DOT lident
-- On OP2 reduce production lqualid -> uqualid DOT lident
-- On OP1 reduce production lqualid -> uqualid DOT lident
-- On MINUS reduce production lqualid -> uqualid DOT lident
-- On META reduce production lqualid -> uqualid DOT lident
-- On LTGT reduce production lqualid -> uqualid DOT lident
-- On LT reduce production lqualid -> uqualid DOT lident
-- On LRARROW reduce production lqualid -> uqualid DOT lident
-- On LIDENT reduce production lqualid -> uqualid DOT lident
-- On LET reduce production lqualid -> uqualid DOT lident
-- On LEMMA reduce production lqualid -> uqualid DOT lident
-- On LEFTSQ reduce production lqualid -> uqualid DOT lident
-- On LEFTPAR reduce production lqualid -> uqualid DOT lident
-- On LEFTBRC reduce production lqualid -> uqualid DOT lident
-- On LARROW reduce production lqualid -> uqualid DOT lident
-- On INVARIANT reduce production lqualid -> uqualid DOT lident
-- On INDUCTIVE reduce production lqualid -> uqualid DOT lident
-- On IN reduce production lqualid -> uqualid DOT lident
-- On IMPORT reduce production lqualid -> uqualid DOT lident
-- On GT reduce production lqualid -> uqualid DOT lident
-- On GOAL reduce production lqualid -> uqualid DOT lident
-- On FUNCTION reduce production lqualid -> uqualid DOT lident
-- On FLOAT reduce production lqualid -> uqualid DOT lident
-- On EXCEPTION reduce production lqualid -> uqualid DOT lident
-- On EQUAL reduce production lqualid -> uqualid DOT lident
-- On EOF reduce production lqualid -> uqualid DOT lident
-- On ENSURES reduce production lqualid -> uqualid DOT lident
-- On END reduce production lqualid -> uqualid DOT lident
-- On ELSE reduce production lqualid -> uqualid DOT lident
-- On DOWNTO reduce production lqualid -> uqualid DOT lident
-- On DOTDOT reduce production lqualid -> uqualid DOT lident
-- On DOT reduce production lqualid -> uqualid DOT lident
-- On DONE reduce production lqualid -> uqualid DOT lident
-- On DO reduce production lqualid -> uqualid DOT lident
-- On DIVERGES reduce production lqualid -> uqualid DOT lident
-- On CORE_UIDENT reduce production lqualid -> uqualid DOT lident
-- On CORE_LIDENT reduce production lqualid -> uqualid DOT lident
-- On CONSTANT reduce production lqualid -> uqualid DOT lident
-- On COMMA reduce production lqualid -> uqualid DOT lident
-- On COLON reduce production lqualid -> uqualid DOT lident
-- On COINDUCTIVE reduce production lqualid -> uqualid DOT lident
-- On CLONE reduce production lqualid -> uqualid DOT lident
-- On BY reduce production lqualid -> uqualid DOT lident
-- On BARBAR reduce production lqualid -> uqualid DOT lident
-- On BAR reduce production lqualid -> uqualid DOT lident
-- On AXIOM reduce production lqualid -> uqualid DOT lident
-- On ATTRIBUTE reduce production lqualid -> uqualid DOT lident
-- On AT reduce production lqualid -> uqualid DOT lident
-- On AS reduce production lqualid -> uqualid DOT lident
-- On ARROW reduce production lqualid -> uqualid DOT lident
-- On AND reduce production lqualid -> uqualid DOT lident
-- On AMPAMP reduce production lqualid -> uqualid DOT lident
-- On ALIAS reduce production lqualid -> uqualid DOT lident

State 89:
## Known stack suffix:
## uident
## LR(1) items:
uqualid -> uident . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AS ARROW AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production uqualid -> uident
-- On WITH reduce production uqualid -> uident
-- On VARIANT reduce production uqualid -> uident
-- On VAL reduce production uqualid -> uident
-- On USE reduce production uqualid -> uident
-- On UNDERSCORE reduce production uqualid -> uident
-- On UIDENT reduce production uqualid -> uident
-- On TYPE reduce production uqualid -> uident
-- On TRUE reduce production uqualid -> uident
-- On TO reduce production uqualid -> uident
-- On THEN reduce production uqualid -> uident
-- On SEMICOLON reduce production uqualid -> uident
-- On SCOPE reduce production uqualid -> uident
-- On RIGHTSQ_QUOTE reduce production uqualid -> uident
-- On RIGHTSQ reduce production uqualid -> uident
-- On RIGHTPAR reduce production uqualid -> uident
-- On RIGHTBRC reduce production uqualid -> uident
-- On RETURNS reduce production uqualid -> uident
-- On REQUIRES reduce production uqualid -> uident
-- On REAL reduce production uqualid -> uident
-- On READS reduce production uqualid -> uident
-- On RANGE reduce production uqualid -> uident
-- On RAISES reduce production uqualid -> uident
-- On PURE reduce production uqualid -> uident
-- On PREDICATE reduce production uqualid -> uident
-- On OPPREF reduce production uqualid -> uident
-- On OP4 reduce production uqualid -> uident
-- On OP3 reduce production uqualid -> uident
-- On OP2 reduce production uqualid -> uident
-- On OP1 reduce production uqualid -> uident
-- On MINUS reduce production uqualid -> uident
-- On META reduce production uqualid -> uident
-- On LTGT reduce production uqualid -> uident
-- On LT reduce production uqualid -> uident
-- On LIDENT reduce production uqualid -> uident
-- On LET reduce production uqualid -> uident
-- On LEMMA reduce production uqualid -> uident
-- On LEFTPAR reduce production uqualid -> uident
-- On LEFTBRC reduce production uqualid -> uident
-- On LARROW reduce production uqualid -> uident
-- On INTEGER reduce production uqualid -> uident
-- On INDUCTIVE reduce production uqualid -> uident
-- On IN reduce production uqualid -> uident
-- On IMPORT reduce production uqualid -> uident
-- On GT reduce production uqualid -> uident
-- On GOAL reduce production uqualid -> uident
-- On FUNCTION reduce production uqualid -> uident
-- On FLOAT reduce production uqualid -> uident
-- On FALSE reduce production uqualid -> uident
-- On EXCEPTION reduce production uqualid -> uident
-- On EQUAL reduce production uqualid -> uident
-- On EOF reduce production uqualid -> uident
-- On ENSURES reduce production uqualid -> uident
-- On END reduce production uqualid -> uident
-- On ELSE reduce production uqualid -> uident
-- On DOWNTO reduce production uqualid -> uident
-- On DOTDOT reduce production uqualid -> uident
-- On DOT reduce production uqualid -> uident
-- On DONE reduce production uqualid -> uident
-- On DO reduce production uqualid -> uident
-- On DIVERGES reduce production uqualid -> uident
-- On CORE_UIDENT reduce production uqualid -> uident
-- On CORE_LIDENT reduce production uqualid -> uident
-- On CONSTANT reduce production uqualid -> uident
-- On COMMA reduce production uqualid -> uident
-- On COLON reduce production uqualid -> uident
-- On COINDUCTIVE reduce production uqualid -> uident
-- On CLONE reduce production uqualid -> uident
-- On BEGIN reduce production uqualid -> uident
-- On BARBAR reduce production uqualid -> uident
-- On BAR reduce production uqualid -> uident
-- On AXIOM reduce production uqualid -> uident
-- On AS reduce production uqualid -> uident
-- On ARROW reduce production uqualid -> uident
-- On AMPAMP reduce production uqualid -> uident
-- On ALIAS reduce production uqualid -> uident

State 90:
## Known stack suffix:
## ty_block
## LR(1) items:
ty_arg -> ty_block . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production ty_arg -> ty_block
-- On WITH reduce production ty_arg -> ty_block
-- On VARIANT reduce production ty_arg -> ty_block
-- On VAL reduce production ty_arg -> ty_block
-- On USE reduce production ty_arg -> ty_block
-- On UNDERSCORE reduce production ty_arg -> ty_block
-- On UIDENT reduce production ty_arg -> ty_block
-- On TYPE reduce production ty_arg -> ty_block
-- On TO reduce production ty_arg -> ty_block
-- On THEN reduce production ty_arg -> ty_block
-- On SO reduce production ty_arg -> ty_block
-- On SEMICOLON reduce production ty_arg -> ty_block
-- On SCOPE reduce production ty_arg -> ty_block
-- On RIGHTSQ_QUOTE reduce production ty_arg -> ty_block
-- On RIGHTSQ reduce production ty_arg -> ty_block
-- On RIGHTPAR reduce production ty_arg -> ty_block
-- On RIGHTBRC reduce production ty_arg -> ty_block
-- On RETURNS reduce production ty_arg -> ty_block
-- On REQUIRES reduce production ty_arg -> ty_block
-- On READS reduce production ty_arg -> ty_block
-- On RANGE reduce production ty_arg -> ty_block
-- On RAISES reduce production ty_arg -> ty_block
-- On QUOTE_LIDENT reduce production ty_arg -> ty_block
-- On PREDICATE reduce production ty_arg -> ty_block
-- On POSITION reduce production ty_arg -> ty_block
-- On OR reduce production ty_arg -> ty_block
-- On OP4 reduce production ty_arg -> ty_block
-- On OP3 reduce production ty_arg -> ty_block
-- On OP2 reduce production ty_arg -> ty_block
-- On OP1 reduce production ty_arg -> ty_block
-- On MINUS reduce production ty_arg -> ty_block
-- On META reduce production ty_arg -> ty_block
-- On LTGT reduce production ty_arg -> ty_block
-- On LT reduce production ty_arg -> ty_block
-- On LRARROW reduce production ty_arg -> ty_block
-- On LIDENT reduce production ty_arg -> ty_block
-- On LET reduce production ty_arg -> ty_block
-- On LEMMA reduce production ty_arg -> ty_block
-- On LEFTSQ reduce production ty_arg -> ty_block
-- On LEFTPAR reduce production ty_arg -> ty_block
-- On LEFTBRC reduce production ty_arg -> ty_block
-- On LARROW reduce production ty_arg -> ty_block
-- On INVARIANT reduce production ty_arg -> ty_block
-- On INDUCTIVE reduce production ty_arg -> ty_block
-- On IN reduce production ty_arg -> ty_block
-- On IMPORT reduce production ty_arg -> ty_block
-- On GT reduce production ty_arg -> ty_block
-- On GOAL reduce production ty_arg -> ty_block
-- On FUNCTION reduce production ty_arg -> ty_block
-- On FLOAT reduce production ty_arg -> ty_block
-- On EXCEPTION reduce production ty_arg -> ty_block
-- On EQUAL reduce production ty_arg -> ty_block
-- On EOF reduce production ty_arg -> ty_block
-- On ENSURES reduce production ty_arg -> ty_block
-- On END reduce production ty_arg -> ty_block
-- On ELSE reduce production ty_arg -> ty_block
-- On DOWNTO reduce production ty_arg -> ty_block
-- On DOTDOT reduce production ty_arg -> ty_block
-- On DOT reduce production ty_arg -> ty_block
-- On DONE reduce production ty_arg -> ty_block
-- On DO reduce production ty_arg -> ty_block
-- On DIVERGES reduce production ty_arg -> ty_block
-- On CORE_UIDENT reduce production ty_arg -> ty_block
-- On CORE_LIDENT reduce production ty_arg -> ty_block
-- On CONSTANT reduce production ty_arg -> ty_block
-- On COMMA reduce production ty_arg -> ty_block
-- On COLON reduce production ty_arg -> ty_block
-- On COINDUCTIVE reduce production ty_arg -> ty_block
-- On CLONE reduce production ty_arg -> ty_block
-- On BY reduce production ty_arg -> ty_block
-- On BARBAR reduce production ty_arg -> ty_block
-- On BAR reduce production ty_arg -> ty_block
-- On AXIOM reduce production ty_arg -> ty_block
-- On ATTRIBUTE reduce production ty_arg -> ty_block
-- On AT reduce production ty_arg -> ty_block
-- On AS reduce production ty_arg -> ty_block
-- On ARROW reduce production ty_arg -> ty_block
-- On AND reduce production ty_arg -> ty_block
-- On AMPAMP reduce production ty_arg -> ty_block
-- On ALIAS reduce production ty_arg -> ty_block

State 91:
## Known stack suffix:
## ty_arg
## LR(1) items:
ty -> ty_arg . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production ty -> ty_arg
-- On WITH reduce production ty -> ty_arg
-- On VARIANT reduce production ty -> ty_arg
-- On VAL reduce production ty -> ty_arg
-- On USE reduce production ty -> ty_arg
-- On UNDERSCORE reduce production ty -> ty_arg
-- On TYPE reduce production ty -> ty_arg
-- On TO reduce production ty -> ty_arg
-- On THEN reduce production ty -> ty_arg
-- On SO reduce production ty -> ty_arg
-- On SEMICOLON reduce production ty -> ty_arg
-- On SCOPE reduce production ty -> ty_arg
-- On RIGHTSQ_QUOTE reduce production ty -> ty_arg
-- On RIGHTSQ reduce production ty -> ty_arg
-- On RIGHTPAR reduce production ty -> ty_arg
-- On RIGHTBRC reduce production ty -> ty_arg
-- On RETURNS reduce production ty -> ty_arg
-- On REQUIRES reduce production ty -> ty_arg
-- On READS reduce production ty -> ty_arg
-- On RAISES reduce production ty -> ty_arg
-- On PREDICATE reduce production ty -> ty_arg
-- On POSITION reduce production ty -> ty_arg
-- On OR reduce production ty -> ty_arg
-- On OP4 reduce production ty -> ty_arg
-- On OP3 reduce production ty -> ty_arg
-- On OP2 reduce production ty -> ty_arg
-- On OP1 reduce production ty -> ty_arg
-- On MINUS reduce production ty -> ty_arg
-- On META reduce production ty -> ty_arg
-- On LTGT reduce production ty -> ty_arg
-- On LT reduce production ty -> ty_arg
-- On LRARROW reduce production ty -> ty_arg
-- On LET reduce production ty -> ty_arg
-- On LEMMA reduce production ty -> ty_arg
-- On LEFTSQ reduce production ty -> ty_arg
-- On LARROW reduce production ty -> ty_arg
-- On INVARIANT reduce production ty -> ty_arg
-- On INDUCTIVE reduce production ty -> ty_arg
-- On IN reduce production ty -> ty_arg
-- On IMPORT reduce production ty -> ty_arg
-- On GT reduce production ty -> ty_arg
-- On GOAL reduce production ty -> ty_arg
-- On FUNCTION reduce production ty -> ty_arg
-- On EXCEPTION reduce production ty -> ty_arg
-- On EQUAL reduce production ty -> ty_arg
-- On EOF reduce production ty -> ty_arg
-- On ENSURES reduce production ty -> ty_arg
-- On END reduce production ty -> ty_arg
-- On ELSE reduce production ty -> ty_arg
-- On DOWNTO reduce production ty -> ty_arg
-- On DOTDOT reduce production ty -> ty_arg
-- On DOT reduce production ty -> ty_arg
-- On DONE reduce production ty -> ty_arg
-- On DO reduce production ty -> ty_arg
-- On DIVERGES reduce production ty -> ty_arg
-- On CONSTANT reduce production ty -> ty_arg
-- On COMMA reduce production ty -> ty_arg
-- On COLON reduce production ty -> ty_arg
-- On COINDUCTIVE reduce production ty -> ty_arg
-- On CLONE reduce production ty -> ty_arg
-- On BY reduce production ty -> ty_arg
-- On BARBAR reduce production ty -> ty_arg
-- On BAR reduce production ty -> ty_arg
-- On AXIOM reduce production ty -> ty_arg
-- On ATTRIBUTE reduce production ty -> ty_arg
-- On AT reduce production ty -> ty_arg
-- On AS reduce production ty -> ty_arg
-- On ARROW reduce production ty -> ty_arg
-- On AND reduce production ty -> ty_arg
-- On AMPAMP reduce production ty -> ty_arg
-- On ALIAS reduce production ty -> ty_arg

State 92:
## Known stack suffix:
## LEFTBRC ty
## LR(1) items:
ty -> ty . ARROW ty [ RIGHTBRC ARROW ]
ty_block -> LEFTBRC ty . RIGHTBRC [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 93
-- On ARROW shift to state 94
## Reductions:

State 93:
## Known stack suffix:
## LEFTBRC ty RIGHTBRC
## LR(1) items:
ty_block -> LEFTBRC ty RIGHTBRC . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On WITH reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On VARIANT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On VAL reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On USE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On UNDERSCORE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On UIDENT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On TYPE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On TO reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On THEN reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On SO reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On SEMICOLON reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On SCOPE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On RIGHTSQ reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On RIGHTPAR reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On RIGHTBRC reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On RETURNS reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On REQUIRES reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On READS reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On RANGE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On RAISES reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On QUOTE_LIDENT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On PREDICATE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On POSITION reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On OR reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On OP4 reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On OP3 reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On OP2 reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On OP1 reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On MINUS reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On META reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On LTGT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On LT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On LRARROW reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On LIDENT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On LET reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On LEMMA reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On LEFTSQ reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On LEFTPAR reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On LEFTBRC reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On LARROW reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On INVARIANT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On INDUCTIVE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On IN reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On IMPORT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On GT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On GOAL reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On FUNCTION reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On FLOAT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On EXCEPTION reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On EQUAL reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On EOF reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On ENSURES reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On END reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On ELSE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On DOWNTO reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On DOTDOT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On DOT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On DONE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On DO reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On DIVERGES reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On CORE_UIDENT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On CORE_LIDENT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On CONSTANT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On COMMA reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On COLON reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On COINDUCTIVE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On CLONE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On BY reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On BARBAR reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On BAR reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On AXIOM reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On ATTRIBUTE reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On AT reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On AS reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On ARROW reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On AND reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On AMPAMP reduce production ty_block -> LEFTBRC ty RIGHTBRC
-- On ALIAS reduce production ty_block -> LEFTBRC ty RIGHTBRC

State 94:
## Known stack suffix:
## ty ARROW
## LR(1) items:
ty -> ty ARROW . ty [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 95
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 95:
## Known stack suffix:
## ty ARROW ty
## LR(1) items:
ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
ty -> ty ARROW ty . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On WRITES reduce production ty -> ty ARROW ty
-- On WITH reduce production ty -> ty ARROW ty
-- On VARIANT reduce production ty -> ty ARROW ty
-- On VAL reduce production ty -> ty ARROW ty
-- On USE reduce production ty -> ty ARROW ty
-- On UNDERSCORE reduce production ty -> ty ARROW ty
-- On TYPE reduce production ty -> ty ARROW ty
-- On TO reduce production ty -> ty ARROW ty
-- On THEN reduce production ty -> ty ARROW ty
-- On SO reduce production ty -> ty ARROW ty
-- On SEMICOLON reduce production ty -> ty ARROW ty
-- On SCOPE reduce production ty -> ty ARROW ty
-- On RIGHTSQ_QUOTE reduce production ty -> ty ARROW ty
-- On RIGHTSQ reduce production ty -> ty ARROW ty
-- On RIGHTPAR reduce production ty -> ty ARROW ty
-- On RIGHTBRC reduce production ty -> ty ARROW ty
-- On RETURNS reduce production ty -> ty ARROW ty
-- On REQUIRES reduce production ty -> ty ARROW ty
-- On READS reduce production ty -> ty ARROW ty
-- On RAISES reduce production ty -> ty ARROW ty
-- On PREDICATE reduce production ty -> ty ARROW ty
-- On POSITION reduce production ty -> ty ARROW ty
-- On OR reduce production ty -> ty ARROW ty
-- On OP4 reduce production ty -> ty ARROW ty
-- On OP3 reduce production ty -> ty ARROW ty
-- On OP2 reduce production ty -> ty ARROW ty
-- On OP1 reduce production ty -> ty ARROW ty
-- On MINUS reduce production ty -> ty ARROW ty
-- On META reduce production ty -> ty ARROW ty
-- On LTGT reduce production ty -> ty ARROW ty
-- On LT reduce production ty -> ty ARROW ty
-- On LRARROW reduce production ty -> ty ARROW ty
-- On LET reduce production ty -> ty ARROW ty
-- On LEMMA reduce production ty -> ty ARROW ty
-- On LEFTSQ reduce production ty -> ty ARROW ty
-- On LARROW reduce production ty -> ty ARROW ty
-- On INVARIANT reduce production ty -> ty ARROW ty
-- On INDUCTIVE reduce production ty -> ty ARROW ty
-- On IN reduce production ty -> ty ARROW ty
-- On IMPORT reduce production ty -> ty ARROW ty
-- On GT reduce production ty -> ty ARROW ty
-- On GOAL reduce production ty -> ty ARROW ty
-- On FUNCTION reduce production ty -> ty ARROW ty
-- On EXCEPTION reduce production ty -> ty ARROW ty
-- On EQUAL reduce production ty -> ty ARROW ty
-- On EOF reduce production ty -> ty ARROW ty
-- On ENSURES reduce production ty -> ty ARROW ty
-- On END reduce production ty -> ty ARROW ty
-- On ELSE reduce production ty -> ty ARROW ty
-- On DOWNTO reduce production ty -> ty ARROW ty
-- On DOTDOT reduce production ty -> ty ARROW ty
-- On DOT reduce production ty -> ty ARROW ty
-- On DONE reduce production ty -> ty ARROW ty
-- On DO reduce production ty -> ty ARROW ty
-- On DIVERGES reduce production ty -> ty ARROW ty
-- On CONSTANT reduce production ty -> ty ARROW ty
-- On COMMA reduce production ty -> ty ARROW ty
-- On COLON reduce production ty -> ty ARROW ty
-- On COINDUCTIVE reduce production ty -> ty ARROW ty
-- On CLONE reduce production ty -> ty ARROW ty
-- On BY reduce production ty -> ty ARROW ty
-- On BARBAR reduce production ty -> ty ARROW ty
-- On BAR reduce production ty -> ty ARROW ty
-- On AXIOM reduce production ty -> ty ARROW ty
-- On ATTRIBUTE reduce production ty -> ty ARROW ty
-- On AT reduce production ty -> ty ARROW ty
-- On AS reduce production ty -> ty ARROW ty
-- On AND reduce production ty -> ty ARROW ty
-- On AMPAMP reduce production ty -> ty ARROW ty
-- On ALIAS reduce production ty -> ty ARROW ty

State 96:
## Known stack suffix:
## quote_lident
## LR(1) items:
ty_arg -> quote_lident . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production ty_arg -> quote_lident
-- On WITH reduce production ty_arg -> quote_lident
-- On VARIANT reduce production ty_arg -> quote_lident
-- On VAL reduce production ty_arg -> quote_lident
-- On USE reduce production ty_arg -> quote_lident
-- On UNDERSCORE reduce production ty_arg -> quote_lident
-- On UIDENT reduce production ty_arg -> quote_lident
-- On TYPE reduce production ty_arg -> quote_lident
-- On TO reduce production ty_arg -> quote_lident
-- On THEN reduce production ty_arg -> quote_lident
-- On SO reduce production ty_arg -> quote_lident
-- On SEMICOLON reduce production ty_arg -> quote_lident
-- On SCOPE reduce production ty_arg -> quote_lident
-- On RIGHTSQ_QUOTE reduce production ty_arg -> quote_lident
-- On RIGHTSQ reduce production ty_arg -> quote_lident
-- On RIGHTPAR reduce production ty_arg -> quote_lident
-- On RIGHTBRC reduce production ty_arg -> quote_lident
-- On RETURNS reduce production ty_arg -> quote_lident
-- On REQUIRES reduce production ty_arg -> quote_lident
-- On READS reduce production ty_arg -> quote_lident
-- On RANGE reduce production ty_arg -> quote_lident
-- On RAISES reduce production ty_arg -> quote_lident
-- On QUOTE_LIDENT reduce production ty_arg -> quote_lident
-- On PREDICATE reduce production ty_arg -> quote_lident
-- On POSITION reduce production ty_arg -> quote_lident
-- On OR reduce production ty_arg -> quote_lident
-- On OP4 reduce production ty_arg -> quote_lident
-- On OP3 reduce production ty_arg -> quote_lident
-- On OP2 reduce production ty_arg -> quote_lident
-- On OP1 reduce production ty_arg -> quote_lident
-- On MINUS reduce production ty_arg -> quote_lident
-- On META reduce production ty_arg -> quote_lident
-- On LTGT reduce production ty_arg -> quote_lident
-- On LT reduce production ty_arg -> quote_lident
-- On LRARROW reduce production ty_arg -> quote_lident
-- On LIDENT reduce production ty_arg -> quote_lident
-- On LET reduce production ty_arg -> quote_lident
-- On LEMMA reduce production ty_arg -> quote_lident
-- On LEFTSQ reduce production ty_arg -> quote_lident
-- On LEFTPAR reduce production ty_arg -> quote_lident
-- On LEFTBRC reduce production ty_arg -> quote_lident
-- On LARROW reduce production ty_arg -> quote_lident
-- On INVARIANT reduce production ty_arg -> quote_lident
-- On INDUCTIVE reduce production ty_arg -> quote_lident
-- On IN reduce production ty_arg -> quote_lident
-- On IMPORT reduce production ty_arg -> quote_lident
-- On GT reduce production ty_arg -> quote_lident
-- On GOAL reduce production ty_arg -> quote_lident
-- On FUNCTION reduce production ty_arg -> quote_lident
-- On FLOAT reduce production ty_arg -> quote_lident
-- On EXCEPTION reduce production ty_arg -> quote_lident
-- On EQUAL reduce production ty_arg -> quote_lident
-- On EOF reduce production ty_arg -> quote_lident
-- On ENSURES reduce production ty_arg -> quote_lident
-- On END reduce production ty_arg -> quote_lident
-- On ELSE reduce production ty_arg -> quote_lident
-- On DOWNTO reduce production ty_arg -> quote_lident
-- On DOTDOT reduce production ty_arg -> quote_lident
-- On DOT reduce production ty_arg -> quote_lident
-- On DONE reduce production ty_arg -> quote_lident
-- On DO reduce production ty_arg -> quote_lident
-- On DIVERGES reduce production ty_arg -> quote_lident
-- On CORE_UIDENT reduce production ty_arg -> quote_lident
-- On CORE_LIDENT reduce production ty_arg -> quote_lident
-- On CONSTANT reduce production ty_arg -> quote_lident
-- On COMMA reduce production ty_arg -> quote_lident
-- On COLON reduce production ty_arg -> quote_lident
-- On COINDUCTIVE reduce production ty_arg -> quote_lident
-- On CLONE reduce production ty_arg -> quote_lident
-- On BY reduce production ty_arg -> quote_lident
-- On BARBAR reduce production ty_arg -> quote_lident
-- On BAR reduce production ty_arg -> quote_lident
-- On AXIOM reduce production ty_arg -> quote_lident
-- On ATTRIBUTE reduce production ty_arg -> quote_lident
-- On AT reduce production ty_arg -> quote_lident
-- On AS reduce production ty_arg -> quote_lident
-- On ARROW reduce production ty_arg -> quote_lident
-- On AND reduce production ty_arg -> quote_lident
-- On AMPAMP reduce production ty_arg -> quote_lident
-- On ALIAS reduce production ty_arg -> quote_lident

State 97:
## Known stack suffix:
## lqualid
## LR(1) items:
ty -> lqualid . nonempty_list(ty_arg) [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
ty_arg -> lqualid . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 98
-- On quote_lident shift to state 96
-- On nonempty_list(ty_arg) shift to state 102
-- On lqualid shift to state 100
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:
-- On WRITES reduce production ty_arg -> lqualid
-- On WITH reduce production ty_arg -> lqualid
-- On VARIANT reduce production ty_arg -> lqualid
-- On VAL reduce production ty_arg -> lqualid
-- On USE reduce production ty_arg -> lqualid
-- On UNDERSCORE reduce production ty_arg -> lqualid
-- On TYPE reduce production ty_arg -> lqualid
-- On TO reduce production ty_arg -> lqualid
-- On THEN reduce production ty_arg -> lqualid
-- On SO reduce production ty_arg -> lqualid
-- On SEMICOLON reduce production ty_arg -> lqualid
-- On SCOPE reduce production ty_arg -> lqualid
-- On RIGHTSQ_QUOTE reduce production ty_arg -> lqualid
-- On RIGHTSQ reduce production ty_arg -> lqualid
-- On RIGHTPAR reduce production ty_arg -> lqualid
-- On RIGHTBRC reduce production ty_arg -> lqualid
-- On RETURNS reduce production ty_arg -> lqualid
-- On REQUIRES reduce production ty_arg -> lqualid
-- On READS reduce production ty_arg -> lqualid
-- On RAISES reduce production ty_arg -> lqualid
-- On PREDICATE reduce production ty_arg -> lqualid
-- On POSITION reduce production ty_arg -> lqualid
-- On OR reduce production ty_arg -> lqualid
-- On OP4 reduce production ty_arg -> lqualid
-- On OP3 reduce production ty_arg -> lqualid
-- On OP2 reduce production ty_arg -> lqualid
-- On OP1 reduce production ty_arg -> lqualid
-- On MINUS reduce production ty_arg -> lqualid
-- On META reduce production ty_arg -> lqualid
-- On LTGT reduce production ty_arg -> lqualid
-- On LT reduce production ty_arg -> lqualid
-- On LRARROW reduce production ty_arg -> lqualid
-- On LET reduce production ty_arg -> lqualid
-- On LEMMA reduce production ty_arg -> lqualid
-- On LEFTSQ reduce production ty_arg -> lqualid
-- On LARROW reduce production ty_arg -> lqualid
-- On INVARIANT reduce production ty_arg -> lqualid
-- On INDUCTIVE reduce production ty_arg -> lqualid
-- On IN reduce production ty_arg -> lqualid
-- On IMPORT reduce production ty_arg -> lqualid
-- On GT reduce production ty_arg -> lqualid
-- On GOAL reduce production ty_arg -> lqualid
-- On FUNCTION reduce production ty_arg -> lqualid
-- On EXCEPTION reduce production ty_arg -> lqualid
-- On EQUAL reduce production ty_arg -> lqualid
-- On EOF reduce production ty_arg -> lqualid
-- On ENSURES reduce production ty_arg -> lqualid
-- On END reduce production ty_arg -> lqualid
-- On ELSE reduce production ty_arg -> lqualid
-- On DOWNTO reduce production ty_arg -> lqualid
-- On DOTDOT reduce production ty_arg -> lqualid
-- On DOT reduce production ty_arg -> lqualid
-- On DONE reduce production ty_arg -> lqualid
-- On DO reduce production ty_arg -> lqualid
-- On DIVERGES reduce production ty_arg -> lqualid
-- On CONSTANT reduce production ty_arg -> lqualid
-- On COMMA reduce production ty_arg -> lqualid
-- On COLON reduce production ty_arg -> lqualid
-- On COINDUCTIVE reduce production ty_arg -> lqualid
-- On CLONE reduce production ty_arg -> lqualid
-- On BY reduce production ty_arg -> lqualid
-- On BARBAR reduce production ty_arg -> lqualid
-- On BAR reduce production ty_arg -> lqualid
-- On AXIOM reduce production ty_arg -> lqualid
-- On ATTRIBUTE reduce production ty_arg -> lqualid
-- On AT reduce production ty_arg -> lqualid
-- On AS reduce production ty_arg -> lqualid
-- On ARROW reduce production ty_arg -> lqualid
-- On AND reduce production ty_arg -> lqualid
-- On AMPAMP reduce production ty_arg -> lqualid
-- On ALIAS reduce production ty_arg -> lqualid

State 98:
## Known stack suffix:
## ty_arg
## LR(1) items:
nonempty_list(ty_arg) -> ty_arg . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
nonempty_list(ty_arg) -> ty_arg . nonempty_list(ty_arg) [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 98
-- On quote_lident shift to state 96
-- On nonempty_list(ty_arg) shift to state 99
-- On lqualid shift to state 100
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:
-- On WRITES reduce production nonempty_list(ty_arg) -> ty_arg
-- On WITH reduce production nonempty_list(ty_arg) -> ty_arg
-- On VARIANT reduce production nonempty_list(ty_arg) -> ty_arg
-- On VAL reduce production nonempty_list(ty_arg) -> ty_arg
-- On USE reduce production nonempty_list(ty_arg) -> ty_arg
-- On UNDERSCORE reduce production nonempty_list(ty_arg) -> ty_arg
-- On TYPE reduce production nonempty_list(ty_arg) -> ty_arg
-- On TO reduce production nonempty_list(ty_arg) -> ty_arg
-- On THEN reduce production nonempty_list(ty_arg) -> ty_arg
-- On SO reduce production nonempty_list(ty_arg) -> ty_arg
-- On SEMICOLON reduce production nonempty_list(ty_arg) -> ty_arg
-- On SCOPE reduce production nonempty_list(ty_arg) -> ty_arg
-- On RIGHTSQ_QUOTE reduce production nonempty_list(ty_arg) -> ty_arg
-- On RIGHTSQ reduce production nonempty_list(ty_arg) -> ty_arg
-- On RIGHTPAR reduce production nonempty_list(ty_arg) -> ty_arg
-- On RIGHTBRC reduce production nonempty_list(ty_arg) -> ty_arg
-- On RETURNS reduce production nonempty_list(ty_arg) -> ty_arg
-- On REQUIRES reduce production nonempty_list(ty_arg) -> ty_arg
-- On READS reduce production nonempty_list(ty_arg) -> ty_arg
-- On RAISES reduce production nonempty_list(ty_arg) -> ty_arg
-- On PREDICATE reduce production nonempty_list(ty_arg) -> ty_arg
-- On POSITION reduce production nonempty_list(ty_arg) -> ty_arg
-- On OR reduce production nonempty_list(ty_arg) -> ty_arg
-- On OP4 reduce production nonempty_list(ty_arg) -> ty_arg
-- On OP3 reduce production nonempty_list(ty_arg) -> ty_arg
-- On OP2 reduce production nonempty_list(ty_arg) -> ty_arg
-- On OP1 reduce production nonempty_list(ty_arg) -> ty_arg
-- On MINUS reduce production nonempty_list(ty_arg) -> ty_arg
-- On META reduce production nonempty_list(ty_arg) -> ty_arg
-- On LTGT reduce production nonempty_list(ty_arg) -> ty_arg
-- On LT reduce production nonempty_list(ty_arg) -> ty_arg
-- On LRARROW reduce production nonempty_list(ty_arg) -> ty_arg
-- On LET reduce production nonempty_list(ty_arg) -> ty_arg
-- On LEMMA reduce production nonempty_list(ty_arg) -> ty_arg
-- On LEFTSQ reduce production nonempty_list(ty_arg) -> ty_arg
-- On LARROW reduce production nonempty_list(ty_arg) -> ty_arg
-- On INVARIANT reduce production nonempty_list(ty_arg) -> ty_arg
-- On INDUCTIVE reduce production nonempty_list(ty_arg) -> ty_arg
-- On IN reduce production nonempty_list(ty_arg) -> ty_arg
-- On IMPORT reduce production nonempty_list(ty_arg) -> ty_arg
-- On GT reduce production nonempty_list(ty_arg) -> ty_arg
-- On GOAL reduce production nonempty_list(ty_arg) -> ty_arg
-- On FUNCTION reduce production nonempty_list(ty_arg) -> ty_arg
-- On EXCEPTION reduce production nonempty_list(ty_arg) -> ty_arg
-- On EQUAL reduce production nonempty_list(ty_arg) -> ty_arg
-- On EOF reduce production nonempty_list(ty_arg) -> ty_arg
-- On ENSURES reduce production nonempty_list(ty_arg) -> ty_arg
-- On END reduce production nonempty_list(ty_arg) -> ty_arg
-- On ELSE reduce production nonempty_list(ty_arg) -> ty_arg
-- On DOWNTO reduce production nonempty_list(ty_arg) -> ty_arg
-- On DOTDOT reduce production nonempty_list(ty_arg) -> ty_arg
-- On DOT reduce production nonempty_list(ty_arg) -> ty_arg
-- On DONE reduce production nonempty_list(ty_arg) -> ty_arg
-- On DO reduce production nonempty_list(ty_arg) -> ty_arg
-- On DIVERGES reduce production nonempty_list(ty_arg) -> ty_arg
-- On CONSTANT reduce production nonempty_list(ty_arg) -> ty_arg
-- On COMMA reduce production nonempty_list(ty_arg) -> ty_arg
-- On COLON reduce production nonempty_list(ty_arg) -> ty_arg
-- On COINDUCTIVE reduce production nonempty_list(ty_arg) -> ty_arg
-- On CLONE reduce production nonempty_list(ty_arg) -> ty_arg
-- On BY reduce production nonempty_list(ty_arg) -> ty_arg
-- On BARBAR reduce production nonempty_list(ty_arg) -> ty_arg
-- On BAR reduce production nonempty_list(ty_arg) -> ty_arg
-- On AXIOM reduce production nonempty_list(ty_arg) -> ty_arg
-- On ATTRIBUTE reduce production nonempty_list(ty_arg) -> ty_arg
-- On AT reduce production nonempty_list(ty_arg) -> ty_arg
-- On AS reduce production nonempty_list(ty_arg) -> ty_arg
-- On ARROW reduce production nonempty_list(ty_arg) -> ty_arg
-- On AND reduce production nonempty_list(ty_arg) -> ty_arg
-- On AMPAMP reduce production nonempty_list(ty_arg) -> ty_arg
-- On ALIAS reduce production nonempty_list(ty_arg) -> ty_arg

State 99:
## Known stack suffix:
## ty_arg nonempty_list(ty_arg)
## LR(1) items:
nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg) . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On WITH reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On VARIANT reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On VAL reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On USE reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On UNDERSCORE reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On TYPE reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On TO reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On THEN reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On SO reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On SEMICOLON reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On SCOPE reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On RIGHTSQ_QUOTE reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On RIGHTSQ reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On RIGHTPAR reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On RIGHTBRC reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On RETURNS reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On REQUIRES reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On READS reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On RAISES reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On PREDICATE reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On POSITION reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On OR reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On OP4 reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On OP3 reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On OP2 reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On OP1 reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On MINUS reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On META reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On LTGT reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On LT reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On LRARROW reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On LET reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On LEMMA reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On LEFTSQ reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On LARROW reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On INVARIANT reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On INDUCTIVE reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On IN reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On IMPORT reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On GT reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On GOAL reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On FUNCTION reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On EXCEPTION reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On EQUAL reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On EOF reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On ENSURES reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On END reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On ELSE reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On DOWNTO reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On DOTDOT reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On DOT reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On DONE reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On DO reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On DIVERGES reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On CONSTANT reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On COMMA reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On COLON reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On COINDUCTIVE reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On CLONE reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On BY reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On BARBAR reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On BAR reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On AXIOM reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On ATTRIBUTE reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On AT reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On AS reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On ARROW reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On AND reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On AMPAMP reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)
-- On ALIAS reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)

State 100:
## Known stack suffix:
## lqualid
## LR(1) items:
ty_arg -> lqualid . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production ty_arg -> lqualid
-- On WITH reduce production ty_arg -> lqualid
-- On VARIANT reduce production ty_arg -> lqualid
-- On VAL reduce production ty_arg -> lqualid
-- On USE reduce production ty_arg -> lqualid
-- On UNDERSCORE reduce production ty_arg -> lqualid
-- On UIDENT reduce production ty_arg -> lqualid
-- On TYPE reduce production ty_arg -> lqualid
-- On TO reduce production ty_arg -> lqualid
-- On THEN reduce production ty_arg -> lqualid
-- On SO reduce production ty_arg -> lqualid
-- On SEMICOLON reduce production ty_arg -> lqualid
-- On SCOPE reduce production ty_arg -> lqualid
-- On RIGHTSQ_QUOTE reduce production ty_arg -> lqualid
-- On RIGHTSQ reduce production ty_arg -> lqualid
-- On RIGHTPAR reduce production ty_arg -> lqualid
-- On RIGHTBRC reduce production ty_arg -> lqualid
-- On RETURNS reduce production ty_arg -> lqualid
-- On REQUIRES reduce production ty_arg -> lqualid
-- On READS reduce production ty_arg -> lqualid
-- On RANGE reduce production ty_arg -> lqualid
-- On RAISES reduce production ty_arg -> lqualid
-- On QUOTE_LIDENT reduce production ty_arg -> lqualid
-- On PREDICATE reduce production ty_arg -> lqualid
-- On POSITION reduce production ty_arg -> lqualid
-- On OR reduce production ty_arg -> lqualid
-- On OP4 reduce production ty_arg -> lqualid
-- On OP3 reduce production ty_arg -> lqualid
-- On OP2 reduce production ty_arg -> lqualid
-- On OP1 reduce production ty_arg -> lqualid
-- On MINUS reduce production ty_arg -> lqualid
-- On META reduce production ty_arg -> lqualid
-- On LTGT reduce production ty_arg -> lqualid
-- On LT reduce production ty_arg -> lqualid
-- On LRARROW reduce production ty_arg -> lqualid
-- On LIDENT reduce production ty_arg -> lqualid
-- On LET reduce production ty_arg -> lqualid
-- On LEMMA reduce production ty_arg -> lqualid
-- On LEFTSQ reduce production ty_arg -> lqualid
-- On LEFTPAR reduce production ty_arg -> lqualid
-- On LEFTBRC reduce production ty_arg -> lqualid
-- On LARROW reduce production ty_arg -> lqualid
-- On INVARIANT reduce production ty_arg -> lqualid
-- On INDUCTIVE reduce production ty_arg -> lqualid
-- On IN reduce production ty_arg -> lqualid
-- On IMPORT reduce production ty_arg -> lqualid
-- On GT reduce production ty_arg -> lqualid
-- On GOAL reduce production ty_arg -> lqualid
-- On FUNCTION reduce production ty_arg -> lqualid
-- On FLOAT reduce production ty_arg -> lqualid
-- On EXCEPTION reduce production ty_arg -> lqualid
-- On EQUAL reduce production ty_arg -> lqualid
-- On EOF reduce production ty_arg -> lqualid
-- On ENSURES reduce production ty_arg -> lqualid
-- On END reduce production ty_arg -> lqualid
-- On ELSE reduce production ty_arg -> lqualid
-- On DOWNTO reduce production ty_arg -> lqualid
-- On DOTDOT reduce production ty_arg -> lqualid
-- On DOT reduce production ty_arg -> lqualid
-- On DONE reduce production ty_arg -> lqualid
-- On DO reduce production ty_arg -> lqualid
-- On DIVERGES reduce production ty_arg -> lqualid
-- On CORE_UIDENT reduce production ty_arg -> lqualid
-- On CORE_LIDENT reduce production ty_arg -> lqualid
-- On CONSTANT reduce production ty_arg -> lqualid
-- On COMMA reduce production ty_arg -> lqualid
-- On COLON reduce production ty_arg -> lqualid
-- On COINDUCTIVE reduce production ty_arg -> lqualid
-- On CLONE reduce production ty_arg -> lqualid
-- On BY reduce production ty_arg -> lqualid
-- On BARBAR reduce production ty_arg -> lqualid
-- On BAR reduce production ty_arg -> lqualid
-- On AXIOM reduce production ty_arg -> lqualid
-- On ATTRIBUTE reduce production ty_arg -> lqualid
-- On AT reduce production ty_arg -> lqualid
-- On AS reduce production ty_arg -> lqualid
-- On ARROW reduce production ty_arg -> lqualid
-- On AND reduce production ty_arg -> lqualid
-- On AMPAMP reduce production ty_arg -> lqualid
-- On ALIAS reduce production ty_arg -> lqualid

State 101:
## Known stack suffix:
## lident
## LR(1) items:
lqualid -> lident . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lqualid -> lident
-- On WITH reduce production lqualid -> lident
-- On VARIANT reduce production lqualid -> lident
-- On VAL reduce production lqualid -> lident
-- On USE reduce production lqualid -> lident
-- On UNDERSCORE reduce production lqualid -> lident
-- On UIDENT reduce production lqualid -> lident
-- On TYPE reduce production lqualid -> lident
-- On TO reduce production lqualid -> lident
-- On THEN reduce production lqualid -> lident
-- On SO reduce production lqualid -> lident
-- On SEMICOLON reduce production lqualid -> lident
-- On SCOPE reduce production lqualid -> lident
-- On RIGHTSQ_QUOTE reduce production lqualid -> lident
-- On RIGHTSQ reduce production lqualid -> lident
-- On RIGHTPAR reduce production lqualid -> lident
-- On RIGHTBRC reduce production lqualid -> lident
-- On RETURNS reduce production lqualid -> lident
-- On REQUIRES reduce production lqualid -> lident
-- On READS reduce production lqualid -> lident
-- On RANGE reduce production lqualid -> lident
-- On RAISES reduce production lqualid -> lident
-- On QUOTE_LIDENT reduce production lqualid -> lident
-- On PREDICATE reduce production lqualid -> lident
-- On POSITION reduce production lqualid -> lident
-- On OR reduce production lqualid -> lident
-- On OP4 reduce production lqualid -> lident
-- On OP3 reduce production lqualid -> lident
-- On OP2 reduce production lqualid -> lident
-- On OP1 reduce production lqualid -> lident
-- On MINUS reduce production lqualid -> lident
-- On META reduce production lqualid -> lident
-- On LTGT reduce production lqualid -> lident
-- On LT reduce production lqualid -> lident
-- On LRARROW reduce production lqualid -> lident
-- On LIDENT reduce production lqualid -> lident
-- On LET reduce production lqualid -> lident
-- On LEMMA reduce production lqualid -> lident
-- On LEFTSQ reduce production lqualid -> lident
-- On LEFTPAR reduce production lqualid -> lident
-- On LEFTBRC reduce production lqualid -> lident
-- On LARROW reduce production lqualid -> lident
-- On INVARIANT reduce production lqualid -> lident
-- On INDUCTIVE reduce production lqualid -> lident
-- On IN reduce production lqualid -> lident
-- On IMPORT reduce production lqualid -> lident
-- On GT reduce production lqualid -> lident
-- On GOAL reduce production lqualid -> lident
-- On FUNCTION reduce production lqualid -> lident
-- On FLOAT reduce production lqualid -> lident
-- On EXCEPTION reduce production lqualid -> lident
-- On EQUAL reduce production lqualid -> lident
-- On EOF reduce production lqualid -> lident
-- On ENSURES reduce production lqualid -> lident
-- On END reduce production lqualid -> lident
-- On ELSE reduce production lqualid -> lident
-- On DOWNTO reduce production lqualid -> lident
-- On DOTDOT reduce production lqualid -> lident
-- On DOT reduce production lqualid -> lident
-- On DONE reduce production lqualid -> lident
-- On DO reduce production lqualid -> lident
-- On DIVERGES reduce production lqualid -> lident
-- On CORE_UIDENT reduce production lqualid -> lident
-- On CORE_LIDENT reduce production lqualid -> lident
-- On CONSTANT reduce production lqualid -> lident
-- On COMMA reduce production lqualid -> lident
-- On COLON reduce production lqualid -> lident
-- On COINDUCTIVE reduce production lqualid -> lident
-- On CLONE reduce production lqualid -> lident
-- On BY reduce production lqualid -> lident
-- On BARBAR reduce production lqualid -> lident
-- On BAR reduce production lqualid -> lident
-- On AXIOM reduce production lqualid -> lident
-- On ATTRIBUTE reduce production lqualid -> lident
-- On AT reduce production lqualid -> lident
-- On AS reduce production lqualid -> lident
-- On ARROW reduce production lqualid -> lident
-- On AND reduce production lqualid -> lident
-- On AMPAMP reduce production lqualid -> lident
-- On ALIAS reduce production lqualid -> lident

State 102:
## Known stack suffix:
## lqualid nonempty_list(ty_arg)
## LR(1) items:
ty -> lqualid nonempty_list(ty_arg) . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production ty -> lqualid nonempty_list(ty_arg)
-- On WITH reduce production ty -> lqualid nonempty_list(ty_arg)
-- On VARIANT reduce production ty -> lqualid nonempty_list(ty_arg)
-- On VAL reduce production ty -> lqualid nonempty_list(ty_arg)
-- On USE reduce production ty -> lqualid nonempty_list(ty_arg)
-- On UNDERSCORE reduce production ty -> lqualid nonempty_list(ty_arg)
-- On TYPE reduce production ty -> lqualid nonempty_list(ty_arg)
-- On TO reduce production ty -> lqualid nonempty_list(ty_arg)
-- On THEN reduce production ty -> lqualid nonempty_list(ty_arg)
-- On SO reduce production ty -> lqualid nonempty_list(ty_arg)
-- On SEMICOLON reduce production ty -> lqualid nonempty_list(ty_arg)
-- On SCOPE reduce production ty -> lqualid nonempty_list(ty_arg)
-- On RIGHTSQ_QUOTE reduce production ty -> lqualid nonempty_list(ty_arg)
-- On RIGHTSQ reduce production ty -> lqualid nonempty_list(ty_arg)
-- On RIGHTPAR reduce production ty -> lqualid nonempty_list(ty_arg)
-- On RIGHTBRC reduce production ty -> lqualid nonempty_list(ty_arg)
-- On RETURNS reduce production ty -> lqualid nonempty_list(ty_arg)
-- On REQUIRES reduce production ty -> lqualid nonempty_list(ty_arg)
-- On READS reduce production ty -> lqualid nonempty_list(ty_arg)
-- On RAISES reduce production ty -> lqualid nonempty_list(ty_arg)
-- On PREDICATE reduce production ty -> lqualid nonempty_list(ty_arg)
-- On POSITION reduce production ty -> lqualid nonempty_list(ty_arg)
-- On OR reduce production ty -> lqualid nonempty_list(ty_arg)
-- On OP4 reduce production ty -> lqualid nonempty_list(ty_arg)
-- On OP3 reduce production ty -> lqualid nonempty_list(ty_arg)
-- On OP2 reduce production ty -> lqualid nonempty_list(ty_arg)
-- On OP1 reduce production ty -> lqualid nonempty_list(ty_arg)
-- On MINUS reduce production ty -> lqualid nonempty_list(ty_arg)
-- On META reduce production ty -> lqualid nonempty_list(ty_arg)
-- On LTGT reduce production ty -> lqualid nonempty_list(ty_arg)
-- On LT reduce production ty -> lqualid nonempty_list(ty_arg)
-- On LRARROW reduce production ty -> lqualid nonempty_list(ty_arg)
-- On LET reduce production ty -> lqualid nonempty_list(ty_arg)
-- On LEMMA reduce production ty -> lqualid nonempty_list(ty_arg)
-- On LEFTSQ reduce production ty -> lqualid nonempty_list(ty_arg)
-- On LARROW reduce production ty -> lqualid nonempty_list(ty_arg)
-- On INVARIANT reduce production ty -> lqualid nonempty_list(ty_arg)
-- On INDUCTIVE reduce production ty -> lqualid nonempty_list(ty_arg)
-- On IN reduce production ty -> lqualid nonempty_list(ty_arg)
-- On IMPORT reduce production ty -> lqualid nonempty_list(ty_arg)
-- On GT reduce production ty -> lqualid nonempty_list(ty_arg)
-- On GOAL reduce production ty -> lqualid nonempty_list(ty_arg)
-- On FUNCTION reduce production ty -> lqualid nonempty_list(ty_arg)
-- On EXCEPTION reduce production ty -> lqualid nonempty_list(ty_arg)
-- On EQUAL reduce production ty -> lqualid nonempty_list(ty_arg)
-- On EOF reduce production ty -> lqualid nonempty_list(ty_arg)
-- On ENSURES reduce production ty -> lqualid nonempty_list(ty_arg)
-- On END reduce production ty -> lqualid nonempty_list(ty_arg)
-- On ELSE reduce production ty -> lqualid nonempty_list(ty_arg)
-- On DOWNTO reduce production ty -> lqualid nonempty_list(ty_arg)
-- On DOTDOT reduce production ty -> lqualid nonempty_list(ty_arg)
-- On DOT reduce production ty -> lqualid nonempty_list(ty_arg)
-- On DONE reduce production ty -> lqualid nonempty_list(ty_arg)
-- On DO reduce production ty -> lqualid nonempty_list(ty_arg)
-- On DIVERGES reduce production ty -> lqualid nonempty_list(ty_arg)
-- On CONSTANT reduce production ty -> lqualid nonempty_list(ty_arg)
-- On COMMA reduce production ty -> lqualid nonempty_list(ty_arg)
-- On COLON reduce production ty -> lqualid nonempty_list(ty_arg)
-- On COINDUCTIVE reduce production ty -> lqualid nonempty_list(ty_arg)
-- On CLONE reduce production ty -> lqualid nonempty_list(ty_arg)
-- On BY reduce production ty -> lqualid nonempty_list(ty_arg)
-- On BARBAR reduce production ty -> lqualid nonempty_list(ty_arg)
-- On BAR reduce production ty -> lqualid nonempty_list(ty_arg)
-- On AXIOM reduce production ty -> lqualid nonempty_list(ty_arg)
-- On ATTRIBUTE reduce production ty -> lqualid nonempty_list(ty_arg)
-- On AT reduce production ty -> lqualid nonempty_list(ty_arg)
-- On AS reduce production ty -> lqualid nonempty_list(ty_arg)
-- On ARROW reduce production ty -> lqualid nonempty_list(ty_arg)
-- On AND reduce production ty -> lqualid nonempty_list(ty_arg)
-- On AMPAMP reduce production ty -> lqualid nonempty_list(ty_arg)
-- On ALIAS reduce production ty -> lqualid nonempty_list(ty_arg)

State 103:
## Known stack suffix:
## LEFTPAR ty
## LR(1) items:
comma_list2(ty) -> ty . COMMA comma_list1(ty) [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
ty_block -> LEFTPAR ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 104
-- On COMMA shift to state 105
-- On ARROW shift to state 94
## Reductions:

State 104:
## Known stack suffix:
## LEFTPAR ty RIGHTPAR
## LR(1) items:
ty_block -> LEFTPAR ty RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On WITH reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On VARIANT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On VAL reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On USE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On UNDERSCORE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On UIDENT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On TYPE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On TO reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On THEN reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On SO reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On SEMICOLON reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On SCOPE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On RIGHTSQ reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On RIGHTPAR reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On RIGHTBRC reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On RETURNS reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On REQUIRES reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On READS reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On RANGE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On RAISES reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On QUOTE_LIDENT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On PREDICATE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On POSITION reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On OR reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On OP4 reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On OP3 reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On OP2 reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On OP1 reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On MINUS reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On META reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On LTGT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On LT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On LRARROW reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On LIDENT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On LET reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On LEMMA reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On LEFTSQ reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On LEFTPAR reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On LEFTBRC reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On LARROW reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On INVARIANT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On INDUCTIVE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On IN reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On IMPORT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On GT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On GOAL reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On FUNCTION reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On FLOAT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On EXCEPTION reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On EQUAL reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On EOF reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On ENSURES reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On END reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On ELSE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On DOWNTO reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On DOTDOT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On DOT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On DONE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On DO reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On DIVERGES reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On CORE_UIDENT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On CORE_LIDENT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On CONSTANT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On COMMA reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On COLON reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On COINDUCTIVE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On CLONE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On BY reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On BARBAR reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On BAR reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On AXIOM reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On ATTRIBUTE reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On AT reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On AS reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On ARROW reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On AND reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On AMPAMP reduce production ty_block -> LEFTPAR ty RIGHTPAR
-- On ALIAS reduce production ty_block -> LEFTPAR ty RIGHTPAR

State 105:
## Known stack suffix:
## ty COMMA
## LR(1) items:
comma_list2(ty) -> ty COMMA . comma_list1(ty) [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 106
-- On separated_nonempty_list(COMMA,ty) shift to state 109
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list1(ty) shift to state 110
## Reductions:

State 106:
## Known stack suffix:
## ty
## LR(1) items:
separated_nonempty_list(COMMA,ty) -> ty . [ RIGHTPAR ]
separated_nonempty_list(COMMA,ty) -> ty . COMMA separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## Transitions:
-- On COMMA shift to state 107
-- On ARROW shift to state 94
## Reductions:
-- On RIGHTPAR reduce production separated_nonempty_list(COMMA,ty) -> ty

State 107:
## Known stack suffix:
## ty COMMA
## LR(1) items:
separated_nonempty_list(COMMA,ty) -> ty COMMA . separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 106
-- On separated_nonempty_list(COMMA,ty) shift to state 108
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 108:
## Known stack suffix:
## ty COMMA separated_nonempty_list(COMMA,ty)
## LR(1) items:
separated_nonempty_list(COMMA,ty) -> ty COMMA separated_nonempty_list(COMMA,ty) . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production separated_nonempty_list(COMMA,ty) -> ty COMMA separated_nonempty_list(COMMA,ty)

State 109:
## Known stack suffix:
## separated_nonempty_list(COMMA,ty)
## LR(1) items:
comma_list1(ty) -> separated_nonempty_list(COMMA,ty) . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production comma_list1(ty) -> separated_nonempty_list(COMMA,ty)

State 110:
## Known stack suffix:
## ty COMMA comma_list1(ty)
## LR(1) items:
comma_list2(ty) -> ty COMMA comma_list1(ty) . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production comma_list2(ty) -> ty COMMA comma_list1(ty)

State 111:
## Known stack suffix:
## LEFTPAR comma_list2(ty)
## LR(1) items:
ty_block -> LEFTPAR comma_list2(ty) . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 112
## Reductions:

State 112:
## Known stack suffix:
## LEFTPAR comma_list2(ty) RIGHTPAR
## LR(1) items:
ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On WITH reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On VARIANT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On VAL reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On USE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On UNDERSCORE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On UIDENT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On TYPE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On TO reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On THEN reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On SO reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On SEMICOLON reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On SCOPE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On RIGHTSQ reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On RIGHTPAR reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On RIGHTBRC reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On RETURNS reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On REQUIRES reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On READS reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On RANGE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On RAISES reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On QUOTE_LIDENT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On PREDICATE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On POSITION reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On OR reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On OP4 reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On OP3 reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On OP2 reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On OP1 reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On MINUS reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On META reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On LTGT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On LT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On LRARROW reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On LIDENT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On LET reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On LEMMA reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On LEFTSQ reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On LEFTPAR reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On LEFTBRC reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On LARROW reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On INVARIANT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On INDUCTIVE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On IN reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On IMPORT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On GT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On GOAL reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On FUNCTION reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On FLOAT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On EXCEPTION reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On EQUAL reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On EOF reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On ENSURES reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On END reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On ELSE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On DOWNTO reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On DOTDOT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On DOT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On DONE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On DO reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On DIVERGES reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On CORE_UIDENT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On CORE_LIDENT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On CONSTANT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On COMMA reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On COLON reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On COINDUCTIVE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On CLONE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On BY reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On BARBAR reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On BAR reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On AXIOM reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On ATTRIBUTE reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On AT reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On AS reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On ARROW reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On AND reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On AMPAMP reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR
-- On ALIAS reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR

State 113:
## Known stack suffix:
## LEFTPAR GHOST
## LR(1) items:
param -> LEFTPAR GHOST . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
param -> LEFTPAR GHOST . binder_vars_rest RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
param -> LEFTPAR GHOST . binder_vars cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 114
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On binder_vars_rest shift to state 116
-- On binder_vars_head shift to state 118
-- On binder_vars shift to state 131
-- On anon_binder shift to state 136
## Reductions:

State 114:
## Known stack suffix:
## LEFTPAR GHOST ty
## LR(1) items:
binder_vars_head -> ty . [ UNDERSCORE POSITION COLON ATTRIBUTE ]
param -> LEFTPAR GHOST ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
ty -> ty . ARROW ty [ UNDERSCORE RIGHTPAR POSITION COLON ATTRIBUTE ARROW ]
## Transitions:
-- On RIGHTPAR shift to state 115
-- On ARROW shift to state 94
## Reductions:
-- On UNDERSCORE reduce production binder_vars_head -> ty
-- On POSITION reduce production binder_vars_head -> ty
-- On COLON reduce production binder_vars_head -> ty
-- On ATTRIBUTE reduce production binder_vars_head -> ty

State 115:
## Known stack suffix:
## LEFTPAR GHOST ty RIGHTPAR
## LR(1) items:
param -> LEFTPAR GHOST ty RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On WITH reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On VARIANT reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On VAL reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On USE reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On UNDERSCORE reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On UIDENT reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On TYPE reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On SCOPE reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On RETURNS reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On REQUIRES reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On READS reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On RANGE reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On RAISES reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On QUOTE_LIDENT reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On PREDICATE reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On META reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On LIDENT reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On LET reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On LEMMA reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On LEFTPAR reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On LEFTBRC reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On INVARIANT reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On INDUCTIVE reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On IN reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On IMPORT reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On GOAL reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On FUNCTION reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On FLOAT reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On EXCEPTION reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On EQUAL reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On EOF reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On ENSURES reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On END reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On DIVERGES reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On CORE_UIDENT reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On CORE_LIDENT reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On CONSTANT reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On COLON reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On COINDUCTIVE reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On CLONE reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On BY reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On BAR reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On AXIOM reduce production param -> LEFTPAR GHOST ty RIGHTPAR
-- On ALIAS reduce production param -> LEFTPAR GHOST ty RIGHTPAR

State 116:
## Known stack suffix:
## LEFTPAR GHOST binder_vars_rest
## LR(1) items:
binder_vars -> binder_vars_rest . [ COLON ]
param -> LEFTPAR GHOST binder_vars_rest . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 117
## Reductions:
-- On COLON reduce production binder_vars -> binder_vars_rest

State 117:
## Known stack suffix:
## LEFTPAR GHOST binder_vars_rest RIGHTPAR
## LR(1) items:
param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On WITH reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On VARIANT reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On VAL reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On USE reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On UNDERSCORE reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On UIDENT reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On TYPE reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On SCOPE reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On RETURNS reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On REQUIRES reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On READS reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On RANGE reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On RAISES reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On QUOTE_LIDENT reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On PREDICATE reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On META reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On LIDENT reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On LET reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On LEMMA reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On LEFTPAR reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On LEFTBRC reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On INVARIANT reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On INDUCTIVE reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On IN reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On IMPORT reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On GOAL reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On FUNCTION reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On FLOAT reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On EXCEPTION reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On EQUAL reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On EOF reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On ENSURES reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On END reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On DIVERGES reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On CORE_UIDENT reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On CORE_LIDENT reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On CONSTANT reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On COLON reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On COINDUCTIVE reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On CLONE reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On BY reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On BAR reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On AXIOM reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On ALIAS reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR

State 118:
## Known stack suffix:
## binder_vars_head
## LR(1) items:
binder_vars -> binder_vars_head . [ COLON ]
binder_vars_rest -> binder_vars_head . nonempty_list(attr) list(binder_var) [ RIGHTPAR COLON ]
binder_vars_rest -> binder_vars_head . anon_binder list(binder_var) [ RIGHTPAR COLON ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On nonempty_list(attr) shift to state 119
-- On attr shift to state 127
-- On anon_binder shift to state 129
## Reductions:
-- On COLON reduce production binder_vars -> binder_vars_head

State 119:
## Known stack suffix:
## binder_vars_head nonempty_list(attr)
## LR(1) items:
binder_vars_rest -> binder_vars_head nonempty_list(attr) . list(binder_var) [ RIGHTPAR COLON ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On list(binder_var) shift to state 120
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On binder_var shift to state 123
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:
-- On RIGHTPAR reduce production list(binder_var) ->
-- On COLON reduce production list(binder_var) ->

State 120:
## Known stack suffix:
## binder_vars_head nonempty_list(attr) list(binder_var)
## LR(1) items:
binder_vars_rest -> binder_vars_head nonempty_list(attr) list(binder_var) . [ RIGHTPAR COLON ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production binder_vars_rest -> binder_vars_head nonempty_list(attr) list(binder_var)
-- On COLON reduce production binder_vars_rest -> binder_vars_head nonempty_list(attr) list(binder_var)

State 121:
## Known stack suffix:
## lident_nq
## LR(1) items:
attrs(lident_nq) -> lident_nq . list(attr) [ WITH VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF END DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 122
-- On attr shift to state 71
## Reductions:
-- On WITH reduce production list(attr) ->
-- On VAL reduce production list(attr) ->
-- On USE reduce production list(attr) ->
-- On UNDERSCORE reduce production list(attr) ->
-- On UIDENT reduce production list(attr) ->
-- On TYPE reduce production list(attr) ->
-- On SEMICOLON reduce production list(attr) ->
-- On SCOPE reduce production list(attr) ->
-- On RIGHTPAR reduce production list(attr) ->
-- On RIGHTBRC reduce production list(attr) ->
-- On RANGE reduce production list(attr) ->
-- On QUOTE_LIDENT reduce production list(attr) ->
-- On PREDICATE reduce production list(attr) ->
-- On META reduce production list(attr) ->
-- On LIDENT reduce production list(attr) ->
-- On LET reduce production list(attr) ->
-- On LEMMA reduce production list(attr) ->
-- On LEFTSQ reduce production list(attr) ->
-- On LEFTPAR reduce production list(attr) ->
-- On LEFTBRC reduce production list(attr) ->
-- On INVARIANT reduce production list(attr) ->
-- On INDUCTIVE reduce production list(attr) ->
-- On IMPORT reduce production list(attr) ->
-- On GOAL reduce production list(attr) ->
-- On FUNCTION reduce production list(attr) ->
-- On FLOAT reduce production list(attr) ->
-- On EXCEPTION reduce production list(attr) ->
-- On EQUAL reduce production list(attr) ->
-- On EOF reduce production list(attr) ->
-- On END reduce production list(attr) ->
-- On DOT reduce production list(attr) ->
-- On CORE_UIDENT reduce production list(attr) ->
-- On CORE_LIDENT reduce production list(attr) ->
-- On CONSTANT reduce production list(attr) ->
-- On COMMA reduce production list(attr) ->
-- On COLON reduce production list(attr) ->
-- On COINDUCTIVE reduce production list(attr) ->
-- On CLONE reduce production list(attr) ->
-- On BY reduce production list(attr) ->
-- On BAR reduce production list(attr) ->
-- On AXIOM reduce production list(attr) ->
-- On AS reduce production list(attr) ->
-- On ARROW reduce production list(attr) ->

State 122:
## Known stack suffix:
## lident_nq list(attr)
## LR(1) items:
attrs(lident_nq) -> lident_nq list(attr) . [ WITH VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF END DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ]
## Transitions:
## Reductions:
-- On WITH reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On VAL reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On USE reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On UNDERSCORE reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On UIDENT reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On TYPE reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On SEMICOLON reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On SCOPE reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On RIGHTPAR reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On RIGHTBRC reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On RANGE reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On QUOTE_LIDENT reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On PREDICATE reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On META reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On LIDENT reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On LET reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On LEMMA reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On LEFTSQ reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On LEFTPAR reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On LEFTBRC reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On INVARIANT reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On INDUCTIVE reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On IMPORT reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On GOAL reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On FUNCTION reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On FLOAT reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On EXCEPTION reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On EQUAL reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On EOF reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On END reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On DOT reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On CORE_UIDENT reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On CORE_LIDENT reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On CONSTANT reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On COMMA reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On COLON reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On COINDUCTIVE reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On CLONE reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On BY reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On BAR reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On AXIOM reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On AS reduce production attrs(lident_nq) -> lident_nq list(attr)
-- On ARROW reduce production attrs(lident_nq) -> lident_nq list(attr)

State 123:
## Known stack suffix:
## binder_var
## LR(1) items:
list(binder_var) -> binder_var . list(binder_var) [ RIGHTPAR COLON ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On list(binder_var) shift to state 124
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On binder_var shift to state 123
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:
-- On RIGHTPAR reduce production list(binder_var) ->
-- On COLON reduce production list(binder_var) ->

State 124:
## Known stack suffix:
## binder_var list(binder_var)
## LR(1) items:
list(binder_var) -> binder_var list(binder_var) . [ RIGHTPAR COLON ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production list(binder_var) -> binder_var list(binder_var)
-- On COLON reduce production list(binder_var) -> binder_var list(binder_var)

State 125:
## Known stack suffix:
## attrs(lident_nq)
## LR(1) items:
binder_var -> attrs(lident_nq) . [ UNDERSCORE RIGHTPAR RANGE LIDENT LEFTSQ FLOAT DOT CORE_LIDENT COMMA COLON ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production binder_var -> attrs(lident_nq)
-- On RIGHTPAR reduce production binder_var -> attrs(lident_nq)
-- On RANGE reduce production binder_var -> attrs(lident_nq)
-- On LIDENT reduce production binder_var -> attrs(lident_nq)
-- On LEFTSQ reduce production binder_var -> attrs(lident_nq)
-- On FLOAT reduce production binder_var -> attrs(lident_nq)
-- On DOT reduce production binder_var -> attrs(lident_nq)
-- On CORE_LIDENT reduce production binder_var -> attrs(lident_nq)
-- On COMMA reduce production binder_var -> attrs(lident_nq)
-- On COLON reduce production binder_var -> attrs(lident_nq)

State 126:
## Known stack suffix:
## anon_binder
## LR(1) items:
binder_var -> anon_binder . [ UNDERSCORE RIGHTPAR RANGE LIDENT LEFTSQ FLOAT DOT CORE_LIDENT COMMA COLON ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production binder_var -> anon_binder
-- On RIGHTPAR reduce production binder_var -> anon_binder
-- On RANGE reduce production binder_var -> anon_binder
-- On LIDENT reduce production binder_var -> anon_binder
-- On LEFTSQ reduce production binder_var -> anon_binder
-- On FLOAT reduce production binder_var -> anon_binder
-- On DOT reduce production binder_var -> anon_binder
-- On CORE_LIDENT reduce production binder_var -> anon_binder
-- On COMMA reduce production binder_var -> anon_binder
-- On COLON reduce production binder_var -> anon_binder

State 127:
## Known stack suffix:
## attr
## LR(1) items:
nonempty_list(attr) -> attr . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
nonempty_list(attr) -> attr . nonempty_list(attr) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On nonempty_list(attr) shift to state 128
-- On attr shift to state 127
## Reductions:
-- On WRITES reduce production nonempty_list(attr) -> attr
-- On WITH reduce production nonempty_list(attr) -> attr
-- On VARIANT reduce production nonempty_list(attr) -> attr
-- On VAL reduce production nonempty_list(attr) -> attr
-- On USE reduce production nonempty_list(attr) -> attr
-- On UNDERSCORE reduce production nonempty_list(attr) -> attr
-- On UIDENT reduce production nonempty_list(attr) -> attr
-- On TYPE reduce production nonempty_list(attr) -> attr
-- On SCOPE reduce production nonempty_list(attr) -> attr
-- On RIGHTPAR reduce production nonempty_list(attr) -> attr
-- On RETURNS reduce production nonempty_list(attr) -> attr
-- On REQUIRES reduce production nonempty_list(attr) -> attr
-- On READS reduce production nonempty_list(attr) -> attr
-- On RANGE reduce production nonempty_list(attr) -> attr
-- On RAISES reduce production nonempty_list(attr) -> attr
-- On QUOTE_LIDENT reduce production nonempty_list(attr) -> attr
-- On PREDICATE reduce production nonempty_list(attr) -> attr
-- On META reduce production nonempty_list(attr) -> attr
-- On LIDENT reduce production nonempty_list(attr) -> attr
-- On LET reduce production nonempty_list(attr) -> attr
-- On LEMMA reduce production nonempty_list(attr) -> attr
-- On LEFTPAR reduce production nonempty_list(attr) -> attr
-- On LEFTBRC reduce production nonempty_list(attr) -> attr
-- On INVARIANT reduce production nonempty_list(attr) -> attr
-- On INDUCTIVE reduce production nonempty_list(attr) -> attr
-- On IN reduce production nonempty_list(attr) -> attr
-- On IMPORT reduce production nonempty_list(attr) -> attr
-- On GOAL reduce production nonempty_list(attr) -> attr
-- On FUNCTION reduce production nonempty_list(attr) -> attr
-- On FLOAT reduce production nonempty_list(attr) -> attr
-- On EXCEPTION reduce production nonempty_list(attr) -> attr
-- On EQUAL reduce production nonempty_list(attr) -> attr
-- On EOF reduce production nonempty_list(attr) -> attr
-- On ENSURES reduce production nonempty_list(attr) -> attr
-- On END reduce production nonempty_list(attr) -> attr
-- On DIVERGES reduce production nonempty_list(attr) -> attr
-- On CORE_UIDENT reduce production nonempty_list(attr) -> attr
-- On CORE_LIDENT reduce production nonempty_list(attr) -> attr
-- On CONSTANT reduce production nonempty_list(attr) -> attr
-- On COLON reduce production nonempty_list(attr) -> attr
-- On COINDUCTIVE reduce production nonempty_list(attr) -> attr
-- On CLONE reduce production nonempty_list(attr) -> attr
-- On BY reduce production nonempty_list(attr) -> attr
-- On BAR reduce production nonempty_list(attr) -> attr
-- On AXIOM reduce production nonempty_list(attr) -> attr
-- On ARROW reduce production nonempty_list(attr) -> attr
-- On ALIAS reduce production nonempty_list(attr) -> attr

State 128:
## Known stack suffix:
## attr nonempty_list(attr)
## LR(1) items:
nonempty_list(attr) -> attr nonempty_list(attr) . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On WITH reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On VARIANT reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On VAL reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On USE reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On UNDERSCORE reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On UIDENT reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On TYPE reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On SCOPE reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On RIGHTPAR reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On RETURNS reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On REQUIRES reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On READS reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On RANGE reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On RAISES reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On QUOTE_LIDENT reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On PREDICATE reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On META reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On LIDENT reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On LET reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On LEMMA reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On LEFTPAR reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On LEFTBRC reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On INVARIANT reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On INDUCTIVE reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On IN reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On IMPORT reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On GOAL reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On FUNCTION reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On FLOAT reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On EXCEPTION reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On EQUAL reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On EOF reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On ENSURES reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On END reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On DIVERGES reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On CORE_UIDENT reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On CORE_LIDENT reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On CONSTANT reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On COLON reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On COINDUCTIVE reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On CLONE reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On BY reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On BAR reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On AXIOM reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On ARROW reduce production nonempty_list(attr) -> attr nonempty_list(attr)
-- On ALIAS reduce production nonempty_list(attr) -> attr nonempty_list(attr)

State 129:
## Known stack suffix:
## binder_vars_head anon_binder
## LR(1) items:
binder_vars_rest -> binder_vars_head anon_binder . list(binder_var) [ RIGHTPAR COLON ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On list(binder_var) shift to state 130
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On binder_var shift to state 123
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:
-- On RIGHTPAR reduce production list(binder_var) ->
-- On COLON reduce production list(binder_var) ->

State 130:
## Known stack suffix:
## binder_vars_head anon_binder list(binder_var)
## LR(1) items:
binder_vars_rest -> binder_vars_head anon_binder list(binder_var) . [ RIGHTPAR COLON ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production binder_vars_rest -> binder_vars_head anon_binder list(binder_var)
-- On COLON reduce production binder_vars_rest -> binder_vars_head anon_binder list(binder_var)

State 131:
## Known stack suffix:
## LEFTPAR GHOST binder_vars
## LR(1) items:
param -> LEFTPAR GHOST binder_vars . cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 134
## Reductions:

State 132:
## Known stack suffix:
## COLON
## LR(1) items:
cast -> COLON . ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 133
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 133:
## Known stack suffix:
## COLON ty
## LR(1) items:
cast -> COLON ty . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT AS ARROW AND AMPAMP ALIAS ]
ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On WRITES reduce production cast -> COLON ty
-- On WITH reduce production cast -> COLON ty
-- On VARIANT reduce production cast -> COLON ty
-- On VAL reduce production cast -> COLON ty
-- On USE reduce production cast -> COLON ty
-- On TYPE reduce production cast -> COLON ty
-- On TO reduce production cast -> COLON ty
-- On THEN reduce production cast -> COLON ty
-- On SO reduce production cast -> COLON ty
-- On SEMICOLON reduce production cast -> COLON ty
-- On SCOPE reduce production cast -> COLON ty
-- On RIGHTSQ_QUOTE reduce production cast -> COLON ty
-- On RIGHTSQ reduce production cast -> COLON ty
-- On RIGHTPAR reduce production cast -> COLON ty
-- On RIGHTBRC reduce production cast -> COLON ty
-- On RETURNS reduce production cast -> COLON ty
-- On REQUIRES reduce production cast -> COLON ty
-- On READS reduce production cast -> COLON ty
-- On RAISES reduce production cast -> COLON ty
-- On PREDICATE reduce production cast -> COLON ty
-- On OR reduce production cast -> COLON ty
-- On OP4 reduce production cast -> COLON ty
-- On OP3 reduce production cast -> COLON ty
-- On OP2 reduce production cast -> COLON ty
-- On OP1 reduce production cast -> COLON ty
-- On MINUS reduce production cast -> COLON ty
-- On META reduce production cast -> COLON ty
-- On LTGT reduce production cast -> COLON ty
-- On LT reduce production cast -> COLON ty
-- On LRARROW reduce production cast -> COLON ty
-- On LET reduce production cast -> COLON ty
-- On LEMMA reduce production cast -> COLON ty
-- On LEFTSQ reduce production cast -> COLON ty
-- On LARROW reduce production cast -> COLON ty
-- On INDUCTIVE reduce production cast -> COLON ty
-- On IN reduce production cast -> COLON ty
-- On IMPORT reduce production cast -> COLON ty
-- On GT reduce production cast -> COLON ty
-- On GOAL reduce production cast -> COLON ty
-- On FUNCTION reduce production cast -> COLON ty
-- On EXCEPTION reduce production cast -> COLON ty
-- On EQUAL reduce production cast -> COLON ty
-- On EOF reduce production cast -> COLON ty
-- On ENSURES reduce production cast -> COLON ty
-- On END reduce production cast -> COLON ty
-- On ELSE reduce production cast -> COLON ty
-- On DOWNTO reduce production cast -> COLON ty
-- On DOTDOT reduce production cast -> COLON ty
-- On DOT reduce production cast -> COLON ty
-- On DONE reduce production cast -> COLON ty
-- On DO reduce production cast -> COLON ty
-- On DIVERGES reduce production cast -> COLON ty
-- On CONSTANT reduce production cast -> COLON ty
-- On COMMA reduce production cast -> COLON ty
-- On COLON reduce production cast -> COLON ty
-- On COINDUCTIVE reduce production cast -> COLON ty
-- On CLONE reduce production cast -> COLON ty
-- On BY reduce production cast -> COLON ty
-- On BARBAR reduce production cast -> COLON ty
-- On BAR reduce production cast -> COLON ty
-- On AXIOM reduce production cast -> COLON ty
-- On AT reduce production cast -> COLON ty
-- On AS reduce production cast -> COLON ty
-- On AND reduce production cast -> COLON ty
-- On AMPAMP reduce production cast -> COLON ty
-- On ALIAS reduce production cast -> COLON ty

State 134:
## Known stack suffix:
## LEFTPAR GHOST binder_vars cast
## LR(1) items:
param -> LEFTPAR GHOST binder_vars cast . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 135
## Reductions:

State 135:
## Known stack suffix:
## LEFTPAR GHOST binder_vars cast RIGHTPAR
## LR(1) items:
param -> LEFTPAR GHOST binder_vars cast RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On WITH reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On VARIANT reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On VAL reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On USE reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On UNDERSCORE reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On UIDENT reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On TYPE reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On SCOPE reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On RETURNS reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On REQUIRES reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On READS reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On RANGE reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On RAISES reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On QUOTE_LIDENT reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On PREDICATE reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On META reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On LIDENT reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On LET reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On LEMMA reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On LEFTPAR reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On LEFTBRC reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On INVARIANT reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On INDUCTIVE reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On IN reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On IMPORT reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On GOAL reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On FUNCTION reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On FLOAT reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On EXCEPTION reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On EQUAL reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On EOF reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On ENSURES reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On END reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On DIVERGES reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On CORE_UIDENT reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On CORE_LIDENT reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On CONSTANT reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On COLON reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On COINDUCTIVE reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On CLONE reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On BY reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On BAR reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On AXIOM reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On ALIAS reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR

State 136:
## Known stack suffix:
## anon_binder
## LR(1) items:
binder_vars_rest -> anon_binder . list(binder_var) [ RIGHTPAR COLON ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On list(binder_var) shift to state 137
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On binder_var shift to state 123
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:
-- On RIGHTPAR reduce production list(binder_var) ->
-- On COLON reduce production list(binder_var) ->

State 137:
## Known stack suffix:
## anon_binder list(binder_var)
## LR(1) items:
binder_vars_rest -> anon_binder list(binder_var) . [ RIGHTPAR COLON ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production binder_vars_rest -> anon_binder list(binder_var)
-- On COLON reduce production binder_vars_rest -> anon_binder list(binder_var)

State 138:
## Known stack suffix:
## LEFTPAR ty
## LR(1) items:
binder_vars_head -> ty . [ UNDERSCORE POSITION COLON ATTRIBUTE ]
comma_list2(ty) -> ty . COMMA comma_list1(ty) [ RIGHTPAR ]
ty -> ty . ARROW ty [ UNDERSCORE RIGHTPAR POSITION COMMA COLON ATTRIBUTE ARROW ]
ty_block -> LEFTPAR ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 104
-- On COMMA shift to state 105
-- On ARROW shift to state 94
## Reductions:
-- On UNDERSCORE reduce production binder_vars_head -> ty
-- On POSITION reduce production binder_vars_head -> ty
-- On COLON reduce production binder_vars_head -> ty
-- On ATTRIBUTE reduce production binder_vars_head -> ty

State 139:
## Known stack suffix:
## LEFTPAR binder_vars_rest
## LR(1) items:
binder_vars -> binder_vars_rest . [ COLON ]
param -> LEFTPAR binder_vars_rest . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 140
## Reductions:
-- On COLON reduce production binder_vars -> binder_vars_rest

State 140:
## Known stack suffix:
## LEFTPAR binder_vars_rest RIGHTPAR
## LR(1) items:
param -> LEFTPAR binder_vars_rest RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On WITH reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On VARIANT reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On VAL reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On USE reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On UNDERSCORE reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On UIDENT reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On TYPE reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On SCOPE reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On RETURNS reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On REQUIRES reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On READS reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On RANGE reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On RAISES reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On QUOTE_LIDENT reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On PREDICATE reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On META reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On LIDENT reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On LET reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On LEMMA reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On LEFTPAR reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On LEFTBRC reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On INVARIANT reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On INDUCTIVE reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On IN reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On IMPORT reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On GOAL reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On FUNCTION reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On FLOAT reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On EXCEPTION reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On EQUAL reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On EOF reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On ENSURES reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On END reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On DIVERGES reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On CORE_UIDENT reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On CORE_LIDENT reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On CONSTANT reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On COLON reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On COINDUCTIVE reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On CLONE reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On BY reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On BAR reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On AXIOM reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR
-- On ALIAS reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR

State 141:
## Known stack suffix:
## LEFTPAR binder_vars
## LR(1) items:
param -> LEFTPAR binder_vars . cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 142
## Reductions:

State 142:
## Known stack suffix:
## LEFTPAR binder_vars cast
## LR(1) items:
param -> LEFTPAR binder_vars cast . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 143
## Reductions:

State 143:
## Known stack suffix:
## LEFTPAR binder_vars cast RIGHTPAR
## LR(1) items:
param -> LEFTPAR binder_vars cast RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On WITH reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On VARIANT reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On VAL reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On USE reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On UNDERSCORE reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On UIDENT reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On TYPE reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On SCOPE reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On RETURNS reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On REQUIRES reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On READS reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On RANGE reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On RAISES reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On QUOTE_LIDENT reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On PREDICATE reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On META reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On LIDENT reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On LET reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On LEMMA reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On LEFTPAR reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On LEFTBRC reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On INVARIANT reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On INDUCTIVE reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On IN reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On IMPORT reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On GOAL reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On FUNCTION reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On FLOAT reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On EXCEPTION reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On EQUAL reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On EOF reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On ENSURES reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On END reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On DIVERGES reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On CORE_UIDENT reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On CORE_LIDENT reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On CONSTANT reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On COLON reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On COINDUCTIVE reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On CLONE reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On BY reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On BAR reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On AXIOM reduce production param -> LEFTPAR binder_vars cast RIGHTPAR
-- On ALIAS reduce production param -> LEFTPAR binder_vars cast RIGHTPAR

State 144:
## Known stack suffix:
## CORE_LIDENT
## LR(1) items:
lident -> CORE_LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
lident_nq -> CORE_LIDENT . [ POSITION ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident -> CORE_LIDENT
-- On WITH reduce production lident -> CORE_LIDENT
-- On VARIANT reduce production lident -> CORE_LIDENT
-- On VAL reduce production lident -> CORE_LIDENT
-- On USE reduce production lident -> CORE_LIDENT
-- On UNDERSCORE reduce production lident -> CORE_LIDENT
-- On UIDENT reduce production lident -> CORE_LIDENT
-- On TYPE reduce production lident -> CORE_LIDENT
-- On SCOPE reduce production lident -> CORE_LIDENT
-- On RETURNS reduce production lident -> CORE_LIDENT
-- On REQUIRES reduce production lident -> CORE_LIDENT
-- On READS reduce production lident -> CORE_LIDENT
-- On RANGE reduce production lident -> CORE_LIDENT
-- On RAISES reduce production lident -> CORE_LIDENT
-- On QUOTE_LIDENT reduce production lident -> CORE_LIDENT
-- On PREDICATE reduce production lident -> CORE_LIDENT
-- On POSITION reduce production lident_nq -> CORE_LIDENT
-- On META reduce production lident -> CORE_LIDENT
-- On LIDENT reduce production lident -> CORE_LIDENT
-- On LET reduce production lident -> CORE_LIDENT
-- On LEMMA reduce production lident -> CORE_LIDENT
-- On LEFTPAR reduce production lident -> CORE_LIDENT
-- On LEFTBRC reduce production lident -> CORE_LIDENT
-- On INVARIANT reduce production lident -> CORE_LIDENT
-- On INDUCTIVE reduce production lident -> CORE_LIDENT
-- On IN reduce production lident -> CORE_LIDENT
-- On IMPORT reduce production lident -> CORE_LIDENT
-- On GOAL reduce production lident -> CORE_LIDENT
-- On FUNCTION reduce production lident -> CORE_LIDENT
-- On FLOAT reduce production lident -> CORE_LIDENT
-- On EXCEPTION reduce production lident -> CORE_LIDENT
-- On EQUAL reduce production lident -> CORE_LIDENT
-- On EOF reduce production lident -> CORE_LIDENT
-- On ENSURES reduce production lident -> CORE_LIDENT
-- On END reduce production lident -> CORE_LIDENT
-- On DIVERGES reduce production lident -> CORE_LIDENT
-- On CORE_UIDENT reduce production lident -> CORE_LIDENT
-- On CORE_LIDENT reduce production lident -> CORE_LIDENT
-- On CONSTANT reduce production lident -> CORE_LIDENT
-- On COLON reduce production lident -> CORE_LIDENT
-- On COINDUCTIVE reduce production lident -> CORE_LIDENT
-- On CLONE reduce production lident -> CORE_LIDENT
-- On BY reduce production lident -> CORE_LIDENT
-- On BAR reduce production lident -> CORE_LIDENT
-- On AXIOM reduce production lident -> CORE_LIDENT
-- On ATTRIBUTE reduce production lident_nq -> CORE_LIDENT
-- On ARROW reduce production lident -> CORE_LIDENT
-- On ALIAS reduce production lident -> CORE_LIDENT

State 145:
## Known stack suffix:
## val_defn
## LR(1) items:
mk_expr(val_defn) -> val_defn . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production mk_expr(val_defn) -> val_defn
-- On USE reduce production mk_expr(val_defn) -> val_defn
-- On TYPE reduce production mk_expr(val_defn) -> val_defn
-- On SCOPE reduce production mk_expr(val_defn) -> val_defn
-- On PREDICATE reduce production mk_expr(val_defn) -> val_defn
-- On META reduce production mk_expr(val_defn) -> val_defn
-- On LET reduce production mk_expr(val_defn) -> val_defn
-- On LEMMA reduce production mk_expr(val_defn) -> val_defn
-- On INDUCTIVE reduce production mk_expr(val_defn) -> val_defn
-- On IN reduce production mk_expr(val_defn) -> val_defn
-- On IMPORT reduce production mk_expr(val_defn) -> val_defn
-- On GOAL reduce production mk_expr(val_defn) -> val_defn
-- On FUNCTION reduce production mk_expr(val_defn) -> val_defn
-- On EXCEPTION reduce production mk_expr(val_defn) -> val_defn
-- On EOF reduce production mk_expr(val_defn) -> val_defn
-- On END reduce production mk_expr(val_defn) -> val_defn
-- On CONSTANT reduce production mk_expr(val_defn) -> val_defn
-- On COINDUCTIVE reduce production mk_expr(val_defn) -> val_defn
-- On CLONE reduce production mk_expr(val_defn) -> val_defn
-- On AXIOM reduce production mk_expr(val_defn) -> val_defn

State 146:
## Known stack suffix:
## ty_arg
## LR(1) items:
param -> ty_arg . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production param -> ty_arg
-- On WITH reduce production param -> ty_arg
-- On VARIANT reduce production param -> ty_arg
-- On VAL reduce production param -> ty_arg
-- On USE reduce production param -> ty_arg
-- On UNDERSCORE reduce production param -> ty_arg
-- On UIDENT reduce production param -> ty_arg
-- On TYPE reduce production param -> ty_arg
-- On SCOPE reduce production param -> ty_arg
-- On RETURNS reduce production param -> ty_arg
-- On REQUIRES reduce production param -> ty_arg
-- On READS reduce production param -> ty_arg
-- On RANGE reduce production param -> ty_arg
-- On RAISES reduce production param -> ty_arg
-- On QUOTE_LIDENT reduce production param -> ty_arg
-- On PREDICATE reduce production param -> ty_arg
-- On META reduce production param -> ty_arg
-- On LIDENT reduce production param -> ty_arg
-- On LET reduce production param -> ty_arg
-- On LEMMA reduce production param -> ty_arg
-- On LEFTPAR reduce production param -> ty_arg
-- On LEFTBRC reduce production param -> ty_arg
-- On INVARIANT reduce production param -> ty_arg
-- On INDUCTIVE reduce production param -> ty_arg
-- On IN reduce production param -> ty_arg
-- On IMPORT reduce production param -> ty_arg
-- On GOAL reduce production param -> ty_arg
-- On FUNCTION reduce production param -> ty_arg
-- On FLOAT reduce production param -> ty_arg
-- On EXCEPTION reduce production param -> ty_arg
-- On EQUAL reduce production param -> ty_arg
-- On EOF reduce production param -> ty_arg
-- On ENSURES reduce production param -> ty_arg
-- On END reduce production param -> ty_arg
-- On DIVERGES reduce production param -> ty_arg
-- On CORE_UIDENT reduce production param -> ty_arg
-- On CORE_LIDENT reduce production param -> ty_arg
-- On CONSTANT reduce production param -> ty_arg
-- On COLON reduce production param -> ty_arg
-- On COINDUCTIVE reduce production param -> ty_arg
-- On CLONE reduce production param -> ty_arg
-- On BY reduce production param -> ty_arg
-- On BAR reduce production param -> ty_arg
-- On AXIOM reduce production param -> ty_arg
-- On ALIAS reduce production param -> ty_arg

State 147:
## Known stack suffix:
## params
## LR(1) items:
val_defn -> params . return_opt spec [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 148
-- On return_opt shift to state 196
## Reductions:
-- On WRITES reduce production return_opt ->
-- On VARIANT reduce production return_opt ->
-- On VAL reduce production return_opt ->
-- On USE reduce production return_opt ->
-- On TYPE reduce production return_opt ->
-- On SCOPE reduce production return_opt ->
-- On RETURNS reduce production return_opt ->
-- On REQUIRES reduce production return_opt ->
-- On READS reduce production return_opt ->
-- On RAISES reduce production return_opt ->
-- On PREDICATE reduce production return_opt ->
-- On META reduce production return_opt ->
-- On LET reduce production return_opt ->
-- On LEMMA reduce production return_opt ->
-- On INDUCTIVE reduce production return_opt ->
-- On IN reduce production return_opt ->
-- On IMPORT reduce production return_opt ->
-- On GOAL reduce production return_opt ->
-- On FUNCTION reduce production return_opt ->
-- On EXCEPTION reduce production return_opt ->
-- On EOF reduce production return_opt ->
-- On ENSURES reduce production return_opt ->
-- On END reduce production return_opt ->
-- On DIVERGES reduce production return_opt ->
-- On CONSTANT reduce production return_opt ->
-- On COINDUCTIVE reduce production return_opt ->
-- On CLONE reduce production return_opt ->
-- On AXIOM reduce production return_opt ->
-- On ALIAS reduce production return_opt ->

State 148:
## Known stack suffix:
## COLON
## LR(1) items:
return_opt -> COLON . return_named [ WRITES VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COINDUCTIVE CLONE AXIOM ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 149
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 191
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 193
-- On return_named shift to state 194
-- On return shift to state 195
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 149:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
return -> LEFTPAR . GHOST ty RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
return -> LEFTPAR . ret_ghost RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
return_named -> LEFTPAR . ret_cast RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
return_named -> LEFTPAR . comma_list2(ret_cast) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
ty_block -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
ty_block -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
ty_block -> LEFTPAR . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 150
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 81
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 151
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 152
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 153
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 169
-- On ret_ident shift to state 176
-- On ret_ghost shift to state 178
-- On ret_cast shift to state 180
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 167
-- On lident shift to state 101
-- On comma_list2(ty) shift to state 111
-- On comma_list2(ret_cast) shift to state 189
-- On attrs(lident_nq) shift to state 168
## Reductions:

State 150:
## Known stack suffix:
## UNDERSCORE
## LR(1) items:
ret_ident -> UNDERSCORE . [ COLON ]
## Transitions:
## Reductions:
-- On COLON reduce production ret_ident -> UNDERSCORE

State 151:
## Known stack suffix:
## LIDENT
## LR(1) items:
lident -> LIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF CORE_UIDENT CORE_LIDENT CONSTANT COMMA COINDUCTIVE CLONE BY BAR AXIOM ARROW ]
lident_nq -> LIDENT . [ POSITION COLON ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WITH reduce production lident -> LIDENT
-- On VAL reduce production lident -> LIDENT
-- On USE reduce production lident -> LIDENT
-- On UNDERSCORE reduce production lident -> LIDENT
-- On UIDENT reduce production lident -> LIDENT
-- On TYPE reduce production lident -> LIDENT
-- On SCOPE reduce production lident -> LIDENT
-- On RIGHTPAR reduce production lident -> LIDENT
-- On RIGHTBRC reduce production lident -> LIDENT
-- On RANGE reduce production lident -> LIDENT
-- On QUOTE_LIDENT reduce production lident -> LIDENT
-- On PREDICATE reduce production lident -> LIDENT
-- On POSITION reduce production lident_nq -> LIDENT
-- On META reduce production lident -> LIDENT
-- On LIDENT reduce production lident -> LIDENT
-- On LET reduce production lident -> LIDENT
-- On LEMMA reduce production lident -> LIDENT
-- On LEFTPAR reduce production lident -> LIDENT
-- On LEFTBRC reduce production lident -> LIDENT
-- On INVARIANT reduce production lident -> LIDENT
-- On INDUCTIVE reduce production lident -> LIDENT
-- On IMPORT reduce production lident -> LIDENT
-- On GOAL reduce production lident -> LIDENT
-- On FUNCTION reduce production lident -> LIDENT
-- On FLOAT reduce production lident -> LIDENT
-- On EXCEPTION reduce production lident -> LIDENT
-- On EOF reduce production lident -> LIDENT
-- On CORE_UIDENT reduce production lident -> LIDENT
-- On CORE_LIDENT reduce production lident -> LIDENT
-- On CONSTANT reduce production lident -> LIDENT
-- On COMMA reduce production lident -> LIDENT
-- On COLON reduce production lident_nq -> LIDENT
-- On COINDUCTIVE reduce production lident -> LIDENT
-- On CLONE reduce production lident -> LIDENT
-- On BY reduce production lident -> LIDENT
-- On BAR reduce production lident -> LIDENT
-- On AXIOM reduce production lident -> LIDENT
-- On ATTRIBUTE reduce production lident_nq -> LIDENT
-- On ARROW reduce production lident -> LIDENT

State 152:
## Known stack suffix:
## LEFTPAR GHOST
## LR(1) items:
ret_cast -> GHOST . ret_ident cast [ RIGHTPAR COMMA ]
ret_ghost -> GHOST . ty COMMA ret_rest [ RIGHTPAR ]
return -> LEFTPAR GHOST . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 150
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 151
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 153
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 154
-- On ret_ident shift to state 165
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 167
-- On lident shift to state 101
-- On attrs(lident_nq) shift to state 168
## Reductions:

State 153:
## Known stack suffix:
## CORE_LIDENT
## LR(1) items:
lident -> CORE_LIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF CORE_UIDENT CORE_LIDENT CONSTANT COMMA COINDUCTIVE CLONE BY BAR AXIOM ARROW ]
lident_nq -> CORE_LIDENT . [ POSITION COLON ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WITH reduce production lident -> CORE_LIDENT
-- On VAL reduce production lident -> CORE_LIDENT
-- On USE reduce production lident -> CORE_LIDENT
-- On UNDERSCORE reduce production lident -> CORE_LIDENT
-- On UIDENT reduce production lident -> CORE_LIDENT
-- On TYPE reduce production lident -> CORE_LIDENT
-- On SCOPE reduce production lident -> CORE_LIDENT
-- On RIGHTPAR reduce production lident -> CORE_LIDENT
-- On RIGHTBRC reduce production lident -> CORE_LIDENT
-- On RANGE reduce production lident -> CORE_LIDENT
-- On QUOTE_LIDENT reduce production lident -> CORE_LIDENT
-- On PREDICATE reduce production lident -> CORE_LIDENT
-- On POSITION reduce production lident_nq -> CORE_LIDENT
-- On META reduce production lident -> CORE_LIDENT
-- On LIDENT reduce production lident -> CORE_LIDENT
-- On LET reduce production lident -> CORE_LIDENT
-- On LEMMA reduce production lident -> CORE_LIDENT
-- On LEFTPAR reduce production lident -> CORE_LIDENT
-- On LEFTBRC reduce production lident -> CORE_LIDENT
-- On INVARIANT reduce production lident -> CORE_LIDENT
-- On INDUCTIVE reduce production lident -> CORE_LIDENT
-- On IMPORT reduce production lident -> CORE_LIDENT
-- On GOAL reduce production lident -> CORE_LIDENT
-- On FUNCTION reduce production lident -> CORE_LIDENT
-- On FLOAT reduce production lident -> CORE_LIDENT
-- On EXCEPTION reduce production lident -> CORE_LIDENT
-- On EOF reduce production lident -> CORE_LIDENT
-- On CORE_UIDENT reduce production lident -> CORE_LIDENT
-- On CORE_LIDENT reduce production lident -> CORE_LIDENT
-- On CONSTANT reduce production lident -> CORE_LIDENT
-- On COMMA reduce production lident -> CORE_LIDENT
-- On COLON reduce production lident_nq -> CORE_LIDENT
-- On COINDUCTIVE reduce production lident -> CORE_LIDENT
-- On CLONE reduce production lident -> CORE_LIDENT
-- On BY reduce production lident -> CORE_LIDENT
-- On BAR reduce production lident -> CORE_LIDENT
-- On AXIOM reduce production lident -> CORE_LIDENT
-- On ATTRIBUTE reduce production lident_nq -> CORE_LIDENT
-- On ARROW reduce production lident -> CORE_LIDENT

State 154:
## Known stack suffix:
## LEFTPAR GHOST ty
## LR(1) items:
ret_ghost -> GHOST ty . COMMA ret_rest [ RIGHTPAR ]
return -> LEFTPAR GHOST ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## Transitions:
-- On RIGHTPAR shift to state 155
-- On COMMA shift to state 156
-- On ARROW shift to state 94
## Reductions:

State 155:
## Known stack suffix:
## LEFTPAR GHOST ty RIGHTPAR
## LR(1) items:
return -> LEFTPAR GHOST ty RIGHTPAR . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On WITH reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On VARIANT reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On VAL reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On USE reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On TYPE reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On TO reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On THEN reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On SEMICOLON reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On SCOPE reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On RIGHTSQ reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On RIGHTPAR reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On RIGHTBRC reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On RETURNS reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On REQUIRES reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On READS reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On RAISES reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On PREDICATE reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On OP4 reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On OP3 reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On OP2 reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On OP1 reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On MINUS reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On META reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On LTGT reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On LT reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On LET reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On LEMMA reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On LARROW reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On INDUCTIVE reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On IN reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On IMPORT reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On GT reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On GOAL reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On FUNCTION reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On EXCEPTION reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On EQUAL reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On EOF reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On ENSURES reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On END reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On ELSE reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On DOWNTO reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On DOTDOT reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On DONE reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On DO reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On DIVERGES reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On CONSTANT reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On COMMA reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On COLON reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On COINDUCTIVE reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On CLONE reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On BARBAR reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On BAR reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On AXIOM reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On AMPAMP reduce production return -> LEFTPAR GHOST ty RIGHTPAR
-- On ALIAS reduce production return -> LEFTPAR GHOST ty RIGHTPAR

State 156:
## Known stack suffix:
## GHOST ty COMMA
## LR(1) items:
ret_ghost -> GHOST ty COMMA . ret_rest [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 157
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 160
-- On ret_rest shift to state 164
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 157:
## Known stack suffix:
## GHOST
## LR(1) items:
ret_rest -> GHOST . ty COMMA ret_rest [ RIGHTPAR ]
ret_rest -> GHOST . ty [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 158
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 158:
## Known stack suffix:
## GHOST ty
## LR(1) items:
ret_rest -> GHOST ty . COMMA ret_rest [ RIGHTPAR ]
ret_rest -> GHOST ty . [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## Transitions:
-- On COMMA shift to state 159
-- On ARROW shift to state 94
## Reductions:
-- On RIGHTPAR reduce production ret_rest -> GHOST ty

State 159:
## Known stack suffix:
## GHOST ty COMMA
## LR(1) items:
ret_rest -> GHOST ty COMMA . ret_rest [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 157
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 160
-- On ret_rest shift to state 163
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 160:
## Known stack suffix:
## ty
## LR(1) items:
ret_rest -> ty . COMMA ret_rest [ RIGHTPAR ]
ret_rest -> ty . [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## Transitions:
-- On COMMA shift to state 161
-- On ARROW shift to state 94
## Reductions:
-- On RIGHTPAR reduce production ret_rest -> ty

State 161:
## Known stack suffix:
## ty COMMA
## LR(1) items:
ret_rest -> ty COMMA . ret_rest [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 157
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 160
-- On ret_rest shift to state 162
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 162:
## Known stack suffix:
## ty COMMA ret_rest
## LR(1) items:
ret_rest -> ty COMMA ret_rest . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production ret_rest -> ty COMMA ret_rest

State 163:
## Known stack suffix:
## GHOST ty COMMA ret_rest
## LR(1) items:
ret_rest -> GHOST ty COMMA ret_rest . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production ret_rest -> GHOST ty COMMA ret_rest

State 164:
## Known stack suffix:
## GHOST ty COMMA ret_rest
## LR(1) items:
ret_ghost -> GHOST ty COMMA ret_rest . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production ret_ghost -> GHOST ty COMMA ret_rest

State 165:
## Known stack suffix:
## GHOST ret_ident
## LR(1) items:
ret_cast -> GHOST ret_ident . cast [ RIGHTPAR COMMA ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 166
## Reductions:

State 166:
## Known stack suffix:
## GHOST ret_ident cast
## LR(1) items:
ret_cast -> GHOST ret_ident cast . [ RIGHTPAR COMMA ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production ret_cast -> GHOST ret_ident cast
-- On COMMA reduce production ret_cast -> GHOST ret_ident cast

State 167:
## Known stack suffix:
## lident_keyword
## LR(1) items:
lident -> lident_keyword . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF CORE_UIDENT CORE_LIDENT CONSTANT COMMA COINDUCTIVE CLONE BY BAR AXIOM ARROW ]
lident_nq -> lident_keyword . [ POSITION COLON ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WITH reduce production lident -> lident_keyword
-- On VAL reduce production lident -> lident_keyword
-- On USE reduce production lident -> lident_keyword
-- On UNDERSCORE reduce production lident -> lident_keyword
-- On UIDENT reduce production lident -> lident_keyword
-- On TYPE reduce production lident -> lident_keyword
-- On SCOPE reduce production lident -> lident_keyword
-- On RIGHTPAR reduce production lident -> lident_keyword
-- On RIGHTBRC reduce production lident -> lident_keyword
-- On RANGE reduce production lident -> lident_keyword
-- On QUOTE_LIDENT reduce production lident -> lident_keyword
-- On PREDICATE reduce production lident -> lident_keyword
-- On POSITION reduce production lident_nq -> lident_keyword
-- On META reduce production lident -> lident_keyword
-- On LIDENT reduce production lident -> lident_keyword
-- On LET reduce production lident -> lident_keyword
-- On LEMMA reduce production lident -> lident_keyword
-- On LEFTPAR reduce production lident -> lident_keyword
-- On LEFTBRC reduce production lident -> lident_keyword
-- On INVARIANT reduce production lident -> lident_keyword
-- On INDUCTIVE reduce production lident -> lident_keyword
-- On IMPORT reduce production lident -> lident_keyword
-- On GOAL reduce production lident -> lident_keyword
-- On FUNCTION reduce production lident -> lident_keyword
-- On FLOAT reduce production lident -> lident_keyword
-- On EXCEPTION reduce production lident -> lident_keyword
-- On EOF reduce production lident -> lident_keyword
-- On CORE_UIDENT reduce production lident -> lident_keyword
-- On CORE_LIDENT reduce production lident -> lident_keyword
-- On CONSTANT reduce production lident -> lident_keyword
-- On COMMA reduce production lident -> lident_keyword
-- On COLON reduce production lident_nq -> lident_keyword
-- On COINDUCTIVE reduce production lident -> lident_keyword
-- On CLONE reduce production lident -> lident_keyword
-- On BY reduce production lident -> lident_keyword
-- On BAR reduce production lident -> lident_keyword
-- On AXIOM reduce production lident -> lident_keyword
-- On ATTRIBUTE reduce production lident_nq -> lident_keyword
-- On ARROW reduce production lident -> lident_keyword

State 168:
## Known stack suffix:
## attrs(lident_nq)
## LR(1) items:
ret_ident -> attrs(lident_nq) . [ COLON ]
## Transitions:
## Reductions:
-- On COLON reduce production ret_ident -> attrs(lident_nq)

State 169:
## Known stack suffix:
## LEFTPAR ty
## LR(1) items:
comma_list2(ty) -> ty . COMMA comma_list1(ty) [ RIGHTPAR ]
ret_ghost -> ty . COMMA GHOST ty [ RIGHTPAR ]
ret_ghost -> ty . COMMA ret_ghost [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
ty_block -> LEFTPAR ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 104
-- On COMMA shift to state 170
-- On ARROW shift to state 94
## Reductions:

State 170:
## Known stack suffix:
## ty COMMA
## LR(1) items:
comma_list2(ty) -> ty COMMA . comma_list1(ty) [ RIGHTPAR ]
ret_ghost -> ty COMMA . GHOST ty [ RIGHTPAR ]
ret_ghost -> ty COMMA . ret_ghost [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 171
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 173
-- On separated_nonempty_list(COMMA,ty) shift to state 109
-- On ret_ghost shift to state 175
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list1(ty) shift to state 110
## Reductions:

State 171:
## Known stack suffix:
## ty COMMA GHOST
## LR(1) items:
ret_ghost -> ty COMMA GHOST . ty [ RIGHTPAR ]
ret_ghost -> GHOST . ty COMMA ret_rest [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 172
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 172:
## Known stack suffix:
## ty COMMA GHOST ty
## LR(1) items:
ret_ghost -> ty COMMA GHOST ty . [ RIGHTPAR ]
ret_ghost -> GHOST ty . COMMA ret_rest [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## Transitions:
-- On COMMA shift to state 156
-- On ARROW shift to state 94
## Reductions:
-- On RIGHTPAR reduce production ret_ghost -> ty COMMA GHOST ty

State 173:
## Known stack suffix:
## ty
## LR(1) items:
ret_ghost -> ty . COMMA GHOST ty [ RIGHTPAR ]
ret_ghost -> ty . COMMA ret_ghost [ RIGHTPAR ]
separated_nonempty_list(COMMA,ty) -> ty . [ RIGHTPAR ]
separated_nonempty_list(COMMA,ty) -> ty . COMMA separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## Transitions:
-- On COMMA shift to state 174
-- On ARROW shift to state 94
## Reductions:
-- On RIGHTPAR reduce production separated_nonempty_list(COMMA,ty) -> ty

State 174:
## Known stack suffix:
## ty COMMA
## LR(1) items:
ret_ghost -> ty COMMA . GHOST ty [ RIGHTPAR ]
ret_ghost -> ty COMMA . ret_ghost [ RIGHTPAR ]
separated_nonempty_list(COMMA,ty) -> ty COMMA . separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 171
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 173
-- On separated_nonempty_list(COMMA,ty) shift to state 108
-- On ret_ghost shift to state 175
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 175:
## Known stack suffix:
## ty COMMA ret_ghost
## LR(1) items:
ret_ghost -> ty COMMA ret_ghost . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production ret_ghost -> ty COMMA ret_ghost

State 176:
## Known stack suffix:
## ret_ident
## LR(1) items:
ret_cast -> ret_ident . cast [ RIGHTPAR COMMA ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 177
## Reductions:

State 177:
## Known stack suffix:
## ret_ident cast
## LR(1) items:
ret_cast -> ret_ident cast . [ RIGHTPAR COMMA ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production ret_cast -> ret_ident cast
-- On COMMA reduce production ret_cast -> ret_ident cast

State 178:
## Known stack suffix:
## LEFTPAR ret_ghost
## LR(1) items:
return -> LEFTPAR ret_ghost . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 179
## Reductions:

State 179:
## Known stack suffix:
## LEFTPAR ret_ghost RIGHTPAR
## LR(1) items:
return -> LEFTPAR ret_ghost RIGHTPAR . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On WITH reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On VARIANT reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On VAL reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On USE reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On TYPE reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On TO reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On THEN reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On SEMICOLON reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On SCOPE reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On RIGHTSQ reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On RIGHTPAR reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On RIGHTBRC reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On RETURNS reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On REQUIRES reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On READS reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On RAISES reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On PREDICATE reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On OP4 reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On OP3 reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On OP2 reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On OP1 reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On MINUS reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On META reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On LTGT reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On LT reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On LET reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On LEMMA reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On LARROW reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On INDUCTIVE reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On IN reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On IMPORT reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On GT reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On GOAL reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On FUNCTION reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On EXCEPTION reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On EQUAL reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On EOF reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On ENSURES reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On END reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On ELSE reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On DOWNTO reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On DOTDOT reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On DONE reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On DO reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On DIVERGES reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On CONSTANT reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On COMMA reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On COLON reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On COINDUCTIVE reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On CLONE reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On BARBAR reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On BAR reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On AXIOM reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On AMPAMP reduce production return -> LEFTPAR ret_ghost RIGHTPAR
-- On ALIAS reduce production return -> LEFTPAR ret_ghost RIGHTPAR

State 180:
## Known stack suffix:
## LEFTPAR ret_cast
## LR(1) items:
comma_list2(ret_cast) -> ret_cast . COMMA comma_list1(ret_cast) [ RIGHTPAR ]
return_named -> LEFTPAR ret_cast . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 181
-- On COMMA shift to state 182
## Reductions:

State 181:
## Known stack suffix:
## LEFTPAR ret_cast RIGHTPAR
## LR(1) items:
return_named -> LEFTPAR ret_cast RIGHTPAR . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On WITH reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On VARIANT reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On VAL reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On USE reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On TYPE reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On TO reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On THEN reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On SEMICOLON reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On SCOPE reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On RIGHTSQ reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On RIGHTPAR reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On RIGHTBRC reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On RETURNS reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On REQUIRES reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On READS reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On RAISES reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On PREDICATE reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On OP4 reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On OP3 reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On OP2 reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On OP1 reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On MINUS reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On META reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On LTGT reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On LT reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On LET reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On LEMMA reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On LARROW reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On INDUCTIVE reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On IN reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On IMPORT reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On GT reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On GOAL reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On FUNCTION reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On EXCEPTION reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On EQUAL reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On EOF reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On ENSURES reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On END reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On ELSE reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On DOWNTO reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On DOTDOT reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On DONE reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On DO reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On DIVERGES reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On CONSTANT reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On COMMA reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On COLON reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On COINDUCTIVE reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On CLONE reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On BARBAR reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On BAR reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On AXIOM reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On AMPAMP reduce production return_named -> LEFTPAR ret_cast RIGHTPAR
-- On ALIAS reduce production return_named -> LEFTPAR ret_cast RIGHTPAR

State 182:
## Known stack suffix:
## ret_cast COMMA
## LR(1) items:
comma_list2(ret_cast) -> ret_cast COMMA . comma_list1(ret_cast) [ RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 150
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On GHOST shift to state 183
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On separated_nonempty_list(COMMA,ret_cast) shift to state 184
-- On ret_ident shift to state 176
-- On ret_cast shift to state 185
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list1(ret_cast) shift to state 188
-- On attrs(lident_nq) shift to state 168
## Reductions:

State 183:
## Known stack suffix:
## GHOST
## LR(1) items:
ret_cast -> GHOST . ret_ident cast [ RIGHTPAR COMMA ]
## Transitions:
-- On UNDERSCORE shift to state 150
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On ret_ident shift to state 165
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 168
## Reductions:

State 184:
## Known stack suffix:
## separated_nonempty_list(COMMA,ret_cast)
## LR(1) items:
comma_list1(ret_cast) -> separated_nonempty_list(COMMA,ret_cast) . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production comma_list1(ret_cast) -> separated_nonempty_list(COMMA,ret_cast)

State 185:
## Known stack suffix:
## ret_cast
## LR(1) items:
separated_nonempty_list(COMMA,ret_cast) -> ret_cast . [ RIGHTPAR ]
separated_nonempty_list(COMMA,ret_cast) -> ret_cast . COMMA separated_nonempty_list(COMMA,ret_cast) [ RIGHTPAR ]
## Transitions:
-- On COMMA shift to state 186
## Reductions:
-- On RIGHTPAR reduce production separated_nonempty_list(COMMA,ret_cast) -> ret_cast

State 186:
## Known stack suffix:
## ret_cast COMMA
## LR(1) items:
separated_nonempty_list(COMMA,ret_cast) -> ret_cast COMMA . separated_nonempty_list(COMMA,ret_cast) [ RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 150
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On GHOST shift to state 183
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On separated_nonempty_list(COMMA,ret_cast) shift to state 187
-- On ret_ident shift to state 176
-- On ret_cast shift to state 185
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 168
## Reductions:

State 187:
## Known stack suffix:
## ret_cast COMMA separated_nonempty_list(COMMA,ret_cast)
## LR(1) items:
separated_nonempty_list(COMMA,ret_cast) -> ret_cast COMMA separated_nonempty_list(COMMA,ret_cast) . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production separated_nonempty_list(COMMA,ret_cast) -> ret_cast COMMA separated_nonempty_list(COMMA,ret_cast)

State 188:
## Known stack suffix:
## ret_cast COMMA comma_list1(ret_cast)
## LR(1) items:
comma_list2(ret_cast) -> ret_cast COMMA comma_list1(ret_cast) . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR reduce production comma_list2(ret_cast) -> ret_cast COMMA comma_list1(ret_cast)

State 189:
## Known stack suffix:
## LEFTPAR comma_list2(ret_cast)
## LR(1) items:
return_named -> LEFTPAR comma_list2(ret_cast) . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 190
## Reductions:

State 190:
## Known stack suffix:
## LEFTPAR comma_list2(ret_cast) RIGHTPAR
## LR(1) items:
return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On WITH reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On VARIANT reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On VAL reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On USE reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On TYPE reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On TO reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On THEN reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On SEMICOLON reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On SCOPE reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On RIGHTSQ reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On RIGHTPAR reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On RIGHTBRC reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On RETURNS reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On REQUIRES reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On READS reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On RAISES reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On PREDICATE reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On OP4 reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On OP3 reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On OP2 reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On OP1 reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On MINUS reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On META reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On LTGT reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On LT reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On LET reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On LEMMA reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On LARROW reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On INDUCTIVE reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On IN reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On IMPORT reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On GT reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On GOAL reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On FUNCTION reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On EXCEPTION reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On EQUAL reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On EOF reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On ENSURES reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On END reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On ELSE reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On DOWNTO reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On DOTDOT reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On DONE reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On DO reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On DIVERGES reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On CONSTANT reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On COMMA reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On COLON reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On COINDUCTIVE reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On CLONE reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On BARBAR reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On BAR reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On AXIOM reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On AMPAMP reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR
-- On ALIAS reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR

State 191:
## Known stack suffix:
## GHOST
## LR(1) items:
return -> GHOST . ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 192
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 192:
## Known stack suffix:
## GHOST ty
## LR(1) items:
return -> GHOST ty . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On WRITES reduce production return -> GHOST ty
-- On WITH reduce production return -> GHOST ty
-- On VARIANT reduce production return -> GHOST ty
-- On VAL reduce production return -> GHOST ty
-- On USE reduce production return -> GHOST ty
-- On TYPE reduce production return -> GHOST ty
-- On TO reduce production return -> GHOST ty
-- On THEN reduce production return -> GHOST ty
-- On SEMICOLON reduce production return -> GHOST ty
-- On SCOPE reduce production return -> GHOST ty
-- On RIGHTSQ_QUOTE reduce production return -> GHOST ty
-- On RIGHTSQ reduce production return -> GHOST ty
-- On RIGHTPAR reduce production return -> GHOST ty
-- On RIGHTBRC reduce production return -> GHOST ty
-- On RETURNS reduce production return -> GHOST ty
-- On REQUIRES reduce production return -> GHOST ty
-- On READS reduce production return -> GHOST ty
-- On RAISES reduce production return -> GHOST ty
-- On PREDICATE reduce production return -> GHOST ty
-- On OP4 reduce production return -> GHOST ty
-- On OP3 reduce production return -> GHOST ty
-- On OP2 reduce production return -> GHOST ty
-- On OP1 reduce production return -> GHOST ty
-- On MINUS reduce production return -> GHOST ty
-- On META reduce production return -> GHOST ty
-- On LTGT reduce production return -> GHOST ty
-- On LT reduce production return -> GHOST ty
-- On LET reduce production return -> GHOST ty
-- On LEMMA reduce production return -> GHOST ty
-- On LARROW reduce production return -> GHOST ty
-- On INDUCTIVE reduce production return -> GHOST ty
-- On IN reduce production return -> GHOST ty
-- On IMPORT reduce production return -> GHOST ty
-- On GT reduce production return -> GHOST ty
-- On GOAL reduce production return -> GHOST ty
-- On FUNCTION reduce production return -> GHOST ty
-- On EXCEPTION reduce production return -> GHOST ty
-- On EQUAL reduce production return -> GHOST ty
-- On EOF reduce production return -> GHOST ty
-- On ENSURES reduce production return -> GHOST ty
-- On END reduce production return -> GHOST ty
-- On ELSE reduce production return -> GHOST ty
-- On DOWNTO reduce production return -> GHOST ty
-- On DOTDOT reduce production return -> GHOST ty
-- On DONE reduce production return -> GHOST ty
-- On DO reduce production return -> GHOST ty
-- On DIVERGES reduce production return -> GHOST ty
-- On CONSTANT reduce production return -> GHOST ty
-- On COMMA reduce production return -> GHOST ty
-- On COLON reduce production return -> GHOST ty
-- On COINDUCTIVE reduce production return -> GHOST ty
-- On CLONE reduce production return -> GHOST ty
-- On BARBAR reduce production return -> GHOST ty
-- On BAR reduce production return -> GHOST ty
-- On AXIOM reduce production return -> GHOST ty
-- On AMPAMP reduce production return -> GHOST ty
-- On ALIAS reduce production return -> GHOST ty

State 193:
## Known stack suffix:
## ty
## LR(1) items:
return -> ty . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On WRITES reduce production return -> ty
-- On WITH reduce production return -> ty
-- On VARIANT reduce production return -> ty
-- On VAL reduce production return -> ty
-- On USE reduce production return -> ty
-- On TYPE reduce production return -> ty
-- On TO reduce production return -> ty
-- On THEN reduce production return -> ty
-- On SEMICOLON reduce production return -> ty
-- On SCOPE reduce production return -> ty
-- On RIGHTSQ_QUOTE reduce production return -> ty
-- On RIGHTSQ reduce production return -> ty
-- On RIGHTPAR reduce production return -> ty
-- On RIGHTBRC reduce production return -> ty
-- On RETURNS reduce production return -> ty
-- On REQUIRES reduce production return -> ty
-- On READS reduce production return -> ty
-- On RAISES reduce production return -> ty
-- On PREDICATE reduce production return -> ty
-- On OP4 reduce production return -> ty
-- On OP3 reduce production return -> ty
-- On OP2 reduce production return -> ty
-- On OP1 reduce production return -> ty
-- On MINUS reduce production return -> ty
-- On META reduce production return -> ty
-- On LTGT reduce production return -> ty
-- On LT reduce production return -> ty
-- On LET reduce production return -> ty
-- On LEMMA reduce production return -> ty
-- On LARROW reduce production return -> ty
-- On INDUCTIVE reduce production return -> ty
-- On IN reduce production return -> ty
-- On IMPORT reduce production return -> ty
-- On GT reduce production return -> ty
-- On GOAL reduce production return -> ty
-- On FUNCTION reduce production return -> ty
-- On EXCEPTION reduce production return -> ty
-- On EQUAL reduce production return -> ty
-- On EOF reduce production return -> ty
-- On ENSURES reduce production return -> ty
-- On END reduce production return -> ty
-- On ELSE reduce production return -> ty
-- On DOWNTO reduce production return -> ty
-- On DOTDOT reduce production return -> ty
-- On DONE reduce production return -> ty
-- On DO reduce production return -> ty
-- On DIVERGES reduce production return -> ty
-- On CONSTANT reduce production return -> ty
-- On COMMA reduce production return -> ty
-- On COLON reduce production return -> ty
-- On COINDUCTIVE reduce production return -> ty
-- On CLONE reduce production return -> ty
-- On BARBAR reduce production return -> ty
-- On BAR reduce production return -> ty
-- On AXIOM reduce production return -> ty
-- On AMPAMP reduce production return -> ty
-- On ALIAS reduce production return -> ty

State 194:
## Known stack suffix:
## COLON return_named
## LR(1) items:
return_opt -> COLON return_named . [ WRITES VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COINDUCTIVE CLONE AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production return_opt -> COLON return_named
-- On VARIANT reduce production return_opt -> COLON return_named
-- On VAL reduce production return_opt -> COLON return_named
-- On USE reduce production return_opt -> COLON return_named
-- On TYPE reduce production return_opt -> COLON return_named
-- On SCOPE reduce production return_opt -> COLON return_named
-- On RETURNS reduce production return_opt -> COLON return_named
-- On REQUIRES reduce production return_opt -> COLON return_named
-- On READS reduce production return_opt -> COLON return_named
-- On RAISES reduce production return_opt -> COLON return_named
-- On PREDICATE reduce production return_opt -> COLON return_named
-- On META reduce production return_opt -> COLON return_named
-- On LET reduce production return_opt -> COLON return_named
-- On LEMMA reduce production return_opt -> COLON return_named
-- On INDUCTIVE reduce production return_opt -> COLON return_named
-- On IN reduce production return_opt -> COLON return_named
-- On IMPORT reduce production return_opt -> COLON return_named
-- On GOAL reduce production return_opt -> COLON return_named
-- On FUNCTION reduce production return_opt -> COLON return_named
-- On EXCEPTION reduce production return_opt -> COLON return_named
-- On EQUAL reduce production return_opt -> COLON return_named
-- On EOF reduce production return_opt -> COLON return_named
-- On ENSURES reduce production return_opt -> COLON return_named
-- On END reduce production return_opt -> COLON return_named
-- On DIVERGES reduce production return_opt -> COLON return_named
-- On CONSTANT reduce production return_opt -> COLON return_named
-- On COINDUCTIVE reduce production return_opt -> COLON return_named
-- On CLONE reduce production return_opt -> COLON return_named
-- On AXIOM reduce production return_opt -> COLON return_named
-- On ALIAS reduce production return_opt -> COLON return_named

State 195:
## Known stack suffix:
## return
## LR(1) items:
return_named -> return . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production return_named -> return
-- On WITH reduce production return_named -> return
-- On VARIANT reduce production return_named -> return
-- On VAL reduce production return_named -> return
-- On USE reduce production return_named -> return
-- On TYPE reduce production return_named -> return
-- On TO reduce production return_named -> return
-- On THEN reduce production return_named -> return
-- On SEMICOLON reduce production return_named -> return
-- On SCOPE reduce production return_named -> return
-- On RIGHTSQ_QUOTE reduce production return_named -> return
-- On RIGHTSQ reduce production return_named -> return
-- On RIGHTPAR reduce production return_named -> return
-- On RIGHTBRC reduce production return_named -> return
-- On RETURNS reduce production return_named -> return
-- On REQUIRES reduce production return_named -> return
-- On READS reduce production return_named -> return
-- On RAISES reduce production return_named -> return
-- On PREDICATE reduce production return_named -> return
-- On OP4 reduce production return_named -> return
-- On OP3 reduce production return_named -> return
-- On OP2 reduce production return_named -> return
-- On OP1 reduce production return_named -> return
-- On MINUS reduce production return_named -> return
-- On META reduce production return_named -> return
-- On LTGT reduce production return_named -> return
-- On LT reduce production return_named -> return
-- On LET reduce production return_named -> return
-- On LEMMA reduce production return_named -> return
-- On LARROW reduce production return_named -> return
-- On INDUCTIVE reduce production return_named -> return
-- On IN reduce production return_named -> return
-- On IMPORT reduce production return_named -> return
-- On GT reduce production return_named -> return
-- On GOAL reduce production return_named -> return
-- On FUNCTION reduce production return_named -> return
-- On EXCEPTION reduce production return_named -> return
-- On EQUAL reduce production return_named -> return
-- On EOF reduce production return_named -> return
-- On ENSURES reduce production return_named -> return
-- On END reduce production return_named -> return
-- On ELSE reduce production return_named -> return
-- On DOWNTO reduce production return_named -> return
-- On DOTDOT reduce production return_named -> return
-- On DONE reduce production return_named -> return
-- On DO reduce production return_named -> return
-- On DIVERGES reduce production return_named -> return
-- On CONSTANT reduce production return_named -> return
-- On COMMA reduce production return_named -> return
-- On COLON reduce production return_named -> return
-- On COINDUCTIVE reduce production return_named -> return
-- On CLONE reduce production return_named -> return
-- On BARBAR reduce production return_named -> return
-- On BAR reduce production return_named -> return
-- On AXIOM reduce production return_named -> return
-- On AMPAMP reduce production return_named -> return
-- On ALIAS reduce production return_named -> return

State 196:
## Known stack suffix:
## params return_opt
## LR(1) items:
val_defn -> params return_opt . spec [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 566
-- On single_spec shift to state 567
## Reductions:
-- On VAL reduce production spec ->
-- On USE reduce production spec ->
-- On TYPE reduce production spec ->
-- On SCOPE reduce production spec ->
-- On PREDICATE reduce production spec ->
-- On META reduce production spec ->
-- On LET reduce production spec ->
-- On LEMMA reduce production spec ->
-- On INDUCTIVE reduce production spec ->
-- On IN reduce production spec ->
-- On IMPORT reduce production spec ->
-- On GOAL reduce production spec ->
-- On FUNCTION reduce production spec ->
-- On EXCEPTION reduce production spec ->
-- On EOF reduce production spec ->
-- On END reduce production spec ->
-- On CONSTANT reduce production spec ->
-- On COINDUCTIVE reduce production spec ->
-- On CLONE reduce production spec ->
-- On AXIOM reduce production spec ->

State 197:
## Known stack suffix:
## WRITES
## LR(1) items:
single_spec -> WRITES . LEFTBRC comma_list0(single_term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 198
## Reductions:

State 198:
## Known stack suffix:
## WRITES LEFTBRC
## LR(1) items:
single_spec -> WRITES LEFTBRC . comma_list0(single_term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 342
-- On separated_nonempty_list(COMMA,single_term) shift to state 489
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On loption(separated_nonempty_list(COMMA,single_term)) shift to state 490
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On comma_list0(single_term) shift to state 491
-- On attr shift to state 356
## Reductions:
-- On RIGHTBRC reduce production loption(separated_nonempty_list(COMMA,single_term)) ->

State 199:
## Known stack suffix:
## TRUE
## LR(1) items:
term_arg_ -> TRUE . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_arg_ -> TRUE
-- On VAL reduce production term_arg_ -> TRUE
-- On USE reduce production term_arg_ -> TRUE
-- On UIDENT reduce production term_arg_ -> TRUE
-- On TYPE reduce production term_arg_ -> TRUE
-- On TRUE reduce production term_arg_ -> TRUE
-- On THEN reduce production term_arg_ -> TRUE
-- On SO reduce production term_arg_ -> TRUE
-- On SEMICOLON reduce production term_arg_ -> TRUE
-- On SCOPE reduce production term_arg_ -> TRUE
-- On RIGHTSQ_QUOTE reduce production term_arg_ -> TRUE
-- On RIGHTSQ reduce production term_arg_ -> TRUE
-- On RIGHTPAR reduce production term_arg_ -> TRUE
-- On RIGHTBRC reduce production term_arg_ -> TRUE
-- On REAL reduce production term_arg_ -> TRUE
-- On RANGE reduce production term_arg_ -> TRUE
-- On PREDICATE reduce production term_arg_ -> TRUE
-- On OR reduce production term_arg_ -> TRUE
-- On OPPREF reduce production term_arg_ -> TRUE
-- On OP4 reduce production term_arg_ -> TRUE
-- On OP3 reduce production term_arg_ -> TRUE
-- On OP2 reduce production term_arg_ -> TRUE
-- On OP1 reduce production term_arg_ -> TRUE
-- On MINUS reduce production term_arg_ -> TRUE
-- On META reduce production term_arg_ -> TRUE
-- On LTGT reduce production term_arg_ -> TRUE
-- On LT reduce production term_arg_ -> TRUE
-- On LRARROW reduce production term_arg_ -> TRUE
-- On LIDENT reduce production term_arg_ -> TRUE
-- On LET reduce production term_arg_ -> TRUE
-- On LEMMA reduce production term_arg_ -> TRUE
-- On LEFTSQ reduce production term_arg_ -> TRUE
-- On LEFTPAR reduce production term_arg_ -> TRUE
-- On LEFTBRC reduce production term_arg_ -> TRUE
-- On LARROW reduce production term_arg_ -> TRUE
-- On INTEGER reduce production term_arg_ -> TRUE
-- On INDUCTIVE reduce production term_arg_ -> TRUE
-- On IN reduce production term_arg_ -> TRUE
-- On IMPORT reduce production term_arg_ -> TRUE
-- On GT reduce production term_arg_ -> TRUE
-- On GOAL reduce production term_arg_ -> TRUE
-- On FUNCTION reduce production term_arg_ -> TRUE
-- On FLOAT reduce production term_arg_ -> TRUE
-- On FALSE reduce production term_arg_ -> TRUE
-- On EXCEPTION reduce production term_arg_ -> TRUE
-- On EQUAL reduce production term_arg_ -> TRUE
-- On EOF reduce production term_arg_ -> TRUE
-- On END reduce production term_arg_ -> TRUE
-- On ELSE reduce production term_arg_ -> TRUE
-- On DOTDOT reduce production term_arg_ -> TRUE
-- On CORE_UIDENT reduce production term_arg_ -> TRUE
-- On CORE_LIDENT reduce production term_arg_ -> TRUE
-- On CONSTANT reduce production term_arg_ -> TRUE
-- On COMMA reduce production term_arg_ -> TRUE
-- On COLON reduce production term_arg_ -> TRUE
-- On COINDUCTIVE reduce production term_arg_ -> TRUE
-- On CLONE reduce production term_arg_ -> TRUE
-- On BY reduce production term_arg_ -> TRUE
-- On BEGIN reduce production term_arg_ -> TRUE
-- On BARBAR reduce production term_arg_ -> TRUE
-- On BAR reduce production term_arg_ -> TRUE
-- On AXIOM reduce production term_arg_ -> TRUE
-- On AT reduce production term_arg_ -> TRUE
-- On ARROW reduce production term_arg_ -> TRUE
-- On AND reduce production term_arg_ -> TRUE
-- On AMPAMP reduce production term_arg_ -> TRUE

State 200:
## Known stack suffix:
## REAL
## LR(1) items:
numeral -> REAL . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production numeral -> REAL
-- On WITH reduce production numeral -> REAL
-- On VARIANT reduce production numeral -> REAL
-- On VAL reduce production numeral -> REAL
-- On USE reduce production numeral -> REAL
-- On UIDENT reduce production numeral -> REAL
-- On TYPE reduce production numeral -> REAL
-- On TRUE reduce production numeral -> REAL
-- On TO reduce production numeral -> REAL
-- On THEN reduce production numeral -> REAL
-- On SO reduce production numeral -> REAL
-- On SEMICOLON reduce production numeral -> REAL
-- On SCOPE reduce production numeral -> REAL
-- On RIGHTSQ_QUOTE reduce production numeral -> REAL
-- On RIGHTSQ reduce production numeral -> REAL
-- On RIGHTPAR reduce production numeral -> REAL
-- On RIGHTBRC reduce production numeral -> REAL
-- On RETURNS reduce production numeral -> REAL
-- On REQUIRES reduce production numeral -> REAL
-- On REAL reduce production numeral -> REAL
-- On READS reduce production numeral -> REAL
-- On RANGE reduce production numeral -> REAL
-- On RAISES reduce production numeral -> REAL
-- On PURE reduce production numeral -> REAL
-- On PREDICATE reduce production numeral -> REAL
-- On OR reduce production numeral -> REAL
-- On OPPREF reduce production numeral -> REAL
-- On OP4 reduce production numeral -> REAL
-- On OP3 reduce production numeral -> REAL
-- On OP2 reduce production numeral -> REAL
-- On OP1 reduce production numeral -> REAL
-- On MINUS reduce production numeral -> REAL
-- On META reduce production numeral -> REAL
-- On LTGT reduce production numeral -> REAL
-- On LT reduce production numeral -> REAL
-- On LRARROW reduce production numeral -> REAL
-- On LIDENT reduce production numeral -> REAL
-- On LET reduce production numeral -> REAL
-- On LEMMA reduce production numeral -> REAL
-- On LEFTSQ reduce production numeral -> REAL
-- On LEFTPAR reduce production numeral -> REAL
-- On LEFTBRC reduce production numeral -> REAL
-- On LARROW reduce production numeral -> REAL
-- On INTEGER reduce production numeral -> REAL
-- On INDUCTIVE reduce production numeral -> REAL
-- On IN reduce production numeral -> REAL
-- On IMPORT reduce production numeral -> REAL
-- On GT reduce production numeral -> REAL
-- On GOAL reduce production numeral -> REAL
-- On FUNCTION reduce production numeral -> REAL
-- On FLOAT reduce production numeral -> REAL
-- On FALSE reduce production numeral -> REAL
-- On EXCEPTION reduce production numeral -> REAL
-- On EQUAL reduce production numeral -> REAL
-- On EOF reduce production numeral -> REAL
-- On ENSURES reduce production numeral -> REAL
-- On END reduce production numeral -> REAL
-- On ELSE reduce production numeral -> REAL
-- On DOWNTO reduce production numeral -> REAL
-- On DOTDOT reduce production numeral -> REAL
-- On DONE reduce production numeral -> REAL
-- On DO reduce production numeral -> REAL
-- On DIVERGES reduce production numeral -> REAL
-- On CORE_UIDENT reduce production numeral -> REAL
-- On CORE_LIDENT reduce production numeral -> REAL
-- On CONSTANT reduce production numeral -> REAL
-- On COMMA reduce production numeral -> REAL
-- On COLON reduce production numeral -> REAL
-- On COINDUCTIVE reduce production numeral -> REAL
-- On CLONE reduce production numeral -> REAL
-- On BY reduce production numeral -> REAL
-- On BEGIN reduce production numeral -> REAL
-- On BARBAR reduce production numeral -> REAL
-- On BAR reduce production numeral -> REAL
-- On AXIOM reduce production numeral -> REAL
-- On AT reduce production numeral -> REAL
-- On ARROW reduce production numeral -> REAL
-- On AND reduce production numeral -> REAL
-- On AMPAMP reduce production numeral -> REAL
-- On ALIAS reduce production numeral -> REAL

State 201:
## Known stack suffix:
## OPPREF
## LR(1) items:
term_arg_ -> OPPREF . term_arg [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_dot_ -> OPPREF . term_dot [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On OPPREF shift to state 201
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 483
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 411
-- On term_arg shift to state 484
-- On qualid shift to state 345
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
## Reductions:

State 202:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
lident_op -> LEFTPAR . lident_op_str RIGHTPAR [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR_USCORE [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR_QUOTE [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_block_ -> LEFTPAR . term RIGHTPAR [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_block_ -> LEFTPAR . RIGHTPAR [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On RIGHTPAR shift to state 203
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 204
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 485
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTSQ shift to state 15
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EQUAL shift to state 30
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 486
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 488
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op_str shift to state 33
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 203:
## Known stack suffix:
## LEFTPAR RIGHTPAR
## LR(1) items:
term_block_ -> LEFTPAR RIGHTPAR . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On VAL reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On USE reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On UIDENT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On TYPE reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On TRUE reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On THEN reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On SO reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On SEMICOLON reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On SCOPE reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On RIGHTSQ reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On RIGHTPAR reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On RIGHTBRC reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On REAL reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On RANGE reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On PREDICATE reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On OR reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On OPPREF reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On OP4 reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On OP3 reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On OP2 reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On OP1 reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On MINUS reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On META reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On LTGT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On LT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On LRARROW reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On LIDENT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On LET reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On LEMMA reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On LEFTSQ reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On LEFTPAR reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On LEFTBRC reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On LARROW reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On INTEGER reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On INDUCTIVE reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On IN reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On IMPORT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On GT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On GOAL reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On FUNCTION reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On FLOAT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On FALSE reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On EXCEPTION reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On EQUAL reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On EOF reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On END reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On ELSE reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On DOTDOT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On DOT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On CORE_UIDENT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On CORE_LIDENT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On CONSTANT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On COMMA reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On COLON reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On COINDUCTIVE reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On CLONE reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On BY reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On BEGIN reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On BARBAR reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On BAR reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On AXIOM reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On AT reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On ARROW reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On AND reduce production term_block_ -> LEFTPAR RIGHTPAR
-- On AMPAMP reduce production term_block_ -> LEFTPAR RIGHTPAR

State 204:
## Known stack suffix:
## OPPREF
## LR(1) items:
lident_op_str -> OPPREF . option(UNDERSCORE) [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
term_arg_ -> OPPREF . term_arg [ UIDENT TRUE SO RIGHTPAR REAL RANGE OR OPPREF OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW LIDENT LEFTSQ LEFTPAR LEFTBRC INTEGER GT FLOAT FALSE EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BY BEGIN BARBAR AT ARROW AND AMPAMP ]
term_dot_ -> OPPREF . term_dot [ DOT ]
## Transitions:
-- On UNDERSCORE shift to state 6
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On OPPREF shift to state 201
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 483
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 411
-- On term_arg shift to state 484
-- On qualid shift to state 345
-- On option(UNDERSCORE) shift to state 7
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
## Reductions:
-- On RIGHTPAR_USCORE reduce production option(UNDERSCORE) ->
-- On RIGHTPAR_QUOTE reduce production option(UNDERSCORE) ->
-- On RIGHTPAR reduce production option(UNDERSCORE) ->

State 205:
## Known stack suffix:
## LEFTBRC
## LR(1) items:
term_block_ -> LEFTBRC . field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_block_ -> LEFTBRC . term_arg WITH field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On OPPREF shift to state 201
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uqualid shift to state 466
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 411
-- On term_arg shift to state 469
-- On semicolon_list1(separated_pair(lqualid,EQUAL,term)) shift to state 471
-- On qualid shift to state 345
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On lqualid shift to state 479
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 480
-- On ident shift to state 355
-- On field_list1(term) shift to state 481
## Reductions:

State 206:
## Known stack suffix:
## INTEGER
## LR(1) items:
numeral -> INTEGER . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production numeral -> INTEGER
-- On WITH reduce production numeral -> INTEGER
-- On VARIANT reduce production numeral -> INTEGER
-- On VAL reduce production numeral -> INTEGER
-- On USE reduce production numeral -> INTEGER
-- On UIDENT reduce production numeral -> INTEGER
-- On TYPE reduce production numeral -> INTEGER
-- On TRUE reduce production numeral -> INTEGER
-- On TO reduce production numeral -> INTEGER
-- On THEN reduce production numeral -> INTEGER
-- On SO reduce production numeral -> INTEGER
-- On SEMICOLON reduce production numeral -> INTEGER
-- On SCOPE reduce production numeral -> INTEGER
-- On RIGHTSQ_QUOTE reduce production numeral -> INTEGER
-- On RIGHTSQ reduce production numeral -> INTEGER
-- On RIGHTPAR reduce production numeral -> INTEGER
-- On RIGHTBRC reduce production numeral -> INTEGER
-- On RETURNS reduce production numeral -> INTEGER
-- On REQUIRES reduce production numeral -> INTEGER
-- On REAL reduce production numeral -> INTEGER
-- On READS reduce production numeral -> INTEGER
-- On RANGE reduce production numeral -> INTEGER
-- On RAISES reduce production numeral -> INTEGER
-- On PURE reduce production numeral -> INTEGER
-- On PREDICATE reduce production numeral -> INTEGER
-- On OR reduce production numeral -> INTEGER
-- On OPPREF reduce production numeral -> INTEGER
-- On OP4 reduce production numeral -> INTEGER
-- On OP3 reduce production numeral -> INTEGER
-- On OP2 reduce production numeral -> INTEGER
-- On OP1 reduce production numeral -> INTEGER
-- On MINUS reduce production numeral -> INTEGER
-- On META reduce production numeral -> INTEGER
-- On LTGT reduce production numeral -> INTEGER
-- On LT reduce production numeral -> INTEGER
-- On LRARROW reduce production numeral -> INTEGER
-- On LIDENT reduce production numeral -> INTEGER
-- On LET reduce production numeral -> INTEGER
-- On LEMMA reduce production numeral -> INTEGER
-- On LEFTSQ reduce production numeral -> INTEGER
-- On LEFTPAR reduce production numeral -> INTEGER
-- On LEFTBRC reduce production numeral -> INTEGER
-- On LARROW reduce production numeral -> INTEGER
-- On INTEGER reduce production numeral -> INTEGER
-- On INDUCTIVE reduce production numeral -> INTEGER
-- On IN reduce production numeral -> INTEGER
-- On IMPORT reduce production numeral -> INTEGER
-- On GT reduce production numeral -> INTEGER
-- On GOAL reduce production numeral -> INTEGER
-- On FUNCTION reduce production numeral -> INTEGER
-- On FLOAT reduce production numeral -> INTEGER
-- On FALSE reduce production numeral -> INTEGER
-- On EXCEPTION reduce production numeral -> INTEGER
-- On EQUAL reduce production numeral -> INTEGER
-- On EOF reduce production numeral -> INTEGER
-- On ENSURES reduce production numeral -> INTEGER
-- On END reduce production numeral -> INTEGER
-- On ELSE reduce production numeral -> INTEGER
-- On DOWNTO reduce production numeral -> INTEGER
-- On DOTDOT reduce production numeral -> INTEGER
-- On DONE reduce production numeral -> INTEGER
-- On DO reduce production numeral -> INTEGER
-- On DIVERGES reduce production numeral -> INTEGER
-- On CORE_UIDENT reduce production numeral -> INTEGER
-- On CORE_LIDENT reduce production numeral -> INTEGER
-- On CONSTANT reduce production numeral -> INTEGER
-- On COMMA reduce production numeral -> INTEGER
-- On COLON reduce production numeral -> INTEGER
-- On COINDUCTIVE reduce production numeral -> INTEGER
-- On CLONE reduce production numeral -> INTEGER
-- On BY reduce production numeral -> INTEGER
-- On BEGIN reduce production numeral -> INTEGER
-- On BARBAR reduce production numeral -> INTEGER
-- On BAR reduce production numeral -> INTEGER
-- On AXIOM reduce production numeral -> INTEGER
-- On AT reduce production numeral -> INTEGER
-- On ARROW reduce production numeral -> INTEGER
-- On AND reduce production numeral -> INTEGER
-- On AMPAMP reduce production numeral -> INTEGER
-- On ALIAS reduce production numeral -> INTEGER

State 207:
## Known stack suffix:
## FALSE
## LR(1) items:
term_arg_ -> FALSE . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_arg_ -> FALSE
-- On VAL reduce production term_arg_ -> FALSE
-- On USE reduce production term_arg_ -> FALSE
-- On UIDENT reduce production term_arg_ -> FALSE
-- On TYPE reduce production term_arg_ -> FALSE
-- On TRUE reduce production term_arg_ -> FALSE
-- On THEN reduce production term_arg_ -> FALSE
-- On SO reduce production term_arg_ -> FALSE
-- On SEMICOLON reduce production term_arg_ -> FALSE
-- On SCOPE reduce production term_arg_ -> FALSE
-- On RIGHTSQ_QUOTE reduce production term_arg_ -> FALSE
-- On RIGHTSQ reduce production term_arg_ -> FALSE
-- On RIGHTPAR reduce production term_arg_ -> FALSE
-- On RIGHTBRC reduce production term_arg_ -> FALSE
-- On REAL reduce production term_arg_ -> FALSE
-- On RANGE reduce production term_arg_ -> FALSE
-- On PREDICATE reduce production term_arg_ -> FALSE
-- On OR reduce production term_arg_ -> FALSE
-- On OPPREF reduce production term_arg_ -> FALSE
-- On OP4 reduce production term_arg_ -> FALSE
-- On OP3 reduce production term_arg_ -> FALSE
-- On OP2 reduce production term_arg_ -> FALSE
-- On OP1 reduce production term_arg_ -> FALSE
-- On MINUS reduce production term_arg_ -> FALSE
-- On META reduce production term_arg_ -> FALSE
-- On LTGT reduce production term_arg_ -> FALSE
-- On LT reduce production term_arg_ -> FALSE
-- On LRARROW reduce production term_arg_ -> FALSE
-- On LIDENT reduce production term_arg_ -> FALSE
-- On LET reduce production term_arg_ -> FALSE
-- On LEMMA reduce production term_arg_ -> FALSE
-- On LEFTSQ reduce production term_arg_ -> FALSE
-- On LEFTPAR reduce production term_arg_ -> FALSE
-- On LEFTBRC reduce production term_arg_ -> FALSE
-- On LARROW reduce production term_arg_ -> FALSE
-- On INTEGER reduce production term_arg_ -> FALSE
-- On INDUCTIVE reduce production term_arg_ -> FALSE
-- On IN reduce production term_arg_ -> FALSE
-- On IMPORT reduce production term_arg_ -> FALSE
-- On GT reduce production term_arg_ -> FALSE
-- On GOAL reduce production term_arg_ -> FALSE
-- On FUNCTION reduce production term_arg_ -> FALSE
-- On FLOAT reduce production term_arg_ -> FALSE
-- On FALSE reduce production term_arg_ -> FALSE
-- On EXCEPTION reduce production term_arg_ -> FALSE
-- On EQUAL reduce production term_arg_ -> FALSE
-- On EOF reduce production term_arg_ -> FALSE
-- On END reduce production term_arg_ -> FALSE
-- On ELSE reduce production term_arg_ -> FALSE
-- On DOTDOT reduce production term_arg_ -> FALSE
-- On CORE_UIDENT reduce production term_arg_ -> FALSE
-- On CORE_LIDENT reduce production term_arg_ -> FALSE
-- On CONSTANT reduce production term_arg_ -> FALSE
-- On COMMA reduce production term_arg_ -> FALSE
-- On COLON reduce production term_arg_ -> FALSE
-- On COINDUCTIVE reduce production term_arg_ -> FALSE
-- On CLONE reduce production term_arg_ -> FALSE
-- On BY reduce production term_arg_ -> FALSE
-- On BEGIN reduce production term_arg_ -> FALSE
-- On BARBAR reduce production term_arg_ -> FALSE
-- On BAR reduce production term_arg_ -> FALSE
-- On AXIOM reduce production term_arg_ -> FALSE
-- On AT reduce production term_arg_ -> FALSE
-- On ARROW reduce production term_arg_ -> FALSE
-- On AND reduce production term_arg_ -> FALSE
-- On AMPAMP reduce production term_arg_ -> FALSE

State 208:
## Known stack suffix:
## BEGIN
## LR(1) items:
term_block_ -> BEGIN . term END [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_block_ -> BEGIN . END [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On END shift to state 463
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 464
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 209:
## Known stack suffix:
## OLD
## LR(1) items:
single_term_ -> OLD . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 462
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 210:
## Known stack suffix:
## NOT
## LR(1) items:
single_term_ -> NOT . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 461
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 211:
## Known stack suffix:
## MINUS
## LR(1) items:
prefix_op -> MINUS . [ UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE ]
single_term_ -> MINUS . INTEGER [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> MINUS . REAL [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On REAL shift to state 212
-- On INTEGER shift to state 213
## Reductions:
-- On UIDENT reduce production prefix_op -> MINUS
-- On TRUE reduce production prefix_op -> MINUS
-- On RANGE reduce production prefix_op -> MINUS
-- On POSITION reduce production prefix_op -> MINUS
-- On OPPREF reduce production prefix_op -> MINUS
-- On OP4 reduce production prefix_op -> MINUS
-- On OP3 reduce production prefix_op -> MINUS
-- On OP2 reduce production prefix_op -> MINUS
-- On OP1 reduce production prefix_op -> MINUS
-- On OLD reduce production prefix_op -> MINUS
-- On NOT reduce production prefix_op -> MINUS
-- On MINUS reduce production prefix_op -> MINUS
-- On MATCH reduce production prefix_op -> MINUS
-- On LT reduce production prefix_op -> MINUS
-- On LIDENT reduce production prefix_op -> MINUS
-- On LET reduce production prefix_op -> MINUS
-- On LEFTPAR reduce production prefix_op -> MINUS
-- On LEFTBRC reduce production prefix_op -> MINUS
-- On IF reduce production prefix_op -> MINUS
-- On GT reduce production prefix_op -> MINUS
-- On FUN reduce production prefix_op -> MINUS
-- On FORALL reduce production prefix_op -> MINUS
-- On FLOAT reduce production prefix_op -> MINUS
-- On FALSE reduce production prefix_op -> MINUS
-- On EXISTS reduce production prefix_op -> MINUS
-- On EPSILON reduce production prefix_op -> MINUS
-- On CORE_UIDENT reduce production prefix_op -> MINUS
-- On CORE_LIDENT reduce production prefix_op -> MINUS
-- On BEGIN reduce production prefix_op -> MINUS
-- On ATTRIBUTE reduce production prefix_op -> MINUS

State 212:
## Known stack suffix:
## MINUS REAL
## LR(1) items:
single_term_ -> MINUS REAL . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> MINUS REAL
-- On VAL reduce production single_term_ -> MINUS REAL
-- On USE reduce production single_term_ -> MINUS REAL
-- On TYPE reduce production single_term_ -> MINUS REAL
-- On THEN reduce production single_term_ -> MINUS REAL
-- On SO reduce production single_term_ -> MINUS REAL
-- On SEMICOLON reduce production single_term_ -> MINUS REAL
-- On SCOPE reduce production single_term_ -> MINUS REAL
-- On RIGHTSQ_QUOTE reduce production single_term_ -> MINUS REAL
-- On RIGHTSQ reduce production single_term_ -> MINUS REAL
-- On RIGHTPAR reduce production single_term_ -> MINUS REAL
-- On RIGHTBRC reduce production single_term_ -> MINUS REAL
-- On PREDICATE reduce production single_term_ -> MINUS REAL
-- On OR reduce production single_term_ -> MINUS REAL
-- On OP4 reduce production single_term_ -> MINUS REAL
-- On OP3 reduce production single_term_ -> MINUS REAL
-- On OP2 reduce production single_term_ -> MINUS REAL
-- On OP1 reduce production single_term_ -> MINUS REAL
-- On MINUS reduce production single_term_ -> MINUS REAL
-- On META reduce production single_term_ -> MINUS REAL
-- On LTGT reduce production single_term_ -> MINUS REAL
-- On LT reduce production single_term_ -> MINUS REAL
-- On LRARROW reduce production single_term_ -> MINUS REAL
-- On LET reduce production single_term_ -> MINUS REAL
-- On LEMMA reduce production single_term_ -> MINUS REAL
-- On LARROW reduce production single_term_ -> MINUS REAL
-- On INDUCTIVE reduce production single_term_ -> MINUS REAL
-- On IN reduce production single_term_ -> MINUS REAL
-- On IMPORT reduce production single_term_ -> MINUS REAL
-- On GT reduce production single_term_ -> MINUS REAL
-- On GOAL reduce production single_term_ -> MINUS REAL
-- On FUNCTION reduce production single_term_ -> MINUS REAL
-- On EXCEPTION reduce production single_term_ -> MINUS REAL
-- On EQUAL reduce production single_term_ -> MINUS REAL
-- On EOF reduce production single_term_ -> MINUS REAL
-- On END reduce production single_term_ -> MINUS REAL
-- On ELSE reduce production single_term_ -> MINUS REAL
-- On DOTDOT reduce production single_term_ -> MINUS REAL
-- On CONSTANT reduce production single_term_ -> MINUS REAL
-- On COMMA reduce production single_term_ -> MINUS REAL
-- On COLON reduce production single_term_ -> MINUS REAL
-- On COINDUCTIVE reduce production single_term_ -> MINUS REAL
-- On CLONE reduce production single_term_ -> MINUS REAL
-- On BY reduce production single_term_ -> MINUS REAL
-- On BARBAR reduce production single_term_ -> MINUS REAL
-- On BAR reduce production single_term_ -> MINUS REAL
-- On AXIOM reduce production single_term_ -> MINUS REAL
-- On AT reduce production single_term_ -> MINUS REAL
-- On ARROW reduce production single_term_ -> MINUS REAL
-- On AND reduce production single_term_ -> MINUS REAL
-- On AMPAMP reduce production single_term_ -> MINUS REAL

State 213:
## Known stack suffix:
## MINUS INTEGER
## LR(1) items:
single_term_ -> MINUS INTEGER . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> MINUS INTEGER
-- On VAL reduce production single_term_ -> MINUS INTEGER
-- On USE reduce production single_term_ -> MINUS INTEGER
-- On TYPE reduce production single_term_ -> MINUS INTEGER
-- On THEN reduce production single_term_ -> MINUS INTEGER
-- On SO reduce production single_term_ -> MINUS INTEGER
-- On SEMICOLON reduce production single_term_ -> MINUS INTEGER
-- On SCOPE reduce production single_term_ -> MINUS INTEGER
-- On RIGHTSQ_QUOTE reduce production single_term_ -> MINUS INTEGER
-- On RIGHTSQ reduce production single_term_ -> MINUS INTEGER
-- On RIGHTPAR reduce production single_term_ -> MINUS INTEGER
-- On RIGHTBRC reduce production single_term_ -> MINUS INTEGER
-- On PREDICATE reduce production single_term_ -> MINUS INTEGER
-- On OR reduce production single_term_ -> MINUS INTEGER
-- On OP4 reduce production single_term_ -> MINUS INTEGER
-- On OP3 reduce production single_term_ -> MINUS INTEGER
-- On OP2 reduce production single_term_ -> MINUS INTEGER
-- On OP1 reduce production single_term_ -> MINUS INTEGER
-- On MINUS reduce production single_term_ -> MINUS INTEGER
-- On META reduce production single_term_ -> MINUS INTEGER
-- On LTGT reduce production single_term_ -> MINUS INTEGER
-- On LT reduce production single_term_ -> MINUS INTEGER
-- On LRARROW reduce production single_term_ -> MINUS INTEGER
-- On LET reduce production single_term_ -> MINUS INTEGER
-- On LEMMA reduce production single_term_ -> MINUS INTEGER
-- On LARROW reduce production single_term_ -> MINUS INTEGER
-- On INDUCTIVE reduce production single_term_ -> MINUS INTEGER
-- On IN reduce production single_term_ -> MINUS INTEGER
-- On IMPORT reduce production single_term_ -> MINUS INTEGER
-- On GT reduce production single_term_ -> MINUS INTEGER
-- On GOAL reduce production single_term_ -> MINUS INTEGER
-- On FUNCTION reduce production single_term_ -> MINUS INTEGER
-- On EXCEPTION reduce production single_term_ -> MINUS INTEGER
-- On EQUAL reduce production single_term_ -> MINUS INTEGER
-- On EOF reduce production single_term_ -> MINUS INTEGER
-- On END reduce production single_term_ -> MINUS INTEGER
-- On ELSE reduce production single_term_ -> MINUS INTEGER
-- On DOTDOT reduce production single_term_ -> MINUS INTEGER
-- On CONSTANT reduce production single_term_ -> MINUS INTEGER
-- On COMMA reduce production single_term_ -> MINUS INTEGER
-- On COLON reduce production single_term_ -> MINUS INTEGER
-- On COINDUCTIVE reduce production single_term_ -> MINUS INTEGER
-- On CLONE reduce production single_term_ -> MINUS INTEGER
-- On BY reduce production single_term_ -> MINUS INTEGER
-- On BARBAR reduce production single_term_ -> MINUS INTEGER
-- On BAR reduce production single_term_ -> MINUS INTEGER
-- On AXIOM reduce production single_term_ -> MINUS INTEGER
-- On AT reduce production single_term_ -> MINUS INTEGER
-- On ARROW reduce production single_term_ -> MINUS INTEGER
-- On AND reduce production single_term_ -> MINUS INTEGER
-- On AMPAMP reduce production single_term_ -> MINUS INTEGER

State 214:
## Known stack suffix:
## MATCH
## LR(1) items:
single_term_ -> MATCH . term WITH match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 447
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 215:
## Known stack suffix:
## LET
## LR(1) items:
single_term_ -> LET . pattern EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> LET . attrs(lident_op_nq) EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> LET . attrs(lident_nq) mk_term(lam_defn) IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> LET . attrs(lident_op_nq) mk_term(lam_defn) IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 217
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 268
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On lident_op_nq shift to state 429
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_op_nq) shift to state 431
-- On attrs(lident_nq) shift to state 443
## Reductions:

State 216:
## Known stack suffix:
## UNDERSCORE
## LR(1) items:
pat_arg_ -> UNDERSCORE . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production pat_arg_ -> UNDERSCORE
-- On UIDENT reduce production pat_arg_ -> UNDERSCORE
-- On SEMICOLON reduce production pat_arg_ -> UNDERSCORE
-- On RIGHTPAR reduce production pat_arg_ -> UNDERSCORE
-- On RIGHTBRC reduce production pat_arg_ -> UNDERSCORE
-- On RANGE reduce production pat_arg_ -> UNDERSCORE
-- On LIDENT reduce production pat_arg_ -> UNDERSCORE
-- On LEFTPAR reduce production pat_arg_ -> UNDERSCORE
-- On LEFTBRC reduce production pat_arg_ -> UNDERSCORE
-- On FLOAT reduce production pat_arg_ -> UNDERSCORE
-- On EQUAL reduce production pat_arg_ -> UNDERSCORE
-- On CORE_UIDENT reduce production pat_arg_ -> UNDERSCORE
-- On CORE_LIDENT reduce production pat_arg_ -> UNDERSCORE
-- On COMMA reduce production pat_arg_ -> UNDERSCORE
-- On COLON reduce production pat_arg_ -> UNDERSCORE
-- On BAR reduce production pat_arg_ -> UNDERSCORE
-- On AS reduce production pat_arg_ -> UNDERSCORE
-- On ARROW reduce production pat_arg_ -> UNDERSCORE

State 217:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
lident_op_nq -> LEFTPAR . lident_op_str RIGHTPAR [ UNDERSCORE UIDENT RANGE QUOTE_LIDENT POSITION LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT ATTRIBUTE ]
lident_op_nq -> LEFTPAR . lident_op_str RIGHTPAR_USCORE [ UNDERSCORE UIDENT RANGE QUOTE_LIDENT POSITION LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT ATTRIBUTE ]
lident_op_nq -> LEFTPAR . lident_op_str RIGHTPAR_QUOTE [ UNDERSCORE UIDENT RANGE QUOTE_LIDENT POSITION LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT ATTRIBUTE ]
pat_block_ -> LEFTPAR . RIGHTPAR [ EQUAL COMMA COLON BAR AS ]
pat_block_ -> LEFTPAR . pattern RIGHTPAR [ EQUAL COMMA COLON BAR AS ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 218
-- On RANGE shift to state 2
-- On OPPREF shift to state 5
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On MINUS shift to state 12
-- On LT shift to state 14
-- On LIDENT shift to state 60
-- On LEFTSQ shift to state 15
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GT shift to state 29
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On EQUAL shift to state 30
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 266
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On op_symbol shift to state 31
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On lident_op_str shift to state 62
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 218:
## Known stack suffix:
## LEFTPAR RIGHTPAR
## LR(1) items:
pat_block_ -> LEFTPAR RIGHTPAR . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On UIDENT reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On SEMICOLON reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On RIGHTPAR reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On RIGHTBRC reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On RANGE reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On LIDENT reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On LEFTPAR reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On LEFTBRC reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On FLOAT reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On EQUAL reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On CORE_UIDENT reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On CORE_LIDENT reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On COMMA reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On COLON reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On BAR reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On AS reduce production pat_block_ -> LEFTPAR RIGHTPAR
-- On ARROW reduce production pat_block_ -> LEFTPAR RIGHTPAR

State 219:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
pat_block_ -> LEFTPAR . RIGHTPAR [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
pat_block_ -> LEFTPAR . pattern RIGHTPAR [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 218
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 266
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 220:
## Known stack suffix:
## LEFTBRC
## LR(1) items:
pat_block_ -> LEFTBRC . field_list1(pattern) RIGHTBRC [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) shift to state 223
-- On lqualid shift to state 224
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On field_list1(pattern) shift to state 264
## Reductions:

State 221:
## Known stack suffix:
## uqualid
## LR(1) items:
lqualid -> uqualid . DOT lident [ RIGHTBRC EQUAL COMMA ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 222
## Reductions:

State 222:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
lqualid -> uqualid DOT . lident [ RIGHTBRC EQUAL COMMA ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 86
-- On lident_keyword shift to state 43
-- On lident shift to state 88
## Reductions:

State 223:
## Known stack suffix:
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern))
## LR(1) items:
field_list1(pattern) -> semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production field_list1(pattern) -> semicolon_list1(separated_pair(lqualid,EQUAL,pattern))

State 224:
## Known stack suffix:
## lqualid
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid . EQUAL pattern [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid . EQUAL pattern SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid . EQUAL pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
## Transitions:
-- On EQUAL shift to state 225
## Reductions:

State 225:
## Known stack suffix:
## lqualid EQUAL
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL . pattern [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL . pattern SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL . pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 244
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 226:
## Known stack suffix:
## GHOST
## LR(1) items:
pat_uni_ -> GHOST . mk_pat(pat_uni_) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pat_uni_ shift to state 239
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pat_uni_) shift to state 241
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 227:
## Known stack suffix:
## uqualid
## LR(1) items:
pat_arg_ -> uqualid . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
pat_arg_ -> uqualid . DOT mk_pat(pat_block_) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
pat_uni_ -> uqualid . nonempty_list(pat_arg) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On DOT shift to state 228
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 231
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 233
-- On pat_arg shift to state 234
-- On nonempty_list(pat_arg) shift to state 238
-- On mk_pat(pat_arg_) shift to state 236
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:
-- On SEMICOLON reduce production pat_arg_ -> uqualid
-- On RIGHTPAR reduce production pat_arg_ -> uqualid
-- On RIGHTBRC reduce production pat_arg_ -> uqualid
-- On EQUAL reduce production pat_arg_ -> uqualid
-- On COMMA reduce production pat_arg_ -> uqualid
-- On COLON reduce production pat_arg_ -> uqualid
-- On BAR reduce production pat_arg_ -> uqualid
-- On AS reduce production pat_arg_ -> uqualid
-- On ARROW reduce production pat_arg_ -> uqualid

State 228:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
pat_arg_ -> uqualid DOT . mk_pat(pat_block_) [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
uqualid -> uqualid DOT . uident [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On UIDENT shift to state 1
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 86
-- On pat_block_ shift to state 229
-- On mk_pat(pat_block_) shift to state 230
## Reductions:

State 229:
## Known stack suffix:
## pat_block_
## LR(1) items:
mk_pat(pat_block_) -> pat_block_ . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production mk_pat(pat_block_) -> pat_block_
-- On UIDENT reduce production mk_pat(pat_block_) -> pat_block_
-- On SEMICOLON reduce production mk_pat(pat_block_) -> pat_block_
-- On RIGHTPAR reduce production mk_pat(pat_block_) -> pat_block_
-- On RIGHTBRC reduce production mk_pat(pat_block_) -> pat_block_
-- On RANGE reduce production mk_pat(pat_block_) -> pat_block_
-- On LIDENT reduce production mk_pat(pat_block_) -> pat_block_
-- On LEFTPAR reduce production mk_pat(pat_block_) -> pat_block_
-- On LEFTBRC reduce production mk_pat(pat_block_) -> pat_block_
-- On FLOAT reduce production mk_pat(pat_block_) -> pat_block_
-- On EQUAL reduce production mk_pat(pat_block_) -> pat_block_
-- On CORE_UIDENT reduce production mk_pat(pat_block_) -> pat_block_
-- On CORE_LIDENT reduce production mk_pat(pat_block_) -> pat_block_
-- On COMMA reduce production mk_pat(pat_block_) -> pat_block_
-- On COLON reduce production mk_pat(pat_block_) -> pat_block_
-- On BAR reduce production mk_pat(pat_block_) -> pat_block_
-- On AS reduce production mk_pat(pat_block_) -> pat_block_
-- On ARROW reduce production mk_pat(pat_block_) -> pat_block_

State 230:
## Known stack suffix:
## uqualid DOT mk_pat(pat_block_)
## LR(1) items:
pat_arg_ -> uqualid DOT mk_pat(pat_block_) . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On UIDENT reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On SEMICOLON reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On RIGHTPAR reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On RIGHTBRC reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On RANGE reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On LIDENT reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On LEFTPAR reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On LEFTBRC reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On FLOAT reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On EQUAL reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On CORE_UIDENT reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On CORE_LIDENT reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On COMMA reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On COLON reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On BAR reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On AS reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)
-- On ARROW reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)

State 231:
## Known stack suffix:
## uqualid
## LR(1) items:
pat_arg_ -> uqualid . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
pat_arg_ -> uqualid . DOT mk_pat(pat_block_) [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On DOT shift to state 228
## Reductions:
-- On UNDERSCORE reduce production pat_arg_ -> uqualid
-- On UIDENT reduce production pat_arg_ -> uqualid
-- On SEMICOLON reduce production pat_arg_ -> uqualid
-- On RIGHTPAR reduce production pat_arg_ -> uqualid
-- On RIGHTBRC reduce production pat_arg_ -> uqualid
-- On RANGE reduce production pat_arg_ -> uqualid
-- On LIDENT reduce production pat_arg_ -> uqualid
-- On LEFTPAR reduce production pat_arg_ -> uqualid
-- On LEFTBRC reduce production pat_arg_ -> uqualid
-- On FLOAT reduce production pat_arg_ -> uqualid
-- On EQUAL reduce production pat_arg_ -> uqualid
-- On CORE_UIDENT reduce production pat_arg_ -> uqualid
-- On CORE_LIDENT reduce production pat_arg_ -> uqualid
-- On COMMA reduce production pat_arg_ -> uqualid
-- On COLON reduce production pat_arg_ -> uqualid
-- On BAR reduce production pat_arg_ -> uqualid
-- On AS reduce production pat_arg_ -> uqualid
-- On ARROW reduce production pat_arg_ -> uqualid

State 232:
## Known stack suffix:
## pat_block_
## LR(1) items:
pat_arg_ -> pat_block_ . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production pat_arg_ -> pat_block_
-- On UIDENT reduce production pat_arg_ -> pat_block_
-- On SEMICOLON reduce production pat_arg_ -> pat_block_
-- On RIGHTPAR reduce production pat_arg_ -> pat_block_
-- On RIGHTBRC reduce production pat_arg_ -> pat_block_
-- On RANGE reduce production pat_arg_ -> pat_block_
-- On LIDENT reduce production pat_arg_ -> pat_block_
-- On LEFTPAR reduce production pat_arg_ -> pat_block_
-- On LEFTBRC reduce production pat_arg_ -> pat_block_
-- On FLOAT reduce production pat_arg_ -> pat_block_
-- On EQUAL reduce production pat_arg_ -> pat_block_
-- On CORE_UIDENT reduce production pat_arg_ -> pat_block_
-- On CORE_LIDENT reduce production pat_arg_ -> pat_block_
-- On COMMA reduce production pat_arg_ -> pat_block_
-- On COLON reduce production pat_arg_ -> pat_block_
-- On BAR reduce production pat_arg_ -> pat_block_
-- On AS reduce production pat_arg_ -> pat_block_
-- On ARROW reduce production pat_arg_ -> pat_block_

State 233:
## Known stack suffix:
## pat_arg_
## LR(1) items:
mk_pat(pat_arg_) -> pat_arg_ . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production mk_pat(pat_arg_) -> pat_arg_
-- On UIDENT reduce production mk_pat(pat_arg_) -> pat_arg_
-- On SEMICOLON reduce production mk_pat(pat_arg_) -> pat_arg_
-- On RIGHTPAR reduce production mk_pat(pat_arg_) -> pat_arg_
-- On RIGHTBRC reduce production mk_pat(pat_arg_) -> pat_arg_
-- On RANGE reduce production mk_pat(pat_arg_) -> pat_arg_
-- On LIDENT reduce production mk_pat(pat_arg_) -> pat_arg_
-- On LEFTPAR reduce production mk_pat(pat_arg_) -> pat_arg_
-- On LEFTBRC reduce production mk_pat(pat_arg_) -> pat_arg_
-- On FLOAT reduce production mk_pat(pat_arg_) -> pat_arg_
-- On EQUAL reduce production mk_pat(pat_arg_) -> pat_arg_
-- On CORE_UIDENT reduce production mk_pat(pat_arg_) -> pat_arg_
-- On CORE_LIDENT reduce production mk_pat(pat_arg_) -> pat_arg_
-- On COMMA reduce production mk_pat(pat_arg_) -> pat_arg_
-- On COLON reduce production mk_pat(pat_arg_) -> pat_arg_
-- On BAR reduce production mk_pat(pat_arg_) -> pat_arg_
-- On AS reduce production mk_pat(pat_arg_) -> pat_arg_
-- On ARROW reduce production mk_pat(pat_arg_) -> pat_arg_

State 234:
## Known stack suffix:
## pat_arg
## LR(1) items:
nonempty_list(pat_arg) -> pat_arg . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
nonempty_list(pat_arg) -> pat_arg . nonempty_list(pat_arg) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 231
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 233
-- On pat_arg shift to state 234
-- On nonempty_list(pat_arg) shift to state 235
-- On mk_pat(pat_arg_) shift to state 236
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:
-- On SEMICOLON reduce production nonempty_list(pat_arg) -> pat_arg
-- On RIGHTPAR reduce production nonempty_list(pat_arg) -> pat_arg
-- On RIGHTBRC reduce production nonempty_list(pat_arg) -> pat_arg
-- On EQUAL reduce production nonempty_list(pat_arg) -> pat_arg
-- On COMMA reduce production nonempty_list(pat_arg) -> pat_arg
-- On COLON reduce production nonempty_list(pat_arg) -> pat_arg
-- On BAR reduce production nonempty_list(pat_arg) -> pat_arg
-- On AS reduce production nonempty_list(pat_arg) -> pat_arg
-- On ARROW reduce production nonempty_list(pat_arg) -> pat_arg

State 235:
## Known stack suffix:
## pat_arg nonempty_list(pat_arg)
## LR(1) items:
nonempty_list(pat_arg) -> pat_arg nonempty_list(pat_arg) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production nonempty_list(pat_arg) -> pat_arg nonempty_list(pat_arg)
-- On RIGHTPAR reduce production nonempty_list(pat_arg) -> pat_arg nonempty_list(pat_arg)
-- On RIGHTBRC reduce production nonempty_list(pat_arg) -> pat_arg nonempty_list(pat_arg)
-- On EQUAL reduce production nonempty_list(pat_arg) -> pat_arg nonempty_list(pat_arg)
-- On COMMA reduce production nonempty_list(pat_arg) -> pat_arg nonempty_list(pat_arg)
-- On COLON reduce production nonempty_list(pat_arg) -> pat_arg nonempty_list(pat_arg)
-- On BAR reduce production nonempty_list(pat_arg) -> pat_arg nonempty_list(pat_arg)
-- On AS reduce production nonempty_list(pat_arg) -> pat_arg nonempty_list(pat_arg)
-- On ARROW reduce production nonempty_list(pat_arg) -> pat_arg nonempty_list(pat_arg)

State 236:
## Known stack suffix:
## mk_pat(pat_arg_)
## LR(1) items:
pat_arg -> mk_pat(pat_arg_) . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production pat_arg -> mk_pat(pat_arg_)
-- On UIDENT reduce production pat_arg -> mk_pat(pat_arg_)
-- On SEMICOLON reduce production pat_arg -> mk_pat(pat_arg_)
-- On RIGHTPAR reduce production pat_arg -> mk_pat(pat_arg_)
-- On RIGHTBRC reduce production pat_arg -> mk_pat(pat_arg_)
-- On RANGE reduce production pat_arg -> mk_pat(pat_arg_)
-- On LIDENT reduce production pat_arg -> mk_pat(pat_arg_)
-- On LEFTPAR reduce production pat_arg -> mk_pat(pat_arg_)
-- On LEFTBRC reduce production pat_arg -> mk_pat(pat_arg_)
-- On FLOAT reduce production pat_arg -> mk_pat(pat_arg_)
-- On EQUAL reduce production pat_arg -> mk_pat(pat_arg_)
-- On CORE_UIDENT reduce production pat_arg -> mk_pat(pat_arg_)
-- On CORE_LIDENT reduce production pat_arg -> mk_pat(pat_arg_)
-- On COMMA reduce production pat_arg -> mk_pat(pat_arg_)
-- On COLON reduce production pat_arg -> mk_pat(pat_arg_)
-- On BAR reduce production pat_arg -> mk_pat(pat_arg_)
-- On AS reduce production pat_arg -> mk_pat(pat_arg_)
-- On ARROW reduce production pat_arg -> mk_pat(pat_arg_)

State 237:
## Known stack suffix:
## attrs(lident_nq)
## LR(1) items:
pat_arg_ -> attrs(lident_nq) . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production pat_arg_ -> attrs(lident_nq)
-- On UIDENT reduce production pat_arg_ -> attrs(lident_nq)
-- On SEMICOLON reduce production pat_arg_ -> attrs(lident_nq)
-- On RIGHTPAR reduce production pat_arg_ -> attrs(lident_nq)
-- On RIGHTBRC reduce production pat_arg_ -> attrs(lident_nq)
-- On RANGE reduce production pat_arg_ -> attrs(lident_nq)
-- On LIDENT reduce production pat_arg_ -> attrs(lident_nq)
-- On LEFTPAR reduce production pat_arg_ -> attrs(lident_nq)
-- On LEFTBRC reduce production pat_arg_ -> attrs(lident_nq)
-- On FLOAT reduce production pat_arg_ -> attrs(lident_nq)
-- On EQUAL reduce production pat_arg_ -> attrs(lident_nq)
-- On CORE_UIDENT reduce production pat_arg_ -> attrs(lident_nq)
-- On CORE_LIDENT reduce production pat_arg_ -> attrs(lident_nq)
-- On COMMA reduce production pat_arg_ -> attrs(lident_nq)
-- On COLON reduce production pat_arg_ -> attrs(lident_nq)
-- On BAR reduce production pat_arg_ -> attrs(lident_nq)
-- On AS reduce production pat_arg_ -> attrs(lident_nq)
-- On ARROW reduce production pat_arg_ -> attrs(lident_nq)

State 238:
## Known stack suffix:
## uqualid nonempty_list(pat_arg)
## LR(1) items:
pat_uni_ -> uqualid nonempty_list(pat_arg) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production pat_uni_ -> uqualid nonempty_list(pat_arg)
-- On RIGHTPAR reduce production pat_uni_ -> uqualid nonempty_list(pat_arg)
-- On RIGHTBRC reduce production pat_uni_ -> uqualid nonempty_list(pat_arg)
-- On EQUAL reduce production pat_uni_ -> uqualid nonempty_list(pat_arg)
-- On COMMA reduce production pat_uni_ -> uqualid nonempty_list(pat_arg)
-- On COLON reduce production pat_uni_ -> uqualid nonempty_list(pat_arg)
-- On BAR reduce production pat_uni_ -> uqualid nonempty_list(pat_arg)
-- On AS reduce production pat_uni_ -> uqualid nonempty_list(pat_arg)
-- On ARROW reduce production pat_uni_ -> uqualid nonempty_list(pat_arg)

State 239:
## Known stack suffix:
## pat_uni_
## LR(1) items:
mk_pat(pat_uni_) -> pat_uni_ . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production mk_pat(pat_uni_) -> pat_uni_
-- On RIGHTPAR reduce production mk_pat(pat_uni_) -> pat_uni_
-- On RIGHTBRC reduce production mk_pat(pat_uni_) -> pat_uni_
-- On EQUAL reduce production mk_pat(pat_uni_) -> pat_uni_
-- On COMMA reduce production mk_pat(pat_uni_) -> pat_uni_
-- On COLON reduce production mk_pat(pat_uni_) -> pat_uni_
-- On BAR reduce production mk_pat(pat_uni_) -> pat_uni_
-- On AS reduce production mk_pat(pat_uni_) -> pat_uni_
-- On ARROW reduce production mk_pat(pat_uni_) -> pat_uni_

State 240:
## Known stack suffix:
## pat_arg_
## LR(1) items:
pat_uni_ -> pat_arg_ . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production pat_uni_ -> pat_arg_
-- On RIGHTPAR reduce production pat_uni_ -> pat_arg_
-- On RIGHTBRC reduce production pat_uni_ -> pat_arg_
-- On EQUAL reduce production pat_uni_ -> pat_arg_
-- On COMMA reduce production pat_uni_ -> pat_arg_
-- On COLON reduce production pat_uni_ -> pat_arg_
-- On BAR reduce production pat_uni_ -> pat_arg_
-- On AS reduce production pat_uni_ -> pat_arg_
-- On ARROW reduce production pat_uni_ -> pat_arg_

State 241:
## Known stack suffix:
## GHOST mk_pat(pat_uni_)
## LR(1) items:
pat_uni_ -> GHOST mk_pat(pat_uni_) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
pat_uni_ -> mk_pat(pat_uni_) . AS ghost attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
pat_uni_ -> mk_pat(pat_uni_) . cast [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 242
## Reductions:
-- On SEMICOLON reduce production pat_uni_ -> GHOST mk_pat(pat_uni_)
-- On RIGHTPAR reduce production pat_uni_ -> GHOST mk_pat(pat_uni_)
-- On RIGHTBRC reduce production pat_uni_ -> GHOST mk_pat(pat_uni_)
-- On EQUAL reduce production pat_uni_ -> GHOST mk_pat(pat_uni_)
-- On COMMA reduce production pat_uni_ -> GHOST mk_pat(pat_uni_)
-- On BAR reduce production pat_uni_ -> GHOST mk_pat(pat_uni_)
-- On AS reduce production pat_uni_ -> GHOST mk_pat(pat_uni_)
-- On ARROW reduce production pat_uni_ -> GHOST mk_pat(pat_uni_)

State 242:
## Known stack suffix:
## mk_pat(pat_uni_) cast
## LR(1) items:
pat_uni_ -> mk_pat(pat_uni_) cast . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production pat_uni_ -> mk_pat(pat_uni_) cast
-- On RIGHTPAR reduce production pat_uni_ -> mk_pat(pat_uni_) cast
-- On RIGHTBRC reduce production pat_uni_ -> mk_pat(pat_uni_) cast
-- On EQUAL reduce production pat_uni_ -> mk_pat(pat_uni_) cast
-- On COMMA reduce production pat_uni_ -> mk_pat(pat_uni_) cast
-- On COLON reduce production pat_uni_ -> mk_pat(pat_uni_) cast
-- On BAR reduce production pat_uni_ -> mk_pat(pat_uni_) cast
-- On AS reduce production pat_uni_ -> mk_pat(pat_uni_) cast
-- On ARROW reduce production pat_uni_ -> mk_pat(pat_uni_) cast

State 243:
## Known stack suffix:
## pattern_
## LR(1) items:
mk_pat(pattern_) -> pattern_ . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production mk_pat(pattern_) -> pattern_
-- On RIGHTPAR reduce production mk_pat(pattern_) -> pattern_
-- On RIGHTBRC reduce production mk_pat(pattern_) -> pattern_
-- On EQUAL reduce production mk_pat(pattern_) -> pattern_
-- On ARROW reduce production mk_pat(pattern_) -> pattern_

State 244:
## Known stack suffix:
## lqualid EQUAL pattern
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern . [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern . SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern . SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
## Transitions:
-- On SEMICOLON shift to state 245
## Reductions:
-- On RIGHTBRC reduce production semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern

State 245:
## Known stack suffix:
## lqualid EQUAL pattern SEMICOLON
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON . [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON . semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) shift to state 246
-- On lqualid shift to state 224
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:
-- On RIGHTBRC reduce production semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON

State 246:
## Known stack suffix:
## lqualid EQUAL pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern))
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern))

State 247:
## Known stack suffix:
## pat_uni_
## LR(1) items:
mk_pat(pat_uni_) -> pat_uni_ . [ COMMA COLON AS ]
pat_conj_ -> pat_uni_ . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production pat_conj_ -> pat_uni_
-- On RIGHTPAR reduce production pat_conj_ -> pat_uni_
-- On RIGHTBRC reduce production pat_conj_ -> pat_uni_
-- On EQUAL reduce production pat_conj_ -> pat_uni_
-- On COMMA reduce production mk_pat(pat_uni_) -> pat_uni_
-- On COLON reduce production mk_pat(pat_uni_) -> pat_uni_
-- On BAR reduce production pat_conj_ -> pat_uni_
-- On AS reduce production mk_pat(pat_uni_) -> pat_uni_
-- On ARROW reduce production pat_conj_ -> pat_uni_

State 248:
## Known stack suffix:
## pat_conj_
## LR(1) items:
mk_pat(pat_conj_) -> pat_conj_ . [ BAR ]
pattern_ -> pat_conj_ . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production pattern_ -> pat_conj_
-- On RIGHTPAR reduce production pattern_ -> pat_conj_
-- On RIGHTBRC reduce production pattern_ -> pat_conj_
-- On EQUAL reduce production pattern_ -> pat_conj_
-- On BAR reduce production mk_pat(pat_conj_) -> pat_conj_
-- On ARROW reduce production pattern_ -> pat_conj_

State 249:
## Known stack suffix:
## mk_pat(pattern_)
## LR(1) items:
pattern -> mk_pat(pattern_) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production pattern -> mk_pat(pattern_)
-- On RIGHTPAR reduce production pattern -> mk_pat(pattern_)
-- On RIGHTBRC reduce production pattern -> mk_pat(pattern_)
-- On EQUAL reduce production pattern -> mk_pat(pattern_)
-- On ARROW reduce production pattern -> mk_pat(pattern_)

State 250:
## Known stack suffix:
## mk_pat(pat_uni_)
## LR(1) items:
comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) . COMMA comma_list1(mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
pat_uni_ -> mk_pat(pat_uni_) . AS ghost attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
pat_uni_ -> mk_pat(pat_uni_) . cast [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
-- On COMMA shift to state 251
-- On COLON shift to state 132
-- On AS shift to state 256
-- On cast shift to state 242
## Reductions:

State 251:
## Known stack suffix:
## mk_pat(pat_uni_) COMMA
## LR(1) items:
comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA . comma_list1(mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,mk_pat(pat_uni_)) shift to state 252
-- On pat_uni_ shift to state 239
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pat_uni_) shift to state 253
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list1(mk_pat(pat_uni_)) shift to state 259
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 252:
## Known stack suffix:
## separated_nonempty_list(COMMA,mk_pat(pat_uni_))
## LR(1) items:
comma_list1(mk_pat(pat_uni_)) -> separated_nonempty_list(COMMA,mk_pat(pat_uni_)) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production comma_list1(mk_pat(pat_uni_)) -> separated_nonempty_list(COMMA,mk_pat(pat_uni_))
-- On RIGHTPAR reduce production comma_list1(mk_pat(pat_uni_)) -> separated_nonempty_list(COMMA,mk_pat(pat_uni_))
-- On RIGHTBRC reduce production comma_list1(mk_pat(pat_uni_)) -> separated_nonempty_list(COMMA,mk_pat(pat_uni_))
-- On EQUAL reduce production comma_list1(mk_pat(pat_uni_)) -> separated_nonempty_list(COMMA,mk_pat(pat_uni_))
-- On BAR reduce production comma_list1(mk_pat(pat_uni_)) -> separated_nonempty_list(COMMA,mk_pat(pat_uni_))
-- On ARROW reduce production comma_list1(mk_pat(pat_uni_)) -> separated_nonempty_list(COMMA,mk_pat(pat_uni_))

State 253:
## Known stack suffix:
## mk_pat(pat_uni_)
## LR(1) items:
pat_uni_ -> mk_pat(pat_uni_) . AS ghost attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
pat_uni_ -> mk_pat(pat_uni_) . cast [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) . COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
-- On COMMA shift to state 254
-- On COLON shift to state 132
-- On AS shift to state 256
-- On cast shift to state 242
## Reductions:
-- On SEMICOLON reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_)
-- On RIGHTPAR reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_)
-- On RIGHTBRC reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_)
-- On EQUAL reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_)
-- On BAR reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_)
-- On ARROW reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_)

State 254:
## Known stack suffix:
## mk_pat(pat_uni_) COMMA
## LR(1) items:
separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA . separated_nonempty_list(COMMA,mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,mk_pat(pat_uni_)) shift to state 255
-- On pat_uni_ shift to state 239
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pat_uni_) shift to state 253
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 255:
## Known stack suffix:
## mk_pat(pat_uni_) COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_))
## LR(1) items:
separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_)) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_))
-- On RIGHTPAR reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_))
-- On RIGHTBRC reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_))
-- On EQUAL reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_))
-- On BAR reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_))
-- On ARROW reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_))

State 256:
## Known stack suffix:
## mk_pat(pat_uni_) AS
## LR(1) items:
pat_uni_ -> mk_pat(pat_uni_) AS . ghost attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
-- On GHOST shift to state 53
-- On ghost shift to state 257
## Reductions:
-- On RANGE reduce production ghost ->
-- On LIDENT reduce production ghost ->
-- On FLOAT reduce production ghost ->
-- On CORE_LIDENT reduce production ghost ->

State 257:
## Known stack suffix:
## mk_pat(pat_uni_) AS ghost
## LR(1) items:
pat_uni_ -> mk_pat(pat_uni_) AS ghost . attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 258
## Reductions:

State 258:
## Known stack suffix:
## mk_pat(pat_uni_) AS ghost attrs(lident_nq)
## LR(1) items:
pat_uni_ -> mk_pat(pat_uni_) AS ghost attrs(lident_nq) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production pat_uni_ -> mk_pat(pat_uni_) AS ghost attrs(lident_nq)
-- On RIGHTPAR reduce production pat_uni_ -> mk_pat(pat_uni_) AS ghost attrs(lident_nq)
-- On RIGHTBRC reduce production pat_uni_ -> mk_pat(pat_uni_) AS ghost attrs(lident_nq)
-- On EQUAL reduce production pat_uni_ -> mk_pat(pat_uni_) AS ghost attrs(lident_nq)
-- On COMMA reduce production pat_uni_ -> mk_pat(pat_uni_) AS ghost attrs(lident_nq)
-- On COLON reduce production pat_uni_ -> mk_pat(pat_uni_) AS ghost attrs(lident_nq)
-- On BAR reduce production pat_uni_ -> mk_pat(pat_uni_) AS ghost attrs(lident_nq)
-- On AS reduce production pat_uni_ -> mk_pat(pat_uni_) AS ghost attrs(lident_nq)
-- On ARROW reduce production pat_uni_ -> mk_pat(pat_uni_) AS ghost attrs(lident_nq)

State 259:
## Known stack suffix:
## mk_pat(pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))
## LR(1) items:
comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA comma_list1(mk_pat(pat_uni_)) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))
-- On RIGHTPAR reduce production comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))
-- On RIGHTBRC reduce production comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))
-- On EQUAL reduce production comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))
-- On BAR reduce production comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))
-- On ARROW reduce production comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))

State 260:
## Known stack suffix:
## mk_pat(pat_conj_)
## LR(1) items:
pattern_ -> mk_pat(pat_conj_) . BAR pattern [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
## Transitions:
-- On BAR shift to state 261
## Reductions:

State 261:
## Known stack suffix:
## mk_pat(pat_conj_) BAR
## LR(1) items:
pattern_ -> mk_pat(pat_conj_) BAR . pattern [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 262
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 262:
## Known stack suffix:
## mk_pat(pat_conj_) BAR pattern
## LR(1) items:
pattern_ -> mk_pat(pat_conj_) BAR pattern . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production pattern_ -> mk_pat(pat_conj_) BAR pattern
-- On RIGHTPAR reduce production pattern_ -> mk_pat(pat_conj_) BAR pattern
-- On RIGHTBRC reduce production pattern_ -> mk_pat(pat_conj_) BAR pattern
-- On EQUAL reduce production pattern_ -> mk_pat(pat_conj_) BAR pattern
-- On ARROW reduce production pattern_ -> mk_pat(pat_conj_) BAR pattern

State 263:
## Known stack suffix:
## comma_list2(mk_pat(pat_uni_))
## LR(1) items:
pat_conj_ -> comma_list2(mk_pat(pat_uni_)) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production pat_conj_ -> comma_list2(mk_pat(pat_uni_))
-- On RIGHTPAR reduce production pat_conj_ -> comma_list2(mk_pat(pat_uni_))
-- On RIGHTBRC reduce production pat_conj_ -> comma_list2(mk_pat(pat_uni_))
-- On EQUAL reduce production pat_conj_ -> comma_list2(mk_pat(pat_uni_))
-- On BAR reduce production pat_conj_ -> comma_list2(mk_pat(pat_uni_))
-- On ARROW reduce production pat_conj_ -> comma_list2(mk_pat(pat_uni_))

State 264:
## Known stack suffix:
## LEFTBRC field_list1(pattern)
## LR(1) items:
pat_block_ -> LEFTBRC field_list1(pattern) . RIGHTBRC [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On RIGHTBRC shift to state 265
## Reductions:

State 265:
## Known stack suffix:
## LEFTBRC field_list1(pattern) RIGHTBRC
## LR(1) items:
pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On UIDENT reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On SEMICOLON reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On RIGHTPAR reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On RIGHTBRC reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On RANGE reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On LIDENT reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On LEFTPAR reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On LEFTBRC reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On FLOAT reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On EQUAL reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On CORE_UIDENT reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On CORE_LIDENT reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On COMMA reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On COLON reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On BAR reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On AS reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC
-- On ARROW reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC

State 266:
## Known stack suffix:
## LEFTPAR pattern
## LR(1) items:
pat_block_ -> LEFTPAR pattern . RIGHTPAR [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On RIGHTPAR shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## LEFTPAR pattern RIGHTPAR
## LR(1) items:
pat_block_ -> LEFTPAR pattern RIGHTPAR . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On UIDENT reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On SEMICOLON reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On RIGHTPAR reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On RIGHTBRC reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On RANGE reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On LIDENT reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On LEFTPAR reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On LEFTBRC reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On FLOAT reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On EQUAL reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On CORE_UIDENT reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On CORE_LIDENT reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On COMMA reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On COLON reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On BAR reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On AS reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR
-- On ARROW reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR

State 268:
## Known stack suffix:
## LET pattern
## LR(1) items:
single_term_ -> LET pattern . EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On EQUAL shift to state 269
## Reductions:

State 269:
## Known stack suffix:
## LET pattern EQUAL
## LR(1) items:
single_term_ -> LET pattern EQUAL . term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 426
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 270:
## Known stack suffix:
## IF
## LR(1) items:
single_term_ -> IF . term THEN term ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 421
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 271:
## Known stack suffix:
## FUN
## LR(1) items:
single_term_ -> FUN . binders ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 151
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 153
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 167
-- On lident shift to state 101
-- On binders shift to state 290
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:

State 272:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
binder -> LEFTPAR . GHOST ty RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder -> LEFTPAR . binder_vars_rest RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder -> LEFTPAR . GHOST binder_vars_rest RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder -> LEFTPAR . binder_vars cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder -> LEFTPAR . GHOST binder_vars cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
ty_block -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
ty_block -> LEFTPAR . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
ty_block -> LEFTPAR . ty RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 81
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 273
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 138
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list2(ty) shift to state 111
-- On binder_vars_rest shift to state 281
-- On binder_vars_head shift to state 118
-- On binder_vars shift to state 283
-- On anon_binder shift to state 136
## Reductions:

State 273:
## Known stack suffix:
## LEFTPAR GHOST
## LR(1) items:
binder -> LEFTPAR GHOST . ty RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder -> LEFTPAR GHOST . binder_vars_rest RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder -> LEFTPAR GHOST . binder_vars cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 274
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On binder_vars_rest shift to state 276
-- On binder_vars_head shift to state 118
-- On binder_vars shift to state 278
-- On anon_binder shift to state 136
## Reductions:

State 274:
## Known stack suffix:
## LEFTPAR GHOST ty
## LR(1) items:
binder -> LEFTPAR GHOST ty . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder_vars_head -> ty . [ UNDERSCORE POSITION COLON ATTRIBUTE ]
ty -> ty . ARROW ty [ UNDERSCORE RIGHTPAR POSITION COLON ATTRIBUTE ARROW ]
## Transitions:
-- On RIGHTPAR shift to state 275
-- On ARROW shift to state 94
## Reductions:
-- On UNDERSCORE reduce production binder_vars_head -> ty
-- On POSITION reduce production binder_vars_head -> ty
-- On COLON reduce production binder_vars_head -> ty
-- On ATTRIBUTE reduce production binder_vars_head -> ty

State 275:
## Known stack suffix:
## LEFTPAR GHOST ty RIGHTPAR
## LR(1) items:
binder -> LEFTPAR GHOST ty RIGHTPAR . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On VARIANT reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On UNDERSCORE reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On UIDENT reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On RETURNS reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On REQUIRES reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On READS reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On RANGE reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On RAISES reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On QUOTE_LIDENT reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On LIDENT reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On LEFTPAR reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On LEFTBRC reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On FLOAT reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On EQUAL reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On ENSURES reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On DIVERGES reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On CORE_UIDENT reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On CORE_LIDENT reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On COLON reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On ARROW reduce production binder -> LEFTPAR GHOST ty RIGHTPAR
-- On ALIAS reduce production binder -> LEFTPAR GHOST ty RIGHTPAR

State 276:
## Known stack suffix:
## LEFTPAR GHOST binder_vars_rest
## LR(1) items:
binder -> LEFTPAR GHOST binder_vars_rest . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder_vars -> binder_vars_rest . [ COLON ]
## Transitions:
-- On RIGHTPAR shift to state 277
## Reductions:
-- On COLON reduce production binder_vars -> binder_vars_rest

State 277:
## Known stack suffix:
## LEFTPAR GHOST binder_vars_rest RIGHTPAR
## LR(1) items:
binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On VARIANT reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On UNDERSCORE reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On UIDENT reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On RETURNS reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On REQUIRES reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On READS reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On RANGE reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On RAISES reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On QUOTE_LIDENT reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On LIDENT reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On LEFTPAR reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On LEFTBRC reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On FLOAT reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On EQUAL reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On ENSURES reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On DIVERGES reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On CORE_UIDENT reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On CORE_LIDENT reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On COLON reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On ARROW reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR
-- On ALIAS reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR

State 278:
## Known stack suffix:
## LEFTPAR GHOST binder_vars
## LR(1) items:
binder -> LEFTPAR GHOST binder_vars . cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 279
## Reductions:

State 279:
## Known stack suffix:
## LEFTPAR GHOST binder_vars cast
## LR(1) items:
binder -> LEFTPAR GHOST binder_vars cast . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 280
## Reductions:

State 280:
## Known stack suffix:
## LEFTPAR GHOST binder_vars cast RIGHTPAR
## LR(1) items:
binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On VARIANT reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On UNDERSCORE reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On UIDENT reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On RETURNS reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On REQUIRES reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On READS reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On RANGE reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On RAISES reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On QUOTE_LIDENT reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On LIDENT reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On LEFTPAR reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On LEFTBRC reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On FLOAT reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On EQUAL reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On ENSURES reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On DIVERGES reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On CORE_UIDENT reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On CORE_LIDENT reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On COLON reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On ARROW reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR
-- On ALIAS reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR

State 281:
## Known stack suffix:
## LEFTPAR binder_vars_rest
## LR(1) items:
binder -> LEFTPAR binder_vars_rest . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder_vars -> binder_vars_rest . [ COLON ]
## Transitions:
-- On RIGHTPAR shift to state 282
## Reductions:
-- On COLON reduce production binder_vars -> binder_vars_rest

State 282:
## Known stack suffix:
## LEFTPAR binder_vars_rest RIGHTPAR
## LR(1) items:
binder -> LEFTPAR binder_vars_rest RIGHTPAR . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On VARIANT reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On UNDERSCORE reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On UIDENT reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On RETURNS reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On REQUIRES reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On READS reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On RANGE reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On RAISES reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On QUOTE_LIDENT reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On LIDENT reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On LEFTPAR reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On LEFTBRC reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On FLOAT reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On EQUAL reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On ENSURES reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On DIVERGES reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On CORE_UIDENT reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On CORE_LIDENT reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On COLON reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On ARROW reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR
-- On ALIAS reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR

State 283:
## Known stack suffix:
## LEFTPAR binder_vars
## LR(1) items:
binder -> LEFTPAR binder_vars . cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 284
## Reductions:

State 284:
## Known stack suffix:
## LEFTPAR binder_vars cast
## LR(1) items:
binder -> LEFTPAR binder_vars cast . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 285
## Reductions:

State 285:
## Known stack suffix:
## LEFTPAR binder_vars cast RIGHTPAR
## LR(1) items:
binder -> LEFTPAR binder_vars cast RIGHTPAR . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On VARIANT reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On UNDERSCORE reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On UIDENT reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On RETURNS reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On REQUIRES reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On READS reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On RANGE reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On RAISES reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On QUOTE_LIDENT reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On LIDENT reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On LEFTPAR reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On LEFTBRC reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On FLOAT reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On EQUAL reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On ENSURES reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On DIVERGES reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On CORE_UIDENT reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On CORE_LIDENT reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On COLON reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On ARROW reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR
-- On ALIAS reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR

State 286:
## Known stack suffix:
## ty_arg
## LR(1) items:
binder -> ty_arg . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production binder -> ty_arg
-- On VARIANT reduce production binder -> ty_arg
-- On UNDERSCORE reduce production binder -> ty_arg
-- On UIDENT reduce production binder -> ty_arg
-- On RETURNS reduce production binder -> ty_arg
-- On REQUIRES reduce production binder -> ty_arg
-- On READS reduce production binder -> ty_arg
-- On RANGE reduce production binder -> ty_arg
-- On RAISES reduce production binder -> ty_arg
-- On QUOTE_LIDENT reduce production binder -> ty_arg
-- On LIDENT reduce production binder -> ty_arg
-- On LEFTPAR reduce production binder -> ty_arg
-- On LEFTBRC reduce production binder -> ty_arg
-- On FLOAT reduce production binder -> ty_arg
-- On EQUAL reduce production binder -> ty_arg
-- On ENSURES reduce production binder -> ty_arg
-- On DIVERGES reduce production binder -> ty_arg
-- On CORE_UIDENT reduce production binder -> ty_arg
-- On CORE_LIDENT reduce production binder -> ty_arg
-- On COLON reduce production binder -> ty_arg
-- On ARROW reduce production binder -> ty_arg
-- On ALIAS reduce production binder -> ty_arg

State 287:
## Known stack suffix:
## nonempty_list(binder)
## LR(1) items:
binders -> nonempty_list(binder) . [ WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production binders -> nonempty_list(binder)
-- On VARIANT reduce production binders -> nonempty_list(binder)
-- On RETURNS reduce production binders -> nonempty_list(binder)
-- On REQUIRES reduce production binders -> nonempty_list(binder)
-- On READS reduce production binders -> nonempty_list(binder)
-- On RAISES reduce production binders -> nonempty_list(binder)
-- On EQUAL reduce production binders -> nonempty_list(binder)
-- On ENSURES reduce production binders -> nonempty_list(binder)
-- On DIVERGES reduce production binders -> nonempty_list(binder)
-- On COLON reduce production binders -> nonempty_list(binder)
-- On ARROW reduce production binders -> nonempty_list(binder)
-- On ALIAS reduce production binders -> nonempty_list(binder)

State 288:
## Known stack suffix:
## lident_nq
## LR(1) items:
binder -> lident_nq . nonempty_list(attr) [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On nonempty_list(attr) shift to state 289
-- On attr shift to state 127
## Reductions:

State 289:
## Known stack suffix:
## lident_nq nonempty_list(attr)
## LR(1) items:
binder -> lident_nq nonempty_list(attr) . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production binder -> lident_nq nonempty_list(attr)
-- On VARIANT reduce production binder -> lident_nq nonempty_list(attr)
-- On UNDERSCORE reduce production binder -> lident_nq nonempty_list(attr)
-- On UIDENT reduce production binder -> lident_nq nonempty_list(attr)
-- On RETURNS reduce production binder -> lident_nq nonempty_list(attr)
-- On REQUIRES reduce production binder -> lident_nq nonempty_list(attr)
-- On READS reduce production binder -> lident_nq nonempty_list(attr)
-- On RANGE reduce production binder -> lident_nq nonempty_list(attr)
-- On RAISES reduce production binder -> lident_nq nonempty_list(attr)
-- On QUOTE_LIDENT reduce production binder -> lident_nq nonempty_list(attr)
-- On LIDENT reduce production binder -> lident_nq nonempty_list(attr)
-- On LEFTPAR reduce production binder -> lident_nq nonempty_list(attr)
-- On LEFTBRC reduce production binder -> lident_nq nonempty_list(attr)
-- On FLOAT reduce production binder -> lident_nq nonempty_list(attr)
-- On EQUAL reduce production binder -> lident_nq nonempty_list(attr)
-- On ENSURES reduce production binder -> lident_nq nonempty_list(attr)
-- On DIVERGES reduce production binder -> lident_nq nonempty_list(attr)
-- On CORE_UIDENT reduce production binder -> lident_nq nonempty_list(attr)
-- On CORE_LIDENT reduce production binder -> lident_nq nonempty_list(attr)
-- On COLON reduce production binder -> lident_nq nonempty_list(attr)
-- On ARROW reduce production binder -> lident_nq nonempty_list(attr)
-- On ALIAS reduce production binder -> lident_nq nonempty_list(attr)

State 290:
## Known stack suffix:
## FUN binders
## LR(1) items:
single_term_ -> FUN binders . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On ARROW shift to state 291
## Reductions:

State 291:
## Known stack suffix:
## FUN binders ARROW
## LR(1) items:
single_term_ -> FUN binders ARROW . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 416
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 292:
## Known stack suffix:
## FORALL
## LR(1) items:
quant -> FORALL . [ UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production quant -> FORALL
-- On RANGE reduce production quant -> FORALL
-- On LIDENT reduce production quant -> FORALL
-- On FLOAT reduce production quant -> FORALL
-- On CORE_LIDENT reduce production quant -> FORALL

State 293:
## Known stack suffix:
## EXISTS
## LR(1) items:
quant -> EXISTS . [ UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production quant -> EXISTS
-- On RANGE reduce production quant -> EXISTS
-- On LIDENT reduce production quant -> EXISTS
-- On FLOAT reduce production quant -> EXISTS
-- On CORE_LIDENT reduce production quant -> EXISTS

State 294:
## Known stack suffix:
## EPSILON
## LR(1) items:
single_term_ -> EPSILON . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> EPSILON
-- On VAL reduce production single_term_ -> EPSILON
-- On USE reduce production single_term_ -> EPSILON
-- On TYPE reduce production single_term_ -> EPSILON
-- On THEN reduce production single_term_ -> EPSILON
-- On SO reduce production single_term_ -> EPSILON
-- On SEMICOLON reduce production single_term_ -> EPSILON
-- On SCOPE reduce production single_term_ -> EPSILON
-- On RIGHTSQ_QUOTE reduce production single_term_ -> EPSILON
-- On RIGHTSQ reduce production single_term_ -> EPSILON
-- On RIGHTPAR reduce production single_term_ -> EPSILON
-- On RIGHTBRC reduce production single_term_ -> EPSILON
-- On PREDICATE reduce production single_term_ -> EPSILON
-- On OR reduce production single_term_ -> EPSILON
-- On OP4 reduce production single_term_ -> EPSILON
-- On OP3 reduce production single_term_ -> EPSILON
-- On OP2 reduce production single_term_ -> EPSILON
-- On OP1 reduce production single_term_ -> EPSILON
-- On MINUS reduce production single_term_ -> EPSILON
-- On META reduce production single_term_ -> EPSILON
-- On LTGT reduce production single_term_ -> EPSILON
-- On LT reduce production single_term_ -> EPSILON
-- On LRARROW reduce production single_term_ -> EPSILON
-- On LET reduce production single_term_ -> EPSILON
-- On LEMMA reduce production single_term_ -> EPSILON
-- On LARROW reduce production single_term_ -> EPSILON
-- On INDUCTIVE reduce production single_term_ -> EPSILON
-- On IN reduce production single_term_ -> EPSILON
-- On IMPORT reduce production single_term_ -> EPSILON
-- On GT reduce production single_term_ -> EPSILON
-- On GOAL reduce production single_term_ -> EPSILON
-- On FUNCTION reduce production single_term_ -> EPSILON
-- On EXCEPTION reduce production single_term_ -> EPSILON
-- On EQUAL reduce production single_term_ -> EPSILON
-- On EOF reduce production single_term_ -> EPSILON
-- On END reduce production single_term_ -> EPSILON
-- On ELSE reduce production single_term_ -> EPSILON
-- On DOTDOT reduce production single_term_ -> EPSILON
-- On CONSTANT reduce production single_term_ -> EPSILON
-- On COMMA reduce production single_term_ -> EPSILON
-- On COLON reduce production single_term_ -> EPSILON
-- On COINDUCTIVE reduce production single_term_ -> EPSILON
-- On CLONE reduce production single_term_ -> EPSILON
-- On BY reduce production single_term_ -> EPSILON
-- On BARBAR reduce production single_term_ -> EPSILON
-- On BAR reduce production single_term_ -> EPSILON
-- On AXIOM reduce production single_term_ -> EPSILON
-- On AT reduce production single_term_ -> EPSILON
-- On ARROW reduce production single_term_ -> EPSILON
-- On AND reduce production single_term_ -> EPSILON
-- On AMPAMP reduce production single_term_ -> EPSILON

State 295:
## Known stack suffix:
## uqualid
## LR(1) items:
lqualid -> uqualid . DOT lident [ DOT ]
qualid -> uqualid . DOT ident [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> uqualid . DOT mk_term(term_block_) [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 296
## Reductions:

State 296:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
lqualid -> uqualid DOT . lident [ DOT ]
qualid -> uqualid DOT . ident [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> uqualid DOT . mk_term(term_block_) [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uident shift to state 297
-- On term_block_ shift to state 298
-- On mk_term(term_block_) shift to state 299
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 300
-- On ident shift to state 301
## Reductions:

State 297:
## Known stack suffix:
## uqualid DOT uident
## LR(1) items:
ident -> uident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
uqualid -> uqualid DOT uident . [ DOT ]
## Transitions:
## Reductions:
-- On WRITES reduce production ident -> uident
-- On WITH reduce production ident -> uident
-- On VARIANT reduce production ident -> uident
-- On VAL reduce production ident -> uident
-- On USE reduce production ident -> uident
-- On UIDENT reduce production ident -> uident
-- On TYPE reduce production ident -> uident
-- On TRUE reduce production ident -> uident
-- On TO reduce production ident -> uident
-- On THEN reduce production ident -> uident
-- On SO reduce production ident -> uident
-- On SEMICOLON reduce production ident -> uident
-- On SCOPE reduce production ident -> uident
-- On RIGHTSQ_QUOTE reduce production ident -> uident
-- On RIGHTSQ reduce production ident -> uident
-- On RIGHTPAR reduce production ident -> uident
-- On RIGHTBRC reduce production ident -> uident
-- On RETURNS reduce production ident -> uident
-- On REQUIRES reduce production ident -> uident
-- On REAL reduce production ident -> uident
-- On READS reduce production ident -> uident
-- On RANGE reduce production ident -> uident
-- On RAISES reduce production ident -> uident
-- On QUOTE_LIDENT reduce production ident -> uident
-- On PURE reduce production ident -> uident
-- On PREDICATE reduce production ident -> uident
-- On OR reduce production ident -> uident
-- On OPPREF reduce production ident -> uident
-- On OP4 reduce production ident -> uident
-- On OP3 reduce production ident -> uident
-- On OP2 reduce production ident -> uident
-- On OP1 reduce production ident -> uident
-- On MINUS reduce production ident -> uident
-- On META reduce production ident -> uident
-- On LTGT reduce production ident -> uident
-- On LT reduce production ident -> uident
-- On LRARROW reduce production ident -> uident
-- On LIDENT reduce production ident -> uident
-- On LET reduce production ident -> uident
-- On LEMMA reduce production ident -> uident
-- On LEFTSQ reduce production ident -> uident
-- On LEFTPAR reduce production ident -> uident
-- On LEFTBRC reduce production ident -> uident
-- On LARROW reduce production ident -> uident
-- On INTEGER reduce production ident -> uident
-- On INDUCTIVE reduce production ident -> uident
-- On IN reduce production ident -> uident
-- On IMPORT reduce production ident -> uident
-- On GT reduce production ident -> uident
-- On GOAL reduce production ident -> uident
-- On FUNCTION reduce production ident -> uident
-- On FLOAT reduce production ident -> uident
-- On FALSE reduce production ident -> uident
-- On EXCEPTION reduce production ident -> uident
-- On EQUAL reduce production ident -> uident
-- On EOF reduce production ident -> uident
-- On ENSURES reduce production ident -> uident
-- On END reduce production ident -> uident
-- On ELSE reduce production ident -> uident
-- On DOWNTO reduce production ident -> uident
-- On DOTDOT reduce production ident -> uident
-- On DOT reduce production uqualid -> uqualid DOT uident
-- On DONE reduce production ident -> uident
-- On DO reduce production ident -> uident
-- On DIVERGES reduce production ident -> uident
-- On CORE_UIDENT reduce production ident -> uident
-- On CORE_LIDENT reduce production ident -> uident
-- On CONSTANT reduce production ident -> uident
-- On COMMA reduce production ident -> uident
-- On COLON reduce production ident -> uident
-- On COINDUCTIVE reduce production ident -> uident
-- On CLONE reduce production ident -> uident
-- On BY reduce production ident -> uident
-- On BEGIN reduce production ident -> uident
-- On BARBAR reduce production ident -> uident
-- On BAR reduce production ident -> uident
-- On AXIOM reduce production ident -> uident
-- On AT reduce production ident -> uident
-- On ARROW reduce production ident -> uident
-- On AND reduce production ident -> uident
-- On AMPAMP reduce production ident -> uident
-- On ALIAS reduce production ident -> uident

State 298:
## Known stack suffix:
## term_block_
## LR(1) items:
mk_term(term_block_) -> term_block_ . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production mk_term(term_block_) -> term_block_
-- On VAL reduce production mk_term(term_block_) -> term_block_
-- On USE reduce production mk_term(term_block_) -> term_block_
-- On UIDENT reduce production mk_term(term_block_) -> term_block_
-- On TYPE reduce production mk_term(term_block_) -> term_block_
-- On TRUE reduce production mk_term(term_block_) -> term_block_
-- On THEN reduce production mk_term(term_block_) -> term_block_
-- On SO reduce production mk_term(term_block_) -> term_block_
-- On SEMICOLON reduce production mk_term(term_block_) -> term_block_
-- On SCOPE reduce production mk_term(term_block_) -> term_block_
-- On RIGHTSQ_QUOTE reduce production mk_term(term_block_) -> term_block_
-- On RIGHTSQ reduce production mk_term(term_block_) -> term_block_
-- On RIGHTPAR reduce production mk_term(term_block_) -> term_block_
-- On RIGHTBRC reduce production mk_term(term_block_) -> term_block_
-- On REAL reduce production mk_term(term_block_) -> term_block_
-- On RANGE reduce production mk_term(term_block_) -> term_block_
-- On PREDICATE reduce production mk_term(term_block_) -> term_block_
-- On OR reduce production mk_term(term_block_) -> term_block_
-- On OPPREF reduce production mk_term(term_block_) -> term_block_
-- On OP4 reduce production mk_term(term_block_) -> term_block_
-- On OP3 reduce production mk_term(term_block_) -> term_block_
-- On OP2 reduce production mk_term(term_block_) -> term_block_
-- On OP1 reduce production mk_term(term_block_) -> term_block_
-- On MINUS reduce production mk_term(term_block_) -> term_block_
-- On META reduce production mk_term(term_block_) -> term_block_
-- On LTGT reduce production mk_term(term_block_) -> term_block_
-- On LT reduce production mk_term(term_block_) -> term_block_
-- On LRARROW reduce production mk_term(term_block_) -> term_block_
-- On LIDENT reduce production mk_term(term_block_) -> term_block_
-- On LET reduce production mk_term(term_block_) -> term_block_
-- On LEMMA reduce production mk_term(term_block_) -> term_block_
-- On LEFTSQ reduce production mk_term(term_block_) -> term_block_
-- On LEFTPAR reduce production mk_term(term_block_) -> term_block_
-- On LEFTBRC reduce production mk_term(term_block_) -> term_block_
-- On LARROW reduce production mk_term(term_block_) -> term_block_
-- On INTEGER reduce production mk_term(term_block_) -> term_block_
-- On INDUCTIVE reduce production mk_term(term_block_) -> term_block_
-- On IN reduce production mk_term(term_block_) -> term_block_
-- On IMPORT reduce production mk_term(term_block_) -> term_block_
-- On GT reduce production mk_term(term_block_) -> term_block_
-- On GOAL reduce production mk_term(term_block_) -> term_block_
-- On FUNCTION reduce production mk_term(term_block_) -> term_block_
-- On FLOAT reduce production mk_term(term_block_) -> term_block_
-- On FALSE reduce production mk_term(term_block_) -> term_block_
-- On EXCEPTION reduce production mk_term(term_block_) -> term_block_
-- On EQUAL reduce production mk_term(term_block_) -> term_block_
-- On EOF reduce production mk_term(term_block_) -> term_block_
-- On END reduce production mk_term(term_block_) -> term_block_
-- On ELSE reduce production mk_term(term_block_) -> term_block_
-- On DOTDOT reduce production mk_term(term_block_) -> term_block_
-- On DOT reduce production mk_term(term_block_) -> term_block_
-- On CORE_UIDENT reduce production mk_term(term_block_) -> term_block_
-- On CORE_LIDENT reduce production mk_term(term_block_) -> term_block_
-- On CONSTANT reduce production mk_term(term_block_) -> term_block_
-- On COMMA reduce production mk_term(term_block_) -> term_block_
-- On COLON reduce production mk_term(term_block_) -> term_block_
-- On COINDUCTIVE reduce production mk_term(term_block_) -> term_block_
-- On CLONE reduce production mk_term(term_block_) -> term_block_
-- On BY reduce production mk_term(term_block_) -> term_block_
-- On BEGIN reduce production mk_term(term_block_) -> term_block_
-- On BARBAR reduce production mk_term(term_block_) -> term_block_
-- On BAR reduce production mk_term(term_block_) -> term_block_
-- On AXIOM reduce production mk_term(term_block_) -> term_block_
-- On AT reduce production mk_term(term_block_) -> term_block_
-- On ARROW reduce production mk_term(term_block_) -> term_block_
-- On AND reduce production mk_term(term_block_) -> term_block_
-- On AMPAMP reduce production mk_term(term_block_) -> term_block_

State 299:
## Known stack suffix:
## uqualid DOT mk_term(term_block_)
## LR(1) items:
term_sub_ -> uqualid DOT mk_term(term_block_) . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On VAL reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On USE reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On UIDENT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On TYPE reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On TRUE reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On THEN reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On SO reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On SEMICOLON reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On SCOPE reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On RIGHTSQ_QUOTE reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On RIGHTSQ reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On RIGHTPAR reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On RIGHTBRC reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On REAL reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On RANGE reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On PREDICATE reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On OR reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On OPPREF reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On OP4 reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On OP3 reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On OP2 reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On OP1 reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On MINUS reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On META reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On LTGT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On LT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On LRARROW reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On LIDENT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On LET reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On LEMMA reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On LEFTSQ reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On LEFTPAR reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On LEFTBRC reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On LARROW reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On INTEGER reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On INDUCTIVE reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On IN reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On IMPORT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On GT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On GOAL reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On FUNCTION reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On FLOAT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On FALSE reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On EXCEPTION reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On EQUAL reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On EOF reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On END reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On ELSE reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On DOTDOT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On DOT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On CORE_UIDENT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On CORE_LIDENT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On CONSTANT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On COMMA reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On COLON reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On COINDUCTIVE reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On CLONE reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On BY reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On BEGIN reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On BARBAR reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On BAR reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On AXIOM reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On AT reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On ARROW reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On AND reduce production term_sub_ -> uqualid DOT mk_term(term_block_)
-- On AMPAMP reduce production term_sub_ -> uqualid DOT mk_term(term_block_)

State 300:
## Known stack suffix:
## uqualid DOT lident
## LR(1) items:
ident -> lident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
lqualid -> uqualid DOT lident . [ DOT ]
## Transitions:
## Reductions:
-- On WRITES reduce production ident -> lident
-- On WITH reduce production ident -> lident
-- On VARIANT reduce production ident -> lident
-- On VAL reduce production ident -> lident
-- On USE reduce production ident -> lident
-- On UIDENT reduce production ident -> lident
-- On TYPE reduce production ident -> lident
-- On TRUE reduce production ident -> lident
-- On TO reduce production ident -> lident
-- On THEN reduce production ident -> lident
-- On SO reduce production ident -> lident
-- On SEMICOLON reduce production ident -> lident
-- On SCOPE reduce production ident -> lident
-- On RIGHTSQ_QUOTE reduce production ident -> lident
-- On RIGHTSQ reduce production ident -> lident
-- On RIGHTPAR reduce production ident -> lident
-- On RIGHTBRC reduce production ident -> lident
-- On RETURNS reduce production ident -> lident
-- On REQUIRES reduce production ident -> lident
-- On REAL reduce production ident -> lident
-- On READS reduce production ident -> lident
-- On RANGE reduce production ident -> lident
-- On RAISES reduce production ident -> lident
-- On PURE reduce production ident -> lident
-- On PREDICATE reduce production ident -> lident
-- On OR reduce production ident -> lident
-- On OPPREF reduce production ident -> lident
-- On OP4 reduce production ident -> lident
-- On OP3 reduce production ident -> lident
-- On OP2 reduce production ident -> lident
-- On OP1 reduce production ident -> lident
-- On MINUS reduce production ident -> lident
-- On META reduce production ident -> lident
-- On LTGT reduce production ident -> lident
-- On LT reduce production ident -> lident
-- On LRARROW reduce production ident -> lident
-- On LIDENT reduce production ident -> lident
-- On LET reduce production ident -> lident
-- On LEMMA reduce production ident -> lident
-- On LEFTSQ reduce production ident -> lident
-- On LEFTPAR reduce production ident -> lident
-- On LEFTBRC reduce production ident -> lident
-- On LARROW reduce production ident -> lident
-- On INTEGER reduce production ident -> lident
-- On INDUCTIVE reduce production ident -> lident
-- On IN reduce production ident -> lident
-- On IMPORT reduce production ident -> lident
-- On GT reduce production ident -> lident
-- On GOAL reduce production ident -> lident
-- On FUNCTION reduce production ident -> lident
-- On FLOAT reduce production ident -> lident
-- On FALSE reduce production ident -> lident
-- On EXCEPTION reduce production ident -> lident
-- On EQUAL reduce production ident -> lident
-- On EOF reduce production ident -> lident
-- On ENSURES reduce production ident -> lident
-- On END reduce production ident -> lident
-- On ELSE reduce production ident -> lident
-- On DOWNTO reduce production ident -> lident
-- On DOTDOT reduce production ident -> lident
-- On DOT reduce production lqualid -> uqualid DOT lident
-- On DONE reduce production ident -> lident
-- On DO reduce production ident -> lident
-- On DIVERGES reduce production ident -> lident
-- On CORE_UIDENT reduce production ident -> lident
-- On CORE_LIDENT reduce production ident -> lident
-- On CONSTANT reduce production ident -> lident
-- On COMMA reduce production ident -> lident
-- On COLON reduce production ident -> lident
-- On COINDUCTIVE reduce production ident -> lident
-- On CLONE reduce production ident -> lident
-- On BY reduce production ident -> lident
-- On BEGIN reduce production ident -> lident
-- On BARBAR reduce production ident -> lident
-- On BAR reduce production ident -> lident
-- On AXIOM reduce production ident -> lident
-- On AT reduce production ident -> lident
-- On ARROW reduce production ident -> lident
-- On AND reduce production ident -> lident
-- On AMPAMP reduce production ident -> lident
-- On ALIAS reduce production ident -> lident

State 301:
## Known stack suffix:
## uqualid DOT ident
## LR(1) items:
qualid -> uqualid DOT ident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production qualid -> uqualid DOT ident
-- On WITH reduce production qualid -> uqualid DOT ident
-- On VARIANT reduce production qualid -> uqualid DOT ident
-- On VAL reduce production qualid -> uqualid DOT ident
-- On USE reduce production qualid -> uqualid DOT ident
-- On UIDENT reduce production qualid -> uqualid DOT ident
-- On TYPE reduce production qualid -> uqualid DOT ident
-- On TRUE reduce production qualid -> uqualid DOT ident
-- On TO reduce production qualid -> uqualid DOT ident
-- On THEN reduce production qualid -> uqualid DOT ident
-- On SO reduce production qualid -> uqualid DOT ident
-- On SEMICOLON reduce production qualid -> uqualid DOT ident
-- On SCOPE reduce production qualid -> uqualid DOT ident
-- On RIGHTSQ_QUOTE reduce production qualid -> uqualid DOT ident
-- On RIGHTSQ reduce production qualid -> uqualid DOT ident
-- On RIGHTPAR reduce production qualid -> uqualid DOT ident
-- On RIGHTBRC reduce production qualid -> uqualid DOT ident
-- On RETURNS reduce production qualid -> uqualid DOT ident
-- On REQUIRES reduce production qualid -> uqualid DOT ident
-- On REAL reduce production qualid -> uqualid DOT ident
-- On READS reduce production qualid -> uqualid DOT ident
-- On RANGE reduce production qualid -> uqualid DOT ident
-- On RAISES reduce production qualid -> uqualid DOT ident
-- On QUOTE_LIDENT reduce production qualid -> uqualid DOT ident
-- On PURE reduce production qualid -> uqualid DOT ident
-- On PREDICATE reduce production qualid -> uqualid DOT ident
-- On OR reduce production qualid -> uqualid DOT ident
-- On OPPREF reduce production qualid -> uqualid DOT ident
-- On OP4 reduce production qualid -> uqualid DOT ident
-- On OP3 reduce production qualid -> uqualid DOT ident
-- On OP2 reduce production qualid -> uqualid DOT ident
-- On OP1 reduce production qualid -> uqualid DOT ident
-- On MINUS reduce production qualid -> uqualid DOT ident
-- On META reduce production qualid -> uqualid DOT ident
-- On LTGT reduce production qualid -> uqualid DOT ident
-- On LT reduce production qualid -> uqualid DOT ident
-- On LRARROW reduce production qualid -> uqualid DOT ident
-- On LIDENT reduce production qualid -> uqualid DOT ident
-- On LET reduce production qualid -> uqualid DOT ident
-- On LEMMA reduce production qualid -> uqualid DOT ident
-- On LEFTSQ reduce production qualid -> uqualid DOT ident
-- On LEFTPAR reduce production qualid -> uqualid DOT ident
-- On LEFTBRC reduce production qualid -> uqualid DOT ident
-- On LARROW reduce production qualid -> uqualid DOT ident
-- On INTEGER reduce production qualid -> uqualid DOT ident
-- On INDUCTIVE reduce production qualid -> uqualid DOT ident
-- On IN reduce production qualid -> uqualid DOT ident
-- On IMPORT reduce production qualid -> uqualid DOT ident
-- On GT reduce production qualid -> uqualid DOT ident
-- On GOAL reduce production qualid -> uqualid DOT ident
-- On FUNCTION reduce production qualid -> uqualid DOT ident
-- On FLOAT reduce production qualid -> uqualid DOT ident
-- On FALSE reduce production qualid -> uqualid DOT ident
-- On EXCEPTION reduce production qualid -> uqualid DOT ident
-- On EQUAL reduce production qualid -> uqualid DOT ident
-- On EOF reduce production qualid -> uqualid DOT ident
-- On ENSURES reduce production qualid -> uqualid DOT ident
-- On END reduce production qualid -> uqualid DOT ident
-- On ELSE reduce production qualid -> uqualid DOT ident
-- On DOWNTO reduce production qualid -> uqualid DOT ident
-- On DOTDOT reduce production qualid -> uqualid DOT ident
-- On DONE reduce production qualid -> uqualid DOT ident
-- On DO reduce production qualid -> uqualid DOT ident
-- On DIVERGES reduce production qualid -> uqualid DOT ident
-- On CORE_UIDENT reduce production qualid -> uqualid DOT ident
-- On CORE_LIDENT reduce production qualid -> uqualid DOT ident
-- On CONSTANT reduce production qualid -> uqualid DOT ident
-- On COMMA reduce production qualid -> uqualid DOT ident
-- On COLON reduce production qualid -> uqualid DOT ident
-- On COINDUCTIVE reduce production qualid -> uqualid DOT ident
-- On CLONE reduce production qualid -> uqualid DOT ident
-- On BY reduce production qualid -> uqualid DOT ident
-- On BEGIN reduce production qualid -> uqualid DOT ident
-- On BARBAR reduce production qualid -> uqualid DOT ident
-- On BAR reduce production qualid -> uqualid DOT ident
-- On AXIOM reduce production qualid -> uqualid DOT ident
-- On AT reduce production qualid -> uqualid DOT ident
-- On ARROW reduce production qualid -> uqualid DOT ident
-- On AND reduce production qualid -> uqualid DOT ident
-- On AMPAMP reduce production qualid -> uqualid DOT ident
-- On ALIAS reduce production qualid -> uqualid DOT ident

State 302:
## Known stack suffix:
## uident
## LR(1) items:
ident -> uident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
uqualid -> uident . [ DOT ]
## Transitions:
## Reductions:
-- On WRITES reduce production ident -> uident
-- On WITH reduce production ident -> uident
-- On VARIANT reduce production ident -> uident
-- On VAL reduce production ident -> uident
-- On USE reduce production ident -> uident
-- On UIDENT reduce production ident -> uident
-- On TYPE reduce production ident -> uident
-- On TRUE reduce production ident -> uident
-- On TO reduce production ident -> uident
-- On THEN reduce production ident -> uident
-- On SO reduce production ident -> uident
-- On SEMICOLON reduce production ident -> uident
-- On SCOPE reduce production ident -> uident
-- On RIGHTSQ_QUOTE reduce production ident -> uident
-- On RIGHTSQ reduce production ident -> uident
-- On RIGHTPAR reduce production ident -> uident
-- On RIGHTBRC reduce production ident -> uident
-- On RETURNS reduce production ident -> uident
-- On REQUIRES reduce production ident -> uident
-- On REAL reduce production ident -> uident
-- On READS reduce production ident -> uident
-- On RANGE reduce production ident -> uident
-- On RAISES reduce production ident -> uident
-- On QUOTE_LIDENT reduce production ident -> uident
-- On PURE reduce production ident -> uident
-- On PREDICATE reduce production ident -> uident
-- On OR reduce production ident -> uident
-- On OPPREF reduce production ident -> uident
-- On OP4 reduce production ident -> uident
-- On OP3 reduce production ident -> uident
-- On OP2 reduce production ident -> uident
-- On OP1 reduce production ident -> uident
-- On MINUS reduce production ident -> uident
-- On META reduce production ident -> uident
-- On LTGT reduce production ident -> uident
-- On LT reduce production ident -> uident
-- On LRARROW reduce production ident -> uident
-- On LIDENT reduce production ident -> uident
-- On LET reduce production ident -> uident
-- On LEMMA reduce production ident -> uident
-- On LEFTSQ reduce production ident -> uident
-- On LEFTPAR reduce production ident -> uident
-- On LEFTBRC reduce production ident -> uident
-- On LARROW reduce production ident -> uident
-- On INTEGER reduce production ident -> uident
-- On INDUCTIVE reduce production ident -> uident
-- On IN reduce production ident -> uident
-- On IMPORT reduce production ident -> uident
-- On GT reduce production ident -> uident
-- On GOAL reduce production ident -> uident
-- On FUNCTION reduce production ident -> uident
-- On FLOAT reduce production ident -> uident
-- On FALSE reduce production ident -> uident
-- On EXCEPTION reduce production ident -> uident
-- On EQUAL reduce production ident -> uident
-- On EOF reduce production ident -> uident
-- On ENSURES reduce production ident -> uident
-- On END reduce production ident -> uident
-- On ELSE reduce production ident -> uident
-- On DOWNTO reduce production ident -> uident
-- On DOTDOT reduce production ident -> uident
-- On DOT reduce production uqualid -> uident
-- On DONE reduce production ident -> uident
-- On DO reduce production ident -> uident
-- On DIVERGES reduce production ident -> uident
-- On CORE_UIDENT reduce production ident -> uident
-- On CORE_LIDENT reduce production ident -> uident
-- On CONSTANT reduce production ident -> uident
-- On COMMA reduce production ident -> uident
-- On COLON reduce production ident -> uident
-- On COINDUCTIVE reduce production ident -> uident
-- On CLONE reduce production ident -> uident
-- On BY reduce production ident -> uident
-- On BEGIN reduce production ident -> uident
-- On BARBAR reduce production ident -> uident
-- On BAR reduce production ident -> uident
-- On AXIOM reduce production ident -> uident
-- On AT reduce production ident -> uident
-- On ARROW reduce production ident -> uident
-- On AND reduce production ident -> uident
-- On AMPAMP reduce production ident -> uident
-- On ALIAS reduce production ident -> uident

State 303:
## Known stack suffix:
## term_sub_
## LR(1) items:
term_arg_ -> term_sub_ . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_dot_ -> term_sub_ . [ DOT ]
## Transitions:
## Reductions:
-- On WITH reduce production term_arg_ -> term_sub_
-- On VAL reduce production term_arg_ -> term_sub_
-- On USE reduce production term_arg_ -> term_sub_
-- On UIDENT reduce production term_arg_ -> term_sub_
-- On TYPE reduce production term_arg_ -> term_sub_
-- On TRUE reduce production term_arg_ -> term_sub_
-- On THEN reduce production term_arg_ -> term_sub_
-- On SO reduce production term_arg_ -> term_sub_
-- On SEMICOLON reduce production term_arg_ -> term_sub_
-- On SCOPE reduce production term_arg_ -> term_sub_
-- On RIGHTSQ_QUOTE reduce production term_arg_ -> term_sub_
-- On RIGHTSQ reduce production term_arg_ -> term_sub_
-- On RIGHTPAR reduce production term_arg_ -> term_sub_
-- On RIGHTBRC reduce production term_arg_ -> term_sub_
-- On REAL reduce production term_arg_ -> term_sub_
-- On RANGE reduce production term_arg_ -> term_sub_
-- On PREDICATE reduce production term_arg_ -> term_sub_
-- On OR reduce production term_arg_ -> term_sub_
-- On OPPREF reduce production term_arg_ -> term_sub_
-- On OP4 reduce production term_arg_ -> term_sub_
-- On OP3 reduce production term_arg_ -> term_sub_
-- On OP2 reduce production term_arg_ -> term_sub_
-- On OP1 reduce production term_arg_ -> term_sub_
-- On MINUS reduce production term_arg_ -> term_sub_
-- On META reduce production term_arg_ -> term_sub_
-- On LTGT reduce production term_arg_ -> term_sub_
-- On LT reduce production term_arg_ -> term_sub_
-- On LRARROW reduce production term_arg_ -> term_sub_
-- On LIDENT reduce production term_arg_ -> term_sub_
-- On LET reduce production term_arg_ -> term_sub_
-- On LEMMA reduce production term_arg_ -> term_sub_
-- On LEFTSQ reduce production term_arg_ -> term_sub_
-- On LEFTPAR reduce production term_arg_ -> term_sub_
-- On LEFTBRC reduce production term_arg_ -> term_sub_
-- On LARROW reduce production term_arg_ -> term_sub_
-- On INTEGER reduce production term_arg_ -> term_sub_
-- On INDUCTIVE reduce production term_arg_ -> term_sub_
-- On IN reduce production term_arg_ -> term_sub_
-- On IMPORT reduce production term_arg_ -> term_sub_
-- On GT reduce production term_arg_ -> term_sub_
-- On GOAL reduce production term_arg_ -> term_sub_
-- On FUNCTION reduce production term_arg_ -> term_sub_
-- On FLOAT reduce production term_arg_ -> term_sub_
-- On FALSE reduce production term_arg_ -> term_sub_
-- On EXCEPTION reduce production term_arg_ -> term_sub_
-- On EQUAL reduce production term_arg_ -> term_sub_
-- On EOF reduce production term_arg_ -> term_sub_
-- On END reduce production term_arg_ -> term_sub_
-- On ELSE reduce production term_arg_ -> term_sub_
-- On DOTDOT reduce production term_arg_ -> term_sub_
-- On DOT reduce production term_dot_ -> term_sub_
-- On CORE_UIDENT reduce production term_arg_ -> term_sub_
-- On CORE_LIDENT reduce production term_arg_ -> term_sub_
-- On CONSTANT reduce production term_arg_ -> term_sub_
-- On COMMA reduce production term_arg_ -> term_sub_
-- On COLON reduce production term_arg_ -> term_sub_
-- On COINDUCTIVE reduce production term_arg_ -> term_sub_
-- On CLONE reduce production term_arg_ -> term_sub_
-- On BY reduce production term_arg_ -> term_sub_
-- On BEGIN reduce production term_arg_ -> term_sub_
-- On BARBAR reduce production term_arg_ -> term_sub_
-- On BAR reduce production term_arg_ -> term_sub_
-- On AXIOM reduce production term_arg_ -> term_sub_
-- On AT reduce production term_arg_ -> term_sub_
-- On ARROW reduce production term_arg_ -> term_sub_
-- On AND reduce production term_arg_ -> term_sub_
-- On AMPAMP reduce production term_arg_ -> term_sub_

State 304:
## Known stack suffix:
## term_dot_
## LR(1) items:
mk_term(term_dot_) -> term_dot_ . [ DOT ]
## Transitions:
## Reductions:
-- On DOT reduce production mk_term(term_dot_) -> term_dot_

State 305:
## Known stack suffix:
## term_dot
## LR(1) items:
term_sub_ -> term_dot . DOT lqualid_rich [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On DOT shift to state 306
## Reductions:

State 306:
## Known stack suffix:
## term_dot DOT
## LR(1) items:
term_sub_ -> term_dot DOT . lqualid_rich [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 307
-- On uident shift to state 89
-- On lqualid_rich shift to state 311
-- On lident_op shift to state 312
-- On lident_keyword shift to state 43
-- On lident shift to state 313
## Reductions:

State 307:
## Known stack suffix:
## uqualid
## LR(1) items:
lqualid_rich -> uqualid . DOT lident [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
lqualid_rich -> uqualid . DOT lident_op [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 308
## Reductions:

State 308:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
lqualid_rich -> uqualid DOT . lident [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
lqualid_rich -> uqualid DOT . lident_op [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 86
-- On lident_op shift to state 309
-- On lident_keyword shift to state 43
-- On lident shift to state 310
## Reductions:

State 309:
## Known stack suffix:
## uqualid DOT lident_op
## LR(1) items:
lqualid_rich -> uqualid DOT lident_op . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lqualid_rich -> uqualid DOT lident_op
-- On WITH reduce production lqualid_rich -> uqualid DOT lident_op
-- On VARIANT reduce production lqualid_rich -> uqualid DOT lident_op
-- On VAL reduce production lqualid_rich -> uqualid DOT lident_op
-- On USE reduce production lqualid_rich -> uqualid DOT lident_op
-- On UIDENT reduce production lqualid_rich -> uqualid DOT lident_op
-- On TYPE reduce production lqualid_rich -> uqualid DOT lident_op
-- On TRUE reduce production lqualid_rich -> uqualid DOT lident_op
-- On TO reduce production lqualid_rich -> uqualid DOT lident_op
-- On THEN reduce production lqualid_rich -> uqualid DOT lident_op
-- On SO reduce production lqualid_rich -> uqualid DOT lident_op
-- On SEMICOLON reduce production lqualid_rich -> uqualid DOT lident_op
-- On SCOPE reduce production lqualid_rich -> uqualid DOT lident_op
-- On RIGHTSQ_QUOTE reduce production lqualid_rich -> uqualid DOT lident_op
-- On RIGHTSQ reduce production lqualid_rich -> uqualid DOT lident_op
-- On RIGHTPAR reduce production lqualid_rich -> uqualid DOT lident_op
-- On RIGHTBRC reduce production lqualid_rich -> uqualid DOT lident_op
-- On RETURNS reduce production lqualid_rich -> uqualid DOT lident_op
-- On REQUIRES reduce production lqualid_rich -> uqualid DOT lident_op
-- On REAL reduce production lqualid_rich -> uqualid DOT lident_op
-- On READS reduce production lqualid_rich -> uqualid DOT lident_op
-- On RANGE reduce production lqualid_rich -> uqualid DOT lident_op
-- On RAISES reduce production lqualid_rich -> uqualid DOT lident_op
-- On PURE reduce production lqualid_rich -> uqualid DOT lident_op
-- On PREDICATE reduce production lqualid_rich -> uqualid DOT lident_op
-- On OR reduce production lqualid_rich -> uqualid DOT lident_op
-- On OPPREF reduce production lqualid_rich -> uqualid DOT lident_op
-- On OP4 reduce production lqualid_rich -> uqualid DOT lident_op
-- On OP3 reduce production lqualid_rich -> uqualid DOT lident_op
-- On OP2 reduce production lqualid_rich -> uqualid DOT lident_op
-- On OP1 reduce production lqualid_rich -> uqualid DOT lident_op
-- On MINUS reduce production lqualid_rich -> uqualid DOT lident_op
-- On META reduce production lqualid_rich -> uqualid DOT lident_op
-- On LTGT reduce production lqualid_rich -> uqualid DOT lident_op
-- On LT reduce production lqualid_rich -> uqualid DOT lident_op
-- On LRARROW reduce production lqualid_rich -> uqualid DOT lident_op
-- On LIDENT reduce production lqualid_rich -> uqualid DOT lident_op
-- On LET reduce production lqualid_rich -> uqualid DOT lident_op
-- On LEMMA reduce production lqualid_rich -> uqualid DOT lident_op
-- On LEFTSQ reduce production lqualid_rich -> uqualid DOT lident_op
-- On LEFTPAR reduce production lqualid_rich -> uqualid DOT lident_op
-- On LEFTBRC reduce production lqualid_rich -> uqualid DOT lident_op
-- On LARROW reduce production lqualid_rich -> uqualid DOT lident_op
-- On INTEGER reduce production lqualid_rich -> uqualid DOT lident_op
-- On INDUCTIVE reduce production lqualid_rich -> uqualid DOT lident_op
-- On IN reduce production lqualid_rich -> uqualid DOT lident_op
-- On IMPORT reduce production lqualid_rich -> uqualid DOT lident_op
-- On GT reduce production lqualid_rich -> uqualid DOT lident_op
-- On GOAL reduce production lqualid_rich -> uqualid DOT lident_op
-- On FUNCTION reduce production lqualid_rich -> uqualid DOT lident_op
-- On FLOAT reduce production lqualid_rich -> uqualid DOT lident_op
-- On FALSE reduce production lqualid_rich -> uqualid DOT lident_op
-- On EXCEPTION reduce production lqualid_rich -> uqualid DOT lident_op
-- On EQUAL reduce production lqualid_rich -> uqualid DOT lident_op
-- On EOF reduce production lqualid_rich -> uqualid DOT lident_op
-- On ENSURES reduce production lqualid_rich -> uqualid DOT lident_op
-- On END reduce production lqualid_rich -> uqualid DOT lident_op
-- On ELSE reduce production lqualid_rich -> uqualid DOT lident_op
-- On DOWNTO reduce production lqualid_rich -> uqualid DOT lident_op
-- On DOTDOT reduce production lqualid_rich -> uqualid DOT lident_op
-- On DOT reduce production lqualid_rich -> uqualid DOT lident_op
-- On DONE reduce production lqualid_rich -> uqualid DOT lident_op
-- On DO reduce production lqualid_rich -> uqualid DOT lident_op
-- On DIVERGES reduce production lqualid_rich -> uqualid DOT lident_op
-- On CORE_UIDENT reduce production lqualid_rich -> uqualid DOT lident_op
-- On CORE_LIDENT reduce production lqualid_rich -> uqualid DOT lident_op
-- On CONSTANT reduce production lqualid_rich -> uqualid DOT lident_op
-- On COMMA reduce production lqualid_rich -> uqualid DOT lident_op
-- On COLON reduce production lqualid_rich -> uqualid DOT lident_op
-- On COINDUCTIVE reduce production lqualid_rich -> uqualid DOT lident_op
-- On CLONE reduce production lqualid_rich -> uqualid DOT lident_op
-- On BY reduce production lqualid_rich -> uqualid DOT lident_op
-- On BEGIN reduce production lqualid_rich -> uqualid DOT lident_op
-- On BARBAR reduce production lqualid_rich -> uqualid DOT lident_op
-- On BAR reduce production lqualid_rich -> uqualid DOT lident_op
-- On AXIOM reduce production lqualid_rich -> uqualid DOT lident_op
-- On AT reduce production lqualid_rich -> uqualid DOT lident_op
-- On ARROW reduce production lqualid_rich -> uqualid DOT lident_op
-- On AND reduce production lqualid_rich -> uqualid DOT lident_op
-- On AMPAMP reduce production lqualid_rich -> uqualid DOT lident_op
-- On ALIAS reduce production lqualid_rich -> uqualid DOT lident_op

State 310:
## Known stack suffix:
## uqualid DOT lident
## LR(1) items:
lqualid_rich -> uqualid DOT lident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lqualid_rich -> uqualid DOT lident
-- On WITH reduce production lqualid_rich -> uqualid DOT lident
-- On VARIANT reduce production lqualid_rich -> uqualid DOT lident
-- On VAL reduce production lqualid_rich -> uqualid DOT lident
-- On USE reduce production lqualid_rich -> uqualid DOT lident
-- On UIDENT reduce production lqualid_rich -> uqualid DOT lident
-- On TYPE reduce production lqualid_rich -> uqualid DOT lident
-- On TRUE reduce production lqualid_rich -> uqualid DOT lident
-- On TO reduce production lqualid_rich -> uqualid DOT lident
-- On THEN reduce production lqualid_rich -> uqualid DOT lident
-- On SO reduce production lqualid_rich -> uqualid DOT lident
-- On SEMICOLON reduce production lqualid_rich -> uqualid DOT lident
-- On SCOPE reduce production lqualid_rich -> uqualid DOT lident
-- On RIGHTSQ_QUOTE reduce production lqualid_rich -> uqualid DOT lident
-- On RIGHTSQ reduce production lqualid_rich -> uqualid DOT lident
-- On RIGHTPAR reduce production lqualid_rich -> uqualid DOT lident
-- On RIGHTBRC reduce production lqualid_rich -> uqualid DOT lident
-- On RETURNS reduce production lqualid_rich -> uqualid DOT lident
-- On REQUIRES reduce production lqualid_rich -> uqualid DOT lident
-- On REAL reduce production lqualid_rich -> uqualid DOT lident
-- On READS reduce production lqualid_rich -> uqualid DOT lident
-- On RANGE reduce production lqualid_rich -> uqualid DOT lident
-- On RAISES reduce production lqualid_rich -> uqualid DOT lident
-- On PURE reduce production lqualid_rich -> uqualid DOT lident
-- On PREDICATE reduce production lqualid_rich -> uqualid DOT lident
-- On OR reduce production lqualid_rich -> uqualid DOT lident
-- On OPPREF reduce production lqualid_rich -> uqualid DOT lident
-- On OP4 reduce production lqualid_rich -> uqualid DOT lident
-- On OP3 reduce production lqualid_rich -> uqualid DOT lident
-- On OP2 reduce production lqualid_rich -> uqualid DOT lident
-- On OP1 reduce production lqualid_rich -> uqualid DOT lident
-- On MINUS reduce production lqualid_rich -> uqualid DOT lident
-- On META reduce production lqualid_rich -> uqualid DOT lident
-- On LTGT reduce production lqualid_rich -> uqualid DOT lident
-- On LT reduce production lqualid_rich -> uqualid DOT lident
-- On LRARROW reduce production lqualid_rich -> uqualid DOT lident
-- On LIDENT reduce production lqualid_rich -> uqualid DOT lident
-- On LET reduce production lqualid_rich -> uqualid DOT lident
-- On LEMMA reduce production lqualid_rich -> uqualid DOT lident
-- On LEFTSQ reduce production lqualid_rich -> uqualid DOT lident
-- On LEFTPAR reduce production lqualid_rich -> uqualid DOT lident
-- On LEFTBRC reduce production lqualid_rich -> uqualid DOT lident
-- On LARROW reduce production lqualid_rich -> uqualid DOT lident
-- On INTEGER reduce production lqualid_rich -> uqualid DOT lident
-- On INDUCTIVE reduce production lqualid_rich -> uqualid DOT lident
-- On IN reduce production lqualid_rich -> uqualid DOT lident
-- On IMPORT reduce production lqualid_rich -> uqualid DOT lident
-- On GT reduce production lqualid_rich -> uqualid DOT lident
-- On GOAL reduce production lqualid_rich -> uqualid DOT lident
-- On FUNCTION reduce production lqualid_rich -> uqualid DOT lident
-- On FLOAT reduce production lqualid_rich -> uqualid DOT lident
-- On FALSE reduce production lqualid_rich -> uqualid DOT lident
-- On EXCEPTION reduce production lqualid_rich -> uqualid DOT lident
-- On EQUAL reduce production lqualid_rich -> uqualid DOT lident
-- On EOF reduce production lqualid_rich -> uqualid DOT lident
-- On ENSURES reduce production lqualid_rich -> uqualid DOT lident
-- On END reduce production lqualid_rich -> uqualid DOT lident
-- On ELSE reduce production lqualid_rich -> uqualid DOT lident
-- On DOWNTO reduce production lqualid_rich -> uqualid DOT lident
-- On DOTDOT reduce production lqualid_rich -> uqualid DOT lident
-- On DOT reduce production lqualid_rich -> uqualid DOT lident
-- On DONE reduce production lqualid_rich -> uqualid DOT lident
-- On DO reduce production lqualid_rich -> uqualid DOT lident
-- On DIVERGES reduce production lqualid_rich -> uqualid DOT lident
-- On CORE_UIDENT reduce production lqualid_rich -> uqualid DOT lident
-- On CORE_LIDENT reduce production lqualid_rich -> uqualid DOT lident
-- On CONSTANT reduce production lqualid_rich -> uqualid DOT lident
-- On COMMA reduce production lqualid_rich -> uqualid DOT lident
-- On COLON reduce production lqualid_rich -> uqualid DOT lident
-- On COINDUCTIVE reduce production lqualid_rich -> uqualid DOT lident
-- On CLONE reduce production lqualid_rich -> uqualid DOT lident
-- On BY reduce production lqualid_rich -> uqualid DOT lident
-- On BEGIN reduce production lqualid_rich -> uqualid DOT lident
-- On BARBAR reduce production lqualid_rich -> uqualid DOT lident
-- On BAR reduce production lqualid_rich -> uqualid DOT lident
-- On AXIOM reduce production lqualid_rich -> uqualid DOT lident
-- On AT reduce production lqualid_rich -> uqualid DOT lident
-- On ARROW reduce production lqualid_rich -> uqualid DOT lident
-- On AND reduce production lqualid_rich -> uqualid DOT lident
-- On AMPAMP reduce production lqualid_rich -> uqualid DOT lident
-- On ALIAS reduce production lqualid_rich -> uqualid DOT lident

State 311:
## Known stack suffix:
## term_dot DOT lqualid_rich
## LR(1) items:
term_sub_ -> term_dot DOT lqualid_rich . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On VAL reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On USE reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On UIDENT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On TYPE reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On TRUE reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On THEN reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On SO reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On SEMICOLON reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On SCOPE reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On RIGHTSQ_QUOTE reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On RIGHTSQ reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On RIGHTPAR reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On RIGHTBRC reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On REAL reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On RANGE reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On PREDICATE reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On OR reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On OPPREF reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On OP4 reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On OP3 reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On OP2 reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On OP1 reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On MINUS reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On META reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On LTGT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On LT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On LRARROW reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On LIDENT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On LET reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On LEMMA reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On LEFTSQ reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On LEFTPAR reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On LEFTBRC reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On LARROW reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On INTEGER reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On INDUCTIVE reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On IN reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On IMPORT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On GT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On GOAL reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On FUNCTION reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On FLOAT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On FALSE reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On EXCEPTION reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On EQUAL reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On EOF reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On END reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On ELSE reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On DOTDOT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On DOT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On CORE_UIDENT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On CORE_LIDENT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On CONSTANT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On COMMA reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On COLON reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On COINDUCTIVE reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On CLONE reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On BY reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On BEGIN reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On BARBAR reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On BAR reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On AXIOM reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On AT reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On ARROW reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On AND reduce production term_sub_ -> term_dot DOT lqualid_rich
-- On AMPAMP reduce production term_sub_ -> term_dot DOT lqualid_rich

State 312:
## Known stack suffix:
## lident_op
## LR(1) items:
lqualid_rich -> lident_op . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lqualid_rich -> lident_op
-- On WITH reduce production lqualid_rich -> lident_op
-- On VARIANT reduce production lqualid_rich -> lident_op
-- On VAL reduce production lqualid_rich -> lident_op
-- On USE reduce production lqualid_rich -> lident_op
-- On UIDENT reduce production lqualid_rich -> lident_op
-- On TYPE reduce production lqualid_rich -> lident_op
-- On TRUE reduce production lqualid_rich -> lident_op
-- On TO reduce production lqualid_rich -> lident_op
-- On THEN reduce production lqualid_rich -> lident_op
-- On SO reduce production lqualid_rich -> lident_op
-- On SEMICOLON reduce production lqualid_rich -> lident_op
-- On SCOPE reduce production lqualid_rich -> lident_op
-- On RIGHTSQ_QUOTE reduce production lqualid_rich -> lident_op
-- On RIGHTSQ reduce production lqualid_rich -> lident_op
-- On RIGHTPAR reduce production lqualid_rich -> lident_op
-- On RIGHTBRC reduce production lqualid_rich -> lident_op
-- On RETURNS reduce production lqualid_rich -> lident_op
-- On REQUIRES reduce production lqualid_rich -> lident_op
-- On REAL reduce production lqualid_rich -> lident_op
-- On READS reduce production lqualid_rich -> lident_op
-- On RANGE reduce production lqualid_rich -> lident_op
-- On RAISES reduce production lqualid_rich -> lident_op
-- On PURE reduce production lqualid_rich -> lident_op
-- On PREDICATE reduce production lqualid_rich -> lident_op
-- On OR reduce production lqualid_rich -> lident_op
-- On OPPREF reduce production lqualid_rich -> lident_op
-- On OP4 reduce production lqualid_rich -> lident_op
-- On OP3 reduce production lqualid_rich -> lident_op
-- On OP2 reduce production lqualid_rich -> lident_op
-- On OP1 reduce production lqualid_rich -> lident_op
-- On MINUS reduce production lqualid_rich -> lident_op
-- On META reduce production lqualid_rich -> lident_op
-- On LTGT reduce production lqualid_rich -> lident_op
-- On LT reduce production lqualid_rich -> lident_op
-- On LRARROW reduce production lqualid_rich -> lident_op
-- On LIDENT reduce production lqualid_rich -> lident_op
-- On LET reduce production lqualid_rich -> lident_op
-- On LEMMA reduce production lqualid_rich -> lident_op
-- On LEFTSQ reduce production lqualid_rich -> lident_op
-- On LEFTPAR reduce production lqualid_rich -> lident_op
-- On LEFTBRC reduce production lqualid_rich -> lident_op
-- On LARROW reduce production lqualid_rich -> lident_op
-- On INTEGER reduce production lqualid_rich -> lident_op
-- On INDUCTIVE reduce production lqualid_rich -> lident_op
-- On IN reduce production lqualid_rich -> lident_op
-- On IMPORT reduce production lqualid_rich -> lident_op
-- On GT reduce production lqualid_rich -> lident_op
-- On GOAL reduce production lqualid_rich -> lident_op
-- On FUNCTION reduce production lqualid_rich -> lident_op
-- On FLOAT reduce production lqualid_rich -> lident_op
-- On FALSE reduce production lqualid_rich -> lident_op
-- On EXCEPTION reduce production lqualid_rich -> lident_op
-- On EQUAL reduce production lqualid_rich -> lident_op
-- On EOF reduce production lqualid_rich -> lident_op
-- On ENSURES reduce production lqualid_rich -> lident_op
-- On END reduce production lqualid_rich -> lident_op
-- On ELSE reduce production lqualid_rich -> lident_op
-- On DOWNTO reduce production lqualid_rich -> lident_op
-- On DOTDOT reduce production lqualid_rich -> lident_op
-- On DOT reduce production lqualid_rich -> lident_op
-- On DONE reduce production lqualid_rich -> lident_op
-- On DO reduce production lqualid_rich -> lident_op
-- On DIVERGES reduce production lqualid_rich -> lident_op
-- On CORE_UIDENT reduce production lqualid_rich -> lident_op
-- On CORE_LIDENT reduce production lqualid_rich -> lident_op
-- On CONSTANT reduce production lqualid_rich -> lident_op
-- On COMMA reduce production lqualid_rich -> lident_op
-- On COLON reduce production lqualid_rich -> lident_op
-- On COINDUCTIVE reduce production lqualid_rich -> lident_op
-- On CLONE reduce production lqualid_rich -> lident_op
-- On BY reduce production lqualid_rich -> lident_op
-- On BEGIN reduce production lqualid_rich -> lident_op
-- On BARBAR reduce production lqualid_rich -> lident_op
-- On BAR reduce production lqualid_rich -> lident_op
-- On AXIOM reduce production lqualid_rich -> lident_op
-- On AT reduce production lqualid_rich -> lident_op
-- On ARROW reduce production lqualid_rich -> lident_op
-- On AND reduce production lqualid_rich -> lident_op
-- On AMPAMP reduce production lqualid_rich -> lident_op
-- On ALIAS reduce production lqualid_rich -> lident_op

State 313:
## Known stack suffix:
## lident
## LR(1) items:
lqualid_rich -> lident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production lqualid_rich -> lident
-- On WITH reduce production lqualid_rich -> lident
-- On VARIANT reduce production lqualid_rich -> lident
-- On VAL reduce production lqualid_rich -> lident
-- On USE reduce production lqualid_rich -> lident
-- On UIDENT reduce production lqualid_rich -> lident
-- On TYPE reduce production lqualid_rich -> lident
-- On TRUE reduce production lqualid_rich -> lident
-- On TO reduce production lqualid_rich -> lident
-- On THEN reduce production lqualid_rich -> lident
-- On SO reduce production lqualid_rich -> lident
-- On SEMICOLON reduce production lqualid_rich -> lident
-- On SCOPE reduce production lqualid_rich -> lident
-- On RIGHTSQ_QUOTE reduce production lqualid_rich -> lident
-- On RIGHTSQ reduce production lqualid_rich -> lident
-- On RIGHTPAR reduce production lqualid_rich -> lident
-- On RIGHTBRC reduce production lqualid_rich -> lident
-- On RETURNS reduce production lqualid_rich -> lident
-- On REQUIRES reduce production lqualid_rich -> lident
-- On REAL reduce production lqualid_rich -> lident
-- On READS reduce production lqualid_rich -> lident
-- On RANGE reduce production lqualid_rich -> lident
-- On RAISES reduce production lqualid_rich -> lident
-- On PURE reduce production lqualid_rich -> lident
-- On PREDICATE reduce production lqualid_rich -> lident
-- On OR reduce production lqualid_rich -> lident
-- On OPPREF reduce production lqualid_rich -> lident
-- On OP4 reduce production lqualid_rich -> lident
-- On OP3 reduce production lqualid_rich -> lident
-- On OP2 reduce production lqualid_rich -> lident
-- On OP1 reduce production lqualid_rich -> lident
-- On MINUS reduce production lqualid_rich -> lident
-- On META reduce production lqualid_rich -> lident
-- On LTGT reduce production lqualid_rich -> lident
-- On LT reduce production lqualid_rich -> lident
-- On LRARROW reduce production lqualid_rich -> lident
-- On LIDENT reduce production lqualid_rich -> lident
-- On LET reduce production lqualid_rich -> lident
-- On LEMMA reduce production lqualid_rich -> lident
-- On LEFTSQ reduce production lqualid_rich -> lident
-- On LEFTPAR reduce production lqualid_rich -> lident
-- On LEFTBRC reduce production lqualid_rich -> lident
-- On LARROW reduce production lqualid_rich -> lident
-- On INTEGER reduce production lqualid_rich -> lident
-- On INDUCTIVE reduce production lqualid_rich -> lident
-- On IN reduce production lqualid_rich -> lident
-- On IMPORT reduce production lqualid_rich -> lident
-- On GT reduce production lqualid_rich -> lident
-- On GOAL reduce production lqualid_rich -> lident
-- On FUNCTION reduce production lqualid_rich -> lident
-- On FLOAT reduce production lqualid_rich -> lident
-- On FALSE reduce production lqualid_rich -> lident
-- On EXCEPTION reduce production lqualid_rich -> lident
-- On EQUAL reduce production lqualid_rich -> lident
-- On EOF reduce production lqualid_rich -> lident
-- On ENSURES reduce production lqualid_rich -> lident
-- On END reduce production lqualid_rich -> lident
-- On ELSE reduce production lqualid_rich -> lident
-- On DOWNTO reduce production lqualid_rich -> lident
-- On DOTDOT reduce production lqualid_rich -> lident
-- On DOT reduce production lqualid_rich -> lident
-- On DONE reduce production lqualid_rich -> lident
-- On DO reduce production lqualid_rich -> lident
-- On DIVERGES reduce production lqualid_rich -> lident
-- On CORE_UIDENT reduce production lqualid_rich -> lident
-- On CORE_LIDENT reduce production lqualid_rich -> lident
-- On CONSTANT reduce production lqualid_rich -> lident
-- On COMMA reduce production lqualid_rich -> lident
-- On COLON reduce production lqualid_rich -> lident
-- On COINDUCTIVE reduce production lqualid_rich -> lident
-- On CLONE reduce production lqualid_rich -> lident
-- On BY reduce production lqualid_rich -> lident
-- On BEGIN reduce production lqualid_rich -> lident
-- On BARBAR reduce production lqualid_rich -> lident
-- On BAR reduce production lqualid_rich -> lident
-- On AXIOM reduce production lqualid_rich -> lident
-- On AT reduce production lqualid_rich -> lident
-- On ARROW reduce production lqualid_rich -> lident
-- On AND reduce production lqualid_rich -> lident
-- On AMPAMP reduce production lqualid_rich -> lident
-- On ALIAS reduce production lqualid_rich -> lident

State 314:
## Known stack suffix:
## term_block_
## LR(1) items:
term_sub_ -> term_block_ . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_sub_ -> term_block_
-- On VAL reduce production term_sub_ -> term_block_
-- On USE reduce production term_sub_ -> term_block_
-- On UIDENT reduce production term_sub_ -> term_block_
-- On TYPE reduce production term_sub_ -> term_block_
-- On TRUE reduce production term_sub_ -> term_block_
-- On THEN reduce production term_sub_ -> term_block_
-- On SO reduce production term_sub_ -> term_block_
-- On SEMICOLON reduce production term_sub_ -> term_block_
-- On SCOPE reduce production term_sub_ -> term_block_
-- On RIGHTSQ_QUOTE reduce production term_sub_ -> term_block_
-- On RIGHTSQ reduce production term_sub_ -> term_block_
-- On RIGHTPAR reduce production term_sub_ -> term_block_
-- On RIGHTBRC reduce production term_sub_ -> term_block_
-- On REAL reduce production term_sub_ -> term_block_
-- On RANGE reduce production term_sub_ -> term_block_
-- On PREDICATE reduce production term_sub_ -> term_block_
-- On OR reduce production term_sub_ -> term_block_
-- On OPPREF reduce production term_sub_ -> term_block_
-- On OP4 reduce production term_sub_ -> term_block_
-- On OP3 reduce production term_sub_ -> term_block_
-- On OP2 reduce production term_sub_ -> term_block_
-- On OP1 reduce production term_sub_ -> term_block_
-- On MINUS reduce production term_sub_ -> term_block_
-- On META reduce production term_sub_ -> term_block_
-- On LTGT reduce production term_sub_ -> term_block_
-- On LT reduce production term_sub_ -> term_block_
-- On LRARROW reduce production term_sub_ -> term_block_
-- On LIDENT reduce production term_sub_ -> term_block_
-- On LET reduce production term_sub_ -> term_block_
-- On LEMMA reduce production term_sub_ -> term_block_
-- On LEFTSQ reduce production term_sub_ -> term_block_
-- On LEFTPAR reduce production term_sub_ -> term_block_
-- On LEFTBRC reduce production term_sub_ -> term_block_
-- On LARROW reduce production term_sub_ -> term_block_
-- On INTEGER reduce production term_sub_ -> term_block_
-- On INDUCTIVE reduce production term_sub_ -> term_block_
-- On IN reduce production term_sub_ -> term_block_
-- On IMPORT reduce production term_sub_ -> term_block_
-- On GT reduce production term_sub_ -> term_block_
-- On GOAL reduce production term_sub_ -> term_block_
-- On FUNCTION reduce production term_sub_ -> term_block_
-- On FLOAT reduce production term_sub_ -> term_block_
-- On FALSE reduce production term_sub_ -> term_block_
-- On EXCEPTION reduce production term_sub_ -> term_block_
-- On EQUAL reduce production term_sub_ -> term_block_
-- On EOF reduce production term_sub_ -> term_block_
-- On END reduce production term_sub_ -> term_block_
-- On ELSE reduce production term_sub_ -> term_block_
-- On DOTDOT reduce production term_sub_ -> term_block_
-- On DOT reduce production term_sub_ -> term_block_
-- On CORE_UIDENT reduce production term_sub_ -> term_block_
-- On CORE_LIDENT reduce production term_sub_ -> term_block_
-- On CONSTANT reduce production term_sub_ -> term_block_
-- On COMMA reduce production term_sub_ -> term_block_
-- On COLON reduce production term_sub_ -> term_block_
-- On COINDUCTIVE reduce production term_sub_ -> term_block_
-- On CLONE reduce production term_sub_ -> term_block_
-- On BY reduce production term_sub_ -> term_block_
-- On BEGIN reduce production term_sub_ -> term_block_
-- On BARBAR reduce production term_sub_ -> term_block_
-- On BAR reduce production term_sub_ -> term_block_
-- On AXIOM reduce production term_sub_ -> term_block_
-- On AT reduce production term_sub_ -> term_block_
-- On ARROW reduce production term_sub_ -> term_block_
-- On AND reduce production term_sub_ -> term_block_
-- On AMPAMP reduce production term_sub_ -> term_block_

State 315:
## Known stack suffix:
## term_arg_
## LR(1) items:
mk_term(term_arg_) -> term_arg_ . [ UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTSQ LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN ]
single_term_ -> term_arg_ . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> term_arg_
-- On VAL reduce production single_term_ -> term_arg_
-- On USE reduce production single_term_ -> term_arg_
-- On UIDENT reduce production mk_term(term_arg_) -> term_arg_
-- On TYPE reduce production single_term_ -> term_arg_
-- On TRUE reduce production mk_term(term_arg_) -> term_arg_
-- On THEN reduce production single_term_ -> term_arg_
-- On SO reduce production single_term_ -> term_arg_
-- On SEMICOLON reduce production single_term_ -> term_arg_
-- On SCOPE reduce production single_term_ -> term_arg_
-- On RIGHTSQ_QUOTE reduce production single_term_ -> term_arg_
-- On RIGHTSQ reduce production single_term_ -> term_arg_
-- On RIGHTPAR reduce production single_term_ -> term_arg_
-- On RIGHTBRC reduce production single_term_ -> term_arg_
-- On REAL reduce production mk_term(term_arg_) -> term_arg_
-- On RANGE reduce production mk_term(term_arg_) -> term_arg_
-- On PREDICATE reduce production single_term_ -> term_arg_
-- On OR reduce production single_term_ -> term_arg_
-- On OPPREF reduce production mk_term(term_arg_) -> term_arg_
-- On OP4 reduce production single_term_ -> term_arg_
-- On OP3 reduce production single_term_ -> term_arg_
-- On OP2 reduce production single_term_ -> term_arg_
-- On OP1 reduce production single_term_ -> term_arg_
-- On MINUS reduce production single_term_ -> term_arg_
-- On META reduce production single_term_ -> term_arg_
-- On LTGT reduce production single_term_ -> term_arg_
-- On LT reduce production single_term_ -> term_arg_
-- On LRARROW reduce production single_term_ -> term_arg_
-- On LIDENT reduce production mk_term(term_arg_) -> term_arg_
-- On LET reduce production single_term_ -> term_arg_
-- On LEMMA reduce production single_term_ -> term_arg_
-- On LEFTSQ reduce production mk_term(term_arg_) -> term_arg_
-- On LEFTPAR reduce production mk_term(term_arg_) -> term_arg_
-- On LEFTBRC reduce production mk_term(term_arg_) -> term_arg_
-- On LARROW reduce production single_term_ -> term_arg_
-- On INTEGER reduce production mk_term(term_arg_) -> term_arg_
-- On INDUCTIVE reduce production single_term_ -> term_arg_
-- On IN reduce production single_term_ -> term_arg_
-- On IMPORT reduce production single_term_ -> term_arg_
-- On GT reduce production single_term_ -> term_arg_
-- On GOAL reduce production single_term_ -> term_arg_
-- On FUNCTION reduce production single_term_ -> term_arg_
-- On FLOAT reduce production mk_term(term_arg_) -> term_arg_
-- On FALSE reduce production mk_term(term_arg_) -> term_arg_
-- On EXCEPTION reduce production single_term_ -> term_arg_
-- On EQUAL reduce production single_term_ -> term_arg_
-- On EOF reduce production single_term_ -> term_arg_
-- On END reduce production single_term_ -> term_arg_
-- On ELSE reduce production single_term_ -> term_arg_
-- On DOTDOT reduce production single_term_ -> term_arg_
-- On CORE_UIDENT reduce production mk_term(term_arg_) -> term_arg_
-- On CORE_LIDENT reduce production mk_term(term_arg_) -> term_arg_
-- On CONSTANT reduce production single_term_ -> term_arg_
-- On COMMA reduce production single_term_ -> term_arg_
-- On COLON reduce production single_term_ -> term_arg_
-- On COINDUCTIVE reduce production single_term_ -> term_arg_
-- On CLONE reduce production single_term_ -> term_arg_
-- On BY reduce production single_term_ -> term_arg_
-- On BEGIN reduce production mk_term(term_arg_) -> term_arg_
-- On BARBAR reduce production single_term_ -> term_arg_
-- On BAR reduce production single_term_ -> term_arg_
-- On AXIOM reduce production single_term_ -> term_arg_
-- On AT reduce production single_term_ -> term_arg_
-- On ARROW reduce production single_term_ -> term_arg_
-- On AND reduce production single_term_ -> term_arg_
-- On AMPAMP reduce production single_term_ -> term_arg_

State 316:
## Known stack suffix:
## term_arg
## LR(1) items:
single_term_ -> term_arg . nonempty_list(located(term_arg)) [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term LARROW term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On OPPREF shift to state 201
-- On LIDENT shift to state 3
-- On LEFTSQ shift to state 317
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 411
-- On term_arg shift to state 412
-- On qualid shift to state 345
-- On numeral shift to state 349
-- On nonempty_list(located(term_arg)) shift to state 413
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On lqualid shift to state 353
-- On located(term_arg) shift to state 414
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
## Reductions:

State 317:
## Known stack suffix:
## term_arg LEFTSQ
## LR(1) items:
term_sub_ -> term_arg LEFTSQ . term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ . term LARROW term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ . term DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ . term DOTDOT rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ . DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On DOTDOT shift to state 318
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 402
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 318:
## Known stack suffix:
## term_arg LEFTSQ DOTDOT
## LR(1) items:
term_sub_ -> term_arg LEFTSQ DOTDOT . term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 319
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 319:
## Known stack suffix:
## term_arg LEFTSQ DOTDOT term
## LR(1) items:
term_sub_ -> term_arg LEFTSQ DOTDOT term . rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 320
## Reductions:

State 320:
## Known stack suffix:
## term_arg LEFTSQ DOTDOT term rightsq
## LR(1) items:
term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On VAL reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On USE reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On UIDENT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On TYPE reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On TRUE reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On THEN reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On SO reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On SEMICOLON reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On SCOPE reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On RIGHTSQ_QUOTE reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On RIGHTSQ reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On RIGHTPAR reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On RIGHTBRC reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On REAL reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On RANGE reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On PREDICATE reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On OR reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On OPPREF reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On OP4 reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On OP3 reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On OP2 reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On OP1 reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On MINUS reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On META reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On LTGT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On LT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On LRARROW reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On LIDENT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On LET reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On LEMMA reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On LEFTSQ reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On LEFTPAR reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On LEFTBRC reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On LARROW reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On INTEGER reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On INDUCTIVE reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On IN reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On IMPORT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On GT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On GOAL reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On FUNCTION reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On FLOAT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On FALSE reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On EXCEPTION reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On EQUAL reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On EOF reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On END reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On ELSE reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On DOTDOT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On DOT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On CORE_UIDENT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On CORE_LIDENT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On CONSTANT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On COMMA reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On COLON reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On COINDUCTIVE reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On CLONE reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On BY reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On BEGIN reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On BARBAR reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On BAR reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On AXIOM reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On AT reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On ARROW reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On AND reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq
-- On AMPAMP reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq

State 321:
## Known stack suffix:
## single_term_
## LR(1) items:
mk_term(single_term_) -> single_term_ . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production mk_term(single_term_) -> single_term_
-- On VAL reduce production mk_term(single_term_) -> single_term_
-- On USE reduce production mk_term(single_term_) -> single_term_
-- On TYPE reduce production mk_term(single_term_) -> single_term_
-- On THEN reduce production mk_term(single_term_) -> single_term_
-- On SO reduce production mk_term(single_term_) -> single_term_
-- On SEMICOLON reduce production mk_term(single_term_) -> single_term_
-- On SCOPE reduce production mk_term(single_term_) -> single_term_
-- On RIGHTSQ_QUOTE reduce production mk_term(single_term_) -> single_term_
-- On RIGHTSQ reduce production mk_term(single_term_) -> single_term_
-- On RIGHTPAR reduce production mk_term(single_term_) -> single_term_
-- On RIGHTBRC reduce production mk_term(single_term_) -> single_term_
-- On PREDICATE reduce production mk_term(single_term_) -> single_term_
-- On OR reduce production mk_term(single_term_) -> single_term_
-- On OP4 reduce production mk_term(single_term_) -> single_term_
-- On OP3 reduce production mk_term(single_term_) -> single_term_
-- On OP2 reduce production mk_term(single_term_) -> single_term_
-- On OP1 reduce production mk_term(single_term_) -> single_term_
-- On MINUS reduce production mk_term(single_term_) -> single_term_
-- On META reduce production mk_term(single_term_) -> single_term_
-- On LTGT reduce production mk_term(single_term_) -> single_term_
-- On LT reduce production mk_term(single_term_) -> single_term_
-- On LRARROW reduce production mk_term(single_term_) -> single_term_
-- On LET reduce production mk_term(single_term_) -> single_term_
-- On LEMMA reduce production mk_term(single_term_) -> single_term_
-- On LARROW reduce production mk_term(single_term_) -> single_term_
-- On INDUCTIVE reduce production mk_term(single_term_) -> single_term_
-- On IN reduce production mk_term(single_term_) -> single_term_
-- On IMPORT reduce production mk_term(single_term_) -> single_term_
-- On GT reduce production mk_term(single_term_) -> single_term_
-- On GOAL reduce production mk_term(single_term_) -> single_term_
-- On FUNCTION reduce production mk_term(single_term_) -> single_term_
-- On EXCEPTION reduce production mk_term(single_term_) -> single_term_
-- On EQUAL reduce production mk_term(single_term_) -> single_term_
-- On EOF reduce production mk_term(single_term_) -> single_term_
-- On END reduce production mk_term(single_term_) -> single_term_
-- On ELSE reduce production mk_term(single_term_) -> single_term_
-- On DOTDOT reduce production mk_term(single_term_) -> single_term_
-- On CONSTANT reduce production mk_term(single_term_) -> single_term_
-- On COMMA reduce production mk_term(single_term_) -> single_term_
-- On COLON reduce production mk_term(single_term_) -> single_term_
-- On COINDUCTIVE reduce production mk_term(single_term_) -> single_term_
-- On CLONE reduce production mk_term(single_term_) -> single_term_
-- On BY reduce production mk_term(single_term_) -> single_term_
-- On BARBAR reduce production mk_term(single_term_) -> single_term_
-- On BAR reduce production mk_term(single_term_) -> single_term_
-- On AXIOM reduce production mk_term(single_term_) -> single_term_
-- On AT reduce production mk_term(single_term_) -> single_term_
-- On ARROW reduce production mk_term(single_term_) -> single_term_
-- On AND reduce production mk_term(single_term_) -> single_term_
-- On AMPAMP reduce production mk_term(single_term_) -> single_term_

State 322:
## Known stack suffix:
## single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term -> single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term -> single_term . COMMA term_ [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On COMMA shift to state 397
-- On COLON shift to state 132
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production term -> single_term
-- On VAL reduce production term -> single_term
-- On USE reduce production term -> single_term
-- On TYPE reduce production term -> single_term
-- On THEN reduce production term -> single_term
-- On SEMICOLON reduce production term -> single_term
-- On SCOPE reduce production term -> single_term
-- On RIGHTSQ_QUOTE reduce production term -> single_term
-- On RIGHTSQ reduce production term -> single_term
-- On RIGHTPAR reduce production term -> single_term
-- On RIGHTBRC reduce production term -> single_term
-- On PREDICATE reduce production term -> single_term
-- On META reduce production term -> single_term
-- On LET reduce production term -> single_term
-- On LEMMA reduce production term -> single_term
-- On LARROW reduce production term -> single_term
-- On INDUCTIVE reduce production term -> single_term
-- On IN reduce production term -> single_term
-- On IMPORT reduce production term -> single_term
-- On GOAL reduce production term -> single_term
-- On FUNCTION reduce production term -> single_term
-- On EXCEPTION reduce production term -> single_term
-- On EOF reduce production term -> single_term
-- On END reduce production term -> single_term
-- On ELSE reduce production term -> single_term
-- On DOTDOT reduce production term -> single_term
-- On CONSTANT reduce production term -> single_term
-- On COINDUCTIVE reduce production term -> single_term
-- On CLONE reduce production term -> single_term
-- On BAR reduce production term -> single_term
-- On AXIOM reduce production term -> single_term

State 323:
## Known stack suffix:
## single_term SO
## LR(1) items:
single_term_ -> single_term SO . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 324
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 324:
## Known stack suffix:
## single_term SO single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term SO single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term SO single_term
-- On VAL reduce production single_term_ -> single_term SO single_term
-- On USE reduce production single_term_ -> single_term SO single_term
-- On TYPE reduce production single_term_ -> single_term SO single_term
-- On THEN reduce production single_term_ -> single_term SO single_term
-- On SEMICOLON reduce production single_term_ -> single_term SO single_term
-- On SCOPE reduce production single_term_ -> single_term SO single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term SO single_term
-- On RIGHTSQ reduce production single_term_ -> single_term SO single_term
-- On RIGHTPAR reduce production single_term_ -> single_term SO single_term
-- On RIGHTBRC reduce production single_term_ -> single_term SO single_term
-- On PREDICATE reduce production single_term_ -> single_term SO single_term
-- On META reduce production single_term_ -> single_term SO single_term
-- On LET reduce production single_term_ -> single_term SO single_term
-- On LEMMA reduce production single_term_ -> single_term SO single_term
-- On LARROW reduce production single_term_ -> single_term SO single_term
-- On INDUCTIVE reduce production single_term_ -> single_term SO single_term
-- On IN reduce production single_term_ -> single_term SO single_term
-- On IMPORT reduce production single_term_ -> single_term SO single_term
-- On GOAL reduce production single_term_ -> single_term SO single_term
-- On FUNCTION reduce production single_term_ -> single_term SO single_term
-- On EXCEPTION reduce production single_term_ -> single_term SO single_term
-- On EOF reduce production single_term_ -> single_term SO single_term
-- On END reduce production single_term_ -> single_term SO single_term
-- On ELSE reduce production single_term_ -> single_term SO single_term
-- On DOTDOT reduce production single_term_ -> single_term SO single_term
-- On CONSTANT reduce production single_term_ -> single_term SO single_term
-- On COMMA reduce production single_term_ -> single_term SO single_term
-- On COLON reduce production single_term_ -> single_term SO single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term SO single_term
-- On CLONE reduce production single_term_ -> single_term SO single_term
-- On BAR reduce production single_term_ -> single_term SO single_term
-- On AXIOM reduce production single_term_ -> single_term SO single_term

State 325:
## Known stack suffix:
## single_term OR
## LR(1) items:
single_term_ -> single_term OR . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 326
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 326:
## Known stack suffix:
## single_term OR single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term OR single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term OR single_term
-- On VAL reduce production single_term_ -> single_term OR single_term
-- On USE reduce production single_term_ -> single_term OR single_term
-- On TYPE reduce production single_term_ -> single_term OR single_term
-- On THEN reduce production single_term_ -> single_term OR single_term
-- On SO reduce production single_term_ -> single_term OR single_term
-- On SEMICOLON reduce production single_term_ -> single_term OR single_term
-- On SCOPE reduce production single_term_ -> single_term OR single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term OR single_term
-- On RIGHTSQ reduce production single_term_ -> single_term OR single_term
-- On RIGHTPAR reduce production single_term_ -> single_term OR single_term
-- On RIGHTBRC reduce production single_term_ -> single_term OR single_term
-- On PREDICATE reduce production single_term_ -> single_term OR single_term
-- On META reduce production single_term_ -> single_term OR single_term
-- On LRARROW reduce production single_term_ -> single_term OR single_term
-- On LET reduce production single_term_ -> single_term OR single_term
-- On LEMMA reduce production single_term_ -> single_term OR single_term
-- On LARROW reduce production single_term_ -> single_term OR single_term
-- On INDUCTIVE reduce production single_term_ -> single_term OR single_term
-- On IN reduce production single_term_ -> single_term OR single_term
-- On IMPORT reduce production single_term_ -> single_term OR single_term
-- On GOAL reduce production single_term_ -> single_term OR single_term
-- On FUNCTION reduce production single_term_ -> single_term OR single_term
-- On EXCEPTION reduce production single_term_ -> single_term OR single_term
-- On EOF reduce production single_term_ -> single_term OR single_term
-- On END reduce production single_term_ -> single_term OR single_term
-- On ELSE reduce production single_term_ -> single_term OR single_term
-- On DOTDOT reduce production single_term_ -> single_term OR single_term
-- On CONSTANT reduce production single_term_ -> single_term OR single_term
-- On COMMA reduce production single_term_ -> single_term OR single_term
-- On COLON reduce production single_term_ -> single_term OR single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term OR single_term
-- On CLONE reduce production single_term_ -> single_term OR single_term
-- On BY reduce production single_term_ -> single_term OR single_term
-- On BAR reduce production single_term_ -> single_term OR single_term
-- On AXIOM reduce production single_term_ -> single_term OR single_term
-- On ARROW reduce production single_term_ -> single_term OR single_term

State 327:
## Known stack suffix:
## single_term OP4
## LR(1) items:
single_term_ -> single_term OP4 . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 328
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 328:
## Known stack suffix:
## single_term OP4 single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term OP4 single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term OP4 single_term
-- On VAL reduce production single_term_ -> single_term OP4 single_term
-- On USE reduce production single_term_ -> single_term OP4 single_term
-- On TYPE reduce production single_term_ -> single_term OP4 single_term
-- On THEN reduce production single_term_ -> single_term OP4 single_term
-- On SO reduce production single_term_ -> single_term OP4 single_term
-- On SEMICOLON reduce production single_term_ -> single_term OP4 single_term
-- On SCOPE reduce production single_term_ -> single_term OP4 single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term OP4 single_term
-- On RIGHTSQ reduce production single_term_ -> single_term OP4 single_term
-- On RIGHTPAR reduce production single_term_ -> single_term OP4 single_term
-- On RIGHTBRC reduce production single_term_ -> single_term OP4 single_term
-- On PREDICATE reduce production single_term_ -> single_term OP4 single_term
-- On OR reduce production single_term_ -> single_term OP4 single_term
-- On OP4 reduce production single_term_ -> single_term OP4 single_term
-- On OP3 reduce production single_term_ -> single_term OP4 single_term
-- On OP2 reduce production single_term_ -> single_term OP4 single_term
-- On OP1 reduce production single_term_ -> single_term OP4 single_term
-- On MINUS reduce production single_term_ -> single_term OP4 single_term
-- On META reduce production single_term_ -> single_term OP4 single_term
-- On LTGT reduce production single_term_ -> single_term OP4 single_term
-- On LT reduce production single_term_ -> single_term OP4 single_term
-- On LRARROW reduce production single_term_ -> single_term OP4 single_term
-- On LET reduce production single_term_ -> single_term OP4 single_term
-- On LEMMA reduce production single_term_ -> single_term OP4 single_term
-- On LARROW reduce production single_term_ -> single_term OP4 single_term
-- On INDUCTIVE reduce production single_term_ -> single_term OP4 single_term
-- On IN reduce production single_term_ -> single_term OP4 single_term
-- On IMPORT reduce production single_term_ -> single_term OP4 single_term
-- On GT reduce production single_term_ -> single_term OP4 single_term
-- On GOAL reduce production single_term_ -> single_term OP4 single_term
-- On FUNCTION reduce production single_term_ -> single_term OP4 single_term
-- On EXCEPTION reduce production single_term_ -> single_term OP4 single_term
-- On EQUAL reduce production single_term_ -> single_term OP4 single_term
-- On EOF reduce production single_term_ -> single_term OP4 single_term
-- On END reduce production single_term_ -> single_term OP4 single_term
-- On ELSE reduce production single_term_ -> single_term OP4 single_term
-- On DOTDOT reduce production single_term_ -> single_term OP4 single_term
-- On CONSTANT reduce production single_term_ -> single_term OP4 single_term
-- On COMMA reduce production single_term_ -> single_term OP4 single_term
-- On COLON reduce production single_term_ -> single_term OP4 single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term OP4 single_term
-- On CLONE reduce production single_term_ -> single_term OP4 single_term
-- On BY reduce production single_term_ -> single_term OP4 single_term
-- On BARBAR reduce production single_term_ -> single_term OP4 single_term
-- On BAR reduce production single_term_ -> single_term OP4 single_term
-- On AXIOM reduce production single_term_ -> single_term OP4 single_term
-- On AT reduce production single_term_ -> single_term OP4 single_term
-- On ARROW reduce production single_term_ -> single_term OP4 single_term
-- On AND reduce production single_term_ -> single_term OP4 single_term
-- On AMPAMP reduce production single_term_ -> single_term OP4 single_term

State 329:
## Known stack suffix:
## single_term cast
## LR(1) items:
single_term_ -> single_term cast . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> single_term cast
-- On VAL reduce production single_term_ -> single_term cast
-- On USE reduce production single_term_ -> single_term cast
-- On TYPE reduce production single_term_ -> single_term cast
-- On THEN reduce production single_term_ -> single_term cast
-- On SO reduce production single_term_ -> single_term cast
-- On SEMICOLON reduce production single_term_ -> single_term cast
-- On SCOPE reduce production single_term_ -> single_term cast
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term cast
-- On RIGHTSQ reduce production single_term_ -> single_term cast
-- On RIGHTPAR reduce production single_term_ -> single_term cast
-- On RIGHTBRC reduce production single_term_ -> single_term cast
-- On PREDICATE reduce production single_term_ -> single_term cast
-- On OR reduce production single_term_ -> single_term cast
-- On OP4 reduce production single_term_ -> single_term cast
-- On OP3 reduce production single_term_ -> single_term cast
-- On OP2 reduce production single_term_ -> single_term cast
-- On OP1 reduce production single_term_ -> single_term cast
-- On MINUS reduce production single_term_ -> single_term cast
-- On META reduce production single_term_ -> single_term cast
-- On LTGT reduce production single_term_ -> single_term cast
-- On LT reduce production single_term_ -> single_term cast
-- On LRARROW reduce production single_term_ -> single_term cast
-- On LET reduce production single_term_ -> single_term cast
-- On LEMMA reduce production single_term_ -> single_term cast
-- On LARROW reduce production single_term_ -> single_term cast
-- On INDUCTIVE reduce production single_term_ -> single_term cast
-- On IN reduce production single_term_ -> single_term cast
-- On IMPORT reduce production single_term_ -> single_term cast
-- On GT reduce production single_term_ -> single_term cast
-- On GOAL reduce production single_term_ -> single_term cast
-- On FUNCTION reduce production single_term_ -> single_term cast
-- On EXCEPTION reduce production single_term_ -> single_term cast
-- On EQUAL reduce production single_term_ -> single_term cast
-- On EOF reduce production single_term_ -> single_term cast
-- On END reduce production single_term_ -> single_term cast
-- On ELSE reduce production single_term_ -> single_term cast
-- On DOTDOT reduce production single_term_ -> single_term cast
-- On CONSTANT reduce production single_term_ -> single_term cast
-- On COMMA reduce production single_term_ -> single_term cast
-- On COLON reduce production single_term_ -> single_term cast
-- On COINDUCTIVE reduce production single_term_ -> single_term cast
-- On CLONE reduce production single_term_ -> single_term cast
-- On BY reduce production single_term_ -> single_term cast
-- On BARBAR reduce production single_term_ -> single_term cast
-- On BAR reduce production single_term_ -> single_term cast
-- On AXIOM reduce production single_term_ -> single_term cast
-- On AT reduce production single_term_ -> single_term cast
-- On ARROW reduce production single_term_ -> single_term cast
-- On AND reduce production single_term_ -> single_term cast
-- On AMPAMP reduce production single_term_ -> single_term cast

State 330:
## Known stack suffix:
## quant
## LR(1) items:
single_term_ -> quant . comma_list1(quant_vars) triggers DOT term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On separated_nonempty_list(COMMA,quant_vars) shift to state 331
-- On quant_vars shift to state 332
-- On nonempty_list(binder_var) shift to state 335
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list1(quant_vars) shift to state 340
-- On binder_var shift to state 338
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:

State 331:
## Known stack suffix:
## separated_nonempty_list(COMMA,quant_vars)
## LR(1) items:
comma_list1(quant_vars) -> separated_nonempty_list(COMMA,quant_vars) . [ LEFTSQ DOT ]
## Transitions:
## Reductions:
-- On LEFTSQ reduce production comma_list1(quant_vars) -> separated_nonempty_list(COMMA,quant_vars)
-- On DOT reduce production comma_list1(quant_vars) -> separated_nonempty_list(COMMA,quant_vars)

State 332:
## Known stack suffix:
## quant_vars
## LR(1) items:
separated_nonempty_list(COMMA,quant_vars) -> quant_vars . [ LEFTSQ DOT ]
separated_nonempty_list(COMMA,quant_vars) -> quant_vars . COMMA separated_nonempty_list(COMMA,quant_vars) [ LEFTSQ DOT ]
## Transitions:
-- On COMMA shift to state 333
## Reductions:
-- On LEFTSQ reduce production separated_nonempty_list(COMMA,quant_vars) -> quant_vars
-- On DOT reduce production separated_nonempty_list(COMMA,quant_vars) -> quant_vars

State 333:
## Known stack suffix:
## quant_vars COMMA
## LR(1) items:
separated_nonempty_list(COMMA,quant_vars) -> quant_vars COMMA . separated_nonempty_list(COMMA,quant_vars) [ LEFTSQ DOT ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On separated_nonempty_list(COMMA,quant_vars) shift to state 334
-- On quant_vars shift to state 332
-- On nonempty_list(binder_var) shift to state 335
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On binder_var shift to state 338
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:

State 334:
## Known stack suffix:
## quant_vars COMMA separated_nonempty_list(COMMA,quant_vars)
## LR(1) items:
separated_nonempty_list(COMMA,quant_vars) -> quant_vars COMMA separated_nonempty_list(COMMA,quant_vars) . [ LEFTSQ DOT ]
## Transitions:
## Reductions:
-- On LEFTSQ reduce production separated_nonempty_list(COMMA,quant_vars) -> quant_vars COMMA separated_nonempty_list(COMMA,quant_vars)
-- On DOT reduce production separated_nonempty_list(COMMA,quant_vars) -> quant_vars COMMA separated_nonempty_list(COMMA,quant_vars)

State 335:
## Known stack suffix:
## nonempty_list(binder_var)
## LR(1) items:
quant_vars -> nonempty_list(binder_var) . option(cast) [ LEFTSQ DOT COMMA ]
## Transitions:
-- On COLON shift to state 132
-- On option(cast) shift to state 336
-- On cast shift to state 337
## Reductions:
-- On LEFTSQ reduce production option(cast) ->
-- On DOT reduce production option(cast) ->
-- On COMMA reduce production option(cast) ->

State 336:
## Known stack suffix:
## nonempty_list(binder_var) option(cast)
## LR(1) items:
quant_vars -> nonempty_list(binder_var) option(cast) . [ LEFTSQ DOT COMMA ]
## Transitions:
## Reductions:
-- On LEFTSQ reduce production quant_vars -> nonempty_list(binder_var) option(cast)
-- On DOT reduce production quant_vars -> nonempty_list(binder_var) option(cast)
-- On COMMA reduce production quant_vars -> nonempty_list(binder_var) option(cast)

State 337:
## Known stack suffix:
## cast
## LR(1) items:
option(cast) -> cast . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA LEFTSQ INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END DOT CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production option(cast) -> cast
-- On VAL reduce production option(cast) -> cast
-- On USE reduce production option(cast) -> cast
-- On TYPE reduce production option(cast) -> cast
-- On SCOPE reduce production option(cast) -> cast
-- On PREDICATE reduce production option(cast) -> cast
-- On META reduce production option(cast) -> cast
-- On LET reduce production option(cast) -> cast
-- On LEMMA reduce production option(cast) -> cast
-- On LEFTSQ reduce production option(cast) -> cast
-- On INDUCTIVE reduce production option(cast) -> cast
-- On IMPORT reduce production option(cast) -> cast
-- On GOAL reduce production option(cast) -> cast
-- On FUNCTION reduce production option(cast) -> cast
-- On EXCEPTION reduce production option(cast) -> cast
-- On EQUAL reduce production option(cast) -> cast
-- On EOF reduce production option(cast) -> cast
-- On END reduce production option(cast) -> cast
-- On DOT reduce production option(cast) -> cast
-- On CONSTANT reduce production option(cast) -> cast
-- On COMMA reduce production option(cast) -> cast
-- On COINDUCTIVE reduce production option(cast) -> cast
-- On CLONE reduce production option(cast) -> cast
-- On AXIOM reduce production option(cast) -> cast

State 338:
## Known stack suffix:
## binder_var
## LR(1) items:
nonempty_list(binder_var) -> binder_var . [ LEFTSQ DOT COMMA COLON ]
nonempty_list(binder_var) -> binder_var . nonempty_list(binder_var) [ LEFTSQ DOT COMMA COLON ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On nonempty_list(binder_var) shift to state 339
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On binder_var shift to state 338
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:
-- On LEFTSQ reduce production nonempty_list(binder_var) -> binder_var
-- On DOT reduce production nonempty_list(binder_var) -> binder_var
-- On COMMA reduce production nonempty_list(binder_var) -> binder_var
-- On COLON reduce production nonempty_list(binder_var) -> binder_var

State 339:
## Known stack suffix:
## binder_var nonempty_list(binder_var)
## LR(1) items:
nonempty_list(binder_var) -> binder_var nonempty_list(binder_var) . [ LEFTSQ DOT COMMA COLON ]
## Transitions:
## Reductions:
-- On LEFTSQ reduce production nonempty_list(binder_var) -> binder_var nonempty_list(binder_var)
-- On DOT reduce production nonempty_list(binder_var) -> binder_var nonempty_list(binder_var)
-- On COMMA reduce production nonempty_list(binder_var) -> binder_var nonempty_list(binder_var)
-- On COLON reduce production nonempty_list(binder_var) -> binder_var nonempty_list(binder_var)

State 340:
## Known stack suffix:
## quant comma_list1(quant_vars)
## LR(1) items:
single_term_ -> quant comma_list1(quant_vars) . triggers DOT term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On LEFTSQ shift to state 341
-- On triggers shift to state 394
## Reductions:
-- On DOT reduce production triggers ->

State 341:
## Known stack suffix:
## LEFTSQ
## LR(1) items:
triggers -> LEFTSQ . separated_nonempty_list(BAR,comma_list1(single_term)) RIGHTSQ [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 342
-- On separated_nonempty_list(COMMA,single_term) shift to state 388
-- On separated_nonempty_list(BAR,comma_list1(single_term)) shift to state 389
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On comma_list1(single_term) shift to state 391
-- On attr shift to state 356
## Reductions:

State 342:
## Known stack suffix:
## single_term
## LR(1) items:
separated_nonempty_list(COMMA,single_term) -> single_term . [ RIGHTSQ RIGHTBRC EOF BAR ]
separated_nonempty_list(COMMA,single_term) -> single_term . COMMA separated_nonempty_list(COMMA,single_term) [ RIGHTSQ RIGHTBRC EOF BAR ]
single_term_ -> single_term . AT uident [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On COMMA shift to state 386
-- On COLON shift to state 132
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On RIGHTSQ reduce production separated_nonempty_list(COMMA,single_term) -> single_term
-- On RIGHTBRC reduce production separated_nonempty_list(COMMA,single_term) -> single_term
-- On EOF reduce production separated_nonempty_list(COMMA,single_term) -> single_term
-- On BAR reduce production separated_nonempty_list(COMMA,single_term) -> single_term

State 343:
## Known stack suffix:
## single_term OP3
## LR(1) items:
single_term_ -> single_term OP3 . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 344
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 344:
## Known stack suffix:
## single_term OP3 single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term OP3 single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term OP3 single_term
-- On VAL reduce production single_term_ -> single_term OP3 single_term
-- On USE reduce production single_term_ -> single_term OP3 single_term
-- On TYPE reduce production single_term_ -> single_term OP3 single_term
-- On THEN reduce production single_term_ -> single_term OP3 single_term
-- On SO reduce production single_term_ -> single_term OP3 single_term
-- On SEMICOLON reduce production single_term_ -> single_term OP3 single_term
-- On SCOPE reduce production single_term_ -> single_term OP3 single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term OP3 single_term
-- On RIGHTSQ reduce production single_term_ -> single_term OP3 single_term
-- On RIGHTPAR reduce production single_term_ -> single_term OP3 single_term
-- On RIGHTBRC reduce production single_term_ -> single_term OP3 single_term
-- On PREDICATE reduce production single_term_ -> single_term OP3 single_term
-- On OR reduce production single_term_ -> single_term OP3 single_term
-- On OP3 reduce production single_term_ -> single_term OP3 single_term
-- On OP2 reduce production single_term_ -> single_term OP3 single_term
-- On OP1 reduce production single_term_ -> single_term OP3 single_term
-- On MINUS reduce production single_term_ -> single_term OP3 single_term
-- On META reduce production single_term_ -> single_term OP3 single_term
-- On LTGT reduce production single_term_ -> single_term OP3 single_term
-- On LT reduce production single_term_ -> single_term OP3 single_term
-- On LRARROW reduce production single_term_ -> single_term OP3 single_term
-- On LET reduce production single_term_ -> single_term OP3 single_term
-- On LEMMA reduce production single_term_ -> single_term OP3 single_term
-- On LARROW reduce production single_term_ -> single_term OP3 single_term
-- On INDUCTIVE reduce production single_term_ -> single_term OP3 single_term
-- On IN reduce production single_term_ -> single_term OP3 single_term
-- On IMPORT reduce production single_term_ -> single_term OP3 single_term
-- On GT reduce production single_term_ -> single_term OP3 single_term
-- On GOAL reduce production single_term_ -> single_term OP3 single_term
-- On FUNCTION reduce production single_term_ -> single_term OP3 single_term
-- On EXCEPTION reduce production single_term_ -> single_term OP3 single_term
-- On EQUAL reduce production single_term_ -> single_term OP3 single_term
-- On EOF reduce production single_term_ -> single_term OP3 single_term
-- On END reduce production single_term_ -> single_term OP3 single_term
-- On ELSE reduce production single_term_ -> single_term OP3 single_term
-- On DOTDOT reduce production single_term_ -> single_term OP3 single_term
-- On CONSTANT reduce production single_term_ -> single_term OP3 single_term
-- On COMMA reduce production single_term_ -> single_term OP3 single_term
-- On COLON reduce production single_term_ -> single_term OP3 single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term OP3 single_term
-- On CLONE reduce production single_term_ -> single_term OP3 single_term
-- On BY reduce production single_term_ -> single_term OP3 single_term
-- On BARBAR reduce production single_term_ -> single_term OP3 single_term
-- On BAR reduce production single_term_ -> single_term OP3 single_term
-- On AXIOM reduce production single_term_ -> single_term OP3 single_term
-- On AT reduce production single_term_ -> single_term OP3 single_term
-- On ARROW reduce production single_term_ -> single_term OP3 single_term
-- On AND reduce production single_term_ -> single_term OP3 single_term
-- On AMPAMP reduce production single_term_ -> single_term OP3 single_term

State 345:
## Known stack suffix:
## qualid
## LR(1) items:
term_arg_ -> qualid . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_arg_ -> qualid
-- On VAL reduce production term_arg_ -> qualid
-- On USE reduce production term_arg_ -> qualid
-- On UIDENT reduce production term_arg_ -> qualid
-- On TYPE reduce production term_arg_ -> qualid
-- On TRUE reduce production term_arg_ -> qualid
-- On THEN reduce production term_arg_ -> qualid
-- On SO reduce production term_arg_ -> qualid
-- On SEMICOLON reduce production term_arg_ -> qualid
-- On SCOPE reduce production term_arg_ -> qualid
-- On RIGHTSQ_QUOTE reduce production term_arg_ -> qualid
-- On RIGHTSQ reduce production term_arg_ -> qualid
-- On RIGHTPAR reduce production term_arg_ -> qualid
-- On RIGHTBRC reduce production term_arg_ -> qualid
-- On REAL reduce production term_arg_ -> qualid
-- On RANGE reduce production term_arg_ -> qualid
-- On PREDICATE reduce production term_arg_ -> qualid
-- On OR reduce production term_arg_ -> qualid
-- On OPPREF reduce production term_arg_ -> qualid
-- On OP4 reduce production term_arg_ -> qualid
-- On OP3 reduce production term_arg_ -> qualid
-- On OP2 reduce production term_arg_ -> qualid
-- On OP1 reduce production term_arg_ -> qualid
-- On MINUS reduce production term_arg_ -> qualid
-- On META reduce production term_arg_ -> qualid
-- On LTGT reduce production term_arg_ -> qualid
-- On LT reduce production term_arg_ -> qualid
-- On LRARROW reduce production term_arg_ -> qualid
-- On LIDENT reduce production term_arg_ -> qualid
-- On LET reduce production term_arg_ -> qualid
-- On LEMMA reduce production term_arg_ -> qualid
-- On LEFTSQ reduce production term_arg_ -> qualid
-- On LEFTPAR reduce production term_arg_ -> qualid
-- On LEFTBRC reduce production term_arg_ -> qualid
-- On LARROW reduce production term_arg_ -> qualid
-- On INTEGER reduce production term_arg_ -> qualid
-- On INDUCTIVE reduce production term_arg_ -> qualid
-- On IN reduce production term_arg_ -> qualid
-- On IMPORT reduce production term_arg_ -> qualid
-- On GT reduce production term_arg_ -> qualid
-- On GOAL reduce production term_arg_ -> qualid
-- On FUNCTION reduce production term_arg_ -> qualid
-- On FLOAT reduce production term_arg_ -> qualid
-- On FALSE reduce production term_arg_ -> qualid
-- On EXCEPTION reduce production term_arg_ -> qualid
-- On EQUAL reduce production term_arg_ -> qualid
-- On EOF reduce production term_arg_ -> qualid
-- On END reduce production term_arg_ -> qualid
-- On ELSE reduce production term_arg_ -> qualid
-- On DOTDOT reduce production term_arg_ -> qualid
-- On CORE_UIDENT reduce production term_arg_ -> qualid
-- On CORE_LIDENT reduce production term_arg_ -> qualid
-- On CONSTANT reduce production term_arg_ -> qualid
-- On COMMA reduce production term_arg_ -> qualid
-- On COLON reduce production term_arg_ -> qualid
-- On COINDUCTIVE reduce production term_arg_ -> qualid
-- On CLONE reduce production term_arg_ -> qualid
-- On BY reduce production term_arg_ -> qualid
-- On BEGIN reduce production term_arg_ -> qualid
-- On BARBAR reduce production term_arg_ -> qualid
-- On BAR reduce production term_arg_ -> qualid
-- On AXIOM reduce production term_arg_ -> qualid
-- On AT reduce production term_arg_ -> qualid
-- On ARROW reduce production term_arg_ -> qualid
-- On AND reduce production term_arg_ -> qualid
-- On AMPAMP reduce production term_arg_ -> qualid

State 346:
## Known stack suffix:
## prefix_op
## LR(1) items:
single_term_ -> prefix_op . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 347
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 347:
## Known stack suffix:
## prefix_op single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> prefix_op single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> prefix_op single_term
-- On VAL reduce production single_term_ -> prefix_op single_term
-- On USE reduce production single_term_ -> prefix_op single_term
-- On TYPE reduce production single_term_ -> prefix_op single_term
-- On THEN reduce production single_term_ -> prefix_op single_term
-- On SO reduce production single_term_ -> prefix_op single_term
-- On SEMICOLON reduce production single_term_ -> prefix_op single_term
-- On SCOPE reduce production single_term_ -> prefix_op single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> prefix_op single_term
-- On RIGHTSQ reduce production single_term_ -> prefix_op single_term
-- On RIGHTPAR reduce production single_term_ -> prefix_op single_term
-- On RIGHTBRC reduce production single_term_ -> prefix_op single_term
-- On PREDICATE reduce production single_term_ -> prefix_op single_term
-- On OR reduce production single_term_ -> prefix_op single_term
-- On OP4 reduce production single_term_ -> prefix_op single_term
-- On OP3 reduce production single_term_ -> prefix_op single_term
-- On OP2 reduce production single_term_ -> prefix_op single_term
-- On OP1 reduce production single_term_ -> prefix_op single_term
-- On MINUS reduce production single_term_ -> prefix_op single_term
-- On META reduce production single_term_ -> prefix_op single_term
-- On LTGT reduce production single_term_ -> prefix_op single_term
-- On LT reduce production single_term_ -> prefix_op single_term
-- On LRARROW reduce production single_term_ -> prefix_op single_term
-- On LET reduce production single_term_ -> prefix_op single_term
-- On LEMMA reduce production single_term_ -> prefix_op single_term
-- On LARROW reduce production single_term_ -> prefix_op single_term
-- On INDUCTIVE reduce production single_term_ -> prefix_op single_term
-- On IN reduce production single_term_ -> prefix_op single_term
-- On IMPORT reduce production single_term_ -> prefix_op single_term
-- On GT reduce production single_term_ -> prefix_op single_term
-- On GOAL reduce production single_term_ -> prefix_op single_term
-- On FUNCTION reduce production single_term_ -> prefix_op single_term
-- On EXCEPTION reduce production single_term_ -> prefix_op single_term
-- On EQUAL reduce production single_term_ -> prefix_op single_term
-- On EOF reduce production single_term_ -> prefix_op single_term
-- On END reduce production single_term_ -> prefix_op single_term
-- On ELSE reduce production single_term_ -> prefix_op single_term
-- On DOTDOT reduce production single_term_ -> prefix_op single_term
-- On CONSTANT reduce production single_term_ -> prefix_op single_term
-- On COMMA reduce production single_term_ -> prefix_op single_term
-- On COLON reduce production single_term_ -> prefix_op single_term
-- On COINDUCTIVE reduce production single_term_ -> prefix_op single_term
-- On CLONE reduce production single_term_ -> prefix_op single_term
-- On BY reduce production single_term_ -> prefix_op single_term
-- On BARBAR reduce production single_term_ -> prefix_op single_term
-- On BAR reduce production single_term_ -> prefix_op single_term
-- On AXIOM reduce production single_term_ -> prefix_op single_term
-- On AT reduce production single_term_ -> prefix_op single_term
-- On ARROW reduce production single_term_ -> prefix_op single_term
-- On AND reduce production single_term_ -> prefix_op single_term
-- On AMPAMP reduce production single_term_ -> prefix_op single_term

State 348:
## Known stack suffix:
## op_symbol
## LR(1) items:
prefix_op -> op_symbol . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE reduce production prefix_op -> op_symbol
-- On VAL reduce production prefix_op -> op_symbol
-- On UIDENT reduce production prefix_op -> op_symbol
-- On TRY reduce production prefix_op -> op_symbol
-- On TRUE reduce production prefix_op -> op_symbol
-- On RETURN reduce production prefix_op -> op_symbol
-- On REAL reduce production prefix_op -> op_symbol
-- On RANGE reduce production prefix_op -> op_symbol
-- On RAISE reduce production prefix_op -> op_symbol
-- On PURE reduce production prefix_op -> op_symbol
-- On POSITION reduce production prefix_op -> op_symbol
-- On OPPREF reduce production prefix_op -> op_symbol
-- On OP4 reduce production prefix_op -> op_symbol
-- On OP3 reduce production prefix_op -> op_symbol
-- On OP2 reduce production prefix_op -> op_symbol
-- On OP1 reduce production prefix_op -> op_symbol
-- On OLD reduce production prefix_op -> op_symbol
-- On NOT reduce production prefix_op -> op_symbol
-- On MINUS reduce production prefix_op -> op_symbol
-- On MATCH reduce production prefix_op -> op_symbol
-- On LT reduce production prefix_op -> op_symbol
-- On LIDENT reduce production prefix_op -> op_symbol
-- On LET reduce production prefix_op -> op_symbol
-- On LEFTPAR reduce production prefix_op -> op_symbol
-- On LEFTBRC reduce production prefix_op -> op_symbol
-- On LABEL reduce production prefix_op -> op_symbol
-- On INTEGER reduce production prefix_op -> op_symbol
-- On IF reduce production prefix_op -> op_symbol
-- On GT reduce production prefix_op -> op_symbol
-- On GHOST reduce production prefix_op -> op_symbol
-- On FUN reduce production prefix_op -> op_symbol
-- On FORALL reduce production prefix_op -> op_symbol
-- On FOR reduce production prefix_op -> op_symbol
-- On FLOAT reduce production prefix_op -> op_symbol
-- On FALSE reduce production prefix_op -> op_symbol
-- On EXISTS reduce production prefix_op -> op_symbol
-- On EXCEPTION reduce production prefix_op -> op_symbol
-- On EPSILON reduce production prefix_op -> op_symbol
-- On CORE_UIDENT reduce production prefix_op -> op_symbol
-- On CORE_LIDENT reduce production prefix_op -> op_symbol
-- On CONTINUE reduce production prefix_op -> op_symbol
-- On CHECK reduce production prefix_op -> op_symbol
-- On BREAK reduce production prefix_op -> op_symbol
-- On BEGIN reduce production prefix_op -> op_symbol
-- On ATTRIBUTE reduce production prefix_op -> op_symbol
-- On ASSUME reduce production prefix_op -> op_symbol
-- On ASSERT reduce production prefix_op -> op_symbol
-- On ANY reduce production prefix_op -> op_symbol
-- On ABSURD reduce production prefix_op -> op_symbol

State 349:
## Known stack suffix:
## numeral
## LR(1) items:
term_arg_ -> numeral . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_arg_ -> numeral
-- On VAL reduce production term_arg_ -> numeral
-- On USE reduce production term_arg_ -> numeral
-- On UIDENT reduce production term_arg_ -> numeral
-- On TYPE reduce production term_arg_ -> numeral
-- On TRUE reduce production term_arg_ -> numeral
-- On THEN reduce production term_arg_ -> numeral
-- On SO reduce production term_arg_ -> numeral
-- On SEMICOLON reduce production term_arg_ -> numeral
-- On SCOPE reduce production term_arg_ -> numeral
-- On RIGHTSQ_QUOTE reduce production term_arg_ -> numeral
-- On RIGHTSQ reduce production term_arg_ -> numeral
-- On RIGHTPAR reduce production term_arg_ -> numeral
-- On RIGHTBRC reduce production term_arg_ -> numeral
-- On REAL reduce production term_arg_ -> numeral
-- On RANGE reduce production term_arg_ -> numeral
-- On PREDICATE reduce production term_arg_ -> numeral
-- On OR reduce production term_arg_ -> numeral
-- On OPPREF reduce production term_arg_ -> numeral
-- On OP4 reduce production term_arg_ -> numeral
-- On OP3 reduce production term_arg_ -> numeral
-- On OP2 reduce production term_arg_ -> numeral
-- On OP1 reduce production term_arg_ -> numeral
-- On MINUS reduce production term_arg_ -> numeral
-- On META reduce production term_arg_ -> numeral
-- On LTGT reduce production term_arg_ -> numeral
-- On LT reduce production term_arg_ -> numeral
-- On LRARROW reduce production term_arg_ -> numeral
-- On LIDENT reduce production term_arg_ -> numeral
-- On LET reduce production term_arg_ -> numeral
-- On LEMMA reduce production term_arg_ -> numeral
-- On LEFTSQ reduce production term_arg_ -> numeral
-- On LEFTPAR reduce production term_arg_ -> numeral
-- On LEFTBRC reduce production term_arg_ -> numeral
-- On LARROW reduce production term_arg_ -> numeral
-- On INTEGER reduce production term_arg_ -> numeral
-- On INDUCTIVE reduce production term_arg_ -> numeral
-- On IN reduce production term_arg_ -> numeral
-- On IMPORT reduce production term_arg_ -> numeral
-- On GT reduce production term_arg_ -> numeral
-- On GOAL reduce production term_arg_ -> numeral
-- On FUNCTION reduce production term_arg_ -> numeral
-- On FLOAT reduce production term_arg_ -> numeral
-- On FALSE reduce production term_arg_ -> numeral
-- On EXCEPTION reduce production term_arg_ -> numeral
-- On EQUAL reduce production term_arg_ -> numeral
-- On EOF reduce production term_arg_ -> numeral
-- On END reduce production term_arg_ -> numeral
-- On ELSE reduce production term_arg_ -> numeral
-- On DOTDOT reduce production term_arg_ -> numeral
-- On CORE_UIDENT reduce production term_arg_ -> numeral
-- On CORE_LIDENT reduce production term_arg_ -> numeral
-- On CONSTANT reduce production term_arg_ -> numeral
-- On COMMA reduce production term_arg_ -> numeral
-- On COLON reduce production term_arg_ -> numeral
-- On COINDUCTIVE reduce production term_arg_ -> numeral
-- On CLONE reduce production term_arg_ -> numeral
-- On BY reduce production term_arg_ -> numeral
-- On BEGIN reduce production term_arg_ -> numeral
-- On BARBAR reduce production term_arg_ -> numeral
-- On BAR reduce production term_arg_ -> numeral
-- On AXIOM reduce production term_arg_ -> numeral
-- On AT reduce production term_arg_ -> numeral
-- On ARROW reduce production term_arg_ -> numeral
-- On AND reduce production term_arg_ -> numeral
-- On AMPAMP reduce production term_arg_ -> numeral

State 350:
## Known stack suffix:
## mk_term(term_dot_)
## LR(1) items:
term_dot -> mk_term(term_dot_) . [ DOT ]
## Transitions:
## Reductions:
-- On DOT reduce production term_dot -> mk_term(term_dot_)

State 351:
## Known stack suffix:
## mk_term(term_arg_)
## LR(1) items:
term_arg -> mk_term(term_arg_) . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_arg -> mk_term(term_arg_)
-- On VAL reduce production term_arg -> mk_term(term_arg_)
-- On USE reduce production term_arg -> mk_term(term_arg_)
-- On UIDENT reduce production term_arg -> mk_term(term_arg_)
-- On TYPE reduce production term_arg -> mk_term(term_arg_)
-- On TRUE reduce production term_arg -> mk_term(term_arg_)
-- On THEN reduce production term_arg -> mk_term(term_arg_)
-- On SO reduce production term_arg -> mk_term(term_arg_)
-- On SEMICOLON reduce production term_arg -> mk_term(term_arg_)
-- On SCOPE reduce production term_arg -> mk_term(term_arg_)
-- On RIGHTSQ_QUOTE reduce production term_arg -> mk_term(term_arg_)
-- On RIGHTSQ reduce production term_arg -> mk_term(term_arg_)
-- On RIGHTPAR reduce production term_arg -> mk_term(term_arg_)
-- On RIGHTBRC reduce production term_arg -> mk_term(term_arg_)
-- On REAL reduce production term_arg -> mk_term(term_arg_)
-- On RANGE reduce production term_arg -> mk_term(term_arg_)
-- On PREDICATE reduce production term_arg -> mk_term(term_arg_)
-- On OR reduce production term_arg -> mk_term(term_arg_)
-- On OPPREF reduce production term_arg -> mk_term(term_arg_)
-- On OP4 reduce production term_arg -> mk_term(term_arg_)
-- On OP3 reduce production term_arg -> mk_term(term_arg_)
-- On OP2 reduce production term_arg -> mk_term(term_arg_)
-- On OP1 reduce production term_arg -> mk_term(term_arg_)
-- On MINUS reduce production term_arg -> mk_term(term_arg_)
-- On META reduce production term_arg -> mk_term(term_arg_)
-- On LTGT reduce production term_arg -> mk_term(term_arg_)
-- On LT reduce production term_arg -> mk_term(term_arg_)
-- On LRARROW reduce production term_arg -> mk_term(term_arg_)
-- On LIDENT reduce production term_arg -> mk_term(term_arg_)
-- On LET reduce production term_arg -> mk_term(term_arg_)
-- On LEMMA reduce production term_arg -> mk_term(term_arg_)
-- On LEFTSQ reduce production term_arg -> mk_term(term_arg_)
-- On LEFTPAR reduce production term_arg -> mk_term(term_arg_)
-- On LEFTBRC reduce production term_arg -> mk_term(term_arg_)
-- On LARROW reduce production term_arg -> mk_term(term_arg_)
-- On INTEGER reduce production term_arg -> mk_term(term_arg_)
-- On INDUCTIVE reduce production term_arg -> mk_term(term_arg_)
-- On IN reduce production term_arg -> mk_term(term_arg_)
-- On IMPORT reduce production term_arg -> mk_term(term_arg_)
-- On GT reduce production term_arg -> mk_term(term_arg_)
-- On GOAL reduce production term_arg -> mk_term(term_arg_)
-- On FUNCTION reduce production term_arg -> mk_term(term_arg_)
-- On FLOAT reduce production term_arg -> mk_term(term_arg_)
-- On FALSE reduce production term_arg -> mk_term(term_arg_)
-- On EXCEPTION reduce production term_arg -> mk_term(term_arg_)
-- On EQUAL reduce production term_arg -> mk_term(term_arg_)
-- On EOF reduce production term_arg -> mk_term(term_arg_)
-- On END reduce production term_arg -> mk_term(term_arg_)
-- On ELSE reduce production term_arg -> mk_term(term_arg_)
-- On DOTDOT reduce production term_arg -> mk_term(term_arg_)
-- On CORE_UIDENT reduce production term_arg -> mk_term(term_arg_)
-- On CORE_LIDENT reduce production term_arg -> mk_term(term_arg_)
-- On CONSTANT reduce production term_arg -> mk_term(term_arg_)
-- On COMMA reduce production term_arg -> mk_term(term_arg_)
-- On COLON reduce production term_arg -> mk_term(term_arg_)
-- On COINDUCTIVE reduce production term_arg -> mk_term(term_arg_)
-- On CLONE reduce production term_arg -> mk_term(term_arg_)
-- On BY reduce production term_arg -> mk_term(term_arg_)
-- On BEGIN reduce production term_arg -> mk_term(term_arg_)
-- On BARBAR reduce production term_arg -> mk_term(term_arg_)
-- On BAR reduce production term_arg -> mk_term(term_arg_)
-- On AXIOM reduce production term_arg -> mk_term(term_arg_)
-- On AT reduce production term_arg -> mk_term(term_arg_)
-- On ARROW reduce production term_arg -> mk_term(term_arg_)
-- On AND reduce production term_arg -> mk_term(term_arg_)
-- On AMPAMP reduce production term_arg -> mk_term(term_arg_)

State 352:
## Known stack suffix:
## mk_term(single_term_)
## LR(1) items:
single_term -> mk_term(single_term_) . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term -> mk_term(single_term_)
-- On VAL reduce production single_term -> mk_term(single_term_)
-- On USE reduce production single_term -> mk_term(single_term_)
-- On TYPE reduce production single_term -> mk_term(single_term_)
-- On THEN reduce production single_term -> mk_term(single_term_)
-- On SO reduce production single_term -> mk_term(single_term_)
-- On SEMICOLON reduce production single_term -> mk_term(single_term_)
-- On SCOPE reduce production single_term -> mk_term(single_term_)
-- On RIGHTSQ_QUOTE reduce production single_term -> mk_term(single_term_)
-- On RIGHTSQ reduce production single_term -> mk_term(single_term_)
-- On RIGHTPAR reduce production single_term -> mk_term(single_term_)
-- On RIGHTBRC reduce production single_term -> mk_term(single_term_)
-- On PREDICATE reduce production single_term -> mk_term(single_term_)
-- On OR reduce production single_term -> mk_term(single_term_)
-- On OP4 reduce production single_term -> mk_term(single_term_)
-- On OP3 reduce production single_term -> mk_term(single_term_)
-- On OP2 reduce production single_term -> mk_term(single_term_)
-- On OP1 reduce production single_term -> mk_term(single_term_)
-- On MINUS reduce production single_term -> mk_term(single_term_)
-- On META reduce production single_term -> mk_term(single_term_)
-- On LTGT reduce production single_term -> mk_term(single_term_)
-- On LT reduce production single_term -> mk_term(single_term_)
-- On LRARROW reduce production single_term -> mk_term(single_term_)
-- On LET reduce production single_term -> mk_term(single_term_)
-- On LEMMA reduce production single_term -> mk_term(single_term_)
-- On LARROW reduce production single_term -> mk_term(single_term_)
-- On INDUCTIVE reduce production single_term -> mk_term(single_term_)
-- On IN reduce production single_term -> mk_term(single_term_)
-- On IMPORT reduce production single_term -> mk_term(single_term_)
-- On GT reduce production single_term -> mk_term(single_term_)
-- On GOAL reduce production single_term -> mk_term(single_term_)
-- On FUNCTION reduce production single_term -> mk_term(single_term_)
-- On EXCEPTION reduce production single_term -> mk_term(single_term_)
-- On EQUAL reduce production single_term -> mk_term(single_term_)
-- On EOF reduce production single_term -> mk_term(single_term_)
-- On END reduce production single_term -> mk_term(single_term_)
-- On ELSE reduce production single_term -> mk_term(single_term_)
-- On DOTDOT reduce production single_term -> mk_term(single_term_)
-- On CONSTANT reduce production single_term -> mk_term(single_term_)
-- On COMMA reduce production single_term -> mk_term(single_term_)
-- On COLON reduce production single_term -> mk_term(single_term_)
-- On COINDUCTIVE reduce production single_term -> mk_term(single_term_)
-- On CLONE reduce production single_term -> mk_term(single_term_)
-- On BY reduce production single_term -> mk_term(single_term_)
-- On BARBAR reduce production single_term -> mk_term(single_term_)
-- On BAR reduce production single_term -> mk_term(single_term_)
-- On AXIOM reduce production single_term -> mk_term(single_term_)
-- On AT reduce production single_term -> mk_term(single_term_)
-- On ARROW reduce production single_term -> mk_term(single_term_)
-- On AND reduce production single_term -> mk_term(single_term_)
-- On AMPAMP reduce production single_term -> mk_term(single_term_)

State 353:
## Known stack suffix:
## lqualid
## LR(1) items:
term_dot_ -> lqualid . [ DOT ]
## Transitions:
## Reductions:
-- On DOT reduce production term_dot_ -> lqualid

State 354:
## Known stack suffix:
## lident
## LR(1) items:
ident -> lident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
lqualid -> lident . [ DOT ]
## Transitions:
## Reductions:
-- On WRITES reduce production ident -> lident
-- On WITH reduce production ident -> lident
-- On VARIANT reduce production ident -> lident
-- On VAL reduce production ident -> lident
-- On USE reduce production ident -> lident
-- On UIDENT reduce production ident -> lident
-- On TYPE reduce production ident -> lident
-- On TRUE reduce production ident -> lident
-- On TO reduce production ident -> lident
-- On THEN reduce production ident -> lident
-- On SO reduce production ident -> lident
-- On SEMICOLON reduce production ident -> lident
-- On SCOPE reduce production ident -> lident
-- On RIGHTSQ_QUOTE reduce production ident -> lident
-- On RIGHTSQ reduce production ident -> lident
-- On RIGHTPAR reduce production ident -> lident
-- On RIGHTBRC reduce production ident -> lident
-- On RETURNS reduce production ident -> lident
-- On REQUIRES reduce production ident -> lident
-- On REAL reduce production ident -> lident
-- On READS reduce production ident -> lident
-- On RANGE reduce production ident -> lident
-- On RAISES reduce production ident -> lident
-- On PURE reduce production ident -> lident
-- On PREDICATE reduce production ident -> lident
-- On OR reduce production ident -> lident
-- On OPPREF reduce production ident -> lident
-- On OP4 reduce production ident -> lident
-- On OP3 reduce production ident -> lident
-- On OP2 reduce production ident -> lident
-- On OP1 reduce production ident -> lident
-- On MINUS reduce production ident -> lident
-- On META reduce production ident -> lident
-- On LTGT reduce production ident -> lident
-- On LT reduce production ident -> lident
-- On LRARROW reduce production ident -> lident
-- On LIDENT reduce production ident -> lident
-- On LET reduce production ident -> lident
-- On LEMMA reduce production ident -> lident
-- On LEFTSQ reduce production ident -> lident
-- On LEFTPAR reduce production ident -> lident
-- On LEFTBRC reduce production ident -> lident
-- On LARROW reduce production ident -> lident
-- On INTEGER reduce production ident -> lident
-- On INDUCTIVE reduce production ident -> lident
-- On IN reduce production ident -> lident
-- On IMPORT reduce production ident -> lident
-- On GT reduce production ident -> lident
-- On GOAL reduce production ident -> lident
-- On FUNCTION reduce production ident -> lident
-- On FLOAT reduce production ident -> lident
-- On FALSE reduce production ident -> lident
-- On EXCEPTION reduce production ident -> lident
-- On EQUAL reduce production ident -> lident
-- On EOF reduce production ident -> lident
-- On ENSURES reduce production ident -> lident
-- On END reduce production ident -> lident
-- On ELSE reduce production ident -> lident
-- On DOWNTO reduce production ident -> lident
-- On DOTDOT reduce production ident -> lident
-- On DOT reduce production lqualid -> lident
-- On DONE reduce production ident -> lident
-- On DO reduce production ident -> lident
-- On DIVERGES reduce production ident -> lident
-- On CORE_UIDENT reduce production ident -> lident
-- On CORE_LIDENT reduce production ident -> lident
-- On CONSTANT reduce production ident -> lident
-- On COMMA reduce production ident -> lident
-- On COLON reduce production ident -> lident
-- On COINDUCTIVE reduce production ident -> lident
-- On CLONE reduce production ident -> lident
-- On BY reduce production ident -> lident
-- On BEGIN reduce production ident -> lident
-- On BARBAR reduce production ident -> lident
-- On BAR reduce production ident -> lident
-- On AXIOM reduce production ident -> lident
-- On AT reduce production ident -> lident
-- On ARROW reduce production ident -> lident
-- On AND reduce production ident -> lident
-- On AMPAMP reduce production ident -> lident
-- On ALIAS reduce production ident -> lident

State 355:
## Known stack suffix:
## ident
## LR(1) items:
qualid -> ident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production qualid -> ident
-- On WITH reduce production qualid -> ident
-- On VARIANT reduce production qualid -> ident
-- On VAL reduce production qualid -> ident
-- On USE reduce production qualid -> ident
-- On UIDENT reduce production qualid -> ident
-- On TYPE reduce production qualid -> ident
-- On TRUE reduce production qualid -> ident
-- On TO reduce production qualid -> ident
-- On THEN reduce production qualid -> ident
-- On SO reduce production qualid -> ident
-- On SEMICOLON reduce production qualid -> ident
-- On SCOPE reduce production qualid -> ident
-- On RIGHTSQ_QUOTE reduce production qualid -> ident
-- On RIGHTSQ reduce production qualid -> ident
-- On RIGHTPAR reduce production qualid -> ident
-- On RIGHTBRC reduce production qualid -> ident
-- On RETURNS reduce production qualid -> ident
-- On REQUIRES reduce production qualid -> ident
-- On REAL reduce production qualid -> ident
-- On READS reduce production qualid -> ident
-- On RANGE reduce production qualid -> ident
-- On RAISES reduce production qualid -> ident
-- On QUOTE_LIDENT reduce production qualid -> ident
-- On PURE reduce production qualid -> ident
-- On PREDICATE reduce production qualid -> ident
-- On OR reduce production qualid -> ident
-- On OPPREF reduce production qualid -> ident
-- On OP4 reduce production qualid -> ident
-- On OP3 reduce production qualid -> ident
-- On OP2 reduce production qualid -> ident
-- On OP1 reduce production qualid -> ident
-- On MINUS reduce production qualid -> ident
-- On META reduce production qualid -> ident
-- On LTGT reduce production qualid -> ident
-- On LT reduce production qualid -> ident
-- On LRARROW reduce production qualid -> ident
-- On LIDENT reduce production qualid -> ident
-- On LET reduce production qualid -> ident
-- On LEMMA reduce production qualid -> ident
-- On LEFTSQ reduce production qualid -> ident
-- On LEFTPAR reduce production qualid -> ident
-- On LEFTBRC reduce production qualid -> ident
-- On LARROW reduce production qualid -> ident
-- On INTEGER reduce production qualid -> ident
-- On INDUCTIVE reduce production qualid -> ident
-- On IN reduce production qualid -> ident
-- On IMPORT reduce production qualid -> ident
-- On GT reduce production qualid -> ident
-- On GOAL reduce production qualid -> ident
-- On FUNCTION reduce production qualid -> ident
-- On FLOAT reduce production qualid -> ident
-- On FALSE reduce production qualid -> ident
-- On EXCEPTION reduce production qualid -> ident
-- On EQUAL reduce production qualid -> ident
-- On EOF reduce production qualid -> ident
-- On ENSURES reduce production qualid -> ident
-- On END reduce production qualid -> ident
-- On ELSE reduce production qualid -> ident
-- On DOWNTO reduce production qualid -> ident
-- On DOTDOT reduce production qualid -> ident
-- On DONE reduce production qualid -> ident
-- On DO reduce production qualid -> ident
-- On DIVERGES reduce production qualid -> ident
-- On CORE_UIDENT reduce production qualid -> ident
-- On CORE_LIDENT reduce production qualid -> ident
-- On CONSTANT reduce production qualid -> ident
-- On COMMA reduce production qualid -> ident
-- On COLON reduce production qualid -> ident
-- On COINDUCTIVE reduce production qualid -> ident
-- On CLONE reduce production qualid -> ident
-- On BY reduce production qualid -> ident
-- On BEGIN reduce production qualid -> ident
-- On BARBAR reduce production qualid -> ident
-- On BAR reduce production qualid -> ident
-- On AXIOM reduce production qualid -> ident
-- On AT reduce production qualid -> ident
-- On ARROW reduce production qualid -> ident
-- On AND reduce production qualid -> ident
-- On AMPAMP reduce production qualid -> ident
-- On ALIAS reduce production qualid -> ident

State 356:
## Known stack suffix:
## attr
## LR(1) items:
single_term_ -> attr . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 357
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 357:
## Known stack suffix:
## attr single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> attr single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On COLON shift to state 132
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> attr single_term
-- On VAL reduce production single_term_ -> attr single_term
-- On USE reduce production single_term_ -> attr single_term
-- On TYPE reduce production single_term_ -> attr single_term
-- On THEN reduce production single_term_ -> attr single_term
-- On SEMICOLON reduce production single_term_ -> attr single_term
-- On SCOPE reduce production single_term_ -> attr single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> attr single_term
-- On RIGHTSQ reduce production single_term_ -> attr single_term
-- On RIGHTPAR reduce production single_term_ -> attr single_term
-- On RIGHTBRC reduce production single_term_ -> attr single_term
-- On PREDICATE reduce production single_term_ -> attr single_term
-- On META reduce production single_term_ -> attr single_term
-- On LET reduce production single_term_ -> attr single_term
-- On LEMMA reduce production single_term_ -> attr single_term
-- On LARROW reduce production single_term_ -> attr single_term
-- On INDUCTIVE reduce production single_term_ -> attr single_term
-- On IN reduce production single_term_ -> attr single_term
-- On IMPORT reduce production single_term_ -> attr single_term
-- On GOAL reduce production single_term_ -> attr single_term
-- On FUNCTION reduce production single_term_ -> attr single_term
-- On EXCEPTION reduce production single_term_ -> attr single_term
-- On EOF reduce production single_term_ -> attr single_term
-- On END reduce production single_term_ -> attr single_term
-- On ELSE reduce production single_term_ -> attr single_term
-- On DOTDOT reduce production single_term_ -> attr single_term
-- On CONSTANT reduce production single_term_ -> attr single_term
-- On COMMA reduce production single_term_ -> attr single_term
-- On COINDUCTIVE reduce production single_term_ -> attr single_term
-- On CLONE reduce production single_term_ -> attr single_term
-- On BAR reduce production single_term_ -> attr single_term
-- On AXIOM reduce production single_term_ -> attr single_term

State 358:
## Known stack suffix:
## single_term OP2
## LR(1) items:
single_term_ -> single_term OP2 . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 359
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 359:
## Known stack suffix:
## single_term OP2 single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term OP2 single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term OP2 single_term
-- On VAL reduce production single_term_ -> single_term OP2 single_term
-- On USE reduce production single_term_ -> single_term OP2 single_term
-- On TYPE reduce production single_term_ -> single_term OP2 single_term
-- On THEN reduce production single_term_ -> single_term OP2 single_term
-- On SO reduce production single_term_ -> single_term OP2 single_term
-- On SEMICOLON reduce production single_term_ -> single_term OP2 single_term
-- On SCOPE reduce production single_term_ -> single_term OP2 single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term OP2 single_term
-- On RIGHTSQ reduce production single_term_ -> single_term OP2 single_term
-- On RIGHTPAR reduce production single_term_ -> single_term OP2 single_term
-- On RIGHTBRC reduce production single_term_ -> single_term OP2 single_term
-- On PREDICATE reduce production single_term_ -> single_term OP2 single_term
-- On OR reduce production single_term_ -> single_term OP2 single_term
-- On OP2 reduce production single_term_ -> single_term OP2 single_term
-- On OP1 reduce production single_term_ -> single_term OP2 single_term
-- On MINUS reduce production single_term_ -> single_term OP2 single_term
-- On META reduce production single_term_ -> single_term OP2 single_term
-- On LTGT reduce production single_term_ -> single_term OP2 single_term
-- On LT reduce production single_term_ -> single_term OP2 single_term
-- On LRARROW reduce production single_term_ -> single_term OP2 single_term
-- On LET reduce production single_term_ -> single_term OP2 single_term
-- On LEMMA reduce production single_term_ -> single_term OP2 single_term
-- On LARROW reduce production single_term_ -> single_term OP2 single_term
-- On INDUCTIVE reduce production single_term_ -> single_term OP2 single_term
-- On IN reduce production single_term_ -> single_term OP2 single_term
-- On IMPORT reduce production single_term_ -> single_term OP2 single_term
-- On GT reduce production single_term_ -> single_term OP2 single_term
-- On GOAL reduce production single_term_ -> single_term OP2 single_term
-- On FUNCTION reduce production single_term_ -> single_term OP2 single_term
-- On EXCEPTION reduce production single_term_ -> single_term OP2 single_term
-- On EQUAL reduce production single_term_ -> single_term OP2 single_term
-- On EOF reduce production single_term_ -> single_term OP2 single_term
-- On END reduce production single_term_ -> single_term OP2 single_term
-- On ELSE reduce production single_term_ -> single_term OP2 single_term
-- On DOTDOT reduce production single_term_ -> single_term OP2 single_term
-- On CONSTANT reduce production single_term_ -> single_term OP2 single_term
-- On COMMA reduce production single_term_ -> single_term OP2 single_term
-- On COLON reduce production single_term_ -> single_term OP2 single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term OP2 single_term
-- On CLONE reduce production single_term_ -> single_term OP2 single_term
-- On BY reduce production single_term_ -> single_term OP2 single_term
-- On BARBAR reduce production single_term_ -> single_term OP2 single_term
-- On BAR reduce production single_term_ -> single_term OP2 single_term
-- On AXIOM reduce production single_term_ -> single_term OP2 single_term
-- On AT reduce production single_term_ -> single_term OP2 single_term
-- On ARROW reduce production single_term_ -> single_term OP2 single_term
-- On AND reduce production single_term_ -> single_term OP2 single_term
-- On AMPAMP reduce production single_term_ -> single_term OP2 single_term

State 360:
## Known stack suffix:
## single_term OP1
## LR(1) items:
single_term_ -> single_term OP1 . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 361
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 361:
## Known stack suffix:
## single_term OP1 single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term OP1 single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term OP1 single_term
-- On VAL reduce production single_term_ -> single_term OP1 single_term
-- On USE reduce production single_term_ -> single_term OP1 single_term
-- On TYPE reduce production single_term_ -> single_term OP1 single_term
-- On THEN reduce production single_term_ -> single_term OP1 single_term
-- On SO reduce production single_term_ -> single_term OP1 single_term
-- On SEMICOLON reduce production single_term_ -> single_term OP1 single_term
-- On SCOPE reduce production single_term_ -> single_term OP1 single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term OP1 single_term
-- On RIGHTSQ reduce production single_term_ -> single_term OP1 single_term
-- On RIGHTPAR reduce production single_term_ -> single_term OP1 single_term
-- On RIGHTBRC reduce production single_term_ -> single_term OP1 single_term
-- On PREDICATE reduce production single_term_ -> single_term OP1 single_term
-- On OR reduce production single_term_ -> single_term OP1 single_term
-- On META reduce production single_term_ -> single_term OP1 single_term
-- On LRARROW reduce production single_term_ -> single_term OP1 single_term
-- On LET reduce production single_term_ -> single_term OP1 single_term
-- On LEMMA reduce production single_term_ -> single_term OP1 single_term
-- On LARROW reduce production single_term_ -> single_term OP1 single_term
-- On INDUCTIVE reduce production single_term_ -> single_term OP1 single_term
-- On IN reduce production single_term_ -> single_term OP1 single_term
-- On IMPORT reduce production single_term_ -> single_term OP1 single_term
-- On GOAL reduce production single_term_ -> single_term OP1 single_term
-- On FUNCTION reduce production single_term_ -> single_term OP1 single_term
-- On EXCEPTION reduce production single_term_ -> single_term OP1 single_term
-- On EOF reduce production single_term_ -> single_term OP1 single_term
-- On END reduce production single_term_ -> single_term OP1 single_term
-- On ELSE reduce production single_term_ -> single_term OP1 single_term
-- On DOTDOT reduce production single_term_ -> single_term OP1 single_term
-- On CONSTANT reduce production single_term_ -> single_term OP1 single_term
-- On COMMA reduce production single_term_ -> single_term OP1 single_term
-- On COLON reduce production single_term_ -> single_term OP1 single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term OP1 single_term
-- On CLONE reduce production single_term_ -> single_term OP1 single_term
-- On BY reduce production single_term_ -> single_term OP1 single_term
-- On BARBAR reduce production single_term_ -> single_term OP1 single_term
-- On BAR reduce production single_term_ -> single_term OP1 single_term
-- On AXIOM reduce production single_term_ -> single_term OP1 single_term
-- On ARROW reduce production single_term_ -> single_term OP1 single_term
-- On AND reduce production single_term_ -> single_term OP1 single_term
-- On AMPAMP reduce production single_term_ -> single_term OP1 single_term

State 362:
## Known stack suffix:
## single_term MINUS
## LR(1) items:
single_term_ -> single_term MINUS . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 363
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 363:
## Known stack suffix:
## single_term MINUS single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term MINUS single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term MINUS single_term
-- On VAL reduce production single_term_ -> single_term MINUS single_term
-- On USE reduce production single_term_ -> single_term MINUS single_term
-- On TYPE reduce production single_term_ -> single_term MINUS single_term
-- On THEN reduce production single_term_ -> single_term MINUS single_term
-- On SO reduce production single_term_ -> single_term MINUS single_term
-- On SEMICOLON reduce production single_term_ -> single_term MINUS single_term
-- On SCOPE reduce production single_term_ -> single_term MINUS single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term MINUS single_term
-- On RIGHTSQ reduce production single_term_ -> single_term MINUS single_term
-- On RIGHTPAR reduce production single_term_ -> single_term MINUS single_term
-- On RIGHTBRC reduce production single_term_ -> single_term MINUS single_term
-- On PREDICATE reduce production single_term_ -> single_term MINUS single_term
-- On OR reduce production single_term_ -> single_term MINUS single_term
-- On OP2 reduce production single_term_ -> single_term MINUS single_term
-- On OP1 reduce production single_term_ -> single_term MINUS single_term
-- On MINUS reduce production single_term_ -> single_term MINUS single_term
-- On META reduce production single_term_ -> single_term MINUS single_term
-- On LTGT reduce production single_term_ -> single_term MINUS single_term
-- On LT reduce production single_term_ -> single_term MINUS single_term
-- On LRARROW reduce production single_term_ -> single_term MINUS single_term
-- On LET reduce production single_term_ -> single_term MINUS single_term
-- On LEMMA reduce production single_term_ -> single_term MINUS single_term
-- On LARROW reduce production single_term_ -> single_term MINUS single_term
-- On INDUCTIVE reduce production single_term_ -> single_term MINUS single_term
-- On IN reduce production single_term_ -> single_term MINUS single_term
-- On IMPORT reduce production single_term_ -> single_term MINUS single_term
-- On GT reduce production single_term_ -> single_term MINUS single_term
-- On GOAL reduce production single_term_ -> single_term MINUS single_term
-- On FUNCTION reduce production single_term_ -> single_term MINUS single_term
-- On EXCEPTION reduce production single_term_ -> single_term MINUS single_term
-- On EQUAL reduce production single_term_ -> single_term MINUS single_term
-- On EOF reduce production single_term_ -> single_term MINUS single_term
-- On END reduce production single_term_ -> single_term MINUS single_term
-- On ELSE reduce production single_term_ -> single_term MINUS single_term
-- On DOTDOT reduce production single_term_ -> single_term MINUS single_term
-- On CONSTANT reduce production single_term_ -> single_term MINUS single_term
-- On COMMA reduce production single_term_ -> single_term MINUS single_term
-- On COLON reduce production single_term_ -> single_term MINUS single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term MINUS single_term
-- On CLONE reduce production single_term_ -> single_term MINUS single_term
-- On BY reduce production single_term_ -> single_term MINUS single_term
-- On BARBAR reduce production single_term_ -> single_term MINUS single_term
-- On BAR reduce production single_term_ -> single_term MINUS single_term
-- On AXIOM reduce production single_term_ -> single_term MINUS single_term
-- On AT reduce production single_term_ -> single_term MINUS single_term
-- On ARROW reduce production single_term_ -> single_term MINUS single_term
-- On AND reduce production single_term_ -> single_term MINUS single_term
-- On AMPAMP reduce production single_term_ -> single_term MINUS single_term

State 364:
## Known stack suffix:
## single_term LTGT
## LR(1) items:
single_term_ -> single_term LTGT . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 365
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 365:
## Known stack suffix:
## single_term LTGT single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term LTGT single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term LTGT single_term
-- On VAL reduce production single_term_ -> single_term LTGT single_term
-- On USE reduce production single_term_ -> single_term LTGT single_term
-- On TYPE reduce production single_term_ -> single_term LTGT single_term
-- On THEN reduce production single_term_ -> single_term LTGT single_term
-- On SO reduce production single_term_ -> single_term LTGT single_term
-- On SEMICOLON reduce production single_term_ -> single_term LTGT single_term
-- On SCOPE reduce production single_term_ -> single_term LTGT single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term LTGT single_term
-- On RIGHTSQ reduce production single_term_ -> single_term LTGT single_term
-- On RIGHTPAR reduce production single_term_ -> single_term LTGT single_term
-- On RIGHTBRC reduce production single_term_ -> single_term LTGT single_term
-- On PREDICATE reduce production single_term_ -> single_term LTGT single_term
-- On OR reduce production single_term_ -> single_term LTGT single_term
-- On META reduce production single_term_ -> single_term LTGT single_term
-- On LRARROW reduce production single_term_ -> single_term LTGT single_term
-- On LET reduce production single_term_ -> single_term LTGT single_term
-- On LEMMA reduce production single_term_ -> single_term LTGT single_term
-- On LARROW reduce production single_term_ -> single_term LTGT single_term
-- On INDUCTIVE reduce production single_term_ -> single_term LTGT single_term
-- On IN reduce production single_term_ -> single_term LTGT single_term
-- On IMPORT reduce production single_term_ -> single_term LTGT single_term
-- On GOAL reduce production single_term_ -> single_term LTGT single_term
-- On FUNCTION reduce production single_term_ -> single_term LTGT single_term
-- On EXCEPTION reduce production single_term_ -> single_term LTGT single_term
-- On EOF reduce production single_term_ -> single_term LTGT single_term
-- On END reduce production single_term_ -> single_term LTGT single_term
-- On ELSE reduce production single_term_ -> single_term LTGT single_term
-- On DOTDOT reduce production single_term_ -> single_term LTGT single_term
-- On CONSTANT reduce production single_term_ -> single_term LTGT single_term
-- On COMMA reduce production single_term_ -> single_term LTGT single_term
-- On COLON reduce production single_term_ -> single_term LTGT single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term LTGT single_term
-- On CLONE reduce production single_term_ -> single_term LTGT single_term
-- On BY reduce production single_term_ -> single_term LTGT single_term
-- On BARBAR reduce production single_term_ -> single_term LTGT single_term
-- On BAR reduce production single_term_ -> single_term LTGT single_term
-- On AXIOM reduce production single_term_ -> single_term LTGT single_term
-- On ARROW reduce production single_term_ -> single_term LTGT single_term
-- On AND reduce production single_term_ -> single_term LTGT single_term
-- On AMPAMP reduce production single_term_ -> single_term LTGT single_term

State 366:
## Known stack suffix:
## single_term LT
## LR(1) items:
single_term_ -> single_term LT . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 367
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 367:
## Known stack suffix:
## single_term LT single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term LT single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term LT single_term
-- On VAL reduce production single_term_ -> single_term LT single_term
-- On USE reduce production single_term_ -> single_term LT single_term
-- On TYPE reduce production single_term_ -> single_term LT single_term
-- On THEN reduce production single_term_ -> single_term LT single_term
-- On SO reduce production single_term_ -> single_term LT single_term
-- On SEMICOLON reduce production single_term_ -> single_term LT single_term
-- On SCOPE reduce production single_term_ -> single_term LT single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term LT single_term
-- On RIGHTSQ reduce production single_term_ -> single_term LT single_term
-- On RIGHTPAR reduce production single_term_ -> single_term LT single_term
-- On RIGHTBRC reduce production single_term_ -> single_term LT single_term
-- On PREDICATE reduce production single_term_ -> single_term LT single_term
-- On OR reduce production single_term_ -> single_term LT single_term
-- On META reduce production single_term_ -> single_term LT single_term
-- On LRARROW reduce production single_term_ -> single_term LT single_term
-- On LET reduce production single_term_ -> single_term LT single_term
-- On LEMMA reduce production single_term_ -> single_term LT single_term
-- On LARROW reduce production single_term_ -> single_term LT single_term
-- On INDUCTIVE reduce production single_term_ -> single_term LT single_term
-- On IN reduce production single_term_ -> single_term LT single_term
-- On IMPORT reduce production single_term_ -> single_term LT single_term
-- On GOAL reduce production single_term_ -> single_term LT single_term
-- On FUNCTION reduce production single_term_ -> single_term LT single_term
-- On EXCEPTION reduce production single_term_ -> single_term LT single_term
-- On EOF reduce production single_term_ -> single_term LT single_term
-- On END reduce production single_term_ -> single_term LT single_term
-- On ELSE reduce production single_term_ -> single_term LT single_term
-- On DOTDOT reduce production single_term_ -> single_term LT single_term
-- On CONSTANT reduce production single_term_ -> single_term LT single_term
-- On COMMA reduce production single_term_ -> single_term LT single_term
-- On COLON reduce production single_term_ -> single_term LT single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term LT single_term
-- On CLONE reduce production single_term_ -> single_term LT single_term
-- On BY reduce production single_term_ -> single_term LT single_term
-- On BARBAR reduce production single_term_ -> single_term LT single_term
-- On BAR reduce production single_term_ -> single_term LT single_term
-- On AXIOM reduce production single_term_ -> single_term LT single_term
-- On ARROW reduce production single_term_ -> single_term LT single_term
-- On AND reduce production single_term_ -> single_term LT single_term
-- On AMPAMP reduce production single_term_ -> single_term LT single_term

State 368:
## Known stack suffix:
## single_term GT
## LR(1) items:
single_term_ -> single_term GT . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 369
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 369:
## Known stack suffix:
## single_term GT single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term GT single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term GT single_term
-- On VAL reduce production single_term_ -> single_term GT single_term
-- On USE reduce production single_term_ -> single_term GT single_term
-- On TYPE reduce production single_term_ -> single_term GT single_term
-- On THEN reduce production single_term_ -> single_term GT single_term
-- On SO reduce production single_term_ -> single_term GT single_term
-- On SEMICOLON reduce production single_term_ -> single_term GT single_term
-- On SCOPE reduce production single_term_ -> single_term GT single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term GT single_term
-- On RIGHTSQ reduce production single_term_ -> single_term GT single_term
-- On RIGHTPAR reduce production single_term_ -> single_term GT single_term
-- On RIGHTBRC reduce production single_term_ -> single_term GT single_term
-- On PREDICATE reduce production single_term_ -> single_term GT single_term
-- On OR reduce production single_term_ -> single_term GT single_term
-- On META reduce production single_term_ -> single_term GT single_term
-- On LRARROW reduce production single_term_ -> single_term GT single_term
-- On LET reduce production single_term_ -> single_term GT single_term
-- On LEMMA reduce production single_term_ -> single_term GT single_term
-- On LARROW reduce production single_term_ -> single_term GT single_term
-- On INDUCTIVE reduce production single_term_ -> single_term GT single_term
-- On IN reduce production single_term_ -> single_term GT single_term
-- On IMPORT reduce production single_term_ -> single_term GT single_term
-- On GOAL reduce production single_term_ -> single_term GT single_term
-- On FUNCTION reduce production single_term_ -> single_term GT single_term
-- On EXCEPTION reduce production single_term_ -> single_term GT single_term
-- On EOF reduce production single_term_ -> single_term GT single_term
-- On END reduce production single_term_ -> single_term GT single_term
-- On ELSE reduce production single_term_ -> single_term GT single_term
-- On DOTDOT reduce production single_term_ -> single_term GT single_term
-- On CONSTANT reduce production single_term_ -> single_term GT single_term
-- On COMMA reduce production single_term_ -> single_term GT single_term
-- On COLON reduce production single_term_ -> single_term GT single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term GT single_term
-- On CLONE reduce production single_term_ -> single_term GT single_term
-- On BY reduce production single_term_ -> single_term GT single_term
-- On BARBAR reduce production single_term_ -> single_term GT single_term
-- On BAR reduce production single_term_ -> single_term GT single_term
-- On AXIOM reduce production single_term_ -> single_term GT single_term
-- On ARROW reduce production single_term_ -> single_term GT single_term
-- On AND reduce production single_term_ -> single_term GT single_term
-- On AMPAMP reduce production single_term_ -> single_term GT single_term

State 370:
## Known stack suffix:
## single_term EQUAL
## LR(1) items:
single_term_ -> single_term EQUAL . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 371
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 371:
## Known stack suffix:
## single_term EQUAL single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term EQUAL single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term EQUAL single_term
-- On VAL reduce production single_term_ -> single_term EQUAL single_term
-- On USE reduce production single_term_ -> single_term EQUAL single_term
-- On TYPE reduce production single_term_ -> single_term EQUAL single_term
-- On THEN reduce production single_term_ -> single_term EQUAL single_term
-- On SO reduce production single_term_ -> single_term EQUAL single_term
-- On SEMICOLON reduce production single_term_ -> single_term EQUAL single_term
-- On SCOPE reduce production single_term_ -> single_term EQUAL single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term EQUAL single_term
-- On RIGHTSQ reduce production single_term_ -> single_term EQUAL single_term
-- On RIGHTPAR reduce production single_term_ -> single_term EQUAL single_term
-- On RIGHTBRC reduce production single_term_ -> single_term EQUAL single_term
-- On PREDICATE reduce production single_term_ -> single_term EQUAL single_term
-- On OR reduce production single_term_ -> single_term EQUAL single_term
-- On META reduce production single_term_ -> single_term EQUAL single_term
-- On LRARROW reduce production single_term_ -> single_term EQUAL single_term
-- On LET reduce production single_term_ -> single_term EQUAL single_term
-- On LEMMA reduce production single_term_ -> single_term EQUAL single_term
-- On LARROW reduce production single_term_ -> single_term EQUAL single_term
-- On INDUCTIVE reduce production single_term_ -> single_term EQUAL single_term
-- On IN reduce production single_term_ -> single_term EQUAL single_term
-- On IMPORT reduce production single_term_ -> single_term EQUAL single_term
-- On GOAL reduce production single_term_ -> single_term EQUAL single_term
-- On FUNCTION reduce production single_term_ -> single_term EQUAL single_term
-- On EXCEPTION reduce production single_term_ -> single_term EQUAL single_term
-- On EOF reduce production single_term_ -> single_term EQUAL single_term
-- On END reduce production single_term_ -> single_term EQUAL single_term
-- On ELSE reduce production single_term_ -> single_term EQUAL single_term
-- On DOTDOT reduce production single_term_ -> single_term EQUAL single_term
-- On CONSTANT reduce production single_term_ -> single_term EQUAL single_term
-- On COMMA reduce production single_term_ -> single_term EQUAL single_term
-- On COLON reduce production single_term_ -> single_term EQUAL single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term EQUAL single_term
-- On CLONE reduce production single_term_ -> single_term EQUAL single_term
-- On BY reduce production single_term_ -> single_term EQUAL single_term
-- On BARBAR reduce production single_term_ -> single_term EQUAL single_term
-- On BAR reduce production single_term_ -> single_term EQUAL single_term
-- On AXIOM reduce production single_term_ -> single_term EQUAL single_term
-- On ARROW reduce production single_term_ -> single_term EQUAL single_term
-- On AND reduce production single_term_ -> single_term EQUAL single_term
-- On AMPAMP reduce production single_term_ -> single_term EQUAL single_term

State 372:
## Known stack suffix:
## single_term AT
## LR(1) items:
single_term_ -> single_term AT . uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 373
## Reductions:

State 373:
## Known stack suffix:
## single_term AT uident
## LR(1) items:
single_term_ -> single_term AT uident . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> single_term AT uident
-- On VAL reduce production single_term_ -> single_term AT uident
-- On USE reduce production single_term_ -> single_term AT uident
-- On TYPE reduce production single_term_ -> single_term AT uident
-- On THEN reduce production single_term_ -> single_term AT uident
-- On SO reduce production single_term_ -> single_term AT uident
-- On SEMICOLON reduce production single_term_ -> single_term AT uident
-- On SCOPE reduce production single_term_ -> single_term AT uident
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term AT uident
-- On RIGHTSQ reduce production single_term_ -> single_term AT uident
-- On RIGHTPAR reduce production single_term_ -> single_term AT uident
-- On RIGHTBRC reduce production single_term_ -> single_term AT uident
-- On PREDICATE reduce production single_term_ -> single_term AT uident
-- On OR reduce production single_term_ -> single_term AT uident
-- On OP4 reduce production single_term_ -> single_term AT uident
-- On OP3 reduce production single_term_ -> single_term AT uident
-- On OP2 reduce production single_term_ -> single_term AT uident
-- On OP1 reduce production single_term_ -> single_term AT uident
-- On MINUS reduce production single_term_ -> single_term AT uident
-- On META reduce production single_term_ -> single_term AT uident
-- On LTGT reduce production single_term_ -> single_term AT uident
-- On LT reduce production single_term_ -> single_term AT uident
-- On LRARROW reduce production single_term_ -> single_term AT uident
-- On LET reduce production single_term_ -> single_term AT uident
-- On LEMMA reduce production single_term_ -> single_term AT uident
-- On LARROW reduce production single_term_ -> single_term AT uident
-- On INDUCTIVE reduce production single_term_ -> single_term AT uident
-- On IN reduce production single_term_ -> single_term AT uident
-- On IMPORT reduce production single_term_ -> single_term AT uident
-- On GT reduce production single_term_ -> single_term AT uident
-- On GOAL reduce production single_term_ -> single_term AT uident
-- On FUNCTION reduce production single_term_ -> single_term AT uident
-- On EXCEPTION reduce production single_term_ -> single_term AT uident
-- On EQUAL reduce production single_term_ -> single_term AT uident
-- On EOF reduce production single_term_ -> single_term AT uident
-- On END reduce production single_term_ -> single_term AT uident
-- On ELSE reduce production single_term_ -> single_term AT uident
-- On DOTDOT reduce production single_term_ -> single_term AT uident
-- On CONSTANT reduce production single_term_ -> single_term AT uident
-- On COMMA reduce production single_term_ -> single_term AT uident
-- On COLON reduce production single_term_ -> single_term AT uident
-- On COINDUCTIVE reduce production single_term_ -> single_term AT uident
-- On CLONE reduce production single_term_ -> single_term AT uident
-- On BY reduce production single_term_ -> single_term AT uident
-- On BARBAR reduce production single_term_ -> single_term AT uident
-- On BAR reduce production single_term_ -> single_term AT uident
-- On AXIOM reduce production single_term_ -> single_term AT uident
-- On AT reduce production single_term_ -> single_term AT uident
-- On ARROW reduce production single_term_ -> single_term AT uident
-- On AND reduce production single_term_ -> single_term AT uident
-- On AMPAMP reduce production single_term_ -> single_term AT uident

State 374:
## Known stack suffix:
## single_term LRARROW
## LR(1) items:
single_term_ -> single_term LRARROW . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 375
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 375:
## Known stack suffix:
## single_term LRARROW single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term LRARROW single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term LRARROW single_term
-- On VAL reduce production single_term_ -> single_term LRARROW single_term
-- On USE reduce production single_term_ -> single_term LRARROW single_term
-- On TYPE reduce production single_term_ -> single_term LRARROW single_term
-- On THEN reduce production single_term_ -> single_term LRARROW single_term
-- On SEMICOLON reduce production single_term_ -> single_term LRARROW single_term
-- On SCOPE reduce production single_term_ -> single_term LRARROW single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term LRARROW single_term
-- On RIGHTSQ reduce production single_term_ -> single_term LRARROW single_term
-- On RIGHTPAR reduce production single_term_ -> single_term LRARROW single_term
-- On RIGHTBRC reduce production single_term_ -> single_term LRARROW single_term
-- On PREDICATE reduce production single_term_ -> single_term LRARROW single_term
-- On META reduce production single_term_ -> single_term LRARROW single_term
-- On LET reduce production single_term_ -> single_term LRARROW single_term
-- On LEMMA reduce production single_term_ -> single_term LRARROW single_term
-- On LARROW reduce production single_term_ -> single_term LRARROW single_term
-- On INDUCTIVE reduce production single_term_ -> single_term LRARROW single_term
-- On IN reduce production single_term_ -> single_term LRARROW single_term
-- On IMPORT reduce production single_term_ -> single_term LRARROW single_term
-- On GOAL reduce production single_term_ -> single_term LRARROW single_term
-- On FUNCTION reduce production single_term_ -> single_term LRARROW single_term
-- On EXCEPTION reduce production single_term_ -> single_term LRARROW single_term
-- On EOF reduce production single_term_ -> single_term LRARROW single_term
-- On END reduce production single_term_ -> single_term LRARROW single_term
-- On ELSE reduce production single_term_ -> single_term LRARROW single_term
-- On DOTDOT reduce production single_term_ -> single_term LRARROW single_term
-- On CONSTANT reduce production single_term_ -> single_term LRARROW single_term
-- On COMMA reduce production single_term_ -> single_term LRARROW single_term
-- On COLON reduce production single_term_ -> single_term LRARROW single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term LRARROW single_term
-- On CLONE reduce production single_term_ -> single_term LRARROW single_term
-- On BAR reduce production single_term_ -> single_term LRARROW single_term
-- On AXIOM reduce production single_term_ -> single_term LRARROW single_term

State 376:
## Known stack suffix:
## single_term BY
## LR(1) items:
single_term_ -> single_term BY . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 377
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 377:
## Known stack suffix:
## single_term BY single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term BY single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term BY single_term
-- On VAL reduce production single_term_ -> single_term BY single_term
-- On USE reduce production single_term_ -> single_term BY single_term
-- On TYPE reduce production single_term_ -> single_term BY single_term
-- On THEN reduce production single_term_ -> single_term BY single_term
-- On SEMICOLON reduce production single_term_ -> single_term BY single_term
-- On SCOPE reduce production single_term_ -> single_term BY single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term BY single_term
-- On RIGHTSQ reduce production single_term_ -> single_term BY single_term
-- On RIGHTPAR reduce production single_term_ -> single_term BY single_term
-- On RIGHTBRC reduce production single_term_ -> single_term BY single_term
-- On PREDICATE reduce production single_term_ -> single_term BY single_term
-- On META reduce production single_term_ -> single_term BY single_term
-- On LET reduce production single_term_ -> single_term BY single_term
-- On LEMMA reduce production single_term_ -> single_term BY single_term
-- On LARROW reduce production single_term_ -> single_term BY single_term
-- On INDUCTIVE reduce production single_term_ -> single_term BY single_term
-- On IN reduce production single_term_ -> single_term BY single_term
-- On IMPORT reduce production single_term_ -> single_term BY single_term
-- On GOAL reduce production single_term_ -> single_term BY single_term
-- On FUNCTION reduce production single_term_ -> single_term BY single_term
-- On EXCEPTION reduce production single_term_ -> single_term BY single_term
-- On EOF reduce production single_term_ -> single_term BY single_term
-- On END reduce production single_term_ -> single_term BY single_term
-- On ELSE reduce production single_term_ -> single_term BY single_term
-- On DOTDOT reduce production single_term_ -> single_term BY single_term
-- On CONSTANT reduce production single_term_ -> single_term BY single_term
-- On COMMA reduce production single_term_ -> single_term BY single_term
-- On COLON reduce production single_term_ -> single_term BY single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term BY single_term
-- On CLONE reduce production single_term_ -> single_term BY single_term
-- On BAR reduce production single_term_ -> single_term BY single_term
-- On AXIOM reduce production single_term_ -> single_term BY single_term

State 378:
## Known stack suffix:
## single_term BARBAR
## LR(1) items:
single_term_ -> single_term BARBAR . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 379
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 379:
## Known stack suffix:
## single_term BARBAR single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term BARBAR single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term BARBAR single_term
-- On VAL reduce production single_term_ -> single_term BARBAR single_term
-- On USE reduce production single_term_ -> single_term BARBAR single_term
-- On TYPE reduce production single_term_ -> single_term BARBAR single_term
-- On THEN reduce production single_term_ -> single_term BARBAR single_term
-- On SO reduce production single_term_ -> single_term BARBAR single_term
-- On SEMICOLON reduce production single_term_ -> single_term BARBAR single_term
-- On SCOPE reduce production single_term_ -> single_term BARBAR single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term BARBAR single_term
-- On RIGHTSQ reduce production single_term_ -> single_term BARBAR single_term
-- On RIGHTPAR reduce production single_term_ -> single_term BARBAR single_term
-- On RIGHTBRC reduce production single_term_ -> single_term BARBAR single_term
-- On PREDICATE reduce production single_term_ -> single_term BARBAR single_term
-- On META reduce production single_term_ -> single_term BARBAR single_term
-- On LRARROW reduce production single_term_ -> single_term BARBAR single_term
-- On LET reduce production single_term_ -> single_term BARBAR single_term
-- On LEMMA reduce production single_term_ -> single_term BARBAR single_term
-- On LARROW reduce production single_term_ -> single_term BARBAR single_term
-- On INDUCTIVE reduce production single_term_ -> single_term BARBAR single_term
-- On IN reduce production single_term_ -> single_term BARBAR single_term
-- On IMPORT reduce production single_term_ -> single_term BARBAR single_term
-- On GOAL reduce production single_term_ -> single_term BARBAR single_term
-- On FUNCTION reduce production single_term_ -> single_term BARBAR single_term
-- On EXCEPTION reduce production single_term_ -> single_term BARBAR single_term
-- On EOF reduce production single_term_ -> single_term BARBAR single_term
-- On END reduce production single_term_ -> single_term BARBAR single_term
-- On ELSE reduce production single_term_ -> single_term BARBAR single_term
-- On DOTDOT reduce production single_term_ -> single_term BARBAR single_term
-- On CONSTANT reduce production single_term_ -> single_term BARBAR single_term
-- On COMMA reduce production single_term_ -> single_term BARBAR single_term
-- On COLON reduce production single_term_ -> single_term BARBAR single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term BARBAR single_term
-- On CLONE reduce production single_term_ -> single_term BARBAR single_term
-- On BY reduce production single_term_ -> single_term BARBAR single_term
-- On BAR reduce production single_term_ -> single_term BARBAR single_term
-- On AXIOM reduce production single_term_ -> single_term BARBAR single_term
-- On ARROW reduce production single_term_ -> single_term BARBAR single_term

State 380:
## Known stack suffix:
## single_term AND
## LR(1) items:
single_term_ -> single_term AND . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 381
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 381:
## Known stack suffix:
## single_term AND single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term AND single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term AND single_term
-- On VAL reduce production single_term_ -> single_term AND single_term
-- On USE reduce production single_term_ -> single_term AND single_term
-- On TYPE reduce production single_term_ -> single_term AND single_term
-- On THEN reduce production single_term_ -> single_term AND single_term
-- On SO reduce production single_term_ -> single_term AND single_term
-- On SEMICOLON reduce production single_term_ -> single_term AND single_term
-- On SCOPE reduce production single_term_ -> single_term AND single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term AND single_term
-- On RIGHTSQ reduce production single_term_ -> single_term AND single_term
-- On RIGHTPAR reduce production single_term_ -> single_term AND single_term
-- On RIGHTBRC reduce production single_term_ -> single_term AND single_term
-- On PREDICATE reduce production single_term_ -> single_term AND single_term
-- On OR reduce production single_term_ -> single_term AND single_term
-- On META reduce production single_term_ -> single_term AND single_term
-- On LRARROW reduce production single_term_ -> single_term AND single_term
-- On LET reduce production single_term_ -> single_term AND single_term
-- On LEMMA reduce production single_term_ -> single_term AND single_term
-- On LARROW reduce production single_term_ -> single_term AND single_term
-- On INDUCTIVE reduce production single_term_ -> single_term AND single_term
-- On IN reduce production single_term_ -> single_term AND single_term
-- On IMPORT reduce production single_term_ -> single_term AND single_term
-- On GOAL reduce production single_term_ -> single_term AND single_term
-- On FUNCTION reduce production single_term_ -> single_term AND single_term
-- On EXCEPTION reduce production single_term_ -> single_term AND single_term
-- On EOF reduce production single_term_ -> single_term AND single_term
-- On END reduce production single_term_ -> single_term AND single_term
-- On ELSE reduce production single_term_ -> single_term AND single_term
-- On DOTDOT reduce production single_term_ -> single_term AND single_term
-- On CONSTANT reduce production single_term_ -> single_term AND single_term
-- On COMMA reduce production single_term_ -> single_term AND single_term
-- On COLON reduce production single_term_ -> single_term AND single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term AND single_term
-- On CLONE reduce production single_term_ -> single_term AND single_term
-- On BY reduce production single_term_ -> single_term AND single_term
-- On BARBAR reduce production single_term_ -> single_term AND single_term
-- On BAR reduce production single_term_ -> single_term AND single_term
-- On AXIOM reduce production single_term_ -> single_term AND single_term
-- On ARROW reduce production single_term_ -> single_term AND single_term

State 382:
## Known stack suffix:
## single_term AMPAMP
## LR(1) items:
single_term_ -> single_term AMPAMP . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 383
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 383:
## Known stack suffix:
## single_term AMPAMP single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term AMPAMP single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term AMPAMP single_term
-- On VAL reduce production single_term_ -> single_term AMPAMP single_term
-- On USE reduce production single_term_ -> single_term AMPAMP single_term
-- On TYPE reduce production single_term_ -> single_term AMPAMP single_term
-- On THEN reduce production single_term_ -> single_term AMPAMP single_term
-- On SO reduce production single_term_ -> single_term AMPAMP single_term
-- On SEMICOLON reduce production single_term_ -> single_term AMPAMP single_term
-- On SCOPE reduce production single_term_ -> single_term AMPAMP single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term AMPAMP single_term
-- On RIGHTSQ reduce production single_term_ -> single_term AMPAMP single_term
-- On RIGHTPAR reduce production single_term_ -> single_term AMPAMP single_term
-- On RIGHTBRC reduce production single_term_ -> single_term AMPAMP single_term
-- On PREDICATE reduce production single_term_ -> single_term AMPAMP single_term
-- On OR reduce production single_term_ -> single_term AMPAMP single_term
-- On META reduce production single_term_ -> single_term AMPAMP single_term
-- On LRARROW reduce production single_term_ -> single_term AMPAMP single_term
-- On LET reduce production single_term_ -> single_term AMPAMP single_term
-- On LEMMA reduce production single_term_ -> single_term AMPAMP single_term
-- On LARROW reduce production single_term_ -> single_term AMPAMP single_term
-- On INDUCTIVE reduce production single_term_ -> single_term AMPAMP single_term
-- On IN reduce production single_term_ -> single_term AMPAMP single_term
-- On IMPORT reduce production single_term_ -> single_term AMPAMP single_term
-- On GOAL reduce production single_term_ -> single_term AMPAMP single_term
-- On FUNCTION reduce production single_term_ -> single_term AMPAMP single_term
-- On EXCEPTION reduce production single_term_ -> single_term AMPAMP single_term
-- On EOF reduce production single_term_ -> single_term AMPAMP single_term
-- On END reduce production single_term_ -> single_term AMPAMP single_term
-- On ELSE reduce production single_term_ -> single_term AMPAMP single_term
-- On DOTDOT reduce production single_term_ -> single_term AMPAMP single_term
-- On CONSTANT reduce production single_term_ -> single_term AMPAMP single_term
-- On COMMA reduce production single_term_ -> single_term AMPAMP single_term
-- On COLON reduce production single_term_ -> single_term AMPAMP single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term AMPAMP single_term
-- On CLONE reduce production single_term_ -> single_term AMPAMP single_term
-- On BY reduce production single_term_ -> single_term AMPAMP single_term
-- On BARBAR reduce production single_term_ -> single_term AMPAMP single_term
-- On BAR reduce production single_term_ -> single_term AMPAMP single_term
-- On AXIOM reduce production single_term_ -> single_term AMPAMP single_term
-- On ARROW reduce production single_term_ -> single_term AMPAMP single_term

State 384:
## Known stack suffix:
## single_term ARROW
## LR(1) items:
single_term_ -> single_term ARROW . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 385
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 385:
## Known stack suffix:
## single_term ARROW single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term ARROW single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> single_term ARROW single_term
-- On VAL reduce production single_term_ -> single_term ARROW single_term
-- On USE reduce production single_term_ -> single_term ARROW single_term
-- On TYPE reduce production single_term_ -> single_term ARROW single_term
-- On THEN reduce production single_term_ -> single_term ARROW single_term
-- On SEMICOLON reduce production single_term_ -> single_term ARROW single_term
-- On SCOPE reduce production single_term_ -> single_term ARROW single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> single_term ARROW single_term
-- On RIGHTSQ reduce production single_term_ -> single_term ARROW single_term
-- On RIGHTPAR reduce production single_term_ -> single_term ARROW single_term
-- On RIGHTBRC reduce production single_term_ -> single_term ARROW single_term
-- On PREDICATE reduce production single_term_ -> single_term ARROW single_term
-- On META reduce production single_term_ -> single_term ARROW single_term
-- On LET reduce production single_term_ -> single_term ARROW single_term
-- On LEMMA reduce production single_term_ -> single_term ARROW single_term
-- On LARROW reduce production single_term_ -> single_term ARROW single_term
-- On INDUCTIVE reduce production single_term_ -> single_term ARROW single_term
-- On IN reduce production single_term_ -> single_term ARROW single_term
-- On IMPORT reduce production single_term_ -> single_term ARROW single_term
-- On GOAL reduce production single_term_ -> single_term ARROW single_term
-- On FUNCTION reduce production single_term_ -> single_term ARROW single_term
-- On EXCEPTION reduce production single_term_ -> single_term ARROW single_term
-- On EOF reduce production single_term_ -> single_term ARROW single_term
-- On END reduce production single_term_ -> single_term ARROW single_term
-- On ELSE reduce production single_term_ -> single_term ARROW single_term
-- On DOTDOT reduce production single_term_ -> single_term ARROW single_term
-- On CONSTANT reduce production single_term_ -> single_term ARROW single_term
-- On COMMA reduce production single_term_ -> single_term ARROW single_term
-- On COLON reduce production single_term_ -> single_term ARROW single_term
-- On COINDUCTIVE reduce production single_term_ -> single_term ARROW single_term
-- On CLONE reduce production single_term_ -> single_term ARROW single_term
-- On BAR reduce production single_term_ -> single_term ARROW single_term
-- On AXIOM reduce production single_term_ -> single_term ARROW single_term

State 386:
## Known stack suffix:
## single_term COMMA
## LR(1) items:
separated_nonempty_list(COMMA,single_term) -> single_term COMMA . separated_nonempty_list(COMMA,single_term) [ RIGHTSQ RIGHTBRC EOF BAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 342
-- On separated_nonempty_list(COMMA,single_term) shift to state 387
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 387:
## Known stack suffix:
## single_term COMMA separated_nonempty_list(COMMA,single_term)
## LR(1) items:
separated_nonempty_list(COMMA,single_term) -> single_term COMMA separated_nonempty_list(COMMA,single_term) . [ RIGHTSQ RIGHTBRC EOF BAR ]
## Transitions:
## Reductions:
-- On RIGHTSQ reduce production separated_nonempty_list(COMMA,single_term) -> single_term COMMA separated_nonempty_list(COMMA,single_term)
-- On RIGHTBRC reduce production separated_nonempty_list(COMMA,single_term) -> single_term COMMA separated_nonempty_list(COMMA,single_term)
-- On EOF reduce production separated_nonempty_list(COMMA,single_term) -> single_term COMMA separated_nonempty_list(COMMA,single_term)
-- On BAR reduce production separated_nonempty_list(COMMA,single_term) -> single_term COMMA separated_nonempty_list(COMMA,single_term)

State 388:
## Known stack suffix:
## separated_nonempty_list(COMMA,single_term)
## LR(1) items:
comma_list1(single_term) -> separated_nonempty_list(COMMA,single_term) . [ RIGHTSQ EOF BAR ]
## Transitions:
## Reductions:
-- On RIGHTSQ reduce production comma_list1(single_term) -> separated_nonempty_list(COMMA,single_term)
-- On EOF reduce production comma_list1(single_term) -> separated_nonempty_list(COMMA,single_term)
-- On BAR reduce production comma_list1(single_term) -> separated_nonempty_list(COMMA,single_term)

State 389:
## Known stack suffix:
## LEFTSQ separated_nonempty_list(BAR,comma_list1(single_term))
## LR(1) items:
triggers -> LEFTSQ separated_nonempty_list(BAR,comma_list1(single_term)) . RIGHTSQ [ DOT ]
## Transitions:
-- On RIGHTSQ shift to state 390
## Reductions:

State 390:
## Known stack suffix:
## LEFTSQ separated_nonempty_list(BAR,comma_list1(single_term)) RIGHTSQ
## LR(1) items:
triggers -> LEFTSQ separated_nonempty_list(BAR,comma_list1(single_term)) RIGHTSQ . [ DOT ]
## Transitions:
## Reductions:
-- On DOT reduce production triggers -> LEFTSQ separated_nonempty_list(BAR,comma_list1(single_term)) RIGHTSQ

State 391:
## Known stack suffix:
## comma_list1(single_term)
## LR(1) items:
separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) . [ RIGHTSQ ]
separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) . BAR separated_nonempty_list(BAR,comma_list1(single_term)) [ RIGHTSQ ]
## Transitions:
-- On BAR shift to state 392
## Reductions:
-- On RIGHTSQ reduce production separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term)

State 392:
## Known stack suffix:
## comma_list1(single_term) BAR
## LR(1) items:
separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) BAR . separated_nonempty_list(BAR,comma_list1(single_term)) [ RIGHTSQ ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 342
-- On separated_nonempty_list(COMMA,single_term) shift to state 388
-- On separated_nonempty_list(BAR,comma_list1(single_term)) shift to state 393
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On comma_list1(single_term) shift to state 391
-- On attr shift to state 356
## Reductions:

State 393:
## Known stack suffix:
## comma_list1(single_term) BAR separated_nonempty_list(BAR,comma_list1(single_term))
## LR(1) items:
separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) BAR separated_nonempty_list(BAR,comma_list1(single_term)) . [ RIGHTSQ ]
## Transitions:
## Reductions:
-- On RIGHTSQ reduce production separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) BAR separated_nonempty_list(BAR,comma_list1(single_term))

State 394:
## Known stack suffix:
## quant comma_list1(quant_vars) triggers
## LR(1) items:
single_term_ -> quant comma_list1(quant_vars) triggers . DOT term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On DOT shift to state 395
## Reductions:

State 395:
## Known stack suffix:
## quant comma_list1(quant_vars) triggers DOT
## LR(1) items:
single_term_ -> quant comma_list1(quant_vars) triggers DOT . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 396
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 396:
## Known stack suffix:
## quant comma_list1(quant_vars) triggers DOT term
## LR(1) items:
single_term_ -> quant comma_list1(quant_vars) triggers DOT term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On VAL reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On USE reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On TYPE reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On THEN reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On SO reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On SEMICOLON reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On SCOPE reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On RIGHTSQ reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On RIGHTPAR reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On RIGHTBRC reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On PREDICATE reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On OR reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On OP4 reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On OP3 reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On OP2 reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On OP1 reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On MINUS reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On META reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On LTGT reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On LT reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On LRARROW reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On LET reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On LEMMA reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On LARROW reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On INDUCTIVE reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On IN reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On IMPORT reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On GT reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On GOAL reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On FUNCTION reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On EXCEPTION reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On EQUAL reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On EOF reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On END reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On ELSE reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On DOTDOT reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On CONSTANT reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On COMMA reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On COLON reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On COINDUCTIVE reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On CLONE reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On BY reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On BARBAR reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On BAR reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On AXIOM reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On AT reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On ARROW reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On AND reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term
-- On AMPAMP reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term

State 397:
## Known stack suffix:
## single_term COMMA
## LR(1) items:
term -> single_term COMMA . term_ [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term_ shift to state 398
-- On single_term_ shift to state 321
-- On single_term shift to state 399
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 398:
## Known stack suffix:
## single_term COMMA term_
## LR(1) items:
term -> single_term COMMA term_ . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term -> single_term COMMA term_
-- On VAL reduce production term -> single_term COMMA term_
-- On USE reduce production term -> single_term COMMA term_
-- On TYPE reduce production term -> single_term COMMA term_
-- On THEN reduce production term -> single_term COMMA term_
-- On SO reduce production term -> single_term COMMA term_
-- On SEMICOLON reduce production term -> single_term COMMA term_
-- On SCOPE reduce production term -> single_term COMMA term_
-- On RIGHTSQ_QUOTE reduce production term -> single_term COMMA term_
-- On RIGHTSQ reduce production term -> single_term COMMA term_
-- On RIGHTPAR reduce production term -> single_term COMMA term_
-- On RIGHTBRC reduce production term -> single_term COMMA term_
-- On PREDICATE reduce production term -> single_term COMMA term_
-- On OR reduce production term -> single_term COMMA term_
-- On OP4 reduce production term -> single_term COMMA term_
-- On OP3 reduce production term -> single_term COMMA term_
-- On OP2 reduce production term -> single_term COMMA term_
-- On OP1 reduce production term -> single_term COMMA term_
-- On MINUS reduce production term -> single_term COMMA term_
-- On META reduce production term -> single_term COMMA term_
-- On LTGT reduce production term -> single_term COMMA term_
-- On LT reduce production term -> single_term COMMA term_
-- On LRARROW reduce production term -> single_term COMMA term_
-- On LET reduce production term -> single_term COMMA term_
-- On LEMMA reduce production term -> single_term COMMA term_
-- On LARROW reduce production term -> single_term COMMA term_
-- On INDUCTIVE reduce production term -> single_term COMMA term_
-- On IN reduce production term -> single_term COMMA term_
-- On IMPORT reduce production term -> single_term COMMA term_
-- On GT reduce production term -> single_term COMMA term_
-- On GOAL reduce production term -> single_term COMMA term_
-- On FUNCTION reduce production term -> single_term COMMA term_
-- On EXCEPTION reduce production term -> single_term COMMA term_
-- On EQUAL reduce production term -> single_term COMMA term_
-- On EOF reduce production term -> single_term COMMA term_
-- On END reduce production term -> single_term COMMA term_
-- On ELSE reduce production term -> single_term COMMA term_
-- On DOTDOT reduce production term -> single_term COMMA term_
-- On CONSTANT reduce production term -> single_term COMMA term_
-- On COMMA reduce production term -> single_term COMMA term_
-- On COLON reduce production term -> single_term COMMA term_
-- On COINDUCTIVE reduce production term -> single_term COMMA term_
-- On CLONE reduce production term -> single_term COMMA term_
-- On BY reduce production term -> single_term COMMA term_
-- On BARBAR reduce production term -> single_term COMMA term_
-- On BAR reduce production term -> single_term COMMA term_
-- On AXIOM reduce production term -> single_term COMMA term_
-- On AT reduce production term -> single_term COMMA term_
-- On ARROW reduce production term -> single_term COMMA term_
-- On AND reduce production term -> single_term COMMA term_
-- On AMPAMP reduce production term -> single_term COMMA term_

State 399:
## Known stack suffix:
## single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_ -> single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_ -> single_term . COMMA term_ [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On COMMA shift to state 400
-- On COLON shift to state 132
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production term_ -> single_term
-- On VAL reduce production term_ -> single_term
-- On USE reduce production term_ -> single_term
-- On TYPE reduce production term_ -> single_term
-- On THEN reduce production term_ -> single_term
-- On SEMICOLON reduce production term_ -> single_term
-- On SCOPE reduce production term_ -> single_term
-- On RIGHTSQ_QUOTE reduce production term_ -> single_term
-- On RIGHTSQ reduce production term_ -> single_term
-- On RIGHTPAR reduce production term_ -> single_term
-- On RIGHTBRC reduce production term_ -> single_term
-- On PREDICATE reduce production term_ -> single_term
-- On META reduce production term_ -> single_term
-- On LET reduce production term_ -> single_term
-- On LEMMA reduce production term_ -> single_term
-- On LARROW reduce production term_ -> single_term
-- On INDUCTIVE reduce production term_ -> single_term
-- On IN reduce production term_ -> single_term
-- On IMPORT reduce production term_ -> single_term
-- On GOAL reduce production term_ -> single_term
-- On FUNCTION reduce production term_ -> single_term
-- On EXCEPTION reduce production term_ -> single_term
-- On EOF reduce production term_ -> single_term
-- On END reduce production term_ -> single_term
-- On ELSE reduce production term_ -> single_term
-- On DOTDOT reduce production term_ -> single_term
-- On CONSTANT reduce production term_ -> single_term
-- On COINDUCTIVE reduce production term_ -> single_term
-- On CLONE reduce production term_ -> single_term
-- On BAR reduce production term_ -> single_term
-- On AXIOM reduce production term_ -> single_term

State 400:
## Known stack suffix:
## single_term COMMA
## LR(1) items:
term_ -> single_term COMMA . term_ [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term_ shift to state 401
-- On single_term_ shift to state 321
-- On single_term shift to state 399
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 401:
## Known stack suffix:
## single_term COMMA term_
## LR(1) items:
term_ -> single_term COMMA term_ . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_ -> single_term COMMA term_
-- On VAL reduce production term_ -> single_term COMMA term_
-- On USE reduce production term_ -> single_term COMMA term_
-- On TYPE reduce production term_ -> single_term COMMA term_
-- On THEN reduce production term_ -> single_term COMMA term_
-- On SO reduce production term_ -> single_term COMMA term_
-- On SEMICOLON reduce production term_ -> single_term COMMA term_
-- On SCOPE reduce production term_ -> single_term COMMA term_
-- On RIGHTSQ_QUOTE reduce production term_ -> single_term COMMA term_
-- On RIGHTSQ reduce production term_ -> single_term COMMA term_
-- On RIGHTPAR reduce production term_ -> single_term COMMA term_
-- On RIGHTBRC reduce production term_ -> single_term COMMA term_
-- On PREDICATE reduce production term_ -> single_term COMMA term_
-- On OR reduce production term_ -> single_term COMMA term_
-- On OP4 reduce production term_ -> single_term COMMA term_
-- On OP3 reduce production term_ -> single_term COMMA term_
-- On OP2 reduce production term_ -> single_term COMMA term_
-- On OP1 reduce production term_ -> single_term COMMA term_
-- On MINUS reduce production term_ -> single_term COMMA term_
-- On META reduce production term_ -> single_term COMMA term_
-- On LTGT reduce production term_ -> single_term COMMA term_
-- On LT reduce production term_ -> single_term COMMA term_
-- On LRARROW reduce production term_ -> single_term COMMA term_
-- On LET reduce production term_ -> single_term COMMA term_
-- On LEMMA reduce production term_ -> single_term COMMA term_
-- On LARROW reduce production term_ -> single_term COMMA term_
-- On INDUCTIVE reduce production term_ -> single_term COMMA term_
-- On IN reduce production term_ -> single_term COMMA term_
-- On IMPORT reduce production term_ -> single_term COMMA term_
-- On GT reduce production term_ -> single_term COMMA term_
-- On GOAL reduce production term_ -> single_term COMMA term_
-- On FUNCTION reduce production term_ -> single_term COMMA term_
-- On EXCEPTION reduce production term_ -> single_term COMMA term_
-- On EQUAL reduce production term_ -> single_term COMMA term_
-- On EOF reduce production term_ -> single_term COMMA term_
-- On END reduce production term_ -> single_term COMMA term_
-- On ELSE reduce production term_ -> single_term COMMA term_
-- On DOTDOT reduce production term_ -> single_term COMMA term_
-- On CONSTANT reduce production term_ -> single_term COMMA term_
-- On COMMA reduce production term_ -> single_term COMMA term_
-- On COLON reduce production term_ -> single_term COMMA term_
-- On COINDUCTIVE reduce production term_ -> single_term COMMA term_
-- On CLONE reduce production term_ -> single_term COMMA term_
-- On BY reduce production term_ -> single_term COMMA term_
-- On BARBAR reduce production term_ -> single_term COMMA term_
-- On BAR reduce production term_ -> single_term COMMA term_
-- On AXIOM reduce production term_ -> single_term COMMA term_
-- On AT reduce production term_ -> single_term COMMA term_
-- On ARROW reduce production term_ -> single_term COMMA term_
-- On AND reduce production term_ -> single_term COMMA term_
-- On AMPAMP reduce production term_ -> single_term COMMA term_

State 402:
## Known stack suffix:
## term_arg LEFTSQ term
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term . rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ term . LARROW term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ term . DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ term . DOTDOT rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On LARROW shift to state 403
-- On DOTDOT shift to state 406
-- On rightsq shift to state 410
## Reductions:

State 403:
## Known stack suffix:
## term_arg LEFTSQ term LARROW
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term LARROW . term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 404
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 404:
## Known stack suffix:
## term_arg LEFTSQ term LARROW term
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term LARROW term . rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 405
## Reductions:

State 405:
## Known stack suffix:
## term_arg LEFTSQ term LARROW term rightsq
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term LARROW term rightsq . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On VAL reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On USE reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On UIDENT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On TYPE reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On TRUE reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On THEN reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On SO reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On SEMICOLON reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On SCOPE reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On RIGHTSQ_QUOTE reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On RIGHTSQ reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On RIGHTPAR reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On RIGHTBRC reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On REAL reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On RANGE reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On PREDICATE reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On OR reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On OPPREF reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On OP4 reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On OP3 reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On OP2 reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On OP1 reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On MINUS reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On META reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On LTGT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On LT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On LRARROW reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On LIDENT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On LET reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On LEMMA reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On LEFTSQ reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On LEFTPAR reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On LEFTBRC reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On LARROW reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On INTEGER reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On INDUCTIVE reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On IN reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On IMPORT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On GT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On GOAL reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On FUNCTION reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On FLOAT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On FALSE reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On EXCEPTION reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On EQUAL reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On EOF reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On END reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On ELSE reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On DOTDOT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On DOT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On CORE_UIDENT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On CORE_LIDENT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On CONSTANT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On COMMA reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On COLON reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On COINDUCTIVE reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On CLONE reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On BY reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On BEGIN reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On BARBAR reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On BAR reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On AXIOM reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On AT reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On ARROW reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On AND reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq
-- On AMPAMP reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq

State 406:
## Known stack suffix:
## term_arg LEFTSQ term DOTDOT
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term DOTDOT . term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ term DOTDOT . rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 407
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On rightsq shift to state 409
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 407:
## Known stack suffix:
## term_arg LEFTSQ term DOTDOT term
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term DOTDOT term . rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 408
## Reductions:

State 408:
## Known stack suffix:
## term_arg LEFTSQ term DOTDOT term rightsq
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On VAL reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On USE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On UIDENT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On TYPE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On TRUE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On THEN reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On SO reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On SEMICOLON reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On SCOPE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On RIGHTSQ_QUOTE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On RIGHTSQ reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On RIGHTPAR reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On RIGHTBRC reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On REAL reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On RANGE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On PREDICATE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On OR reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On OPPREF reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On OP4 reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On OP3 reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On OP2 reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On OP1 reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On MINUS reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On META reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On LTGT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On LT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On LRARROW reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On LIDENT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On LET reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On LEMMA reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On LEFTSQ reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On LEFTPAR reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On LEFTBRC reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On LARROW reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On INTEGER reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On INDUCTIVE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On IN reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On IMPORT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On GT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On GOAL reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On FUNCTION reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On FLOAT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On FALSE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On EXCEPTION reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On EQUAL reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On EOF reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On END reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On ELSE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On DOTDOT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On DOT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On CORE_UIDENT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On CORE_LIDENT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On CONSTANT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On COMMA reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On COLON reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On COINDUCTIVE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On CLONE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On BY reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On BEGIN reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On BARBAR reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On BAR reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On AXIOM reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On AT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On ARROW reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On AND reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq
-- On AMPAMP reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq

State 409:
## Known stack suffix:
## term_arg LEFTSQ term DOTDOT rightsq
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On VAL reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On USE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On UIDENT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On TYPE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On TRUE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On THEN reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On SO reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On SEMICOLON reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On SCOPE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On RIGHTSQ_QUOTE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On RIGHTSQ reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On RIGHTPAR reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On RIGHTBRC reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On REAL reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On RANGE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On PREDICATE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On OR reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On OPPREF reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On OP4 reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On OP3 reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On OP2 reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On OP1 reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On MINUS reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On META reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On LTGT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On LT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On LRARROW reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On LIDENT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On LET reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On LEMMA reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On LEFTSQ reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On LEFTPAR reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On LEFTBRC reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On LARROW reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On INTEGER reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On INDUCTIVE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On IN reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On IMPORT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On GT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On GOAL reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On FUNCTION reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On FLOAT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On FALSE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On EXCEPTION reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On EQUAL reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On EOF reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On END reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On ELSE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On DOTDOT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On DOT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On CORE_UIDENT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On CORE_LIDENT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On CONSTANT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On COMMA reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On COLON reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On COINDUCTIVE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On CLONE reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On BY reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On BEGIN reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On BARBAR reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On BAR reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On AXIOM reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On AT reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On ARROW reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On AND reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq
-- On AMPAMP reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq

State 410:
## Known stack suffix:
## term_arg LEFTSQ term rightsq
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term rightsq . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On VAL reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On USE reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On UIDENT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On TYPE reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On TRUE reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On THEN reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On SO reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On SEMICOLON reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On SCOPE reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On RIGHTSQ_QUOTE reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On RIGHTSQ reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On RIGHTPAR reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On RIGHTBRC reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On REAL reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On RANGE reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On PREDICATE reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On OR reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On OPPREF reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On OP4 reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On OP3 reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On OP2 reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On OP1 reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On MINUS reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On META reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On LTGT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On LT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On LRARROW reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On LIDENT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On LET reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On LEMMA reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On LEFTSQ reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On LEFTPAR reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On LEFTBRC reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On LARROW reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On INTEGER reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On INDUCTIVE reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On IN reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On IMPORT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On GT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On GOAL reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On FUNCTION reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On FLOAT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On FALSE reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On EXCEPTION reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On EQUAL reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On EOF reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On END reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On ELSE reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On DOTDOT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On DOT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On CORE_UIDENT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On CORE_LIDENT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On CONSTANT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On COMMA reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On COLON reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On COINDUCTIVE reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On CLONE reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On BY reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On BEGIN reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On BARBAR reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On BAR reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On AXIOM reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On AT reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On ARROW reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On AND reduce production term_sub_ -> term_arg LEFTSQ term rightsq
-- On AMPAMP reduce production term_sub_ -> term_arg LEFTSQ term rightsq

State 411:
## Known stack suffix:
## term_arg_
## LR(1) items:
mk_term(term_arg_) -> term_arg_ . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production mk_term(term_arg_) -> term_arg_
-- On VAL reduce production mk_term(term_arg_) -> term_arg_
-- On USE reduce production mk_term(term_arg_) -> term_arg_
-- On UIDENT reduce production mk_term(term_arg_) -> term_arg_
-- On TYPE reduce production mk_term(term_arg_) -> term_arg_
-- On TRUE reduce production mk_term(term_arg_) -> term_arg_
-- On THEN reduce production mk_term(term_arg_) -> term_arg_
-- On SO reduce production mk_term(term_arg_) -> term_arg_
-- On SEMICOLON reduce production mk_term(term_arg_) -> term_arg_
-- On SCOPE reduce production mk_term(term_arg_) -> term_arg_
-- On RIGHTSQ_QUOTE reduce production mk_term(term_arg_) -> term_arg_
-- On RIGHTSQ reduce production mk_term(term_arg_) -> term_arg_
-- On RIGHTPAR reduce production mk_term(term_arg_) -> term_arg_
-- On RIGHTBRC reduce production mk_term(term_arg_) -> term_arg_
-- On REAL reduce production mk_term(term_arg_) -> term_arg_
-- On RANGE reduce production mk_term(term_arg_) -> term_arg_
-- On PREDICATE reduce production mk_term(term_arg_) -> term_arg_
-- On OR reduce production mk_term(term_arg_) -> term_arg_
-- On OPPREF reduce production mk_term(term_arg_) -> term_arg_
-- On OP4 reduce production mk_term(term_arg_) -> term_arg_
-- On OP3 reduce production mk_term(term_arg_) -> term_arg_
-- On OP2 reduce production mk_term(term_arg_) -> term_arg_
-- On OP1 reduce production mk_term(term_arg_) -> term_arg_
-- On MINUS reduce production mk_term(term_arg_) -> term_arg_
-- On META reduce production mk_term(term_arg_) -> term_arg_
-- On LTGT reduce production mk_term(term_arg_) -> term_arg_
-- On LT reduce production mk_term(term_arg_) -> term_arg_
-- On LRARROW reduce production mk_term(term_arg_) -> term_arg_
-- On LIDENT reduce production mk_term(term_arg_) -> term_arg_
-- On LET reduce production mk_term(term_arg_) -> term_arg_
-- On LEMMA reduce production mk_term(term_arg_) -> term_arg_
-- On LEFTSQ reduce production mk_term(term_arg_) -> term_arg_
-- On LEFTPAR reduce production mk_term(term_arg_) -> term_arg_
-- On LEFTBRC reduce production mk_term(term_arg_) -> term_arg_
-- On LARROW reduce production mk_term(term_arg_) -> term_arg_
-- On INTEGER reduce production mk_term(term_arg_) -> term_arg_
-- On INDUCTIVE reduce production mk_term(term_arg_) -> term_arg_
-- On IN reduce production mk_term(term_arg_) -> term_arg_
-- On IMPORT reduce production mk_term(term_arg_) -> term_arg_
-- On GT reduce production mk_term(term_arg_) -> term_arg_
-- On GOAL reduce production mk_term(term_arg_) -> term_arg_
-- On FUNCTION reduce production mk_term(term_arg_) -> term_arg_
-- On FLOAT reduce production mk_term(term_arg_) -> term_arg_
-- On FALSE reduce production mk_term(term_arg_) -> term_arg_
-- On EXCEPTION reduce production mk_term(term_arg_) -> term_arg_
-- On EQUAL reduce production mk_term(term_arg_) -> term_arg_
-- On EOF reduce production mk_term(term_arg_) -> term_arg_
-- On END reduce production mk_term(term_arg_) -> term_arg_
-- On ELSE reduce production mk_term(term_arg_) -> term_arg_
-- On DOTDOT reduce production mk_term(term_arg_) -> term_arg_
-- On CORE_UIDENT reduce production mk_term(term_arg_) -> term_arg_
-- On CORE_LIDENT reduce production mk_term(term_arg_) -> term_arg_
-- On CONSTANT reduce production mk_term(term_arg_) -> term_arg_
-- On COMMA reduce production mk_term(term_arg_) -> term_arg_
-- On COLON reduce production mk_term(term_arg_) -> term_arg_
-- On COINDUCTIVE reduce production mk_term(term_arg_) -> term_arg_
-- On CLONE reduce production mk_term(term_arg_) -> term_arg_
-- On BY reduce production mk_term(term_arg_) -> term_arg_
-- On BEGIN reduce production mk_term(term_arg_) -> term_arg_
-- On BARBAR reduce production mk_term(term_arg_) -> term_arg_
-- On BAR reduce production mk_term(term_arg_) -> term_arg_
-- On AXIOM reduce production mk_term(term_arg_) -> term_arg_
-- On AT reduce production mk_term(term_arg_) -> term_arg_
-- On ARROW reduce production mk_term(term_arg_) -> term_arg_
-- On AND reduce production mk_term(term_arg_) -> term_arg_
-- On AMPAMP reduce production mk_term(term_arg_) -> term_arg_

State 412:
## Known stack suffix:
## term_arg
## LR(1) items:
located(term_arg) -> term_arg . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term LARROW term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On LEFTSQ shift to state 317
## Reductions:
-- On WITH reduce production located(term_arg) -> term_arg
-- On VAL reduce production located(term_arg) -> term_arg
-- On USE reduce production located(term_arg) -> term_arg
-- On UIDENT reduce production located(term_arg) -> term_arg
-- On TYPE reduce production located(term_arg) -> term_arg
-- On TRUE reduce production located(term_arg) -> term_arg
-- On THEN reduce production located(term_arg) -> term_arg
-- On SO reduce production located(term_arg) -> term_arg
-- On SEMICOLON reduce production located(term_arg) -> term_arg
-- On SCOPE reduce production located(term_arg) -> term_arg
-- On RIGHTSQ_QUOTE reduce production located(term_arg) -> term_arg
-- On RIGHTSQ reduce production located(term_arg) -> term_arg
-- On RIGHTPAR reduce production located(term_arg) -> term_arg
-- On RIGHTBRC reduce production located(term_arg) -> term_arg
-- On REAL reduce production located(term_arg) -> term_arg
-- On RANGE reduce production located(term_arg) -> term_arg
-- On PREDICATE reduce production located(term_arg) -> term_arg
-- On OR reduce production located(term_arg) -> term_arg
-- On OPPREF reduce production located(term_arg) -> term_arg
-- On OP4 reduce production located(term_arg) -> term_arg
-- On OP3 reduce production located(term_arg) -> term_arg
-- On OP2 reduce production located(term_arg) -> term_arg
-- On OP1 reduce production located(term_arg) -> term_arg
-- On MINUS reduce production located(term_arg) -> term_arg
-- On META reduce production located(term_arg) -> term_arg
-- On LTGT reduce production located(term_arg) -> term_arg
-- On LT reduce production located(term_arg) -> term_arg
-- On LRARROW reduce production located(term_arg) -> term_arg
-- On LIDENT reduce production located(term_arg) -> term_arg
-- On LET reduce production located(term_arg) -> term_arg
-- On LEMMA reduce production located(term_arg) -> term_arg
-- On LEFTPAR reduce production located(term_arg) -> term_arg
-- On LEFTBRC reduce production located(term_arg) -> term_arg
-- On LARROW reduce production located(term_arg) -> term_arg
-- On INTEGER reduce production located(term_arg) -> term_arg
-- On INDUCTIVE reduce production located(term_arg) -> term_arg
-- On IN reduce production located(term_arg) -> term_arg
-- On IMPORT reduce production located(term_arg) -> term_arg
-- On GT reduce production located(term_arg) -> term_arg
-- On GOAL reduce production located(term_arg) -> term_arg
-- On FUNCTION reduce production located(term_arg) -> term_arg
-- On FLOAT reduce production located(term_arg) -> term_arg
-- On FALSE reduce production located(term_arg) -> term_arg
-- On EXCEPTION reduce production located(term_arg) -> term_arg
-- On EQUAL reduce production located(term_arg) -> term_arg
-- On EOF reduce production located(term_arg) -> term_arg
-- On END reduce production located(term_arg) -> term_arg
-- On ELSE reduce production located(term_arg) -> term_arg
-- On DOTDOT reduce production located(term_arg) -> term_arg
-- On CORE_UIDENT reduce production located(term_arg) -> term_arg
-- On CORE_LIDENT reduce production located(term_arg) -> term_arg
-- On CONSTANT reduce production located(term_arg) -> term_arg
-- On COMMA reduce production located(term_arg) -> term_arg
-- On COLON reduce production located(term_arg) -> term_arg
-- On COINDUCTIVE reduce production located(term_arg) -> term_arg
-- On CLONE reduce production located(term_arg) -> term_arg
-- On BY reduce production located(term_arg) -> term_arg
-- On BEGIN reduce production located(term_arg) -> term_arg
-- On BARBAR reduce production located(term_arg) -> term_arg
-- On BAR reduce production located(term_arg) -> term_arg
-- On AXIOM reduce production located(term_arg) -> term_arg
-- On AT reduce production located(term_arg) -> term_arg
-- On ARROW reduce production located(term_arg) -> term_arg
-- On AND reduce production located(term_arg) -> term_arg
-- On AMPAMP reduce production located(term_arg) -> term_arg

State 413:
## Known stack suffix:
## term_arg nonempty_list(located(term_arg))
## LR(1) items:
single_term_ -> term_arg nonempty_list(located(term_arg)) . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On VAL reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On USE reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On TYPE reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On THEN reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On SO reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On SEMICOLON reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On SCOPE reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On RIGHTSQ_QUOTE reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On RIGHTSQ reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On RIGHTPAR reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On RIGHTBRC reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On PREDICATE reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On OR reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On OP4 reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On OP3 reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On OP2 reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On OP1 reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On MINUS reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On META reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On LTGT reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On LT reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On LRARROW reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On LET reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On LEMMA reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On LARROW reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On INDUCTIVE reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On IN reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On IMPORT reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On GT reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On GOAL reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On FUNCTION reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On EXCEPTION reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On EQUAL reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On EOF reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On END reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On ELSE reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On DOTDOT reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On CONSTANT reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On COMMA reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On COLON reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On COINDUCTIVE reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On CLONE reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On BY reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On BARBAR reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On BAR reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On AXIOM reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On AT reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On ARROW reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On AND reduce production single_term_ -> term_arg nonempty_list(located(term_arg))
-- On AMPAMP reduce production single_term_ -> term_arg nonempty_list(located(term_arg))

State 414:
## Known stack suffix:
## located(term_arg)
## LR(1) items:
nonempty_list(located(term_arg)) -> located(term_arg) . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
nonempty_list(located(term_arg)) -> located(term_arg) . nonempty_list(located(term_arg)) [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On OPPREF shift to state 201
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 411
-- On term_arg shift to state 412
-- On qualid shift to state 345
-- On numeral shift to state 349
-- On nonempty_list(located(term_arg)) shift to state 415
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On lqualid shift to state 353
-- On located(term_arg) shift to state 414
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
## Reductions:
-- On WITH reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On VAL reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On USE reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On TYPE reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On THEN reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On SO reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On SEMICOLON reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On SCOPE reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On RIGHTSQ_QUOTE reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On RIGHTSQ reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On RIGHTPAR reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On RIGHTBRC reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On PREDICATE reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On OR reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On OP4 reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On OP3 reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On OP2 reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On OP1 reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On MINUS reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On META reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On LTGT reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On LT reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On LRARROW reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On LET reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On LEMMA reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On LARROW reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On INDUCTIVE reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On IN reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On IMPORT reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On GT reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On GOAL reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On FUNCTION reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On EXCEPTION reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On EQUAL reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On EOF reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On END reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On ELSE reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On DOTDOT reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On CONSTANT reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On COMMA reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On COLON reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On COINDUCTIVE reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On CLONE reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On BY reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On BARBAR reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On BAR reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On AXIOM reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On AT reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On ARROW reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On AND reduce production nonempty_list(located(term_arg)) -> located(term_arg)
-- On AMPAMP reduce production nonempty_list(located(term_arg)) -> located(term_arg)

State 415:
## Known stack suffix:
## located(term_arg) nonempty_list(located(term_arg))
## LR(1) items:
nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg)) . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On VAL reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On USE reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On TYPE reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On THEN reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On SO reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On SEMICOLON reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On SCOPE reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On RIGHTSQ_QUOTE reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On RIGHTSQ reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On RIGHTPAR reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On RIGHTBRC reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On PREDICATE reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On OR reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On OP4 reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On OP3 reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On OP2 reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On OP1 reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On MINUS reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On META reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On LTGT reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On LT reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On LRARROW reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On LET reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On LEMMA reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On LARROW reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On INDUCTIVE reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On IN reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On IMPORT reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On GT reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On GOAL reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On FUNCTION reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On EXCEPTION reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On EQUAL reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On EOF reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On END reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On ELSE reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On DOTDOT reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On CONSTANT reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On COMMA reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On COLON reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On COINDUCTIVE reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On CLONE reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On BY reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On BARBAR reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On BAR reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On AXIOM reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On AT reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On ARROW reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On AND reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))
-- On AMPAMP reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))

State 416:
## Known stack suffix:
## FUN binders ARROW term
## LR(1) items:
single_term_ -> FUN binders ARROW term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> FUN binders ARROW term
-- On VAL reduce production single_term_ -> FUN binders ARROW term
-- On USE reduce production single_term_ -> FUN binders ARROW term
-- On TYPE reduce production single_term_ -> FUN binders ARROW term
-- On THEN reduce production single_term_ -> FUN binders ARROW term
-- On SO reduce production single_term_ -> FUN binders ARROW term
-- On SEMICOLON reduce production single_term_ -> FUN binders ARROW term
-- On SCOPE reduce production single_term_ -> FUN binders ARROW term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> FUN binders ARROW term
-- On RIGHTSQ reduce production single_term_ -> FUN binders ARROW term
-- On RIGHTPAR reduce production single_term_ -> FUN binders ARROW term
-- On RIGHTBRC reduce production single_term_ -> FUN binders ARROW term
-- On PREDICATE reduce production single_term_ -> FUN binders ARROW term
-- On OR reduce production single_term_ -> FUN binders ARROW term
-- On OP4 reduce production single_term_ -> FUN binders ARROW term
-- On OP3 reduce production single_term_ -> FUN binders ARROW term
-- On OP2 reduce production single_term_ -> FUN binders ARROW term
-- On OP1 reduce production single_term_ -> FUN binders ARROW term
-- On MINUS reduce production single_term_ -> FUN binders ARROW term
-- On META reduce production single_term_ -> FUN binders ARROW term
-- On LTGT reduce production single_term_ -> FUN binders ARROW term
-- On LT reduce production single_term_ -> FUN binders ARROW term
-- On LRARROW reduce production single_term_ -> FUN binders ARROW term
-- On LET reduce production single_term_ -> FUN binders ARROW term
-- On LEMMA reduce production single_term_ -> FUN binders ARROW term
-- On LARROW reduce production single_term_ -> FUN binders ARROW term
-- On INDUCTIVE reduce production single_term_ -> FUN binders ARROW term
-- On IN reduce production single_term_ -> FUN binders ARROW term
-- On IMPORT reduce production single_term_ -> FUN binders ARROW term
-- On GT reduce production single_term_ -> FUN binders ARROW term
-- On GOAL reduce production single_term_ -> FUN binders ARROW term
-- On FUNCTION reduce production single_term_ -> FUN binders ARROW term
-- On EXCEPTION reduce production single_term_ -> FUN binders ARROW term
-- On EQUAL reduce production single_term_ -> FUN binders ARROW term
-- On EOF reduce production single_term_ -> FUN binders ARROW term
-- On END reduce production single_term_ -> FUN binders ARROW term
-- On ELSE reduce production single_term_ -> FUN binders ARROW term
-- On DOTDOT reduce production single_term_ -> FUN binders ARROW term
-- On CONSTANT reduce production single_term_ -> FUN binders ARROW term
-- On COMMA reduce production single_term_ -> FUN binders ARROW term
-- On COLON reduce production single_term_ -> FUN binders ARROW term
-- On COINDUCTIVE reduce production single_term_ -> FUN binders ARROW term
-- On CLONE reduce production single_term_ -> FUN binders ARROW term
-- On BY reduce production single_term_ -> FUN binders ARROW term
-- On BARBAR reduce production single_term_ -> FUN binders ARROW term
-- On BAR reduce production single_term_ -> FUN binders ARROW term
-- On AXIOM reduce production single_term_ -> FUN binders ARROW term
-- On AT reduce production single_term_ -> FUN binders ARROW term
-- On ARROW reduce production single_term_ -> FUN binders ARROW term
-- On AND reduce production single_term_ -> FUN binders ARROW term
-- On AMPAMP reduce production single_term_ -> FUN binders ARROW term

State 417:
## Known stack suffix:
## binder
## LR(1) items:
nonempty_list(binder) -> binder . [ WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS ]
nonempty_list(binder) -> binder . nonempty_list(binder) [ WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 418
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:
-- On WRITES reduce production nonempty_list(binder) -> binder
-- On VARIANT reduce production nonempty_list(binder) -> binder
-- On RETURNS reduce production nonempty_list(binder) -> binder
-- On REQUIRES reduce production nonempty_list(binder) -> binder
-- On READS reduce production nonempty_list(binder) -> binder
-- On RAISES reduce production nonempty_list(binder) -> binder
-- On EQUAL reduce production nonempty_list(binder) -> binder
-- On ENSURES reduce production nonempty_list(binder) -> binder
-- On DIVERGES reduce production nonempty_list(binder) -> binder
-- On COLON reduce production nonempty_list(binder) -> binder
-- On ARROW reduce production nonempty_list(binder) -> binder
-- On ALIAS reduce production nonempty_list(binder) -> binder

State 418:
## Known stack suffix:
## binder nonempty_list(binder)
## LR(1) items:
nonempty_list(binder) -> binder nonempty_list(binder) . [ WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production nonempty_list(binder) -> binder nonempty_list(binder)
-- On VARIANT reduce production nonempty_list(binder) -> binder nonempty_list(binder)
-- On RETURNS reduce production nonempty_list(binder) -> binder nonempty_list(binder)
-- On REQUIRES reduce production nonempty_list(binder) -> binder nonempty_list(binder)
-- On READS reduce production nonempty_list(binder) -> binder nonempty_list(binder)
-- On RAISES reduce production nonempty_list(binder) -> binder nonempty_list(binder)
-- On EQUAL reduce production nonempty_list(binder) -> binder nonempty_list(binder)
-- On ENSURES reduce production nonempty_list(binder) -> binder nonempty_list(binder)
-- On DIVERGES reduce production nonempty_list(binder) -> binder nonempty_list(binder)
-- On COLON reduce production nonempty_list(binder) -> binder nonempty_list(binder)
-- On ARROW reduce production nonempty_list(binder) -> binder nonempty_list(binder)
-- On ALIAS reduce production nonempty_list(binder) -> binder nonempty_list(binder)

State 419:
## Known stack suffix:
## lident_keyword
## LR(1) items:
lident -> lident_keyword . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
lident_nq -> lident_keyword . [ POSITION ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WRITES reduce production lident -> lident_keyword
-- On WITH reduce production lident -> lident_keyword
-- On VARIANT reduce production lident -> lident_keyword
-- On VAL reduce production lident -> lident_keyword
-- On USE reduce production lident -> lident_keyword
-- On UNDERSCORE reduce production lident -> lident_keyword
-- On UIDENT reduce production lident -> lident_keyword
-- On TYPE reduce production lident -> lident_keyword
-- On SCOPE reduce production lident -> lident_keyword
-- On RETURNS reduce production lident -> lident_keyword
-- On REQUIRES reduce production lident -> lident_keyword
-- On READS reduce production lident -> lident_keyword
-- On RANGE reduce production lident -> lident_keyword
-- On RAISES reduce production lident -> lident_keyword
-- On QUOTE_LIDENT reduce production lident -> lident_keyword
-- On PREDICATE reduce production lident -> lident_keyword
-- On POSITION reduce production lident_nq -> lident_keyword
-- On META reduce production lident -> lident_keyword
-- On LIDENT reduce production lident -> lident_keyword
-- On LET reduce production lident -> lident_keyword
-- On LEMMA reduce production lident -> lident_keyword
-- On LEFTPAR reduce production lident -> lident_keyword
-- On LEFTBRC reduce production lident -> lident_keyword
-- On INVARIANT reduce production lident -> lident_keyword
-- On INDUCTIVE reduce production lident -> lident_keyword
-- On IN reduce production lident -> lident_keyword
-- On IMPORT reduce production lident -> lident_keyword
-- On GOAL reduce production lident -> lident_keyword
-- On FUNCTION reduce production lident -> lident_keyword
-- On FLOAT reduce production lident -> lident_keyword
-- On EXCEPTION reduce production lident -> lident_keyword
-- On EQUAL reduce production lident -> lident_keyword
-- On EOF reduce production lident -> lident_keyword
-- On ENSURES reduce production lident -> lident_keyword
-- On END reduce production lident -> lident_keyword
-- On DIVERGES reduce production lident -> lident_keyword
-- On CORE_UIDENT reduce production lident -> lident_keyword
-- On CORE_LIDENT reduce production lident -> lident_keyword
-- On CONSTANT reduce production lident -> lident_keyword
-- On COLON reduce production lident -> lident_keyword
-- On COINDUCTIVE reduce production lident -> lident_keyword
-- On CLONE reduce production lident -> lident_keyword
-- On BY reduce production lident -> lident_keyword
-- On BAR reduce production lident -> lident_keyword
-- On AXIOM reduce production lident -> lident_keyword
-- On ATTRIBUTE reduce production lident_nq -> lident_keyword
-- On ARROW reduce production lident -> lident_keyword
-- On ALIAS reduce production lident -> lident_keyword

State 420:
## Known stack suffix:
## anon_binder
## LR(1) items:
binder -> anon_binder . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production binder -> anon_binder
-- On VARIANT reduce production binder -> anon_binder
-- On UNDERSCORE reduce production binder -> anon_binder
-- On UIDENT reduce production binder -> anon_binder
-- On RETURNS reduce production binder -> anon_binder
-- On REQUIRES reduce production binder -> anon_binder
-- On READS reduce production binder -> anon_binder
-- On RANGE reduce production binder -> anon_binder
-- On RAISES reduce production binder -> anon_binder
-- On QUOTE_LIDENT reduce production binder -> anon_binder
-- On LIDENT reduce production binder -> anon_binder
-- On LEFTPAR reduce production binder -> anon_binder
-- On LEFTBRC reduce production binder -> anon_binder
-- On FLOAT reduce production binder -> anon_binder
-- On EQUAL reduce production binder -> anon_binder
-- On ENSURES reduce production binder -> anon_binder
-- On DIVERGES reduce production binder -> anon_binder
-- On CORE_UIDENT reduce production binder -> anon_binder
-- On CORE_LIDENT reduce production binder -> anon_binder
-- On COLON reduce production binder -> anon_binder
-- On ARROW reduce production binder -> anon_binder
-- On ALIAS reduce production binder -> anon_binder

State 421:
## Known stack suffix:
## IF term
## LR(1) items:
single_term_ -> IF term . THEN term ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On THEN shift to state 422
## Reductions:

State 422:
## Known stack suffix:
## IF term THEN
## LR(1) items:
single_term_ -> IF term THEN . term ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 423
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 423:
## Known stack suffix:
## IF term THEN term
## LR(1) items:
single_term_ -> IF term THEN term . ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On ELSE shift to state 424
## Reductions:

State 424:
## Known stack suffix:
## IF term THEN term ELSE
## LR(1) items:
single_term_ -> IF term THEN term ELSE . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 425
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 425:
## Known stack suffix:
## IF term THEN term ELSE term
## LR(1) items:
single_term_ -> IF term THEN term ELSE term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> IF term THEN term ELSE term
-- On VAL reduce production single_term_ -> IF term THEN term ELSE term
-- On USE reduce production single_term_ -> IF term THEN term ELSE term
-- On TYPE reduce production single_term_ -> IF term THEN term ELSE term
-- On THEN reduce production single_term_ -> IF term THEN term ELSE term
-- On SO reduce production single_term_ -> IF term THEN term ELSE term
-- On SEMICOLON reduce production single_term_ -> IF term THEN term ELSE term
-- On SCOPE reduce production single_term_ -> IF term THEN term ELSE term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> IF term THEN term ELSE term
-- On RIGHTSQ reduce production single_term_ -> IF term THEN term ELSE term
-- On RIGHTPAR reduce production single_term_ -> IF term THEN term ELSE term
-- On RIGHTBRC reduce production single_term_ -> IF term THEN term ELSE term
-- On PREDICATE reduce production single_term_ -> IF term THEN term ELSE term
-- On OR reduce production single_term_ -> IF term THEN term ELSE term
-- On OP4 reduce production single_term_ -> IF term THEN term ELSE term
-- On OP3 reduce production single_term_ -> IF term THEN term ELSE term
-- On OP2 reduce production single_term_ -> IF term THEN term ELSE term
-- On OP1 reduce production single_term_ -> IF term THEN term ELSE term
-- On MINUS reduce production single_term_ -> IF term THEN term ELSE term
-- On META reduce production single_term_ -> IF term THEN term ELSE term
-- On LTGT reduce production single_term_ -> IF term THEN term ELSE term
-- On LT reduce production single_term_ -> IF term THEN term ELSE term
-- On LRARROW reduce production single_term_ -> IF term THEN term ELSE term
-- On LET reduce production single_term_ -> IF term THEN term ELSE term
-- On LEMMA reduce production single_term_ -> IF term THEN term ELSE term
-- On LARROW reduce production single_term_ -> IF term THEN term ELSE term
-- On INDUCTIVE reduce production single_term_ -> IF term THEN term ELSE term
-- On IN reduce production single_term_ -> IF term THEN term ELSE term
-- On IMPORT reduce production single_term_ -> IF term THEN term ELSE term
-- On GT reduce production single_term_ -> IF term THEN term ELSE term
-- On GOAL reduce production single_term_ -> IF term THEN term ELSE term
-- On FUNCTION reduce production single_term_ -> IF term THEN term ELSE term
-- On EXCEPTION reduce production single_term_ -> IF term THEN term ELSE term
-- On EQUAL reduce production single_term_ -> IF term THEN term ELSE term
-- On EOF reduce production single_term_ -> IF term THEN term ELSE term
-- On END reduce production single_term_ -> IF term THEN term ELSE term
-- On ELSE reduce production single_term_ -> IF term THEN term ELSE term
-- On DOTDOT reduce production single_term_ -> IF term THEN term ELSE term
-- On CONSTANT reduce production single_term_ -> IF term THEN term ELSE term
-- On COMMA reduce production single_term_ -> IF term THEN term ELSE term
-- On COLON reduce production single_term_ -> IF term THEN term ELSE term
-- On COINDUCTIVE reduce production single_term_ -> IF term THEN term ELSE term
-- On CLONE reduce production single_term_ -> IF term THEN term ELSE term
-- On BY reduce production single_term_ -> IF term THEN term ELSE term
-- On BARBAR reduce production single_term_ -> IF term THEN term ELSE term
-- On BAR reduce production single_term_ -> IF term THEN term ELSE term
-- On AXIOM reduce production single_term_ -> IF term THEN term ELSE term
-- On AT reduce production single_term_ -> IF term THEN term ELSE term
-- On ARROW reduce production single_term_ -> IF term THEN term ELSE term
-- On AND reduce production single_term_ -> IF term THEN term ELSE term
-- On AMPAMP reduce production single_term_ -> IF term THEN term ELSE term

State 426:
## Known stack suffix:
## LET pattern EQUAL term
## LR(1) items:
single_term_ -> LET pattern EQUAL term . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On IN shift to state 427
## Reductions:

State 427:
## Known stack suffix:
## LET pattern EQUAL term IN
## LR(1) items:
single_term_ -> LET pattern EQUAL term IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 428
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 428:
## Known stack suffix:
## LET pattern EQUAL term IN term
## LR(1) items:
single_term_ -> LET pattern EQUAL term IN term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> LET pattern EQUAL term IN term
-- On VAL reduce production single_term_ -> LET pattern EQUAL term IN term
-- On USE reduce production single_term_ -> LET pattern EQUAL term IN term
-- On TYPE reduce production single_term_ -> LET pattern EQUAL term IN term
-- On THEN reduce production single_term_ -> LET pattern EQUAL term IN term
-- On SO reduce production single_term_ -> LET pattern EQUAL term IN term
-- On SEMICOLON reduce production single_term_ -> LET pattern EQUAL term IN term
-- On SCOPE reduce production single_term_ -> LET pattern EQUAL term IN term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> LET pattern EQUAL term IN term
-- On RIGHTSQ reduce production single_term_ -> LET pattern EQUAL term IN term
-- On RIGHTPAR reduce production single_term_ -> LET pattern EQUAL term IN term
-- On RIGHTBRC reduce production single_term_ -> LET pattern EQUAL term IN term
-- On PREDICATE reduce production single_term_ -> LET pattern EQUAL term IN term
-- On OR reduce production single_term_ -> LET pattern EQUAL term IN term
-- On OP4 reduce production single_term_ -> LET pattern EQUAL term IN term
-- On OP3 reduce production single_term_ -> LET pattern EQUAL term IN term
-- On OP2 reduce production single_term_ -> LET pattern EQUAL term IN term
-- On OP1 reduce production single_term_ -> LET pattern EQUAL term IN term
-- On MINUS reduce production single_term_ -> LET pattern EQUAL term IN term
-- On META reduce production single_term_ -> LET pattern EQUAL term IN term
-- On LTGT reduce production single_term_ -> LET pattern EQUAL term IN term
-- On LT reduce production single_term_ -> LET pattern EQUAL term IN term
-- On LRARROW reduce production single_term_ -> LET pattern EQUAL term IN term
-- On LET reduce production single_term_ -> LET pattern EQUAL term IN term
-- On LEMMA reduce production single_term_ -> LET pattern EQUAL term IN term
-- On LARROW reduce production single_term_ -> LET pattern EQUAL term IN term
-- On INDUCTIVE reduce production single_term_ -> LET pattern EQUAL term IN term
-- On IN reduce production single_term_ -> LET pattern EQUAL term IN term
-- On IMPORT reduce production single_term_ -> LET pattern EQUAL term IN term
-- On GT reduce production single_term_ -> LET pattern EQUAL term IN term
-- On GOAL reduce production single_term_ -> LET pattern EQUAL term IN term
-- On FUNCTION reduce production single_term_ -> LET pattern EQUAL term IN term
-- On EXCEPTION reduce production single_term_ -> LET pattern EQUAL term IN term
-- On EQUAL reduce production single_term_ -> LET pattern EQUAL term IN term
-- On EOF reduce production single_term_ -> LET pattern EQUAL term IN term
-- On END reduce production single_term_ -> LET pattern EQUAL term IN term
-- On ELSE reduce production single_term_ -> LET pattern EQUAL term IN term
-- On DOTDOT reduce production single_term_ -> LET pattern EQUAL term IN term
-- On CONSTANT reduce production single_term_ -> LET pattern EQUAL term IN term
-- On COMMA reduce production single_term_ -> LET pattern EQUAL term IN term
-- On COLON reduce production single_term_ -> LET pattern EQUAL term IN term
-- On COINDUCTIVE reduce production single_term_ -> LET pattern EQUAL term IN term
-- On CLONE reduce production single_term_ -> LET pattern EQUAL term IN term
-- On BY reduce production single_term_ -> LET pattern EQUAL term IN term
-- On BARBAR reduce production single_term_ -> LET pattern EQUAL term IN term
-- On BAR reduce production single_term_ -> LET pattern EQUAL term IN term
-- On AXIOM reduce production single_term_ -> LET pattern EQUAL term IN term
-- On AT reduce production single_term_ -> LET pattern EQUAL term IN term
-- On ARROW reduce production single_term_ -> LET pattern EQUAL term IN term
-- On AND reduce production single_term_ -> LET pattern EQUAL term IN term
-- On AMPAMP reduce production single_term_ -> LET pattern EQUAL term IN term

State 429:
## Known stack suffix:
## lident_op_nq
## LR(1) items:
attrs(lident_op_nq) -> lident_op_nq . list(attr) [ UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 430
-- On attr shift to state 71
## Reductions:
-- On UNDERSCORE reduce production list(attr) ->
-- On UIDENT reduce production list(attr) ->
-- On RANGE reduce production list(attr) ->
-- On QUOTE_LIDENT reduce production list(attr) ->
-- On LIDENT reduce production list(attr) ->
-- On LEFTPAR reduce production list(attr) ->
-- On LEFTBRC reduce production list(attr) ->
-- On FLOAT reduce production list(attr) ->
-- On EQUAL reduce production list(attr) ->
-- On CORE_UIDENT reduce production list(attr) ->
-- On CORE_LIDENT reduce production list(attr) ->

State 430:
## Known stack suffix:
## lident_op_nq list(attr)
## LR(1) items:
attrs(lident_op_nq) -> lident_op_nq list(attr) . [ UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE reduce production attrs(lident_op_nq) -> lident_op_nq list(attr)
-- On UIDENT reduce production attrs(lident_op_nq) -> lident_op_nq list(attr)
-- On RANGE reduce production attrs(lident_op_nq) -> lident_op_nq list(attr)
-- On QUOTE_LIDENT reduce production attrs(lident_op_nq) -> lident_op_nq list(attr)
-- On LIDENT reduce production attrs(lident_op_nq) -> lident_op_nq list(attr)
-- On LEFTPAR reduce production attrs(lident_op_nq) -> lident_op_nq list(attr)
-- On LEFTBRC reduce production attrs(lident_op_nq) -> lident_op_nq list(attr)
-- On FLOAT reduce production attrs(lident_op_nq) -> lident_op_nq list(attr)
-- On EQUAL reduce production attrs(lident_op_nq) -> lident_op_nq list(attr)
-- On CORE_UIDENT reduce production attrs(lident_op_nq) -> lident_op_nq list(attr)
-- On CORE_LIDENT reduce production attrs(lident_op_nq) -> lident_op_nq list(attr)

State 431:
## Known stack suffix:
## LET attrs(lident_op_nq)
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) . EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> LET attrs(lident_op_nq) . mk_term(lam_defn) IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On EQUAL shift to state 432
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On mk_term(lam_defn) shift to state 436
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On lam_defn shift to state 439
-- On binders shift to state 440
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:

State 432:
## Known stack suffix:
## LET attrs(lident_op_nq) EQUAL
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) EQUAL . term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 433
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 433:
## Known stack suffix:
## LET attrs(lident_op_nq) EQUAL term
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) EQUAL term . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On IN shift to state 434
## Reductions:

State 434:
## Known stack suffix:
## LET attrs(lident_op_nq) EQUAL term IN
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) EQUAL term IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 435
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 435:
## Known stack suffix:
## LET attrs(lident_op_nq) EQUAL term IN term
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On VAL reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On USE reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On TYPE reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On THEN reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On SO reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On SEMICOLON reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On SCOPE reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On RIGHTSQ reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On RIGHTPAR reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On RIGHTBRC reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On PREDICATE reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On OR reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On OP4 reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On OP3 reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On OP2 reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On OP1 reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On MINUS reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On META reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On LTGT reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On LT reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On LRARROW reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On LET reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On LEMMA reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On LARROW reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On INDUCTIVE reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On IN reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On IMPORT reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On GT reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On GOAL reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On FUNCTION reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On EXCEPTION reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On EQUAL reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On EOF reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On END reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On ELSE reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On DOTDOT reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On CONSTANT reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On COMMA reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On COLON reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On COINDUCTIVE reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On CLONE reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On BY reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On BARBAR reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On BAR reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On AXIOM reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On AT reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On ARROW reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On AND reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term
-- On AMPAMP reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term

State 436:
## Known stack suffix:
## LET attrs(lident_op_nq) mk_term(lam_defn)
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On IN shift to state 437
## Reductions:

State 437:
## Known stack suffix:
## LET attrs(lident_op_nq) mk_term(lam_defn) IN
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 438
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 438:
## Known stack suffix:
## LET attrs(lident_op_nq) mk_term(lam_defn) IN term
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On VAL reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On USE reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On TYPE reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On THEN reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On SO reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On SEMICOLON reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On SCOPE reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On RIGHTSQ reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On RIGHTPAR reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On RIGHTBRC reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On PREDICATE reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On OR reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On OP4 reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On OP3 reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On OP2 reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On OP1 reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On MINUS reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On META reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On LTGT reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On LT reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On LRARROW reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On LET reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On LEMMA reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On LARROW reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On INDUCTIVE reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On IN reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On IMPORT reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On GT reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On GOAL reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On FUNCTION reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On EXCEPTION reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On EQUAL reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On EOF reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On END reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On ELSE reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On DOTDOT reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On CONSTANT reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On COMMA reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On COLON reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On COINDUCTIVE reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On CLONE reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On BY reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On BARBAR reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On BAR reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On AXIOM reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On AT reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On ARROW reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On AND reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term
-- On AMPAMP reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term

State 439:
## Known stack suffix:
## lam_defn
## LR(1) items:
mk_term(lam_defn) -> lam_defn . [ IN ]
## Transitions:
## Reductions:
-- On IN reduce production mk_term(lam_defn) -> lam_defn

State 440:
## Known stack suffix:
## binders
## LR(1) items:
lam_defn -> binders . EQUAL term [ IN ]
## Transitions:
-- On EQUAL shift to state 441
## Reductions:

State 441:
## Known stack suffix:
## binders EQUAL
## LR(1) items:
lam_defn -> binders EQUAL . term [ IN ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 442
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 442:
## Known stack suffix:
## binders EQUAL term
## LR(1) items:
lam_defn -> binders EQUAL term . [ IN ]
## Transitions:
## Reductions:
-- On IN reduce production lam_defn -> binders EQUAL term

State 443:
## Known stack suffix:
## LET attrs(lident_nq)
## LR(1) items:
pat_arg_ -> attrs(lident_nq) . [ EQUAL COMMA COLON BAR AS ]
single_term_ -> LET attrs(lident_nq) . mk_term(lam_defn) IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On mk_term(lam_defn) shift to state 444
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On lam_defn shift to state 439
-- On binders shift to state 440
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:
-- On EQUAL reduce production pat_arg_ -> attrs(lident_nq)
-- On COMMA reduce production pat_arg_ -> attrs(lident_nq)
-- On COLON reduce production pat_arg_ -> attrs(lident_nq)
-- On BAR reduce production pat_arg_ -> attrs(lident_nq)
-- On AS reduce production pat_arg_ -> attrs(lident_nq)

State 444:
## Known stack suffix:
## LET attrs(lident_nq) mk_term(lam_defn)
## LR(1) items:
single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On IN shift to state 445
## Reductions:

State 445:
## Known stack suffix:
## LET attrs(lident_nq) mk_term(lam_defn) IN
## LR(1) items:
single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 446
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 446:
## Known stack suffix:
## LET attrs(lident_nq) mk_term(lam_defn) IN term
## LR(1) items:
single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On VAL reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On USE reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On TYPE reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On THEN reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On SO reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On SEMICOLON reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On SCOPE reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On RIGHTSQ reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On RIGHTPAR reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On RIGHTBRC reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On PREDICATE reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On OR reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On OP4 reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On OP3 reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On OP2 reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On OP1 reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On MINUS reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On META reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On LTGT reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On LT reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On LRARROW reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On LET reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On LEMMA reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On LARROW reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On INDUCTIVE reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On IN reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On IMPORT reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On GT reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On GOAL reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On FUNCTION reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On EXCEPTION reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On EQUAL reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On EOF reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On END reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On ELSE reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On DOTDOT reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On CONSTANT reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On COMMA reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On COLON reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On COINDUCTIVE reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On CLONE reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On BY reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On BARBAR reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On BAR reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On AXIOM reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On AT reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On ARROW reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On AND reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term
-- On AMPAMP reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term

State 447:
## Known stack suffix:
## MATCH term
## LR(1) items:
single_term_ -> MATCH term . WITH match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On WITH shift to state 448
## Reductions:

State 448:
## Known stack suffix:
## MATCH term WITH
## LR(1) items:
single_term_ -> MATCH term WITH . match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On BAR shift to state 449
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,match_case(term)) shift to state 457
-- On pattern_ shift to state 243
-- On pattern shift to state 451
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_cases(term) shift to state 458
-- On match_case(term) shift to state 454
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On bar_list1(match_case(term)) shift to state 460
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 449:
## Known stack suffix:
## BAR
## LR(1) items:
bar_list1(match_case(term)) -> BAR . separated_nonempty_list(BAR,match_case(term)) [ RIGHTBRC END ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,match_case(term)) shift to state 450
-- On pattern_ shift to state 243
-- On pattern shift to state 451
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_case(term) shift to state 454
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 450:
## Known stack suffix:
## BAR separated_nonempty_list(BAR,match_case(term))
## LR(1) items:
bar_list1(match_case(term)) -> BAR separated_nonempty_list(BAR,match_case(term)) . [ RIGHTBRC END ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production bar_list1(match_case(term)) -> BAR separated_nonempty_list(BAR,match_case(term))
-- On END reduce production bar_list1(match_case(term)) -> BAR separated_nonempty_list(BAR,match_case(term))

State 451:
## Known stack suffix:
## pattern
## LR(1) items:
match_case(term) -> pattern . ARROW term [ RIGHTBRC END BAR ]
## Transitions:
-- On ARROW shift to state 452
## Reductions:

State 452:
## Known stack suffix:
## pattern ARROW
## LR(1) items:
match_case(term) -> pattern ARROW . term [ RIGHTBRC END BAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 453
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 453:
## Known stack suffix:
## pattern ARROW term
## LR(1) items:
match_case(term) -> pattern ARROW term . [ RIGHTBRC END BAR ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production match_case(term) -> pattern ARROW term
-- On END reduce production match_case(term) -> pattern ARROW term
-- On BAR reduce production match_case(term) -> pattern ARROW term

State 454:
## Known stack suffix:
## match_case(term)
## LR(1) items:
separated_nonempty_list(BAR,match_case(term)) -> match_case(term) . [ RIGHTBRC END ]
separated_nonempty_list(BAR,match_case(term)) -> match_case(term) . BAR separated_nonempty_list(BAR,match_case(term)) [ RIGHTBRC END ]
## Transitions:
-- On BAR shift to state 455
## Reductions:
-- On RIGHTBRC reduce production separated_nonempty_list(BAR,match_case(term)) -> match_case(term)
-- On END reduce production separated_nonempty_list(BAR,match_case(term)) -> match_case(term)

State 455:
## Known stack suffix:
## match_case(term) BAR
## LR(1) items:
separated_nonempty_list(BAR,match_case(term)) -> match_case(term) BAR . separated_nonempty_list(BAR,match_case(term)) [ RIGHTBRC END ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,match_case(term)) shift to state 456
-- On pattern_ shift to state 243
-- On pattern shift to state 451
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_case(term) shift to state 454
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 456:
## Known stack suffix:
## match_case(term) BAR separated_nonempty_list(BAR,match_case(term))
## LR(1) items:
separated_nonempty_list(BAR,match_case(term)) -> match_case(term) BAR separated_nonempty_list(BAR,match_case(term)) . [ RIGHTBRC END ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production separated_nonempty_list(BAR,match_case(term)) -> match_case(term) BAR separated_nonempty_list(BAR,match_case(term))
-- On END reduce production separated_nonempty_list(BAR,match_case(term)) -> match_case(term) BAR separated_nonempty_list(BAR,match_case(term))

State 457:
## Known stack suffix:
## separated_nonempty_list(BAR,match_case(term))
## LR(1) items:
bar_list1(match_case(term)) -> separated_nonempty_list(BAR,match_case(term)) . [ RIGHTBRC END ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production bar_list1(match_case(term)) -> separated_nonempty_list(BAR,match_case(term))
-- On END reduce production bar_list1(match_case(term)) -> separated_nonempty_list(BAR,match_case(term))

State 458:
## Known stack suffix:
## MATCH term WITH match_cases(term)
## LR(1) items:
single_term_ -> MATCH term WITH match_cases(term) . END [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On END shift to state 459
## Reductions:

State 459:
## Known stack suffix:
## MATCH term WITH match_cases(term) END
## LR(1) items:
single_term_ -> MATCH term WITH match_cases(term) END . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On VAL reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On USE reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On TYPE reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On THEN reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On SO reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On SEMICOLON reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On SCOPE reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On RIGHTSQ_QUOTE reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On RIGHTSQ reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On RIGHTPAR reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On RIGHTBRC reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On PREDICATE reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On OR reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On OP4 reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On OP3 reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On OP2 reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On OP1 reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On MINUS reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On META reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On LTGT reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On LT reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On LRARROW reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On LET reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On LEMMA reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On LARROW reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On INDUCTIVE reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On IN reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On IMPORT reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On GT reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On GOAL reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On FUNCTION reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On EXCEPTION reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On EQUAL reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On EOF reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On END reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On ELSE reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On DOTDOT reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On CONSTANT reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On COMMA reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On COLON reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On COINDUCTIVE reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On CLONE reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On BY reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On BARBAR reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On BAR reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On AXIOM reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On AT reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On ARROW reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On AND reduce production single_term_ -> MATCH term WITH match_cases(term) END
-- On AMPAMP reduce production single_term_ -> MATCH term WITH match_cases(term) END

State 460:
## Known stack suffix:
## bar_list1(match_case(term))
## LR(1) items:
match_cases(term) -> bar_list1(match_case(term)) . [ RIGHTBRC END ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production match_cases(term) -> bar_list1(match_case(term))
-- On END reduce production match_cases(term) -> bar_list1(match_case(term))

State 461:
## Known stack suffix:
## NOT single_term
## LR(1) items:
single_term_ -> NOT single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> NOT single_term
-- On VAL reduce production single_term_ -> NOT single_term
-- On USE reduce production single_term_ -> NOT single_term
-- On TYPE reduce production single_term_ -> NOT single_term
-- On THEN reduce production single_term_ -> NOT single_term
-- On SO reduce production single_term_ -> NOT single_term
-- On SEMICOLON reduce production single_term_ -> NOT single_term
-- On SCOPE reduce production single_term_ -> NOT single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> NOT single_term
-- On RIGHTSQ reduce production single_term_ -> NOT single_term
-- On RIGHTPAR reduce production single_term_ -> NOT single_term
-- On RIGHTBRC reduce production single_term_ -> NOT single_term
-- On PREDICATE reduce production single_term_ -> NOT single_term
-- On OR reduce production single_term_ -> NOT single_term
-- On META reduce production single_term_ -> NOT single_term
-- On LRARROW reduce production single_term_ -> NOT single_term
-- On LET reduce production single_term_ -> NOT single_term
-- On LEMMA reduce production single_term_ -> NOT single_term
-- On LARROW reduce production single_term_ -> NOT single_term
-- On INDUCTIVE reduce production single_term_ -> NOT single_term
-- On IN reduce production single_term_ -> NOT single_term
-- On IMPORT reduce production single_term_ -> NOT single_term
-- On GOAL reduce production single_term_ -> NOT single_term
-- On FUNCTION reduce production single_term_ -> NOT single_term
-- On EXCEPTION reduce production single_term_ -> NOT single_term
-- On EOF reduce production single_term_ -> NOT single_term
-- On END reduce production single_term_ -> NOT single_term
-- On ELSE reduce production single_term_ -> NOT single_term
-- On DOTDOT reduce production single_term_ -> NOT single_term
-- On CONSTANT reduce production single_term_ -> NOT single_term
-- On COMMA reduce production single_term_ -> NOT single_term
-- On COLON reduce production single_term_ -> NOT single_term
-- On COINDUCTIVE reduce production single_term_ -> NOT single_term
-- On CLONE reduce production single_term_ -> NOT single_term
-- On BY reduce production single_term_ -> NOT single_term
-- On BARBAR reduce production single_term_ -> NOT single_term
-- On BAR reduce production single_term_ -> NOT single_term
-- On AXIOM reduce production single_term_ -> NOT single_term
-- On ARROW reduce production single_term_ -> NOT single_term
-- On AND reduce production single_term_ -> NOT single_term
-- On AMPAMP reduce production single_term_ -> NOT single_term

State 462:
## Known stack suffix:
## OLD single_term
## LR(1) items:
single_term_ -> OLD single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On MINUS shift to state 362
-- On cast shift to state 329
## Reductions:
-- On WITH reduce production single_term_ -> OLD single_term
-- On VAL reduce production single_term_ -> OLD single_term
-- On USE reduce production single_term_ -> OLD single_term
-- On TYPE reduce production single_term_ -> OLD single_term
-- On THEN reduce production single_term_ -> OLD single_term
-- On SO reduce production single_term_ -> OLD single_term
-- On SEMICOLON reduce production single_term_ -> OLD single_term
-- On SCOPE reduce production single_term_ -> OLD single_term
-- On RIGHTSQ_QUOTE reduce production single_term_ -> OLD single_term
-- On RIGHTSQ reduce production single_term_ -> OLD single_term
-- On RIGHTPAR reduce production single_term_ -> OLD single_term
-- On RIGHTBRC reduce production single_term_ -> OLD single_term
-- On PREDICATE reduce production single_term_ -> OLD single_term
-- On OR reduce production single_term_ -> OLD single_term
-- On OP1 reduce production single_term_ -> OLD single_term
-- On META reduce production single_term_ -> OLD single_term
-- On LTGT reduce production single_term_ -> OLD single_term
-- On LT reduce production single_term_ -> OLD single_term
-- On LRARROW reduce production single_term_ -> OLD single_term
-- On LET reduce production single_term_ -> OLD single_term
-- On LEMMA reduce production single_term_ -> OLD single_term
-- On LARROW reduce production single_term_ -> OLD single_term
-- On INDUCTIVE reduce production single_term_ -> OLD single_term
-- On IN reduce production single_term_ -> OLD single_term
-- On IMPORT reduce production single_term_ -> OLD single_term
-- On GT reduce production single_term_ -> OLD single_term
-- On GOAL reduce production single_term_ -> OLD single_term
-- On FUNCTION reduce production single_term_ -> OLD single_term
-- On EXCEPTION reduce production single_term_ -> OLD single_term
-- On EQUAL reduce production single_term_ -> OLD single_term
-- On EOF reduce production single_term_ -> OLD single_term
-- On END reduce production single_term_ -> OLD single_term
-- On ELSE reduce production single_term_ -> OLD single_term
-- On DOTDOT reduce production single_term_ -> OLD single_term
-- On CONSTANT reduce production single_term_ -> OLD single_term
-- On COMMA reduce production single_term_ -> OLD single_term
-- On COLON reduce production single_term_ -> OLD single_term
-- On COINDUCTIVE reduce production single_term_ -> OLD single_term
-- On CLONE reduce production single_term_ -> OLD single_term
-- On BY reduce production single_term_ -> OLD single_term
-- On BARBAR reduce production single_term_ -> OLD single_term
-- On BAR reduce production single_term_ -> OLD single_term
-- On AXIOM reduce production single_term_ -> OLD single_term
-- On ARROW reduce production single_term_ -> OLD single_term
-- On AND reduce production single_term_ -> OLD single_term
-- On AMPAMP reduce production single_term_ -> OLD single_term

State 463:
## Known stack suffix:
## BEGIN END
## LR(1) items:
term_block_ -> BEGIN END . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_block_ -> BEGIN END
-- On VAL reduce production term_block_ -> BEGIN END
-- On USE reduce production term_block_ -> BEGIN END
-- On UIDENT reduce production term_block_ -> BEGIN END
-- On TYPE reduce production term_block_ -> BEGIN END
-- On TRUE reduce production term_block_ -> BEGIN END
-- On THEN reduce production term_block_ -> BEGIN END
-- On SO reduce production term_block_ -> BEGIN END
-- On SEMICOLON reduce production term_block_ -> BEGIN END
-- On SCOPE reduce production term_block_ -> BEGIN END
-- On RIGHTSQ_QUOTE reduce production term_block_ -> BEGIN END
-- On RIGHTSQ reduce production term_block_ -> BEGIN END
-- On RIGHTPAR reduce production term_block_ -> BEGIN END
-- On RIGHTBRC reduce production term_block_ -> BEGIN END
-- On REAL reduce production term_block_ -> BEGIN END
-- On RANGE reduce production term_block_ -> BEGIN END
-- On PREDICATE reduce production term_block_ -> BEGIN END
-- On OR reduce production term_block_ -> BEGIN END
-- On OPPREF reduce production term_block_ -> BEGIN END
-- On OP4 reduce production term_block_ -> BEGIN END
-- On OP3 reduce production term_block_ -> BEGIN END
-- On OP2 reduce production term_block_ -> BEGIN END
-- On OP1 reduce production term_block_ -> BEGIN END
-- On MINUS reduce production term_block_ -> BEGIN END
-- On META reduce production term_block_ -> BEGIN END
-- On LTGT reduce production term_block_ -> BEGIN END
-- On LT reduce production term_block_ -> BEGIN END
-- On LRARROW reduce production term_block_ -> BEGIN END
-- On LIDENT reduce production term_block_ -> BEGIN END
-- On LET reduce production term_block_ -> BEGIN END
-- On LEMMA reduce production term_block_ -> BEGIN END
-- On LEFTSQ reduce production term_block_ -> BEGIN END
-- On LEFTPAR reduce production term_block_ -> BEGIN END
-- On LEFTBRC reduce production term_block_ -> BEGIN END
-- On LARROW reduce production term_block_ -> BEGIN END
-- On INTEGER reduce production term_block_ -> BEGIN END
-- On INDUCTIVE reduce production term_block_ -> BEGIN END
-- On IN reduce production term_block_ -> BEGIN END
-- On IMPORT reduce production term_block_ -> BEGIN END
-- On GT reduce production term_block_ -> BEGIN END
-- On GOAL reduce production term_block_ -> BEGIN END
-- On FUNCTION reduce production term_block_ -> BEGIN END
-- On FLOAT reduce production term_block_ -> BEGIN END
-- On FALSE reduce production term_block_ -> BEGIN END
-- On EXCEPTION reduce production term_block_ -> BEGIN END
-- On EQUAL reduce production term_block_ -> BEGIN END
-- On EOF reduce production term_block_ -> BEGIN END
-- On END reduce production term_block_ -> BEGIN END
-- On ELSE reduce production term_block_ -> BEGIN END
-- On DOTDOT reduce production term_block_ -> BEGIN END
-- On DOT reduce production term_block_ -> BEGIN END
-- On CORE_UIDENT reduce production term_block_ -> BEGIN END
-- On CORE_LIDENT reduce production term_block_ -> BEGIN END
-- On CONSTANT reduce production term_block_ -> BEGIN END
-- On COMMA reduce production term_block_ -> BEGIN END
-- On COLON reduce production term_block_ -> BEGIN END
-- On COINDUCTIVE reduce production term_block_ -> BEGIN END
-- On CLONE reduce production term_block_ -> BEGIN END
-- On BY reduce production term_block_ -> BEGIN END
-- On BEGIN reduce production term_block_ -> BEGIN END
-- On BARBAR reduce production term_block_ -> BEGIN END
-- On BAR reduce production term_block_ -> BEGIN END
-- On AXIOM reduce production term_block_ -> BEGIN END
-- On AT reduce production term_block_ -> BEGIN END
-- On ARROW reduce production term_block_ -> BEGIN END
-- On AND reduce production term_block_ -> BEGIN END
-- On AMPAMP reduce production term_block_ -> BEGIN END

State 464:
## Known stack suffix:
## BEGIN term
## LR(1) items:
term_block_ -> BEGIN term . END [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On END shift to state 465
## Reductions:

State 465:
## Known stack suffix:
## BEGIN term END
## LR(1) items:
term_block_ -> BEGIN term END . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_block_ -> BEGIN term END
-- On VAL reduce production term_block_ -> BEGIN term END
-- On USE reduce production term_block_ -> BEGIN term END
-- On UIDENT reduce production term_block_ -> BEGIN term END
-- On TYPE reduce production term_block_ -> BEGIN term END
-- On TRUE reduce production term_block_ -> BEGIN term END
-- On THEN reduce production term_block_ -> BEGIN term END
-- On SO reduce production term_block_ -> BEGIN term END
-- On SEMICOLON reduce production term_block_ -> BEGIN term END
-- On SCOPE reduce production term_block_ -> BEGIN term END
-- On RIGHTSQ_QUOTE reduce production term_block_ -> BEGIN term END
-- On RIGHTSQ reduce production term_block_ -> BEGIN term END
-- On RIGHTPAR reduce production term_block_ -> BEGIN term END
-- On RIGHTBRC reduce production term_block_ -> BEGIN term END
-- On REAL reduce production term_block_ -> BEGIN term END
-- On RANGE reduce production term_block_ -> BEGIN term END
-- On PREDICATE reduce production term_block_ -> BEGIN term END
-- On OR reduce production term_block_ -> BEGIN term END
-- On OPPREF reduce production term_block_ -> BEGIN term END
-- On OP4 reduce production term_block_ -> BEGIN term END
-- On OP3 reduce production term_block_ -> BEGIN term END
-- On OP2 reduce production term_block_ -> BEGIN term END
-- On OP1 reduce production term_block_ -> BEGIN term END
-- On MINUS reduce production term_block_ -> BEGIN term END
-- On META reduce production term_block_ -> BEGIN term END
-- On LTGT reduce production term_block_ -> BEGIN term END
-- On LT reduce production term_block_ -> BEGIN term END
-- On LRARROW reduce production term_block_ -> BEGIN term END
-- On LIDENT reduce production term_block_ -> BEGIN term END
-- On LET reduce production term_block_ -> BEGIN term END
-- On LEMMA reduce production term_block_ -> BEGIN term END
-- On LEFTSQ reduce production term_block_ -> BEGIN term END
-- On LEFTPAR reduce production term_block_ -> BEGIN term END
-- On LEFTBRC reduce production term_block_ -> BEGIN term END
-- On LARROW reduce production term_block_ -> BEGIN term END
-- On INTEGER reduce production term_block_ -> BEGIN term END
-- On INDUCTIVE reduce production term_block_ -> BEGIN term END
-- On IN reduce production term_block_ -> BEGIN term END
-- On IMPORT reduce production term_block_ -> BEGIN term END
-- On GT reduce production term_block_ -> BEGIN term END
-- On GOAL reduce production term_block_ -> BEGIN term END
-- On FUNCTION reduce production term_block_ -> BEGIN term END
-- On FLOAT reduce production term_block_ -> BEGIN term END
-- On FALSE reduce production term_block_ -> BEGIN term END
-- On EXCEPTION reduce production term_block_ -> BEGIN term END
-- On EQUAL reduce production term_block_ -> BEGIN term END
-- On EOF reduce production term_block_ -> BEGIN term END
-- On END reduce production term_block_ -> BEGIN term END
-- On ELSE reduce production term_block_ -> BEGIN term END
-- On DOTDOT reduce production term_block_ -> BEGIN term END
-- On DOT reduce production term_block_ -> BEGIN term END
-- On CORE_UIDENT reduce production term_block_ -> BEGIN term END
-- On CORE_LIDENT reduce production term_block_ -> BEGIN term END
-- On CONSTANT reduce production term_block_ -> BEGIN term END
-- On COMMA reduce production term_block_ -> BEGIN term END
-- On COLON reduce production term_block_ -> BEGIN term END
-- On COINDUCTIVE reduce production term_block_ -> BEGIN term END
-- On CLONE reduce production term_block_ -> BEGIN term END
-- On BY reduce production term_block_ -> BEGIN term END
-- On BEGIN reduce production term_block_ -> BEGIN term END
-- On BARBAR reduce production term_block_ -> BEGIN term END
-- On BAR reduce production term_block_ -> BEGIN term END
-- On AXIOM reduce production term_block_ -> BEGIN term END
-- On AT reduce production term_block_ -> BEGIN term END
-- On ARROW reduce production term_block_ -> BEGIN term END
-- On AND reduce production term_block_ -> BEGIN term END
-- On AMPAMP reduce production term_block_ -> BEGIN term END

State 466:
## Known stack suffix:
## uqualid
## LR(1) items:
lqualid -> uqualid . DOT lident [ EQUAL DOT ]
qualid -> uqualid . DOT ident [ WITH LEFTSQ ]
term_sub_ -> uqualid . DOT mk_term(term_block_) [ WITH LEFTSQ DOT ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 467
## Reductions:

State 467:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
lqualid -> uqualid DOT . lident [ EQUAL DOT ]
qualid -> uqualid DOT . ident [ WITH LEFTSQ ]
term_sub_ -> uqualid DOT . mk_term(term_block_) [ WITH LEFTSQ DOT ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uident shift to state 297
-- On term_block_ shift to state 298
-- On mk_term(term_block_) shift to state 299
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 468
-- On ident shift to state 301
## Reductions:

State 468:
## Known stack suffix:
## uqualid DOT lident
## LR(1) items:
ident -> lident . [ WITH RIGHTBRC LEFTSQ ]
lqualid -> uqualid DOT lident . [ EQUAL DOT ]
## Transitions:
## Reductions:
-- On WITH reduce production ident -> lident
-- On RIGHTBRC reduce production ident -> lident
-- On LEFTSQ reduce production ident -> lident
-- On EQUAL reduce production lqualid -> uqualid DOT lident
-- On DOT reduce production lqualid -> uqualid DOT lident

State 469:
## Known stack suffix:
## LEFTBRC term_arg
## LR(1) items:
term_block_ -> LEFTBRC term_arg . WITH field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term rightsq [ WITH LEFTSQ DOT ]
term_sub_ -> term_arg . LEFTSQ term LARROW term rightsq [ WITH LEFTSQ DOT ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT term rightsq [ WITH LEFTSQ DOT ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT rightsq [ WITH LEFTSQ DOT ]
term_sub_ -> term_arg . LEFTSQ DOTDOT term rightsq [ WITH LEFTSQ DOT ]
## Transitions:
-- On WITH shift to state 470
-- On LEFTSQ shift to state 317
## Reductions:

State 470:
## Known stack suffix:
## LEFTBRC term_arg WITH
## LR(1) items:
term_block_ -> LEFTBRC term_arg WITH . field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,term)) shift to state 471
-- On lqualid shift to state 472
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On field_list1(term) shift to state 477
## Reductions:

State 471:
## Known stack suffix:
## semicolon_list1(separated_pair(lqualid,EQUAL,term))
## LR(1) items:
field_list1(term) -> semicolon_list1(separated_pair(lqualid,EQUAL,term)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production field_list1(term) -> semicolon_list1(separated_pair(lqualid,EQUAL,term))

State 472:
## Known stack suffix:
## lqualid
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
## Transitions:
-- On EQUAL shift to state 473
## Reductions:

State 473:
## Known stack suffix:
## lqualid EQUAL
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL . term [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL . term SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL . term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 474
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 474:
## Known stack suffix:
## lqualid EQUAL term
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term . [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term . SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term . SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
## Transitions:
-- On SEMICOLON shift to state 475
## Reductions:
-- On RIGHTBRC reduce production semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term

State 475:
## Known stack suffix:
## lqualid EQUAL term SEMICOLON
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON . [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON . semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,term)) shift to state 476
-- On lqualid shift to state 472
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:
-- On RIGHTBRC reduce production semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON

State 476:
## Known stack suffix:
## lqualid EQUAL term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term))
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term))

State 477:
## Known stack suffix:
## LEFTBRC term_arg WITH field_list1(term)
## LR(1) items:
term_block_ -> LEFTBRC term_arg WITH field_list1(term) . RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTBRC shift to state 478
## Reductions:

State 478:
## Known stack suffix:
## LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
## LR(1) items:
term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On VAL reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On USE reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On UIDENT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On TYPE reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On TRUE reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On THEN reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On SO reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On SEMICOLON reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On SCOPE reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On RIGHTSQ reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On RIGHTPAR reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On RIGHTBRC reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On REAL reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On RANGE reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On PREDICATE reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On OR reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On OPPREF reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On OP4 reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On OP3 reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On OP2 reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On OP1 reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On MINUS reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On META reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On LTGT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On LT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On LRARROW reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On LIDENT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On LET reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On LEMMA reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On LEFTSQ reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On LEFTPAR reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On LEFTBRC reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On LARROW reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On INTEGER reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On INDUCTIVE reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On IN reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On IMPORT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On GT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On GOAL reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On FUNCTION reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On FLOAT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On FALSE reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On EXCEPTION reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On EQUAL reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On EOF reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On END reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On ELSE reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On DOTDOT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On DOT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On CORE_UIDENT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On CORE_LIDENT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On CONSTANT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On COMMA reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On COLON reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On COINDUCTIVE reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On CLONE reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On BY reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On BEGIN reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On BARBAR reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On BAR reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On AXIOM reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On AT reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On ARROW reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On AND reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
-- On AMPAMP reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC

State 479:
## Known stack suffix:
## lqualid
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
term_dot_ -> lqualid . [ DOT ]
## Transitions:
-- On EQUAL shift to state 473
## Reductions:
-- On DOT reduce production term_dot_ -> lqualid

State 480:
## Known stack suffix:
## lident
## LR(1) items:
ident -> lident . [ WITH RIGHTBRC LEFTSQ ]
lqualid -> lident . [ EQUAL DOT ]
## Transitions:
## Reductions:
-- On WITH reduce production ident -> lident
-- On RIGHTBRC reduce production ident -> lident
-- On LEFTSQ reduce production ident -> lident
-- On EQUAL reduce production lqualid -> lident
-- On DOT reduce production lqualid -> lident

State 481:
## Known stack suffix:
## LEFTBRC field_list1(term)
## LR(1) items:
term_block_ -> LEFTBRC field_list1(term) . RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTBRC shift to state 482
## Reductions:

State 482:
## Known stack suffix:
## LEFTBRC field_list1(term) RIGHTBRC
## LR(1) items:
term_block_ -> LEFTBRC field_list1(term) RIGHTBRC . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On VAL reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On USE reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On UIDENT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On TYPE reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On TRUE reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On THEN reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On SO reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On SEMICOLON reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On SCOPE reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On RIGHTSQ reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On RIGHTPAR reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On RIGHTBRC reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On REAL reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On RANGE reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On PREDICATE reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On OR reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On OPPREF reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On OP4 reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On OP3 reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On OP2 reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On OP1 reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On MINUS reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On META reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On LTGT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On LT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On LRARROW reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On LIDENT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On LET reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On LEMMA reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On LEFTSQ reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On LEFTPAR reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On LEFTBRC reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On LARROW reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On INTEGER reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On INDUCTIVE reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On IN reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On IMPORT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On GT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On GOAL reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On FUNCTION reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On FLOAT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On FALSE reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On EXCEPTION reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On EQUAL reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On EOF reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On END reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On ELSE reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On DOTDOT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On DOT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On CORE_UIDENT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On CORE_LIDENT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On CONSTANT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On COMMA reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On COLON reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On COINDUCTIVE reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On CLONE reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On BY reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On BEGIN reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On BARBAR reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On BAR reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On AXIOM reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On AT reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On ARROW reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On AND reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC
-- On AMPAMP reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC

State 483:
## Known stack suffix:
## OPPREF term_dot
## LR(1) items:
term_dot_ -> OPPREF term_dot . [ DOT ]
term_sub_ -> term_dot . DOT lqualid_rich [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On DOT reduce production term_dot_ -> OPPREF term_dot

State 484:
## Known stack suffix:
## OPPREF term_arg
## LR(1) items:
term_arg_ -> OPPREF term_arg . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term LARROW term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_arg_ -> OPPREF term_arg
-- On VAL reduce production term_arg_ -> OPPREF term_arg
-- On USE reduce production term_arg_ -> OPPREF term_arg
-- On UIDENT reduce production term_arg_ -> OPPREF term_arg
-- On TYPE reduce production term_arg_ -> OPPREF term_arg
-- On TRUE reduce production term_arg_ -> OPPREF term_arg
-- On THEN reduce production term_arg_ -> OPPREF term_arg
-- On SO reduce production term_arg_ -> OPPREF term_arg
-- On SEMICOLON reduce production term_arg_ -> OPPREF term_arg
-- On SCOPE reduce production term_arg_ -> OPPREF term_arg
-- On RIGHTSQ_QUOTE reduce production term_arg_ -> OPPREF term_arg
-- On RIGHTSQ reduce production term_arg_ -> OPPREF term_arg
-- On RIGHTPAR reduce production term_arg_ -> OPPREF term_arg
-- On RIGHTBRC reduce production term_arg_ -> OPPREF term_arg
-- On REAL reduce production term_arg_ -> OPPREF term_arg
-- On RANGE reduce production term_arg_ -> OPPREF term_arg
-- On PREDICATE reduce production term_arg_ -> OPPREF term_arg
-- On OR reduce production term_arg_ -> OPPREF term_arg
-- On OPPREF reduce production term_arg_ -> OPPREF term_arg
-- On OP4 reduce production term_arg_ -> OPPREF term_arg
-- On OP3 reduce production term_arg_ -> OPPREF term_arg
-- On OP2 reduce production term_arg_ -> OPPREF term_arg
-- On OP1 reduce production term_arg_ -> OPPREF term_arg
-- On MINUS reduce production term_arg_ -> OPPREF term_arg
-- On META reduce production term_arg_ -> OPPREF term_arg
-- On LTGT reduce production term_arg_ -> OPPREF term_arg
-- On LT reduce production term_arg_ -> OPPREF term_arg
-- On LRARROW reduce production term_arg_ -> OPPREF term_arg
-- On LIDENT reduce production term_arg_ -> OPPREF term_arg
-- On LET reduce production term_arg_ -> OPPREF term_arg
-- On LEMMA reduce production term_arg_ -> OPPREF term_arg
-- On LEFTSQ reduce production term_arg_ -> OPPREF term_arg
-- On LEFTPAR reduce production term_arg_ -> OPPREF term_arg
-- On LEFTBRC reduce production term_arg_ -> OPPREF term_arg
-- On LARROW reduce production term_arg_ -> OPPREF term_arg
-- On INTEGER reduce production term_arg_ -> OPPREF term_arg
-- On INDUCTIVE reduce production term_arg_ -> OPPREF term_arg
-- On IN reduce production term_arg_ -> OPPREF term_arg
-- On IMPORT reduce production term_arg_ -> OPPREF term_arg
-- On GT reduce production term_arg_ -> OPPREF term_arg
-- On GOAL reduce production term_arg_ -> OPPREF term_arg
-- On FUNCTION reduce production term_arg_ -> OPPREF term_arg
-- On FLOAT reduce production term_arg_ -> OPPREF term_arg
-- On FALSE reduce production term_arg_ -> OPPREF term_arg
-- On EXCEPTION reduce production term_arg_ -> OPPREF term_arg
-- On EQUAL reduce production term_arg_ -> OPPREF term_arg
-- On EOF reduce production term_arg_ -> OPPREF term_arg
-- On END reduce production term_arg_ -> OPPREF term_arg
-- On ELSE reduce production term_arg_ -> OPPREF term_arg
-- On DOTDOT reduce production term_arg_ -> OPPREF term_arg
-- On CORE_UIDENT reduce production term_arg_ -> OPPREF term_arg
-- On CORE_LIDENT reduce production term_arg_ -> OPPREF term_arg
-- On CONSTANT reduce production term_arg_ -> OPPREF term_arg
-- On COMMA reduce production term_arg_ -> OPPREF term_arg
-- On COLON reduce production term_arg_ -> OPPREF term_arg
-- On COINDUCTIVE reduce production term_arg_ -> OPPREF term_arg
-- On CLONE reduce production term_arg_ -> OPPREF term_arg
-- On BY reduce production term_arg_ -> OPPREF term_arg
-- On BEGIN reduce production term_arg_ -> OPPREF term_arg
-- On BARBAR reduce production term_arg_ -> OPPREF term_arg
-- On BAR reduce production term_arg_ -> OPPREF term_arg
-- On AXIOM reduce production term_arg_ -> OPPREF term_arg
-- On AT reduce production term_arg_ -> OPPREF term_arg
-- On ARROW reduce production term_arg_ -> OPPREF term_arg
-- On AND reduce production term_arg_ -> OPPREF term_arg
-- On AMPAMP reduce production term_arg_ -> OPPREF term_arg

State 485:
## Known stack suffix:
## MINUS
## LR(1) items:
lident_op_str -> MINUS . UNDERSCORE [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> MINUS . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
prefix_op -> MINUS . [ UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE ]
single_term_ -> MINUS . INTEGER [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> MINUS . REAL [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 13
-- On REAL shift to state 212
-- On INTEGER shift to state 213
## Reductions:
-- On UIDENT reduce production prefix_op -> MINUS
-- On TRUE reduce production prefix_op -> MINUS
-- On RIGHTPAR_USCORE reduce production lident_op_str -> MINUS
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> MINUS
-- On RIGHTPAR reduce production lident_op_str -> MINUS
-- On RANGE reduce production prefix_op -> MINUS
-- On POSITION reduce production prefix_op -> MINUS
-- On OPPREF reduce production prefix_op -> MINUS
-- On OP4 reduce production prefix_op -> MINUS
-- On OP3 reduce production prefix_op -> MINUS
-- On OP2 reduce production prefix_op -> MINUS
-- On OP1 reduce production prefix_op -> MINUS
-- On OLD reduce production prefix_op -> MINUS
-- On NOT reduce production prefix_op -> MINUS
-- On MINUS reduce production prefix_op -> MINUS
-- On MATCH reduce production prefix_op -> MINUS
-- On LT reduce production prefix_op -> MINUS
-- On LIDENT reduce production prefix_op -> MINUS
-- On LET reduce production prefix_op -> MINUS
-- On LEFTPAR reduce production prefix_op -> MINUS
-- On LEFTBRC reduce production prefix_op -> MINUS
-- On IF reduce production prefix_op -> MINUS
-- On GT reduce production prefix_op -> MINUS
-- On FUN reduce production prefix_op -> MINUS
-- On FORALL reduce production prefix_op -> MINUS
-- On FLOAT reduce production prefix_op -> MINUS
-- On FALSE reduce production prefix_op -> MINUS
-- On EXISTS reduce production prefix_op -> MINUS
-- On EPSILON reduce production prefix_op -> MINUS
-- On CORE_UIDENT reduce production prefix_op -> MINUS
-- On CORE_LIDENT reduce production prefix_op -> MINUS
-- On BEGIN reduce production prefix_op -> MINUS
-- On ATTRIBUTE reduce production prefix_op -> MINUS

State 486:
## Known stack suffix:
## LEFTPAR term
## LR(1) items:
term_block_ -> LEFTPAR term . RIGHTPAR [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTPAR shift to state 487
## Reductions:

State 487:
## Known stack suffix:
## LEFTPAR term RIGHTPAR
## LR(1) items:
term_block_ -> LEFTPAR term RIGHTPAR . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On VAL reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On USE reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On UIDENT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On TYPE reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On TRUE reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On THEN reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On SO reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On SEMICOLON reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On SCOPE reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On RIGHTSQ reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On RIGHTPAR reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On RIGHTBRC reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On REAL reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On RANGE reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On PREDICATE reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On OR reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On OPPREF reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On OP4 reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On OP3 reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On OP2 reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On OP1 reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On MINUS reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On META reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On LTGT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On LT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On LRARROW reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On LIDENT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On LET reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On LEMMA reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On LEFTSQ reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On LEFTPAR reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On LEFTBRC reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On LARROW reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On INTEGER reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On INDUCTIVE reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On IN reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On IMPORT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On GT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On GOAL reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On FUNCTION reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On FLOAT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On FALSE reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On EXCEPTION reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On EQUAL reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On EOF reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On END reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On ELSE reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On DOTDOT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On DOT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On CORE_UIDENT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On CORE_LIDENT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On CONSTANT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On COMMA reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On COLON reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On COINDUCTIVE reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On CLONE reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On BY reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On BEGIN reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On BARBAR reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On BAR reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On AXIOM reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On AT reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On ARROW reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On AND reduce production term_block_ -> LEFTPAR term RIGHTPAR
-- On AMPAMP reduce production term_block_ -> LEFTPAR term RIGHTPAR

State 488:
## Known stack suffix:
## op_symbol
## LR(1) items:
lident_op_str -> op_symbol . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> op_symbol . UNDERSCORE [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
prefix_op -> op_symbol . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On UNDERSCORE shift to state 32
## Reductions:
-- On WHILE reduce production prefix_op -> op_symbol
-- On VAL reduce production prefix_op -> op_symbol
-- On UIDENT reduce production prefix_op -> op_symbol
-- On TRY reduce production prefix_op -> op_symbol
-- On TRUE reduce production prefix_op -> op_symbol
-- On RIGHTPAR_USCORE reduce production lident_op_str -> op_symbol
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> op_symbol
-- On RIGHTPAR reduce production lident_op_str -> op_symbol
-- On RETURN reduce production prefix_op -> op_symbol
-- On REAL reduce production prefix_op -> op_symbol
-- On RANGE reduce production prefix_op -> op_symbol
-- On RAISE reduce production prefix_op -> op_symbol
-- On PURE reduce production prefix_op -> op_symbol
-- On POSITION reduce production prefix_op -> op_symbol
-- On OPPREF reduce production prefix_op -> op_symbol
-- On OP4 reduce production prefix_op -> op_symbol
-- On OP3 reduce production prefix_op -> op_symbol
-- On OP2 reduce production prefix_op -> op_symbol
-- On OP1 reduce production prefix_op -> op_symbol
-- On OLD reduce production prefix_op -> op_symbol
-- On NOT reduce production prefix_op -> op_symbol
-- On MINUS reduce production prefix_op -> op_symbol
-- On MATCH reduce production prefix_op -> op_symbol
-- On LT reduce production prefix_op -> op_symbol
-- On LIDENT reduce production prefix_op -> op_symbol
-- On LET reduce production prefix_op -> op_symbol
-- On LEFTPAR reduce production prefix_op -> op_symbol
-- On LEFTBRC reduce production prefix_op -> op_symbol
-- On LABEL reduce production prefix_op -> op_symbol
-- On INTEGER reduce production prefix_op -> op_symbol
-- On IF reduce production prefix_op -> op_symbol
-- On GT reduce production prefix_op -> op_symbol
-- On GHOST reduce production prefix_op -> op_symbol
-- On FUN reduce production prefix_op -> op_symbol
-- On FORALL reduce production prefix_op -> op_symbol
-- On FOR reduce production prefix_op -> op_symbol
-- On FLOAT reduce production prefix_op -> op_symbol
-- On FALSE reduce production prefix_op -> op_symbol
-- On EXISTS reduce production prefix_op -> op_symbol
-- On EXCEPTION reduce production prefix_op -> op_symbol
-- On EPSILON reduce production prefix_op -> op_symbol
-- On CORE_UIDENT reduce production prefix_op -> op_symbol
-- On CORE_LIDENT reduce production prefix_op -> op_symbol
-- On CONTINUE reduce production prefix_op -> op_symbol
-- On CHECK reduce production prefix_op -> op_symbol
-- On BREAK reduce production prefix_op -> op_symbol
-- On BEGIN reduce production prefix_op -> op_symbol
-- On ATTRIBUTE reduce production prefix_op -> op_symbol
-- On ASSUME reduce production prefix_op -> op_symbol
-- On ASSERT reduce production prefix_op -> op_symbol
-- On ANY reduce production prefix_op -> op_symbol
-- On ABSURD reduce production prefix_op -> op_symbol

State 489:
## Known stack suffix:
## separated_nonempty_list(COMMA,single_term)
## LR(1) items:
loption(separated_nonempty_list(COMMA,single_term)) -> separated_nonempty_list(COMMA,single_term) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production loption(separated_nonempty_list(COMMA,single_term)) -> separated_nonempty_list(COMMA,single_term)

State 490:
## Known stack suffix:
## loption(separated_nonempty_list(COMMA,single_term))
## LR(1) items:
comma_list0(single_term) -> loption(separated_nonempty_list(COMMA,single_term)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production comma_list0(single_term) -> loption(separated_nonempty_list(COMMA,single_term))

State 491:
## Known stack suffix:
## WRITES LEFTBRC comma_list0(single_term)
## LR(1) items:
single_spec -> WRITES LEFTBRC comma_list0(single_term) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 492
## Reductions:

State 492:
## Known stack suffix:
## WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
## LR(1) items:
single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On WITH reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On WHILE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On VARIANT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On VAL reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On USE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On UIDENT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On TYPE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On TRY reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On TRUE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On TO reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On THEN reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On SEMICOLON reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On SCOPE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On RIGHTSQ reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On RIGHTPAR reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On RIGHTBRC reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On RETURNS reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On RETURN reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On REQUIRES reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On REAL reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On READS reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On RANGE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On RAISES reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On RAISE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On PURE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On PREDICATE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On POSITION reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On OPPREF reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On OP4 reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On OP3 reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On OP2 reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On OP1 reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On NOT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On MINUS reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On META reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On MATCH reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On LTGT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On LT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On LIDENT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On LET reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On LEMMA reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On LEFTPAR reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On LEFTBRC reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On LARROW reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On LABEL reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On INTEGER reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On INDUCTIVE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On IN reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On IMPORT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On IF reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On GT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On GOAL reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On GHOST reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On FUNCTION reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On FUN reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On FOR reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On FLOAT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On FALSE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On EXCEPTION reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On EQUAL reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On EOF reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On ENSURES reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On END reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On ELSE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On DOWNTO reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On DOTDOT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On DONE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On DO reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On DIVERGES reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On CORE_UIDENT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On CORE_LIDENT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On CONTINUE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On CONSTANT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On COMMA reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On COLON reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On COINDUCTIVE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On CLONE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On CHECK reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On BREAK reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On BEGIN reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On BARBAR reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On BAR reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On AXIOM reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On ATTRIBUTE reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On ASSUME reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On ASSERT reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On ARROW reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On ANY reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On AMPAMP reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On ALIAS reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
-- On ABSURD reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC

State 493:
## Known stack suffix:
## VARIANT
## LR(1) items:
variant -> VARIANT . LEFTBRC comma_list1(single_variant) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 494
## Reductions:

State 494:
## Known stack suffix:
## VARIANT LEFTBRC
## LR(1) items:
variant -> VARIANT LEFTBRC . comma_list1(single_variant) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_variant shift to state 495
-- On single_term_ shift to state 321
-- On single_term shift to state 497
-- On separated_nonempty_list(COMMA,single_variant) shift to state 502
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On comma_list1(single_variant) shift to state 503
-- On attr shift to state 356
## Reductions:

State 495:
## Known stack suffix:
## single_variant
## LR(1) items:
separated_nonempty_list(COMMA,single_variant) -> single_variant . [ RIGHTBRC ]
separated_nonempty_list(COMMA,single_variant) -> single_variant . COMMA separated_nonempty_list(COMMA,single_variant) [ RIGHTBRC ]
## Transitions:
-- On COMMA shift to state 496
## Reductions:
-- On RIGHTBRC reduce production separated_nonempty_list(COMMA,single_variant) -> single_variant

State 496:
## Known stack suffix:
## single_variant COMMA
## LR(1) items:
separated_nonempty_list(COMMA,single_variant) -> single_variant COMMA . separated_nonempty_list(COMMA,single_variant) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_variant shift to state 495
-- On single_term_ shift to state 321
-- On single_term shift to state 497
-- On separated_nonempty_list(COMMA,single_variant) shift to state 501
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 497:
## Known stack suffix:
## single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_variant -> single_term . option(preceded(WITH,lqualid)) [ RIGHTBRC COMMA ]
## Transitions:
-- On WITH shift to state 498
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On COLON shift to state 132
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On option(preceded(WITH,lqualid)) shift to state 500
-- On cast shift to state 329
## Reductions:
-- On RIGHTBRC reduce production option(preceded(WITH,lqualid)) ->
-- On COMMA reduce production option(preceded(WITH,lqualid)) ->

State 498:
## Known stack suffix:
## WITH
## LR(1) items:
option(preceded(WITH,lqualid)) -> WITH . lqualid [ RIGHTBRC COMMA ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On lqualid shift to state 499
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 499:
## Known stack suffix:
## WITH lqualid
## LR(1) items:
option(preceded(WITH,lqualid)) -> WITH lqualid . [ RIGHTBRC COMMA ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production option(preceded(WITH,lqualid)) -> WITH lqualid
-- On COMMA reduce production option(preceded(WITH,lqualid)) -> WITH lqualid

State 500:
## Known stack suffix:
## single_term option(preceded(WITH,lqualid))
## LR(1) items:
single_variant -> single_term option(preceded(WITH,lqualid)) . [ RIGHTBRC COMMA ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production single_variant -> single_term option(preceded(WITH,lqualid))
-- On COMMA reduce production single_variant -> single_term option(preceded(WITH,lqualid))

State 501:
## Known stack suffix:
## single_variant COMMA separated_nonempty_list(COMMA,single_variant)
## LR(1) items:
separated_nonempty_list(COMMA,single_variant) -> single_variant COMMA separated_nonempty_list(COMMA,single_variant) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production separated_nonempty_list(COMMA,single_variant) -> single_variant COMMA separated_nonempty_list(COMMA,single_variant)

State 502:
## Known stack suffix:
## separated_nonempty_list(COMMA,single_variant)
## LR(1) items:
comma_list1(single_variant) -> separated_nonempty_list(COMMA,single_variant) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production comma_list1(single_variant) -> separated_nonempty_list(COMMA,single_variant)

State 503:
## Known stack suffix:
## VARIANT LEFTBRC comma_list1(single_variant)
## LR(1) items:
variant -> VARIANT LEFTBRC comma_list1(single_variant) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 504
## Reductions:

State 504:
## Known stack suffix:
## VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
## LR(1) items:
variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On WITH reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On WHILE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On VARIANT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On VAL reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On USE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On UIDENT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On TYPE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On TRY reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On TRUE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On TO reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On THEN reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On SEMICOLON reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On SCOPE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On RIGHTSQ reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On RIGHTPAR reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On RIGHTBRC reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On RETURNS reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On RETURN reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On REQUIRES reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On REAL reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On READS reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On RANGE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On RAISES reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On RAISE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On PURE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On PREDICATE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On POSITION reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On OPPREF reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On OP4 reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On OP3 reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On OP2 reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On OP1 reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On NOT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On MINUS reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On META reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On MATCH reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On LTGT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On LT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On LIDENT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On LET reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On LEMMA reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On LEFTPAR reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On LEFTBRC reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On LARROW reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On LABEL reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On INVARIANT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On INTEGER reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On INDUCTIVE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On IN reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On IMPORT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On IF reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On GT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On GOAL reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On GHOST reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On FUNCTION reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On FUN reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On FOR reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On FLOAT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On FALSE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On EXCEPTION reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On EQUAL reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On EOF reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On ENSURES reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On END reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On ELSE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On DOWNTO reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On DOTDOT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On DONE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On DO reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On DIVERGES reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On CORE_UIDENT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On CORE_LIDENT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On CONTINUE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On CONSTANT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On COMMA reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On COLON reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On COINDUCTIVE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On CLONE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On CHECK reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On BREAK reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On BEGIN reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On BARBAR reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On BAR reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On AXIOM reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On ATTRIBUTE reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On ASSUME reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On ASSERT reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On ARROW reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On ANY reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On AMPAMP reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On ALIAS reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
-- On ABSURD reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC

State 505:
## Known stack suffix:
## RETURNS
## LR(1) items:
single_spec -> RETURNS . LEFTBRC match_cases(term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 506
## Reductions:

State 506:
## Known stack suffix:
## RETURNS LEFTBRC
## LR(1) items:
single_spec -> RETURNS LEFTBRC . match_cases(term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On BAR shift to state 449
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,match_case(term)) shift to state 457
-- On pattern_ shift to state 243
-- On pattern shift to state 451
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_cases(term) shift to state 507
-- On match_case(term) shift to state 454
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On bar_list1(match_case(term)) shift to state 460
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 507:
## Known stack suffix:
## RETURNS LEFTBRC match_cases(term)
## LR(1) items:
single_spec -> RETURNS LEFTBRC match_cases(term) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 508
## Reductions:

State 508:
## Known stack suffix:
## RETURNS LEFTBRC match_cases(term) RIGHTBRC
## LR(1) items:
single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On WITH reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On WHILE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On VARIANT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On VAL reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On USE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On UIDENT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On TYPE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On TRY reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On TRUE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On TO reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On THEN reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On SEMICOLON reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On SCOPE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On RIGHTSQ reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On RIGHTPAR reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On RIGHTBRC reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On RETURNS reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On RETURN reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On REQUIRES reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On REAL reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On READS reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On RANGE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On RAISES reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On RAISE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On PURE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On PREDICATE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On POSITION reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On OPPREF reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On OP4 reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On OP3 reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On OP2 reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On OP1 reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On NOT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On MINUS reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On META reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On MATCH reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On LTGT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On LT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On LIDENT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On LET reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On LEMMA reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On LEFTPAR reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On LEFTBRC reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On LARROW reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On LABEL reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On INTEGER reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On INDUCTIVE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On IN reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On IMPORT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On IF reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On GT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On GOAL reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On GHOST reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On FUNCTION reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On FUN reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On FOR reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On FLOAT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On FALSE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On EXCEPTION reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On EQUAL reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On EOF reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On ENSURES reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On END reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On ELSE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On DOWNTO reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On DOTDOT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On DONE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On DO reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On DIVERGES reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On CORE_UIDENT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On CORE_LIDENT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On CONTINUE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On CONSTANT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On COMMA reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On COLON reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On COINDUCTIVE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On CLONE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On CHECK reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On BREAK reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On BEGIN reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On BARBAR reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On BAR reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On AXIOM reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On ATTRIBUTE reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On ASSUME reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On ASSERT reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On ARROW reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On ANY reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On AMPAMP reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On ALIAS reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC
-- On ABSURD reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC

State 509:
## Known stack suffix:
## REQUIRES
## LR(1) items:
single_spec -> REQUIRES . LEFTBRC term RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 510
## Reductions:

State 510:
## Known stack suffix:
## REQUIRES LEFTBRC
## LR(1) items:
single_spec -> REQUIRES LEFTBRC . term RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 511
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 511:
## Known stack suffix:
## REQUIRES LEFTBRC term
## LR(1) items:
single_spec -> REQUIRES LEFTBRC term . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 512
## Reductions:

State 512:
## Known stack suffix:
## REQUIRES LEFTBRC term RIGHTBRC
## LR(1) items:
single_spec -> REQUIRES LEFTBRC term RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On WITH reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On WHILE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On VARIANT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On VAL reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On USE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On UIDENT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On TYPE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On TRY reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On TRUE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On TO reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On THEN reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On SEMICOLON reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On SCOPE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On RIGHTSQ reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On RIGHTPAR reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On RIGHTBRC reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On RETURNS reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On RETURN reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On REQUIRES reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On REAL reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On READS reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On RANGE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On RAISES reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On RAISE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On PURE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On PREDICATE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On POSITION reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On OPPREF reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On OP4 reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On OP3 reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On OP2 reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On OP1 reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On NOT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On MINUS reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On META reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On MATCH reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On LTGT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On LT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On LIDENT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On LET reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On LEMMA reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On LEFTPAR reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On LEFTBRC reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On LARROW reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On LABEL reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On INTEGER reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On INDUCTIVE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On IN reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On IMPORT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On IF reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On GT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On GOAL reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On GHOST reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On FUNCTION reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On FUN reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On FOR reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On FLOAT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On FALSE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On EXCEPTION reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On EQUAL reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On EOF reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On ENSURES reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On END reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On ELSE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On DOWNTO reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On DOTDOT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On DONE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On DO reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On DIVERGES reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On CORE_UIDENT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On CORE_LIDENT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On CONTINUE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On CONSTANT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On COMMA reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On COLON reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On COINDUCTIVE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On CLONE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On CHECK reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On BREAK reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On BEGIN reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On BARBAR reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On BAR reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On AXIOM reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On ATTRIBUTE reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On ASSUME reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On ASSERT reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On ARROW reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On ANY reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On AMPAMP reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On ALIAS reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC
-- On ABSURD reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC

State 513:
## Known stack suffix:
## READS
## LR(1) items:
single_spec -> READS . LEFTBRC comma_list0(lqualid) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 514
## Reductions:

State 514:
## Known stack suffix:
## READS LEFTBRC
## LR(1) items:
single_spec -> READS LEFTBRC . comma_list0(lqualid) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,lqualid) shift to state 515
-- On lqualid shift to state 516
-- On loption(separated_nonempty_list(COMMA,lqualid)) shift to state 519
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list0(lqualid) shift to state 520
## Reductions:
-- On RIGHTBRC reduce production loption(separated_nonempty_list(COMMA,lqualid)) ->

State 515:
## Known stack suffix:
## separated_nonempty_list(COMMA,lqualid)
## LR(1) items:
loption(separated_nonempty_list(COMMA,lqualid)) -> separated_nonempty_list(COMMA,lqualid) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production loption(separated_nonempty_list(COMMA,lqualid)) -> separated_nonempty_list(COMMA,lqualid)

State 516:
## Known stack suffix:
## lqualid
## LR(1) items:
separated_nonempty_list(COMMA,lqualid) -> lqualid . [ RIGHTBRC ]
separated_nonempty_list(COMMA,lqualid) -> lqualid . COMMA separated_nonempty_list(COMMA,lqualid) [ RIGHTBRC ]
## Transitions:
-- On COMMA shift to state 517
## Reductions:
-- On RIGHTBRC reduce production separated_nonempty_list(COMMA,lqualid) -> lqualid

State 517:
## Known stack suffix:
## lqualid COMMA
## LR(1) items:
separated_nonempty_list(COMMA,lqualid) -> lqualid COMMA . separated_nonempty_list(COMMA,lqualid) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,lqualid) shift to state 518
-- On lqualid shift to state 516
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 518:
## Known stack suffix:
## lqualid COMMA separated_nonempty_list(COMMA,lqualid)
## LR(1) items:
separated_nonempty_list(COMMA,lqualid) -> lqualid COMMA separated_nonempty_list(COMMA,lqualid) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production separated_nonempty_list(COMMA,lqualid) -> lqualid COMMA separated_nonempty_list(COMMA,lqualid)

State 519:
## Known stack suffix:
## loption(separated_nonempty_list(COMMA,lqualid))
## LR(1) items:
comma_list0(lqualid) -> loption(separated_nonempty_list(COMMA,lqualid)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production comma_list0(lqualid) -> loption(separated_nonempty_list(COMMA,lqualid))

State 520:
## Known stack suffix:
## READS LEFTBRC comma_list0(lqualid)
## LR(1) items:
single_spec -> READS LEFTBRC comma_list0(lqualid) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 521
## Reductions:

State 521:
## Known stack suffix:
## READS LEFTBRC comma_list0(lqualid) RIGHTBRC
## LR(1) items:
single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On WITH reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On WHILE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On VARIANT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On VAL reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On USE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On UIDENT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On TYPE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On TRY reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On TRUE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On TO reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On THEN reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On SEMICOLON reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On SCOPE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On RIGHTSQ reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On RIGHTPAR reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On RIGHTBRC reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On RETURNS reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On RETURN reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On REQUIRES reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On REAL reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On READS reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On RANGE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On RAISES reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On RAISE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On PURE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On PREDICATE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On POSITION reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On OPPREF reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On OP4 reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On OP3 reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On OP2 reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On OP1 reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On NOT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On MINUS reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On META reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On MATCH reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On LTGT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On LT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On LIDENT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On LET reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On LEMMA reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On LEFTPAR reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On LEFTBRC reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On LARROW reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On LABEL reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On INTEGER reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On INDUCTIVE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On IN reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On IMPORT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On IF reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On GT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On GOAL reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On GHOST reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On FUNCTION reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On FUN reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On FOR reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On FLOAT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On FALSE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On EXCEPTION reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On EQUAL reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On EOF reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On ENSURES reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On END reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On ELSE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On DOWNTO reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On DOTDOT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On DONE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On DO reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On DIVERGES reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On CORE_UIDENT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On CORE_LIDENT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On CONTINUE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On CONSTANT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On COMMA reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On COLON reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On COINDUCTIVE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On CLONE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On CHECK reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On BREAK reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On BEGIN reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On BARBAR reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On BAR reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On AXIOM reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On ATTRIBUTE reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On ASSUME reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On ASSERT reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On ARROW reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On ANY reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On AMPAMP reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On ALIAS reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC
-- On ABSURD reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC

State 522:
## Known stack suffix:
## RAISES
## LR(1) items:
single_spec -> RAISES . LEFTBRC bar_list1(raises) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
single_spec -> RAISES . LEFTBRC comma_list1(xsymbol) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 523
## Reductions:

State 523:
## Known stack suffix:
## RAISES LEFTBRC
## LR(1) items:
single_spec -> RAISES LEFTBRC . bar_list1(raises) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
single_spec -> RAISES LEFTBRC . comma_list1(xsymbol) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On BAR shift to state 524
-- On xsymbol shift to state 536
-- On uqualid shift to state 540
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,xsymbol) shift to state 541
-- On separated_nonempty_list(BAR,raises) shift to state 542
-- On raises shift to state 533
-- On comma_list1(xsymbol) shift to state 543
-- On bar_list1(raises) shift to state 545
## Reductions:

State 524:
## Known stack suffix:
## BAR
## LR(1) items:
bar_list1(raises) -> BAR . separated_nonempty_list(BAR,raises) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 525
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,raises) shift to state 532
-- On raises shift to state 533
## Reductions:

State 525:
## Known stack suffix:
## uqualid
## LR(1) items:
raises -> uqualid . ARROW term [ RIGHTBRC BAR ]
raises -> uqualid . pat_arg ARROW term [ RIGHTBRC BAR ]
uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT DOT CORE_UIDENT CORE_LIDENT ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On DOT shift to state 526
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On ARROW shift to state 527
-- On uqualid shift to state 231
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 233
-- On pat_arg shift to state 529
-- On mk_pat(pat_arg_) shift to state 236
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 526:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
uqualid -> uqualid DOT . uident [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 86
## Reductions:

State 527:
## Known stack suffix:
## uqualid ARROW
## LR(1) items:
raises -> uqualid ARROW . term [ RIGHTBRC BAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 528
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 528:
## Known stack suffix:
## uqualid ARROW term
## LR(1) items:
raises -> uqualid ARROW term . [ RIGHTBRC BAR ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production raises -> uqualid ARROW term
-- On BAR reduce production raises -> uqualid ARROW term

State 529:
## Known stack suffix:
## uqualid pat_arg
## LR(1) items:
raises -> uqualid pat_arg . ARROW term [ RIGHTBRC BAR ]
## Transitions:
-- On ARROW shift to state 530
## Reductions:

State 530:
## Known stack suffix:
## uqualid pat_arg ARROW
## LR(1) items:
raises -> uqualid pat_arg ARROW . term [ RIGHTBRC BAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 531
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 531:
## Known stack suffix:
## uqualid pat_arg ARROW term
## LR(1) items:
raises -> uqualid pat_arg ARROW term . [ RIGHTBRC BAR ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production raises -> uqualid pat_arg ARROW term
-- On BAR reduce production raises -> uqualid pat_arg ARROW term

State 532:
## Known stack suffix:
## BAR separated_nonempty_list(BAR,raises)
## LR(1) items:
bar_list1(raises) -> BAR separated_nonempty_list(BAR,raises) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production bar_list1(raises) -> BAR separated_nonempty_list(BAR,raises)

State 533:
## Known stack suffix:
## raises
## LR(1) items:
separated_nonempty_list(BAR,raises) -> raises . [ RIGHTBRC ]
separated_nonempty_list(BAR,raises) -> raises . BAR separated_nonempty_list(BAR,raises) [ RIGHTBRC ]
## Transitions:
-- On BAR shift to state 534
## Reductions:
-- On RIGHTBRC reduce production separated_nonempty_list(BAR,raises) -> raises

State 534:
## Known stack suffix:
## raises BAR
## LR(1) items:
separated_nonempty_list(BAR,raises) -> raises BAR . separated_nonempty_list(BAR,raises) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 525
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,raises) shift to state 535
-- On raises shift to state 533
## Reductions:

State 535:
## Known stack suffix:
## raises BAR separated_nonempty_list(BAR,raises)
## LR(1) items:
separated_nonempty_list(BAR,raises) -> raises BAR separated_nonempty_list(BAR,raises) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production separated_nonempty_list(BAR,raises) -> raises BAR separated_nonempty_list(BAR,raises)

State 536:
## Known stack suffix:
## xsymbol
## LR(1) items:
separated_nonempty_list(COMMA,xsymbol) -> xsymbol . [ RIGHTBRC ]
separated_nonempty_list(COMMA,xsymbol) -> xsymbol . COMMA separated_nonempty_list(COMMA,xsymbol) [ RIGHTBRC ]
## Transitions:
-- On COMMA shift to state 537
## Reductions:
-- On RIGHTBRC reduce production separated_nonempty_list(COMMA,xsymbol) -> xsymbol

State 537:
## Known stack suffix:
## xsymbol COMMA
## LR(1) items:
separated_nonempty_list(COMMA,xsymbol) -> xsymbol COMMA . separated_nonempty_list(COMMA,xsymbol) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On xsymbol shift to state 536
-- On uqualid shift to state 538
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,xsymbol) shift to state 539
## Reductions:

State 538:
## Known stack suffix:
## uqualid
## LR(1) items:
uqualid -> uqualid . DOT uident [ RIGHTBRC DOT COMMA ]
xsymbol -> uqualid . [ RIGHTBRC COMMA ]
## Transitions:
-- On DOT shift to state 526
## Reductions:
-- On RIGHTBRC reduce production xsymbol -> uqualid
-- On COMMA reduce production xsymbol -> uqualid

State 539:
## Known stack suffix:
## xsymbol COMMA separated_nonempty_list(COMMA,xsymbol)
## LR(1) items:
separated_nonempty_list(COMMA,xsymbol) -> xsymbol COMMA separated_nonempty_list(COMMA,xsymbol) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production separated_nonempty_list(COMMA,xsymbol) -> xsymbol COMMA separated_nonempty_list(COMMA,xsymbol)

State 540:
## Known stack suffix:
## uqualid
## LR(1) items:
raises -> uqualid . ARROW term [ RIGHTBRC BAR ]
raises -> uqualid . pat_arg ARROW term [ RIGHTBRC BAR ]
uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT DOT CORE_UIDENT CORE_LIDENT COMMA ARROW ]
xsymbol -> uqualid . [ RIGHTBRC COMMA ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On DOT shift to state 526
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On ARROW shift to state 527
-- On uqualid shift to state 231
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 233
-- On pat_arg shift to state 529
-- On mk_pat(pat_arg_) shift to state 236
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:
-- On RIGHTBRC reduce production xsymbol -> uqualid
-- On COMMA reduce production xsymbol -> uqualid

State 541:
## Known stack suffix:
## separated_nonempty_list(COMMA,xsymbol)
## LR(1) items:
comma_list1(xsymbol) -> separated_nonempty_list(COMMA,xsymbol) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production comma_list1(xsymbol) -> separated_nonempty_list(COMMA,xsymbol)

State 542:
## Known stack suffix:
## separated_nonempty_list(BAR,raises)
## LR(1) items:
bar_list1(raises) -> separated_nonempty_list(BAR,raises) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production bar_list1(raises) -> separated_nonempty_list(BAR,raises)

State 543:
## Known stack suffix:
## RAISES LEFTBRC comma_list1(xsymbol)
## LR(1) items:
single_spec -> RAISES LEFTBRC comma_list1(xsymbol) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 544
## Reductions:

State 544:
## Known stack suffix:
## RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
## LR(1) items:
single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On WITH reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On WHILE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On VARIANT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On VAL reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On USE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On UIDENT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On TYPE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On TRY reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On TRUE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On TO reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On THEN reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On SEMICOLON reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On SCOPE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On RIGHTSQ reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On RIGHTPAR reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On RIGHTBRC reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On RETURNS reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On RETURN reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On REQUIRES reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On REAL reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On READS reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On RANGE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On RAISES reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On RAISE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On PURE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On PREDICATE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On POSITION reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On OPPREF reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On OP4 reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On OP3 reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On OP2 reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On OP1 reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On NOT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On MINUS reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On META reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On MATCH reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On LTGT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On LT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On LIDENT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On LET reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On LEMMA reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On LEFTPAR reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On LEFTBRC reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On LARROW reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On LABEL reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On INTEGER reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On INDUCTIVE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On IN reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On IMPORT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On IF reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On GT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On GOAL reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On GHOST reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On FUNCTION reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On FUN reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On FOR reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On FLOAT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On FALSE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On EXCEPTION reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On EQUAL reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On EOF reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On ENSURES reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On END reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On ELSE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On DOWNTO reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On DOTDOT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On DONE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On DO reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On DIVERGES reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On CORE_UIDENT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On CORE_LIDENT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On CONTINUE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On CONSTANT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On COMMA reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On COLON reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On COINDUCTIVE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On CLONE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On CHECK reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On BREAK reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On BEGIN reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On BARBAR reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On BAR reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On AXIOM reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On ATTRIBUTE reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On ASSUME reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On ASSERT reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On ARROW reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On ANY reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On AMPAMP reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On ALIAS reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
-- On ABSURD reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC

State 545:
## Known stack suffix:
## RAISES LEFTBRC bar_list1(raises)
## LR(1) items:
single_spec -> RAISES LEFTBRC bar_list1(raises) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 546
## Reductions:

State 546:
## Known stack suffix:
## RAISES LEFTBRC bar_list1(raises) RIGHTBRC
## LR(1) items:
single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On WITH reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On WHILE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On VARIANT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On VAL reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On USE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On UIDENT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On TYPE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On TRY reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On TRUE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On TO reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On THEN reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On SEMICOLON reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On SCOPE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On RIGHTSQ reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On RIGHTPAR reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On RIGHTBRC reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On RETURNS reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On RETURN reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On REQUIRES reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On REAL reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On READS reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On RANGE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On RAISES reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On RAISE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On PURE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On PREDICATE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On POSITION reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On OPPREF reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On OP4 reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On OP3 reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On OP2 reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On OP1 reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On NOT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On MINUS reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On META reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On MATCH reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On LTGT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On LT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On LIDENT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On LET reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On LEMMA reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On LEFTPAR reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On LEFTBRC reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On LARROW reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On LABEL reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On INTEGER reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On INDUCTIVE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On IN reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On IMPORT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On IF reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On GT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On GOAL reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On GHOST reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On FUNCTION reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On FUN reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On FOR reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On FLOAT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On FALSE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On EXCEPTION reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On EQUAL reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On EOF reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On ENSURES reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On END reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On ELSE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On DOWNTO reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On DOTDOT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On DONE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On DO reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On DIVERGES reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On CORE_UIDENT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On CORE_LIDENT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On CONTINUE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On CONSTANT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On COMMA reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On COLON reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On COINDUCTIVE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On CLONE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On CHECK reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On BREAK reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On BEGIN reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On BARBAR reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On BAR reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On AXIOM reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On ATTRIBUTE reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On ASSUME reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On ASSERT reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On ARROW reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On ANY reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On AMPAMP reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On ALIAS reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC
-- On ABSURD reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC

State 547:
## Known stack suffix:
## ENSURES
## LR(1) items:
single_spec -> ENSURES . LEFTBRC ensures RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 548
## Reductions:

State 548:
## Known stack suffix:
## ENSURES LEFTBRC
## LR(1) items:
single_spec -> ENSURES LEFTBRC . ensures RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 549
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On ensures shift to state 550
-- On attr shift to state 356
## Reductions:

State 549:
## Known stack suffix:
## term
## LR(1) items:
ensures -> term . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production ensures -> term

State 550:
## Known stack suffix:
## ENSURES LEFTBRC ensures
## LR(1) items:
single_spec -> ENSURES LEFTBRC ensures . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 551
## Reductions:

State 551:
## Known stack suffix:
## ENSURES LEFTBRC ensures RIGHTBRC
## LR(1) items:
single_spec -> ENSURES LEFTBRC ensures RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On WITH reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On WHILE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On VARIANT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On VAL reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On USE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On UIDENT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On TYPE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On TRY reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On TRUE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On TO reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On THEN reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On SEMICOLON reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On SCOPE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On RIGHTSQ reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On RIGHTPAR reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On RIGHTBRC reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On RETURNS reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On RETURN reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On REQUIRES reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On REAL reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On READS reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On RANGE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On RAISES reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On RAISE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On PURE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On PREDICATE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On POSITION reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On OPPREF reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On OP4 reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On OP3 reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On OP2 reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On OP1 reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On NOT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On MINUS reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On META reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On MATCH reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On LTGT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On LT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On LIDENT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On LET reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On LEMMA reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On LEFTPAR reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On LEFTBRC reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On LARROW reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On LABEL reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On INTEGER reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On INDUCTIVE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On IN reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On IMPORT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On IF reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On GT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On GOAL reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On GHOST reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On FUNCTION reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On FUN reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On FOR reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On FLOAT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On FALSE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On EXCEPTION reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On EQUAL reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On EOF reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On ENSURES reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On END reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On ELSE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On DOWNTO reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On DOTDOT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On DONE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On DO reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On DIVERGES reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On CORE_UIDENT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On CORE_LIDENT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On CONTINUE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On CONSTANT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On COMMA reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On COLON reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On COINDUCTIVE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On CLONE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On CHECK reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On BREAK reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On BEGIN reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On BARBAR reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On BAR reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On AXIOM reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On ATTRIBUTE reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On ASSUME reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On ASSERT reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On ARROW reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On ANY reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On AMPAMP reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On ALIAS reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC
-- On ABSURD reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC

State 552:
## Known stack suffix:
## DIVERGES
## LR(1) items:
single_spec -> DIVERGES . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_spec -> DIVERGES
-- On WITH reduce production single_spec -> DIVERGES
-- On WHILE reduce production single_spec -> DIVERGES
-- On VARIANT reduce production single_spec -> DIVERGES
-- On VAL reduce production single_spec -> DIVERGES
-- On USE reduce production single_spec -> DIVERGES
-- On UIDENT reduce production single_spec -> DIVERGES
-- On TYPE reduce production single_spec -> DIVERGES
-- On TRY reduce production single_spec -> DIVERGES
-- On TRUE reduce production single_spec -> DIVERGES
-- On TO reduce production single_spec -> DIVERGES
-- On THEN reduce production single_spec -> DIVERGES
-- On SEMICOLON reduce production single_spec -> DIVERGES
-- On SCOPE reduce production single_spec -> DIVERGES
-- On RIGHTSQ_QUOTE reduce production single_spec -> DIVERGES
-- On RIGHTSQ reduce production single_spec -> DIVERGES
-- On RIGHTPAR reduce production single_spec -> DIVERGES
-- On RIGHTBRC reduce production single_spec -> DIVERGES
-- On RETURNS reduce production single_spec -> DIVERGES
-- On RETURN reduce production single_spec -> DIVERGES
-- On REQUIRES reduce production single_spec -> DIVERGES
-- On REAL reduce production single_spec -> DIVERGES
-- On READS reduce production single_spec -> DIVERGES
-- On RANGE reduce production single_spec -> DIVERGES
-- On RAISES reduce production single_spec -> DIVERGES
-- On RAISE reduce production single_spec -> DIVERGES
-- On PURE reduce production single_spec -> DIVERGES
-- On PREDICATE reduce production single_spec -> DIVERGES
-- On POSITION reduce production single_spec -> DIVERGES
-- On OPPREF reduce production single_spec -> DIVERGES
-- On OP4 reduce production single_spec -> DIVERGES
-- On OP3 reduce production single_spec -> DIVERGES
-- On OP2 reduce production single_spec -> DIVERGES
-- On OP1 reduce production single_spec -> DIVERGES
-- On NOT reduce production single_spec -> DIVERGES
-- On MINUS reduce production single_spec -> DIVERGES
-- On META reduce production single_spec -> DIVERGES
-- On MATCH reduce production single_spec -> DIVERGES
-- On LTGT reduce production single_spec -> DIVERGES
-- On LT reduce production single_spec -> DIVERGES
-- On LIDENT reduce production single_spec -> DIVERGES
-- On LET reduce production single_spec -> DIVERGES
-- On LEMMA reduce production single_spec -> DIVERGES
-- On LEFTPAR reduce production single_spec -> DIVERGES
-- On LEFTBRC reduce production single_spec -> DIVERGES
-- On LARROW reduce production single_spec -> DIVERGES
-- On LABEL reduce production single_spec -> DIVERGES
-- On INTEGER reduce production single_spec -> DIVERGES
-- On INDUCTIVE reduce production single_spec -> DIVERGES
-- On IN reduce production single_spec -> DIVERGES
-- On IMPORT reduce production single_spec -> DIVERGES
-- On IF reduce production single_spec -> DIVERGES
-- On GT reduce production single_spec -> DIVERGES
-- On GOAL reduce production single_spec -> DIVERGES
-- On GHOST reduce production single_spec -> DIVERGES
-- On FUNCTION reduce production single_spec -> DIVERGES
-- On FUN reduce production single_spec -> DIVERGES
-- On FOR reduce production single_spec -> DIVERGES
-- On FLOAT reduce production single_spec -> DIVERGES
-- On FALSE reduce production single_spec -> DIVERGES
-- On EXCEPTION reduce production single_spec -> DIVERGES
-- On EQUAL reduce production single_spec -> DIVERGES
-- On EOF reduce production single_spec -> DIVERGES
-- On ENSURES reduce production single_spec -> DIVERGES
-- On END reduce production single_spec -> DIVERGES
-- On ELSE reduce production single_spec -> DIVERGES
-- On DOWNTO reduce production single_spec -> DIVERGES
-- On DOTDOT reduce production single_spec -> DIVERGES
-- On DONE reduce production single_spec -> DIVERGES
-- On DO reduce production single_spec -> DIVERGES
-- On DIVERGES reduce production single_spec -> DIVERGES
-- On CORE_UIDENT reduce production single_spec -> DIVERGES
-- On CORE_LIDENT reduce production single_spec -> DIVERGES
-- On CONTINUE reduce production single_spec -> DIVERGES
-- On CONSTANT reduce production single_spec -> DIVERGES
-- On COMMA reduce production single_spec -> DIVERGES
-- On COLON reduce production single_spec -> DIVERGES
-- On COINDUCTIVE reduce production single_spec -> DIVERGES
-- On CLONE reduce production single_spec -> DIVERGES
-- On CHECK reduce production single_spec -> DIVERGES
-- On BREAK reduce production single_spec -> DIVERGES
-- On BEGIN reduce production single_spec -> DIVERGES
-- On BARBAR reduce production single_spec -> DIVERGES
-- On BAR reduce production single_spec -> DIVERGES
-- On AXIOM reduce production single_spec -> DIVERGES
-- On ATTRIBUTE reduce production single_spec -> DIVERGES
-- On ASSUME reduce production single_spec -> DIVERGES
-- On ASSERT reduce production single_spec -> DIVERGES
-- On ARROW reduce production single_spec -> DIVERGES
-- On ANY reduce production single_spec -> DIVERGES
-- On AMPAMP reduce production single_spec -> DIVERGES
-- On ALIAS reduce production single_spec -> DIVERGES
-- On ABSURD reduce production single_spec -> DIVERGES

State 553:
## Known stack suffix:
## ALIAS
## LR(1) items:
single_spec -> ALIAS . LEFTBRC comma_list0(alias) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 554
## Reductions:

State 554:
## Known stack suffix:
## ALIAS LEFTBRC
## LR(1) items:
single_spec -> ALIAS LEFTBRC . comma_list0(alias) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 555
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On separated_nonempty_list(COMMA,alias) shift to state 558
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On loption(separated_nonempty_list(COMMA,alias)) shift to state 559
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On comma_list0(alias) shift to state 560
-- On attr shift to state 356
-- On alias shift to state 562
## Reductions:
-- On RIGHTBRC reduce production loption(separated_nonempty_list(COMMA,alias)) ->

State 555:
## Known stack suffix:
## term
## LR(1) items:
alias -> term . WITH term [ RIGHTBRC COMMA ]
## Transitions:
-- On WITH shift to state 556
## Reductions:

State 556:
## Known stack suffix:
## term WITH
## LR(1) items:
alias -> term WITH . term [ RIGHTBRC COMMA ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 557
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 557:
## Known stack suffix:
## term WITH term
## LR(1) items:
alias -> term WITH term . [ RIGHTBRC COMMA ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production alias -> term WITH term
-- On COMMA reduce production alias -> term WITH term

State 558:
## Known stack suffix:
## separated_nonempty_list(COMMA,alias)
## LR(1) items:
loption(separated_nonempty_list(COMMA,alias)) -> separated_nonempty_list(COMMA,alias) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production loption(separated_nonempty_list(COMMA,alias)) -> separated_nonempty_list(COMMA,alias)

State 559:
## Known stack suffix:
## loption(separated_nonempty_list(COMMA,alias))
## LR(1) items:
comma_list0(alias) -> loption(separated_nonempty_list(COMMA,alias)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production comma_list0(alias) -> loption(separated_nonempty_list(COMMA,alias))

State 560:
## Known stack suffix:
## ALIAS LEFTBRC comma_list0(alias)
## LR(1) items:
single_spec -> ALIAS LEFTBRC comma_list0(alias) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 561
## Reductions:

State 561:
## Known stack suffix:
## ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
## LR(1) items:
single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On WITH reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On WHILE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On VARIANT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On VAL reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On USE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On UIDENT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On TYPE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On TRY reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On TRUE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On TO reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On THEN reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On SEMICOLON reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On SCOPE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On RIGHTSQ reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On RIGHTPAR reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On RIGHTBRC reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On RETURNS reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On RETURN reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On REQUIRES reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On REAL reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On READS reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On RANGE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On RAISES reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On RAISE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On PURE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On PREDICATE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On POSITION reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On OPPREF reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On OP4 reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On OP3 reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On OP2 reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On OP1 reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On NOT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On MINUS reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On META reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On MATCH reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On LTGT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On LT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On LIDENT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On LET reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On LEMMA reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On LEFTPAR reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On LEFTBRC reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On LARROW reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On LABEL reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On INTEGER reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On INDUCTIVE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On IN reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On IMPORT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On IF reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On GT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On GOAL reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On GHOST reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On FUNCTION reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On FUN reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On FOR reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On FLOAT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On FALSE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On EXCEPTION reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On EQUAL reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On EOF reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On ENSURES reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On END reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On ELSE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On DOWNTO reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On DOTDOT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On DONE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On DO reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On DIVERGES reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On CORE_UIDENT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On CORE_LIDENT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On CONTINUE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On CONSTANT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On COMMA reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On COLON reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On COINDUCTIVE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On CLONE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On CHECK reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On BREAK reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On BEGIN reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On BARBAR reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On BAR reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On AXIOM reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On ATTRIBUTE reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On ASSUME reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On ASSERT reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On ARROW reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On ANY reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On AMPAMP reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On ALIAS reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
-- On ABSURD reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC

State 562:
## Known stack suffix:
## alias
## LR(1) items:
separated_nonempty_list(COMMA,alias) -> alias . [ RIGHTBRC ]
separated_nonempty_list(COMMA,alias) -> alias . COMMA separated_nonempty_list(COMMA,alias) [ RIGHTBRC ]
## Transitions:
-- On COMMA shift to state 563
## Reductions:
-- On RIGHTBRC reduce production separated_nonempty_list(COMMA,alias) -> alias

State 563:
## Known stack suffix:
## alias COMMA
## LR(1) items:
separated_nonempty_list(COMMA,alias) -> alias COMMA . separated_nonempty_list(COMMA,alias) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 555
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On separated_nonempty_list(COMMA,alias) shift to state 564
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
-- On alias shift to state 562
## Reductions:

State 564:
## Known stack suffix:
## alias COMMA separated_nonempty_list(COMMA,alias)
## LR(1) items:
separated_nonempty_list(COMMA,alias) -> alias COMMA separated_nonempty_list(COMMA,alias) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production separated_nonempty_list(COMMA,alias) -> alias COMMA separated_nonempty_list(COMMA,alias)

State 565:
## Known stack suffix:
## variant
## LR(1) items:
single_spec -> variant . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_spec -> variant
-- On WITH reduce production single_spec -> variant
-- On WHILE reduce production single_spec -> variant
-- On VARIANT reduce production single_spec -> variant
-- On VAL reduce production single_spec -> variant
-- On USE reduce production single_spec -> variant
-- On UIDENT reduce production single_spec -> variant
-- On TYPE reduce production single_spec -> variant
-- On TRY reduce production single_spec -> variant
-- On TRUE reduce production single_spec -> variant
-- On TO reduce production single_spec -> variant
-- On THEN reduce production single_spec -> variant
-- On SEMICOLON reduce production single_spec -> variant
-- On SCOPE reduce production single_spec -> variant
-- On RIGHTSQ_QUOTE reduce production single_spec -> variant
-- On RIGHTSQ reduce production single_spec -> variant
-- On RIGHTPAR reduce production single_spec -> variant
-- On RIGHTBRC reduce production single_spec -> variant
-- On RETURNS reduce production single_spec -> variant
-- On RETURN reduce production single_spec -> variant
-- On REQUIRES reduce production single_spec -> variant
-- On REAL reduce production single_spec -> variant
-- On READS reduce production single_spec -> variant
-- On RANGE reduce production single_spec -> variant
-- On RAISES reduce production single_spec -> variant
-- On RAISE reduce production single_spec -> variant
-- On PURE reduce production single_spec -> variant
-- On PREDICATE reduce production single_spec -> variant
-- On POSITION reduce production single_spec -> variant
-- On OPPREF reduce production single_spec -> variant
-- On OP4 reduce production single_spec -> variant
-- On OP3 reduce production single_spec -> variant
-- On OP2 reduce production single_spec -> variant
-- On OP1 reduce production single_spec -> variant
-- On NOT reduce production single_spec -> variant
-- On MINUS reduce production single_spec -> variant
-- On META reduce production single_spec -> variant
-- On MATCH reduce production single_spec -> variant
-- On LTGT reduce production single_spec -> variant
-- On LT reduce production single_spec -> variant
-- On LIDENT reduce production single_spec -> variant
-- On LET reduce production single_spec -> variant
-- On LEMMA reduce production single_spec -> variant
-- On LEFTPAR reduce production single_spec -> variant
-- On LEFTBRC reduce production single_spec -> variant
-- On LARROW reduce production single_spec -> variant
-- On LABEL reduce production single_spec -> variant
-- On INTEGER reduce production single_spec -> variant
-- On INDUCTIVE reduce production single_spec -> variant
-- On IN reduce production single_spec -> variant
-- On IMPORT reduce production single_spec -> variant
-- On IF reduce production single_spec -> variant
-- On GT reduce production single_spec -> variant
-- On GOAL reduce production single_spec -> variant
-- On GHOST reduce production single_spec -> variant
-- On FUNCTION reduce production single_spec -> variant
-- On FUN reduce production single_spec -> variant
-- On FOR reduce production single_spec -> variant
-- On FLOAT reduce production single_spec -> variant
-- On FALSE reduce production single_spec -> variant
-- On EXCEPTION reduce production single_spec -> variant
-- On EQUAL reduce production single_spec -> variant
-- On EOF reduce production single_spec -> variant
-- On ENSURES reduce production single_spec -> variant
-- On END reduce production single_spec -> variant
-- On ELSE reduce production single_spec -> variant
-- On DOWNTO reduce production single_spec -> variant
-- On DOTDOT reduce production single_spec -> variant
-- On DONE reduce production single_spec -> variant
-- On DO reduce production single_spec -> variant
-- On DIVERGES reduce production single_spec -> variant
-- On CORE_UIDENT reduce production single_spec -> variant
-- On CORE_LIDENT reduce production single_spec -> variant
-- On CONTINUE reduce production single_spec -> variant
-- On CONSTANT reduce production single_spec -> variant
-- On COMMA reduce production single_spec -> variant
-- On COLON reduce production single_spec -> variant
-- On COINDUCTIVE reduce production single_spec -> variant
-- On CLONE reduce production single_spec -> variant
-- On CHECK reduce production single_spec -> variant
-- On BREAK reduce production single_spec -> variant
-- On BEGIN reduce production single_spec -> variant
-- On BARBAR reduce production single_spec -> variant
-- On BAR reduce production single_spec -> variant
-- On AXIOM reduce production single_spec -> variant
-- On ATTRIBUTE reduce production single_spec -> variant
-- On ASSUME reduce production single_spec -> variant
-- On ASSERT reduce production single_spec -> variant
-- On ARROW reduce production single_spec -> variant
-- On ANY reduce production single_spec -> variant
-- On AMPAMP reduce production single_spec -> variant
-- On ALIAS reduce production single_spec -> variant
-- On ABSURD reduce production single_spec -> variant

State 566:
## Known stack suffix:
## params return_opt spec
## LR(1) items:
val_defn -> params return_opt spec . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production val_defn -> params return_opt spec
-- On USE reduce production val_defn -> params return_opt spec
-- On TYPE reduce production val_defn -> params return_opt spec
-- On SCOPE reduce production val_defn -> params return_opt spec
-- On PREDICATE reduce production val_defn -> params return_opt spec
-- On META reduce production val_defn -> params return_opt spec
-- On LET reduce production val_defn -> params return_opt spec
-- On LEMMA reduce production val_defn -> params return_opt spec
-- On INDUCTIVE reduce production val_defn -> params return_opt spec
-- On IN reduce production val_defn -> params return_opt spec
-- On IMPORT reduce production val_defn -> params return_opt spec
-- On GOAL reduce production val_defn -> params return_opt spec
-- On FUNCTION reduce production val_defn -> params return_opt spec
-- On EXCEPTION reduce production val_defn -> params return_opt spec
-- On EOF reduce production val_defn -> params return_opt spec
-- On END reduce production val_defn -> params return_opt spec
-- On CONSTANT reduce production val_defn -> params return_opt spec
-- On COINDUCTIVE reduce production val_defn -> params return_opt spec
-- On CLONE reduce production val_defn -> params return_opt spec
-- On AXIOM reduce production val_defn -> params return_opt spec

State 567:
## Known stack suffix:
## single_spec
## LR(1) items:
spec -> single_spec . spec [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 568
-- On single_spec shift to state 567
## Reductions:
-- On WITH reduce production spec ->
-- On WHILE reduce production spec ->
-- On VAL reduce production spec ->
-- On USE reduce production spec ->
-- On UIDENT reduce production spec ->
-- On TYPE reduce production spec ->
-- On TRY reduce production spec ->
-- On TRUE reduce production spec ->
-- On TO reduce production spec ->
-- On THEN reduce production spec ->
-- On SEMICOLON reduce production spec ->
-- On SCOPE reduce production spec ->
-- On RIGHTSQ_QUOTE reduce production spec ->
-- On RIGHTSQ reduce production spec ->
-- On RIGHTPAR reduce production spec ->
-- On RIGHTBRC reduce production spec ->
-- On RETURN reduce production spec ->
-- On REAL reduce production spec ->
-- On RANGE reduce production spec ->
-- On RAISE reduce production spec ->
-- On PURE reduce production spec ->
-- On PREDICATE reduce production spec ->
-- On POSITION reduce production spec ->
-- On OPPREF reduce production spec ->
-- On OP4 reduce production spec ->
-- On OP3 reduce production spec ->
-- On OP2 reduce production spec ->
-- On OP1 reduce production spec ->
-- On NOT reduce production spec ->
-- On MINUS reduce production spec ->
-- On META reduce production spec ->
-- On MATCH reduce production spec ->
-- On LTGT reduce production spec ->
-- On LT reduce production spec ->
-- On LIDENT reduce production spec ->
-- On LET reduce production spec ->
-- On LEMMA reduce production spec ->
-- On LEFTPAR reduce production spec ->
-- On LEFTBRC reduce production spec ->
-- On LARROW reduce production spec ->
-- On LABEL reduce production spec ->
-- On INTEGER reduce production spec ->
-- On INDUCTIVE reduce production spec ->
-- On IN reduce production spec ->
-- On IMPORT reduce production spec ->
-- On IF reduce production spec ->
-- On GT reduce production spec ->
-- On GOAL reduce production spec ->
-- On GHOST reduce production spec ->
-- On FUNCTION reduce production spec ->
-- On FUN reduce production spec ->
-- On FOR reduce production spec ->
-- On FLOAT reduce production spec ->
-- On FALSE reduce production spec ->
-- On EXCEPTION reduce production spec ->
-- On EQUAL reduce production spec ->
-- On EOF reduce production spec ->
-- On END reduce production spec ->
-- On ELSE reduce production spec ->
-- On DOWNTO reduce production spec ->
-- On DOTDOT reduce production spec ->
-- On DONE reduce production spec ->
-- On DO reduce production spec ->
-- On CORE_UIDENT reduce production spec ->
-- On CORE_LIDENT reduce production spec ->
-- On CONTINUE reduce production spec ->
-- On CONSTANT reduce production spec ->
-- On COMMA reduce production spec ->
-- On COLON reduce production spec ->
-- On COINDUCTIVE reduce production spec ->
-- On CLONE reduce production spec ->
-- On CHECK reduce production spec ->
-- On BREAK reduce production spec ->
-- On BEGIN reduce production spec ->
-- On BARBAR reduce production spec ->
-- On BAR reduce production spec ->
-- On AXIOM reduce production spec ->
-- On ATTRIBUTE reduce production spec ->
-- On ASSUME reduce production spec ->
-- On ASSERT reduce production spec ->
-- On ARROW reduce production spec ->
-- On ANY reduce production spec ->
-- On AMPAMP reduce production spec ->
-- On ABSURD reduce production spec ->

State 568:
## Known stack suffix:
## single_spec spec
## LR(1) items:
spec -> single_spec spec . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES reduce production spec -> single_spec spec
-- On WITH reduce production spec -> single_spec spec
-- On WHILE reduce production spec -> single_spec spec
-- On VARIANT reduce production spec -> single_spec spec
-- On VAL reduce production spec -> single_spec spec
-- On USE reduce production spec -> single_spec spec
-- On UIDENT reduce production spec -> single_spec spec
-- On TYPE reduce production spec -> single_spec spec
-- On TRY reduce production spec -> single_spec spec
-- On TRUE reduce production spec -> single_spec spec
-- On TO reduce production spec -> single_spec spec
-- On THEN reduce production spec -> single_spec spec
-- On SEMICOLON reduce production spec -> single_spec spec
-- On SCOPE reduce production spec -> single_spec spec
-- On RIGHTSQ_QUOTE reduce production spec -> single_spec spec
-- On RIGHTSQ reduce production spec -> single_spec spec
-- On RIGHTPAR reduce production spec -> single_spec spec
-- On RIGHTBRC reduce production spec -> single_spec spec
-- On RETURNS reduce production spec -> single_spec spec
-- On RETURN reduce production spec -> single_spec spec
-- On REQUIRES reduce production spec -> single_spec spec
-- On REAL reduce production spec -> single_spec spec
-- On READS reduce production spec -> single_spec spec
-- On RANGE reduce production spec -> single_spec spec
-- On RAISES reduce production spec -> single_spec spec
-- On RAISE reduce production spec -> single_spec spec
-- On PURE reduce production spec -> single_spec spec
-- On PREDICATE reduce production spec -> single_spec spec
-- On POSITION reduce production spec -> single_spec spec
-- On OPPREF reduce production spec -> single_spec spec
-- On OP4 reduce production spec -> single_spec spec
-- On OP3 reduce production spec -> single_spec spec
-- On OP2 reduce production spec -> single_spec spec
-- On OP1 reduce production spec -> single_spec spec
-- On NOT reduce production spec -> single_spec spec
-- On MINUS reduce production spec -> single_spec spec
-- On META reduce production spec -> single_spec spec
-- On MATCH reduce production spec -> single_spec spec
-- On LTGT reduce production spec -> single_spec spec
-- On LT reduce production spec -> single_spec spec
-- On LIDENT reduce production spec -> single_spec spec
-- On LET reduce production spec -> single_spec spec
-- On LEMMA reduce production spec -> single_spec spec
-- On LEFTPAR reduce production spec -> single_spec spec
-- On LEFTBRC reduce production spec -> single_spec spec
-- On LARROW reduce production spec -> single_spec spec
-- On LABEL reduce production spec -> single_spec spec
-- On INTEGER reduce production spec -> single_spec spec
-- On INDUCTIVE reduce production spec -> single_spec spec
-- On IN reduce production spec -> single_spec spec
-- On IMPORT reduce production spec -> single_spec spec
-- On IF reduce production spec -> single_spec spec
-- On GT reduce production spec -> single_spec spec
-- On GOAL reduce production spec -> single_spec spec
-- On GHOST reduce production spec -> single_spec spec
-- On FUNCTION reduce production spec -> single_spec spec
-- On FUN reduce production spec -> single_spec spec
-- On FOR reduce production spec -> single_spec spec
-- On FLOAT reduce production spec -> single_spec spec
-- On FALSE reduce production spec -> single_spec spec
-- On EXCEPTION reduce production spec -> single_spec spec
-- On EQUAL reduce production spec -> single_spec spec
-- On EOF reduce production spec -> single_spec spec
-- On ENSURES reduce production spec -> single_spec spec
-- On END reduce production spec -> single_spec spec
-- On ELSE reduce production spec -> single_spec spec
-- On DOWNTO reduce production spec -> single_spec spec
-- On DOTDOT reduce production spec -> single_spec spec
-- On DONE reduce production spec -> single_spec spec
-- On DO reduce production spec -> single_spec spec
-- On DIVERGES reduce production spec -> single_spec spec
-- On CORE_UIDENT reduce production spec -> single_spec spec
-- On CORE_LIDENT reduce production spec -> single_spec spec
-- On CONTINUE reduce production spec -> single_spec spec
-- On CONSTANT reduce production spec -> single_spec spec
-- On COMMA reduce production spec -> single_spec spec
-- On COLON reduce production spec -> single_spec spec
-- On COINDUCTIVE reduce production spec -> single_spec spec
-- On CLONE reduce production spec -> single_spec spec
-- On CHECK reduce production spec -> single_spec spec
-- On BREAK reduce production spec -> single_spec spec
-- On BEGIN reduce production spec -> single_spec spec
-- On BARBAR reduce production spec -> single_spec spec
-- On BAR reduce production spec -> single_spec spec
-- On AXIOM reduce production spec -> single_spec spec
-- On ATTRIBUTE reduce production spec -> single_spec spec
-- On ASSUME reduce production spec -> single_spec spec
-- On ASSERT reduce production spec -> single_spec spec
-- On ARROW reduce production spec -> single_spec spec
-- On ANY reduce production spec -> single_spec spec
-- On AMPAMP reduce production spec -> single_spec spec
-- On ALIAS reduce production spec -> single_spec spec
-- On ABSURD reduce production spec -> single_spec spec

State 569:
## Known stack suffix:
## param
## LR(1) items:
list(param) -> param . list(param) [ WRITES WITH VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On param shift to state 569
-- On lqualid shift to state 100
-- On list(param) shift to state 570
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WRITES reduce production list(param) ->
-- On WITH reduce production list(param) ->
-- On VARIANT reduce production list(param) ->
-- On VAL reduce production list(param) ->
-- On USE reduce production list(param) ->
-- On TYPE reduce production list(param) ->
-- On SCOPE reduce production list(param) ->
-- On RETURNS reduce production list(param) ->
-- On REQUIRES reduce production list(param) ->
-- On READS reduce production list(param) ->
-- On RAISES reduce production list(param) ->
-- On PREDICATE reduce production list(param) ->
-- On META reduce production list(param) ->
-- On LET reduce production list(param) ->
-- On LEMMA reduce production list(param) ->
-- On INVARIANT reduce production list(param) ->
-- On INDUCTIVE reduce production list(param) ->
-- On IN reduce production list(param) ->
-- On IMPORT reduce production list(param) ->
-- On GOAL reduce production list(param) ->
-- On FUNCTION reduce production list(param) ->
-- On EXCEPTION reduce production list(param) ->
-- On EQUAL reduce production list(param) ->
-- On EOF reduce production list(param) ->
-- On ENSURES reduce production list(param) ->
-- On END reduce production list(param) ->
-- On DIVERGES reduce production list(param) ->
-- On CONSTANT reduce production list(param) ->
-- On COLON reduce production list(param) ->
-- On COINDUCTIVE reduce production list(param) ->
-- On CLONE reduce production list(param) ->
-- On BY reduce production list(param) ->
-- On BAR reduce production list(param) ->
-- On AXIOM reduce production list(param) ->
-- On ALIAS reduce production list(param) ->

State 570:
## Known stack suffix:
## param list(param)
## LR(1) items:
list(param) -> param list(param) . [ WRITES WITH VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production list(param) -> param list(param)
-- On WITH reduce production list(param) -> param list(param)
-- On VARIANT reduce production list(param) -> param list(param)
-- On VAL reduce production list(param) -> param list(param)
-- On USE reduce production list(param) -> param list(param)
-- On TYPE reduce production list(param) -> param list(param)
-- On SCOPE reduce production list(param) -> param list(param)
-- On RETURNS reduce production list(param) -> param list(param)
-- On REQUIRES reduce production list(param) -> param list(param)
-- On READS reduce production list(param) -> param list(param)
-- On RAISES reduce production list(param) -> param list(param)
-- On PREDICATE reduce production list(param) -> param list(param)
-- On META reduce production list(param) -> param list(param)
-- On LET reduce production list(param) -> param list(param)
-- On LEMMA reduce production list(param) -> param list(param)
-- On INVARIANT reduce production list(param) -> param list(param)
-- On INDUCTIVE reduce production list(param) -> param list(param)
-- On IN reduce production list(param) -> param list(param)
-- On IMPORT reduce production list(param) -> param list(param)
-- On GOAL reduce production list(param) -> param list(param)
-- On FUNCTION reduce production list(param) -> param list(param)
-- On EXCEPTION reduce production list(param) -> param list(param)
-- On EQUAL reduce production list(param) -> param list(param)
-- On EOF reduce production list(param) -> param list(param)
-- On ENSURES reduce production list(param) -> param list(param)
-- On END reduce production list(param) -> param list(param)
-- On DIVERGES reduce production list(param) -> param list(param)
-- On CONSTANT reduce production list(param) -> param list(param)
-- On COLON reduce production list(param) -> param list(param)
-- On COINDUCTIVE reduce production list(param) -> param list(param)
-- On CLONE reduce production list(param) -> param list(param)
-- On BY reduce production list(param) -> param list(param)
-- On BAR reduce production list(param) -> param list(param)
-- On AXIOM reduce production list(param) -> param list(param)
-- On ALIAS reduce production list(param) -> param list(param)

State 571:
## Known stack suffix:
## lident_nq
## LR(1) items:
param -> lident_nq . nonempty_list(attr) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On nonempty_list(attr) shift to state 572
-- On attr shift to state 127
## Reductions:

State 572:
## Known stack suffix:
## lident_nq nonempty_list(attr)
## LR(1) items:
param -> lident_nq nonempty_list(attr) . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production param -> lident_nq nonempty_list(attr)
-- On WITH reduce production param -> lident_nq nonempty_list(attr)
-- On VARIANT reduce production param -> lident_nq nonempty_list(attr)
-- On VAL reduce production param -> lident_nq nonempty_list(attr)
-- On USE reduce production param -> lident_nq nonempty_list(attr)
-- On UNDERSCORE reduce production param -> lident_nq nonempty_list(attr)
-- On UIDENT reduce production param -> lident_nq nonempty_list(attr)
-- On TYPE reduce production param -> lident_nq nonempty_list(attr)
-- On SCOPE reduce production param -> lident_nq nonempty_list(attr)
-- On RETURNS reduce production param -> lident_nq nonempty_list(attr)
-- On REQUIRES reduce production param -> lident_nq nonempty_list(attr)
-- On READS reduce production param -> lident_nq nonempty_list(attr)
-- On RANGE reduce production param -> lident_nq nonempty_list(attr)
-- On RAISES reduce production param -> lident_nq nonempty_list(attr)
-- On QUOTE_LIDENT reduce production param -> lident_nq nonempty_list(attr)
-- On PREDICATE reduce production param -> lident_nq nonempty_list(attr)
-- On META reduce production param -> lident_nq nonempty_list(attr)
-- On LIDENT reduce production param -> lident_nq nonempty_list(attr)
-- On LET reduce production param -> lident_nq nonempty_list(attr)
-- On LEMMA reduce production param -> lident_nq nonempty_list(attr)
-- On LEFTPAR reduce production param -> lident_nq nonempty_list(attr)
-- On LEFTBRC reduce production param -> lident_nq nonempty_list(attr)
-- On INVARIANT reduce production param -> lident_nq nonempty_list(attr)
-- On INDUCTIVE reduce production param -> lident_nq nonempty_list(attr)
-- On IN reduce production param -> lident_nq nonempty_list(attr)
-- On IMPORT reduce production param -> lident_nq nonempty_list(attr)
-- On GOAL reduce production param -> lident_nq nonempty_list(attr)
-- On FUNCTION reduce production param -> lident_nq nonempty_list(attr)
-- On FLOAT reduce production param -> lident_nq nonempty_list(attr)
-- On EXCEPTION reduce production param -> lident_nq nonempty_list(attr)
-- On EQUAL reduce production param -> lident_nq nonempty_list(attr)
-- On EOF reduce production param -> lident_nq nonempty_list(attr)
-- On ENSURES reduce production param -> lident_nq nonempty_list(attr)
-- On END reduce production param -> lident_nq nonempty_list(attr)
-- On DIVERGES reduce production param -> lident_nq nonempty_list(attr)
-- On CORE_UIDENT reduce production param -> lident_nq nonempty_list(attr)
-- On CORE_LIDENT reduce production param -> lident_nq nonempty_list(attr)
-- On CONSTANT reduce production param -> lident_nq nonempty_list(attr)
-- On COLON reduce production param -> lident_nq nonempty_list(attr)
-- On COINDUCTIVE reduce production param -> lident_nq nonempty_list(attr)
-- On CLONE reduce production param -> lident_nq nonempty_list(attr)
-- On BY reduce production param -> lident_nq nonempty_list(attr)
-- On BAR reduce production param -> lident_nq nonempty_list(attr)
-- On AXIOM reduce production param -> lident_nq nonempty_list(attr)
-- On ALIAS reduce production param -> lident_nq nonempty_list(attr)

State 573:
## Known stack suffix:
## anon_binder
## LR(1) items:
param -> anon_binder . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production param -> anon_binder
-- On WITH reduce production param -> anon_binder
-- On VARIANT reduce production param -> anon_binder
-- On VAL reduce production param -> anon_binder
-- On USE reduce production param -> anon_binder
-- On UNDERSCORE reduce production param -> anon_binder
-- On UIDENT reduce production param -> anon_binder
-- On TYPE reduce production param -> anon_binder
-- On SCOPE reduce production param -> anon_binder
-- On RETURNS reduce production param -> anon_binder
-- On REQUIRES reduce production param -> anon_binder
-- On READS reduce production param -> anon_binder
-- On RANGE reduce production param -> anon_binder
-- On RAISES reduce production param -> anon_binder
-- On QUOTE_LIDENT reduce production param -> anon_binder
-- On PREDICATE reduce production param -> anon_binder
-- On META reduce production param -> anon_binder
-- On LIDENT reduce production param -> anon_binder
-- On LET reduce production param -> anon_binder
-- On LEMMA reduce production param -> anon_binder
-- On LEFTPAR reduce production param -> anon_binder
-- On LEFTBRC reduce production param -> anon_binder
-- On INVARIANT reduce production param -> anon_binder
-- On INDUCTIVE reduce production param -> anon_binder
-- On IN reduce production param -> anon_binder
-- On IMPORT reduce production param -> anon_binder
-- On GOAL reduce production param -> anon_binder
-- On FUNCTION reduce production param -> anon_binder
-- On FLOAT reduce production param -> anon_binder
-- On EXCEPTION reduce production param -> anon_binder
-- On EQUAL reduce production param -> anon_binder
-- On EOF reduce production param -> anon_binder
-- On ENSURES reduce production param -> anon_binder
-- On END reduce production param -> anon_binder
-- On DIVERGES reduce production param -> anon_binder
-- On CORE_UIDENT reduce production param -> anon_binder
-- On CORE_LIDENT reduce production param -> anon_binder
-- On CONSTANT reduce production param -> anon_binder
-- On COLON reduce production param -> anon_binder
-- On COINDUCTIVE reduce production param -> anon_binder
-- On CLONE reduce production param -> anon_binder
-- On BY reduce production param -> anon_binder
-- On BAR reduce production param -> anon_binder
-- On AXIOM reduce production param -> anon_binder
-- On ALIAS reduce production param -> anon_binder

State 574:
## Known stack suffix:
## VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
## LR(1) items:
prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On USE reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On TYPE reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On SCOPE reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On PREDICATE reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On META reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On LET reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On LEMMA reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On INDUCTIVE reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On IMPORT reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On GOAL reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On FUNCTION reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On EXCEPTION reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On EOF reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On END reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On CONSTANT reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On COINDUCTIVE reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On CLONE reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
-- On AXIOM reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)

State 575:
## Known stack suffix:
## list(param)
## LR(1) items:
params -> list(param) . [ WRITES WITH VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production params -> list(param)
-- On WITH reduce production params -> list(param)
-- On VARIANT reduce production params -> list(param)
-- On VAL reduce production params -> list(param)
-- On USE reduce production params -> list(param)
-- On TYPE reduce production params -> list(param)
-- On SCOPE reduce production params -> list(param)
-- On RETURNS reduce production params -> list(param)
-- On REQUIRES reduce production params -> list(param)
-- On READS reduce production params -> list(param)
-- On RAISES reduce production params -> list(param)
-- On PREDICATE reduce production params -> list(param)
-- On META reduce production params -> list(param)
-- On LET reduce production params -> list(param)
-- On LEMMA reduce production params -> list(param)
-- On INVARIANT reduce production params -> list(param)
-- On INDUCTIVE reduce production params -> list(param)
-- On IN reduce production params -> list(param)
-- On IMPORT reduce production params -> list(param)
-- On GOAL reduce production params -> list(param)
-- On FUNCTION reduce production params -> list(param)
-- On EXCEPTION reduce production params -> list(param)
-- On EQUAL reduce production params -> list(param)
-- On EOF reduce production params -> list(param)
-- On ENSURES reduce production params -> list(param)
-- On END reduce production params -> list(param)
-- On DIVERGES reduce production params -> list(param)
-- On CONSTANT reduce production params -> list(param)
-- On COLON reduce production params -> list(param)
-- On COINDUCTIVE reduce production params -> list(param)
-- On CLONE reduce production params -> list(param)
-- On BY reduce production params -> list(param)
-- On BAR reduce production params -> list(param)
-- On AXIOM reduce production params -> list(param)
-- On ALIAS reduce production params -> list(param)

State 576:
## Known stack suffix:
## USE
## LR(1) items:
use_clone -> USE . EXPORT tqualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
use_clone -> USE . boption(IMPORT) comma_list1(use_as) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On IMPORT shift to state 577
-- On EXPORT shift to state 578
-- On boption(IMPORT) shift to state 588
## Reductions:
-- On UIDENT reduce production boption(IMPORT) ->
-- On STRING reduce production boption(IMPORT) ->
-- On RANGE reduce production boption(IMPORT) ->
-- On LIDENT reduce production boption(IMPORT) ->
-- On FLOAT reduce production boption(IMPORT) ->
-- On CORE_UIDENT reduce production boption(IMPORT) ->
-- On CORE_LIDENT reduce production boption(IMPORT) ->

State 577:
## Known stack suffix:
## IMPORT
## LR(1) items:
boption(IMPORT) -> IMPORT . [ UIDENT STRING RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UIDENT reduce production boption(IMPORT) -> IMPORT
-- On STRING reduce production boption(IMPORT) -> IMPORT
-- On RANGE reduce production boption(IMPORT) -> IMPORT
-- On LIDENT reduce production boption(IMPORT) -> IMPORT
-- On FLOAT reduce production boption(IMPORT) -> IMPORT
-- On CORE_UIDENT reduce production boption(IMPORT) -> IMPORT
-- On CORE_LIDENT reduce production boption(IMPORT) -> IMPORT

State 578:
## Known stack suffix:
## USE EXPORT
## LR(1) items:
use_clone -> USE EXPORT . tqualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 580
-- On tqualid shift to state 581
-- On squalid shift to state 582
-- On sident shift to state 587
-- On lident_keyword shift to state 43
-- On lident shift to state 586
## Reductions:

State 579:
## Known stack suffix:
## STRING
## LR(1) items:
sident -> STRING . [ TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION DOT CONSTANT AXIOM ]
## Transitions:
## Reductions:
-- On TYPE reduce production sident -> STRING
-- On STRING reduce production sident -> STRING
-- On PREDICATE reduce production sident -> STRING
-- On LEMMA reduce production sident -> STRING
-- On INTEGER reduce production sident -> STRING
-- On GOAL reduce production sident -> STRING
-- On FUNCTION reduce production sident -> STRING
-- On DOT reduce production sident -> STRING
-- On CONSTANT reduce production sident -> STRING
-- On AXIOM reduce production sident -> STRING

State 580:
## Known stack suffix:
## uident
## LR(1) items:
sident -> uident . [ DOT ]
tqualid -> uident . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS ]
## Transitions:
## Reductions:
-- On WITH reduce production tqualid -> uident
-- On VAL reduce production tqualid -> uident
-- On USE reduce production tqualid -> uident
-- On TYPE reduce production tqualid -> uident
-- On SCOPE reduce production tqualid -> uident
-- On PREDICATE reduce production tqualid -> uident
-- On META reduce production tqualid -> uident
-- On LET reduce production tqualid -> uident
-- On LEMMA reduce production tqualid -> uident
-- On INDUCTIVE reduce production tqualid -> uident
-- On IMPORT reduce production tqualid -> uident
-- On GOAL reduce production tqualid -> uident
-- On FUNCTION reduce production tqualid -> uident
-- On EXCEPTION reduce production tqualid -> uident
-- On EOF reduce production tqualid -> uident
-- On END reduce production tqualid -> uident
-- On DOT reduce production sident -> uident
-- On CONSTANT reduce production tqualid -> uident
-- On COMMA reduce production tqualid -> uident
-- On COINDUCTIVE reduce production tqualid -> uident
-- On CLONE reduce production tqualid -> uident
-- On AXIOM reduce production tqualid -> uident
-- On AS reduce production tqualid -> uident

State 581:
## Known stack suffix:
## USE EXPORT tqualid
## LR(1) items:
use_clone -> USE EXPORT tqualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production use_clone -> USE EXPORT tqualid
-- On USE reduce production use_clone -> USE EXPORT tqualid
-- On TYPE reduce production use_clone -> USE EXPORT tqualid
-- On SCOPE reduce production use_clone -> USE EXPORT tqualid
-- On PREDICATE reduce production use_clone -> USE EXPORT tqualid
-- On META reduce production use_clone -> USE EXPORT tqualid
-- On LET reduce production use_clone -> USE EXPORT tqualid
-- On LEMMA reduce production use_clone -> USE EXPORT tqualid
-- On INDUCTIVE reduce production use_clone -> USE EXPORT tqualid
-- On IMPORT reduce production use_clone -> USE EXPORT tqualid
-- On GOAL reduce production use_clone -> USE EXPORT tqualid
-- On FUNCTION reduce production use_clone -> USE EXPORT tqualid
-- On EXCEPTION reduce production use_clone -> USE EXPORT tqualid
-- On EOF reduce production use_clone -> USE EXPORT tqualid
-- On END reduce production use_clone -> USE EXPORT tqualid
-- On CONSTANT reduce production use_clone -> USE EXPORT tqualid
-- On COINDUCTIVE reduce production use_clone -> USE EXPORT tqualid
-- On CLONE reduce production use_clone -> USE EXPORT tqualid
-- On AXIOM reduce production use_clone -> USE EXPORT tqualid

State 582:
## Known stack suffix:
## squalid
## LR(1) items:
squalid -> squalid . DOT sident [ DOT ]
tqualid -> squalid . DOT uident [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS ]
## Transitions:
-- On DOT shift to state 583
## Reductions:

State 583:
## Known stack suffix:
## squalid DOT
## LR(1) items:
squalid -> squalid DOT . sident [ DOT ]
tqualid -> squalid DOT . uident [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 584
-- On sident shift to state 585
-- On lident_keyword shift to state 43
-- On lident shift to state 586
## Reductions:

State 584:
## Known stack suffix:
## squalid DOT uident
## LR(1) items:
sident -> uident . [ DOT ]
tqualid -> squalid DOT uident . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS ]
## Transitions:
## Reductions:
-- On WITH reduce production tqualid -> squalid DOT uident
-- On VAL reduce production tqualid -> squalid DOT uident
-- On USE reduce production tqualid -> squalid DOT uident
-- On TYPE reduce production tqualid -> squalid DOT uident
-- On SCOPE reduce production tqualid -> squalid DOT uident
-- On PREDICATE reduce production tqualid -> squalid DOT uident
-- On META reduce production tqualid -> squalid DOT uident
-- On LET reduce production tqualid -> squalid DOT uident
-- On LEMMA reduce production tqualid -> squalid DOT uident
-- On INDUCTIVE reduce production tqualid -> squalid DOT uident
-- On IMPORT reduce production tqualid -> squalid DOT uident
-- On GOAL reduce production tqualid -> squalid DOT uident
-- On FUNCTION reduce production tqualid -> squalid DOT uident
-- On EXCEPTION reduce production tqualid -> squalid DOT uident
-- On EOF reduce production tqualid -> squalid DOT uident
-- On END reduce production tqualid -> squalid DOT uident
-- On DOT reduce production sident -> uident
-- On CONSTANT reduce production tqualid -> squalid DOT uident
-- On COMMA reduce production tqualid -> squalid DOT uident
-- On COINDUCTIVE reduce production tqualid -> squalid DOT uident
-- On CLONE reduce production tqualid -> squalid DOT uident
-- On AXIOM reduce production tqualid -> squalid DOT uident
-- On AS reduce production tqualid -> squalid DOT uident

State 585:
## Known stack suffix:
## squalid DOT sident
## LR(1) items:
squalid -> squalid DOT sident . [ DOT ]
## Transitions:
## Reductions:
-- On DOT reduce production squalid -> squalid DOT sident

State 586:
## Known stack suffix:
## lident
## LR(1) items:
sident -> lident . [ TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION DOT CONSTANT AXIOM ]
## Transitions:
## Reductions:
-- On TYPE reduce production sident -> lident
-- On STRING reduce production sident -> lident
-- On PREDICATE reduce production sident -> lident
-- On LEMMA reduce production sident -> lident
-- On INTEGER reduce production sident -> lident
-- On GOAL reduce production sident -> lident
-- On FUNCTION reduce production sident -> lident
-- On DOT reduce production sident -> lident
-- On CONSTANT reduce production sident -> lident
-- On AXIOM reduce production sident -> lident

State 587:
## Known stack suffix:
## sident
## LR(1) items:
squalid -> sident . [ DOT ]
## Transitions:
## Reductions:
-- On DOT reduce production squalid -> sident

State 588:
## Known stack suffix:
## USE boption(IMPORT)
## LR(1) items:
use_clone -> USE boption(IMPORT) . comma_list1(use_as) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On use_as shift to state 589
-- On uident shift to state 580
-- On tqualid shift to state 591
-- On squalid shift to state 582
-- On sident shift to state 587
-- On separated_nonempty_list(COMMA,use_as) shift to state 596
-- On lident_keyword shift to state 43
-- On lident shift to state 586
-- On comma_list1(use_as) shift to state 597
## Reductions:

State 589:
## Known stack suffix:
## use_as
## LR(1) items:
separated_nonempty_list(COMMA,use_as) -> use_as . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(COMMA,use_as) -> use_as . COMMA separated_nonempty_list(COMMA,use_as) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COMMA shift to state 590
## Reductions:
-- On VAL reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On USE reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On TYPE reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On SCOPE reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On PREDICATE reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On META reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On LET reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On LEMMA reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On INDUCTIVE reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On IMPORT reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On GOAL reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On FUNCTION reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On EXCEPTION reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On EOF reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On END reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On CONSTANT reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On COINDUCTIVE reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On CLONE reduce production separated_nonempty_list(COMMA,use_as) -> use_as
-- On AXIOM reduce production separated_nonempty_list(COMMA,use_as) -> use_as

State 590:
## Known stack suffix:
## use_as COMMA
## LR(1) items:
separated_nonempty_list(COMMA,use_as) -> use_as COMMA . separated_nonempty_list(COMMA,use_as) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On use_as shift to state 589
-- On uident shift to state 580
-- On tqualid shift to state 591
-- On squalid shift to state 582
-- On sident shift to state 587
-- On separated_nonempty_list(COMMA,use_as) shift to state 595
-- On lident_keyword shift to state 43
-- On lident shift to state 586
## Reductions:

State 591:
## Known stack suffix:
## tqualid
## LR(1) items:
use_as -> tqualid . option(preceded(AS,uident)) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On AS shift to state 592
-- On option(preceded(AS,uident)) shift to state 594
## Reductions:
-- On VAL reduce production option(preceded(AS,uident)) ->
-- On USE reduce production option(preceded(AS,uident)) ->
-- On TYPE reduce production option(preceded(AS,uident)) ->
-- On SCOPE reduce production option(preceded(AS,uident)) ->
-- On PREDICATE reduce production option(preceded(AS,uident)) ->
-- On META reduce production option(preceded(AS,uident)) ->
-- On LET reduce production option(preceded(AS,uident)) ->
-- On LEMMA reduce production option(preceded(AS,uident)) ->
-- On INDUCTIVE reduce production option(preceded(AS,uident)) ->
-- On IMPORT reduce production option(preceded(AS,uident)) ->
-- On GOAL reduce production option(preceded(AS,uident)) ->
-- On FUNCTION reduce production option(preceded(AS,uident)) ->
-- On EXCEPTION reduce production option(preceded(AS,uident)) ->
-- On EOF reduce production option(preceded(AS,uident)) ->
-- On END reduce production option(preceded(AS,uident)) ->
-- On CONSTANT reduce production option(preceded(AS,uident)) ->
-- On COMMA reduce production option(preceded(AS,uident)) ->
-- On COINDUCTIVE reduce production option(preceded(AS,uident)) ->
-- On CLONE reduce production option(preceded(AS,uident)) ->
-- On AXIOM reduce production option(preceded(AS,uident)) ->

State 592:
## Known stack suffix:
## AS
## LR(1) items:
option(preceded(AS,uident)) -> AS . uident [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 593
## Reductions:

State 593:
## Known stack suffix:
## AS uident
## LR(1) items:
option(preceded(AS,uident)) -> AS uident . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production option(preceded(AS,uident)) -> AS uident
-- On VAL reduce production option(preceded(AS,uident)) -> AS uident
-- On USE reduce production option(preceded(AS,uident)) -> AS uident
-- On TYPE reduce production option(preceded(AS,uident)) -> AS uident
-- On SCOPE reduce production option(preceded(AS,uident)) -> AS uident
-- On PREDICATE reduce production option(preceded(AS,uident)) -> AS uident
-- On META reduce production option(preceded(AS,uident)) -> AS uident
-- On LET reduce production option(preceded(AS,uident)) -> AS uident
-- On LEMMA reduce production option(preceded(AS,uident)) -> AS uident
-- On INDUCTIVE reduce production option(preceded(AS,uident)) -> AS uident
-- On IMPORT reduce production option(preceded(AS,uident)) -> AS uident
-- On GOAL reduce production option(preceded(AS,uident)) -> AS uident
-- On FUNCTION reduce production option(preceded(AS,uident)) -> AS uident
-- On EXCEPTION reduce production option(preceded(AS,uident)) -> AS uident
-- On EOF reduce production option(preceded(AS,uident)) -> AS uident
-- On END reduce production option(preceded(AS,uident)) -> AS uident
-- On CONSTANT reduce production option(preceded(AS,uident)) -> AS uident
-- On COMMA reduce production option(preceded(AS,uident)) -> AS uident
-- On COINDUCTIVE reduce production option(preceded(AS,uident)) -> AS uident
-- On CLONE reduce production option(preceded(AS,uident)) -> AS uident
-- On AXIOM reduce production option(preceded(AS,uident)) -> AS uident

State 594:
## Known stack suffix:
## tqualid option(preceded(AS,uident))
## LR(1) items:
use_as -> tqualid option(preceded(AS,uident)) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production use_as -> tqualid option(preceded(AS,uident))
-- On USE reduce production use_as -> tqualid option(preceded(AS,uident))
-- On TYPE reduce production use_as -> tqualid option(preceded(AS,uident))
-- On SCOPE reduce production use_as -> tqualid option(preceded(AS,uident))
-- On PREDICATE reduce production use_as -> tqualid option(preceded(AS,uident))
-- On META reduce production use_as -> tqualid option(preceded(AS,uident))
-- On LET reduce production use_as -> tqualid option(preceded(AS,uident))
-- On LEMMA reduce production use_as -> tqualid option(preceded(AS,uident))
-- On INDUCTIVE reduce production use_as -> tqualid option(preceded(AS,uident))
-- On IMPORT reduce production use_as -> tqualid option(preceded(AS,uident))
-- On GOAL reduce production use_as -> tqualid option(preceded(AS,uident))
-- On FUNCTION reduce production use_as -> tqualid option(preceded(AS,uident))
-- On EXCEPTION reduce production use_as -> tqualid option(preceded(AS,uident))
-- On EOF reduce production use_as -> tqualid option(preceded(AS,uident))
-- On END reduce production use_as -> tqualid option(preceded(AS,uident))
-- On CONSTANT reduce production use_as -> tqualid option(preceded(AS,uident))
-- On COMMA reduce production use_as -> tqualid option(preceded(AS,uident))
-- On COINDUCTIVE reduce production use_as -> tqualid option(preceded(AS,uident))
-- On CLONE reduce production use_as -> tqualid option(preceded(AS,uident))
-- On AXIOM reduce production use_as -> tqualid option(preceded(AS,uident))

State 595:
## Known stack suffix:
## use_as COMMA separated_nonempty_list(COMMA,use_as)
## LR(1) items:
separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On USE reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On TYPE reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On SCOPE reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On PREDICATE reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On META reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On LET reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On LEMMA reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On INDUCTIVE reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On IMPORT reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On GOAL reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On FUNCTION reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On EXCEPTION reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On EOF reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On END reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On CONSTANT reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On COINDUCTIVE reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On CLONE reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)
-- On AXIOM reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)

State 596:
## Known stack suffix:
## separated_nonempty_list(COMMA,use_as)
## LR(1) items:
comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On USE reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On TYPE reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On SCOPE reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On PREDICATE reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On META reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On LET reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On LEMMA reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On INDUCTIVE reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On IMPORT reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On GOAL reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On FUNCTION reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On EXCEPTION reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On EOF reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On END reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On CONSTANT reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On COINDUCTIVE reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On CLONE reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)
-- On AXIOM reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)

State 597:
## Known stack suffix:
## USE boption(IMPORT) comma_list1(use_as)
## LR(1) items:
use_clone -> USE boption(IMPORT) comma_list1(use_as) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On USE reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On TYPE reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On SCOPE reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On PREDICATE reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On META reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On LET reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On LEMMA reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On INDUCTIVE reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On IMPORT reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On GOAL reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On FUNCTION reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On EXCEPTION reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On EOF reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On END reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On CONSTANT reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On COINDUCTIVE reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On CLONE reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)
-- On AXIOM reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)

State 598:
## Known stack suffix:
## TYPE
## LR(1) items:
pure_decl -> TYPE . with_list1(type_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On with_list1(type_decl) shift to state 599
-- On type_decl shift to state 600
-- On separated_nonempty_list(WITH,type_decl) shift to state 994
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 603
## Reductions:

State 599:
## Known stack suffix:
## TYPE with_list1(type_decl)
## LR(1) items:
pure_decl -> TYPE with_list1(type_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production pure_decl -> TYPE with_list1(type_decl)
-- On USE reduce production pure_decl -> TYPE with_list1(type_decl)
-- On TYPE reduce production pure_decl -> TYPE with_list1(type_decl)
-- On SCOPE reduce production pure_decl -> TYPE with_list1(type_decl)
-- On PREDICATE reduce production pure_decl -> TYPE with_list1(type_decl)
-- On META reduce production pure_decl -> TYPE with_list1(type_decl)
-- On LET reduce production pure_decl -> TYPE with_list1(type_decl)
-- On LEMMA reduce production pure_decl -> TYPE with_list1(type_decl)
-- On INDUCTIVE reduce production pure_decl -> TYPE with_list1(type_decl)
-- On IMPORT reduce production pure_decl -> TYPE with_list1(type_decl)
-- On GOAL reduce production pure_decl -> TYPE with_list1(type_decl)
-- On FUNCTION reduce production pure_decl -> TYPE with_list1(type_decl)
-- On EXCEPTION reduce production pure_decl -> TYPE with_list1(type_decl)
-- On EOF reduce production pure_decl -> TYPE with_list1(type_decl)
-- On END reduce production pure_decl -> TYPE with_list1(type_decl)
-- On CONSTANT reduce production pure_decl -> TYPE with_list1(type_decl)
-- On COINDUCTIVE reduce production pure_decl -> TYPE with_list1(type_decl)
-- On CLONE reduce production pure_decl -> TYPE with_list1(type_decl)
-- On AXIOM reduce production pure_decl -> TYPE with_list1(type_decl)

State 600:
## Known stack suffix:
## type_decl
## LR(1) items:
separated_nonempty_list(WITH,type_decl) -> type_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(WITH,type_decl) -> type_decl . WITH separated_nonempty_list(WITH,type_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 601
## Reductions:
-- On VAL reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On USE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On TYPE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On SCOPE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On PREDICATE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On META reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On LET reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On LEMMA reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On INDUCTIVE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On IMPORT reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On GOAL reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On FUNCTION reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On EXCEPTION reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On EOF reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On END reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On CONSTANT reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On COINDUCTIVE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On CLONE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl
-- On AXIOM reduce production separated_nonempty_list(WITH,type_decl) -> type_decl

State 601:
## Known stack suffix:
## type_decl WITH
## LR(1) items:
separated_nonempty_list(WITH,type_decl) -> type_decl WITH . separated_nonempty_list(WITH,type_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On type_decl shift to state 600
-- On separated_nonempty_list(WITH,type_decl) shift to state 602
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 603
## Reductions:

State 602:
## Known stack suffix:
## type_decl WITH separated_nonempty_list(WITH,type_decl)
## LR(1) items:
separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On USE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On TYPE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On SCOPE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On PREDICATE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On META reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On LET reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On LEMMA reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On INDUCTIVE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On IMPORT reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On GOAL reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On FUNCTION reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On EXCEPTION reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On EOF reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On END reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On CONSTANT reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On COINDUCTIVE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On CLONE reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)
-- On AXIOM reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)

State 603:
## Known stack suffix:
## attrs(lident_nq)
## LR(1) items:
type_decl -> attrs(lident_nq) . list(ty_var) typedefn list(invariant) type_witness [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On QUOTE_LIDENT shift to state 78
-- On ty_var shift to state 604
-- On quote_lident shift to state 605
-- On list(ty_var) shift to state 609
-- On attrs(quote_lident) shift to state 608
## Reductions:
-- On WITH reduce production list(ty_var) ->
-- On VAL reduce production list(ty_var) ->
-- On USE reduce production list(ty_var) ->
-- On TYPE reduce production list(ty_var) ->
-- On SCOPE reduce production list(ty_var) ->
-- On PREDICATE reduce production list(ty_var) ->
-- On META reduce production list(ty_var) ->
-- On LET reduce production list(ty_var) ->
-- On LEMMA reduce production list(ty_var) ->
-- On INVARIANT reduce production list(ty_var) ->
-- On INDUCTIVE reduce production list(ty_var) ->
-- On IMPORT reduce production list(ty_var) ->
-- On GOAL reduce production list(ty_var) ->
-- On FUNCTION reduce production list(ty_var) ->
-- On EXCEPTION reduce production list(ty_var) ->
-- On EQUAL reduce production list(ty_var) ->
-- On EOF reduce production list(ty_var) ->
-- On END reduce production list(ty_var) ->
-- On CONSTANT reduce production list(ty_var) ->
-- On COINDUCTIVE reduce production list(ty_var) ->
-- On CLONE reduce production list(ty_var) ->
-- On BY reduce production list(ty_var) ->
-- On AXIOM reduce production list(ty_var) ->

State 604:
## Known stack suffix:
## ty_var
## LR(1) items:
list(ty_var) -> ty_var . list(ty_var) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On QUOTE_LIDENT shift to state 78
-- On ty_var shift to state 604
-- On quote_lident shift to state 605
-- On list(ty_var) shift to state 607
-- On attrs(quote_lident) shift to state 608
## Reductions:
-- On WITH reduce production list(ty_var) ->
-- On VAL reduce production list(ty_var) ->
-- On USE reduce production list(ty_var) ->
-- On TYPE reduce production list(ty_var) ->
-- On SCOPE reduce production list(ty_var) ->
-- On PREDICATE reduce production list(ty_var) ->
-- On META reduce production list(ty_var) ->
-- On LET reduce production list(ty_var) ->
-- On LEMMA reduce production list(ty_var) ->
-- On INVARIANT reduce production list(ty_var) ->
-- On INDUCTIVE reduce production list(ty_var) ->
-- On IMPORT reduce production list(ty_var) ->
-- On GOAL reduce production list(ty_var) ->
-- On FUNCTION reduce production list(ty_var) ->
-- On EXCEPTION reduce production list(ty_var) ->
-- On EQUAL reduce production list(ty_var) ->
-- On EOF reduce production list(ty_var) ->
-- On END reduce production list(ty_var) ->
-- On CONSTANT reduce production list(ty_var) ->
-- On COINDUCTIVE reduce production list(ty_var) ->
-- On CLONE reduce production list(ty_var) ->
-- On BY reduce production list(ty_var) ->
-- On AXIOM reduce production list(ty_var) ->

State 605:
## Known stack suffix:
## quote_lident
## LR(1) items:
attrs(quote_lident) -> quote_lident . list(attr) [ WITH VAL USE TYPE SCOPE QUOTE_LIDENT PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 606
-- On attr shift to state 71
## Reductions:
-- On WITH reduce production list(attr) ->
-- On VAL reduce production list(attr) ->
-- On USE reduce production list(attr) ->
-- On TYPE reduce production list(attr) ->
-- On SCOPE reduce production list(attr) ->
-- On QUOTE_LIDENT reduce production list(attr) ->
-- On PREDICATE reduce production list(attr) ->
-- On META reduce production list(attr) ->
-- On LET reduce production list(attr) ->
-- On LEMMA reduce production list(attr) ->
-- On INVARIANT reduce production list(attr) ->
-- On INDUCTIVE reduce production list(attr) ->
-- On IMPORT reduce production list(attr) ->
-- On GOAL reduce production list(attr) ->
-- On FUNCTION reduce production list(attr) ->
-- On EXCEPTION reduce production list(attr) ->
-- On EQUAL reduce production list(attr) ->
-- On EOF reduce production list(attr) ->
-- On END reduce production list(attr) ->
-- On CONSTANT reduce production list(attr) ->
-- On COINDUCTIVE reduce production list(attr) ->
-- On CLONE reduce production list(attr) ->
-- On BY reduce production list(attr) ->
-- On AXIOM reduce production list(attr) ->

State 606:
## Known stack suffix:
## quote_lident list(attr)
## LR(1) items:
attrs(quote_lident) -> quote_lident list(attr) . [ WITH VAL USE TYPE SCOPE QUOTE_LIDENT PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On VAL reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On USE reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On TYPE reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On SCOPE reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On QUOTE_LIDENT reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On PREDICATE reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On META reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On LET reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On LEMMA reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On INVARIANT reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On INDUCTIVE reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On IMPORT reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On GOAL reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On FUNCTION reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On EXCEPTION reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On EQUAL reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On EOF reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On END reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On CONSTANT reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On COINDUCTIVE reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On CLONE reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On BY reduce production attrs(quote_lident) -> quote_lident list(attr)
-- On AXIOM reduce production attrs(quote_lident) -> quote_lident list(attr)

State 607:
## Known stack suffix:
## ty_var list(ty_var)
## LR(1) items:
list(ty_var) -> ty_var list(ty_var) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production list(ty_var) -> ty_var list(ty_var)
-- On VAL reduce production list(ty_var) -> ty_var list(ty_var)
-- On USE reduce production list(ty_var) -> ty_var list(ty_var)
-- On TYPE reduce production list(ty_var) -> ty_var list(ty_var)
-- On SCOPE reduce production list(ty_var) -> ty_var list(ty_var)
-- On PREDICATE reduce production list(ty_var) -> ty_var list(ty_var)
-- On META reduce production list(ty_var) -> ty_var list(ty_var)
-- On LET reduce production list(ty_var) -> ty_var list(ty_var)
-- On LEMMA reduce production list(ty_var) -> ty_var list(ty_var)
-- On INVARIANT reduce production list(ty_var) -> ty_var list(ty_var)
-- On INDUCTIVE reduce production list(ty_var) -> ty_var list(ty_var)
-- On IMPORT reduce production list(ty_var) -> ty_var list(ty_var)
-- On GOAL reduce production list(ty_var) -> ty_var list(ty_var)
-- On FUNCTION reduce production list(ty_var) -> ty_var list(ty_var)
-- On EXCEPTION reduce production list(ty_var) -> ty_var list(ty_var)
-- On EQUAL reduce production list(ty_var) -> ty_var list(ty_var)
-- On EOF reduce production list(ty_var) -> ty_var list(ty_var)
-- On END reduce production list(ty_var) -> ty_var list(ty_var)
-- On CONSTANT reduce production list(ty_var) -> ty_var list(ty_var)
-- On COINDUCTIVE reduce production list(ty_var) -> ty_var list(ty_var)
-- On CLONE reduce production list(ty_var) -> ty_var list(ty_var)
-- On BY reduce production list(ty_var) -> ty_var list(ty_var)
-- On AXIOM reduce production list(ty_var) -> ty_var list(ty_var)

State 608:
## Known stack suffix:
## attrs(quote_lident)
## LR(1) items:
ty_var -> attrs(quote_lident) . [ WITH VAL USE TYPE SCOPE QUOTE_LIDENT PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production ty_var -> attrs(quote_lident)
-- On VAL reduce production ty_var -> attrs(quote_lident)
-- On USE reduce production ty_var -> attrs(quote_lident)
-- On TYPE reduce production ty_var -> attrs(quote_lident)
-- On SCOPE reduce production ty_var -> attrs(quote_lident)
-- On QUOTE_LIDENT reduce production ty_var -> attrs(quote_lident)
-- On PREDICATE reduce production ty_var -> attrs(quote_lident)
-- On META reduce production ty_var -> attrs(quote_lident)
-- On LET reduce production ty_var -> attrs(quote_lident)
-- On LEMMA reduce production ty_var -> attrs(quote_lident)
-- On INVARIANT reduce production ty_var -> attrs(quote_lident)
-- On INDUCTIVE reduce production ty_var -> attrs(quote_lident)
-- On IMPORT reduce production ty_var -> attrs(quote_lident)
-- On GOAL reduce production ty_var -> attrs(quote_lident)
-- On FUNCTION reduce production ty_var -> attrs(quote_lident)
-- On EXCEPTION reduce production ty_var -> attrs(quote_lident)
-- On EQUAL reduce production ty_var -> attrs(quote_lident)
-- On EOF reduce production ty_var -> attrs(quote_lident)
-- On END reduce production ty_var -> attrs(quote_lident)
-- On CONSTANT reduce production ty_var -> attrs(quote_lident)
-- On COINDUCTIVE reduce production ty_var -> attrs(quote_lident)
-- On CLONE reduce production ty_var -> attrs(quote_lident)
-- On BY reduce production ty_var -> attrs(quote_lident)
-- On AXIOM reduce production ty_var -> attrs(quote_lident)

State 609:
## Known stack suffix:
## attrs(lident_nq) list(ty_var)
## LR(1) items:
type_decl -> attrs(lident_nq) list(ty_var) . typedefn list(invariant) type_witness [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 610
-- On typedefn shift to state 662
## Reductions:
-- On WITH reduce production typedefn ->
-- On VAL reduce production typedefn ->
-- On USE reduce production typedefn ->
-- On TYPE reduce production typedefn ->
-- On SCOPE reduce production typedefn ->
-- On PREDICATE reduce production typedefn ->
-- On META reduce production typedefn ->
-- On LET reduce production typedefn ->
-- On LEMMA reduce production typedefn ->
-- On INVARIANT reduce production typedefn ->
-- On INDUCTIVE reduce production typedefn ->
-- On IMPORT reduce production typedefn ->
-- On GOAL reduce production typedefn ->
-- On FUNCTION reduce production typedefn ->
-- On EXCEPTION reduce production typedefn ->
-- On EOF reduce production typedefn ->
-- On END reduce production typedefn ->
-- On CONSTANT reduce production typedefn ->
-- On COINDUCTIVE reduce production typedefn ->
-- On CLONE reduce production typedefn ->
-- On BY reduce production typedefn ->
-- On AXIOM reduce production typedefn ->

State 610:
## Known stack suffix:
## EQUAL
## LR(1) items:
typedefn -> EQUAL . vis_mut bar_list1(type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL . vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL . vis_mut ty [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL . LT RANGE int_constant int_constant GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL . LT FLOAT INTEGER INTEGER GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On PRIVATE shift to state 611
-- On MUTABLE shift to state 612
-- On LT shift to state 615
-- On ABSTRACT shift to state 613
-- On vis_mut shift to state 627
-- On abstract shift to state 660
## Reductions:
-- On UIDENT reduce production vis_mut ->
-- On RANGE reduce production vis_mut ->
-- On QUOTE_LIDENT reduce production vis_mut ->
-- On LIDENT reduce production vis_mut ->
-- On LEFTPAR reduce production vis_mut ->
-- On LEFTBRC reduce production vis_mut ->
-- On FLOAT reduce production vis_mut ->
-- On CORE_UIDENT reduce production vis_mut ->
-- On CORE_LIDENT reduce production vis_mut ->
-- On BAR reduce production vis_mut ->

State 611:
## Known stack suffix:
## PRIVATE
## LR(1) items:
abstract -> PRIVATE . [ UIDENT RANGE QUOTE_LIDENT MUTABLE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## Transitions:
## Reductions:
-- On UIDENT reduce production abstract -> PRIVATE
-- On RANGE reduce production abstract -> PRIVATE
-- On QUOTE_LIDENT reduce production abstract -> PRIVATE
-- On MUTABLE reduce production abstract -> PRIVATE
-- On LIDENT reduce production abstract -> PRIVATE
-- On LEFTPAR reduce production abstract -> PRIVATE
-- On LEFTBRC reduce production abstract -> PRIVATE
-- On FLOAT reduce production abstract -> PRIVATE
-- On CORE_UIDENT reduce production abstract -> PRIVATE
-- On CORE_LIDENT reduce production abstract -> PRIVATE
-- On BAR reduce production abstract -> PRIVATE

State 612:
## Known stack suffix:
## MUTABLE
## LR(1) items:
vis_mut -> MUTABLE . [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
vis_mut -> MUTABLE . abstract [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## Transitions:
-- On PRIVATE shift to state 611
-- On ABSTRACT shift to state 613
-- On abstract shift to state 614
## Reductions:
-- On UIDENT reduce production vis_mut -> MUTABLE
-- On RANGE reduce production vis_mut -> MUTABLE
-- On QUOTE_LIDENT reduce production vis_mut -> MUTABLE
-- On LIDENT reduce production vis_mut -> MUTABLE
-- On LEFTPAR reduce production vis_mut -> MUTABLE
-- On LEFTBRC reduce production vis_mut -> MUTABLE
-- On FLOAT reduce production vis_mut -> MUTABLE
-- On CORE_UIDENT reduce production vis_mut -> MUTABLE
-- On CORE_LIDENT reduce production vis_mut -> MUTABLE
-- On BAR reduce production vis_mut -> MUTABLE

State 613:
## Known stack suffix:
## ABSTRACT
## LR(1) items:
abstract -> ABSTRACT . [ UIDENT RANGE QUOTE_LIDENT MUTABLE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## Transitions:
## Reductions:
-- On UIDENT reduce production abstract -> ABSTRACT
-- On RANGE reduce production abstract -> ABSTRACT
-- On QUOTE_LIDENT reduce production abstract -> ABSTRACT
-- On MUTABLE reduce production abstract -> ABSTRACT
-- On LIDENT reduce production abstract -> ABSTRACT
-- On LEFTPAR reduce production abstract -> ABSTRACT
-- On LEFTBRC reduce production abstract -> ABSTRACT
-- On FLOAT reduce production abstract -> ABSTRACT
-- On CORE_UIDENT reduce production abstract -> ABSTRACT
-- On CORE_LIDENT reduce production abstract -> ABSTRACT
-- On BAR reduce production abstract -> ABSTRACT

State 614:
## Known stack suffix:
## MUTABLE abstract
## LR(1) items:
vis_mut -> MUTABLE abstract . [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## Transitions:
## Reductions:
-- On UIDENT reduce production vis_mut -> MUTABLE abstract
-- On RANGE reduce production vis_mut -> MUTABLE abstract
-- On QUOTE_LIDENT reduce production vis_mut -> MUTABLE abstract
-- On LIDENT reduce production vis_mut -> MUTABLE abstract
-- On LEFTPAR reduce production vis_mut -> MUTABLE abstract
-- On LEFTBRC reduce production vis_mut -> MUTABLE abstract
-- On FLOAT reduce production vis_mut -> MUTABLE abstract
-- On CORE_UIDENT reduce production vis_mut -> MUTABLE abstract
-- On CORE_LIDENT reduce production vis_mut -> MUTABLE abstract
-- On BAR reduce production vis_mut -> MUTABLE abstract

State 615:
## Known stack suffix:
## EQUAL LT
## LR(1) items:
typedefn -> EQUAL LT . RANGE int_constant int_constant GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL LT . FLOAT INTEGER INTEGER GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On RANGE shift to state 616
-- On FLOAT shift to state 623
## Reductions:

State 616:
## Known stack suffix:
## EQUAL LT RANGE
## LR(1) items:
typedefn -> EQUAL LT RANGE . int_constant int_constant GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On MINUS shift to state 617
-- On INTEGER shift to state 619
-- On int_constant shift to state 620
## Reductions:

State 617:
## Known stack suffix:
## MINUS
## LR(1) items:
int_constant -> MINUS . INTEGER [ MINUS INTEGER GT ]
## Transitions:
-- On INTEGER shift to state 618
## Reductions:

State 618:
## Known stack suffix:
## MINUS INTEGER
## LR(1) items:
int_constant -> MINUS INTEGER . [ MINUS INTEGER GT ]
## Transitions:
## Reductions:
-- On MINUS reduce production int_constant -> MINUS INTEGER
-- On INTEGER reduce production int_constant -> MINUS INTEGER
-- On GT reduce production int_constant -> MINUS INTEGER

State 619:
## Known stack suffix:
## INTEGER
## LR(1) items:
int_constant -> INTEGER . [ MINUS INTEGER GT ]
## Transitions:
## Reductions:
-- On MINUS reduce production int_constant -> INTEGER
-- On INTEGER reduce production int_constant -> INTEGER
-- On GT reduce production int_constant -> INTEGER

State 620:
## Known stack suffix:
## EQUAL LT RANGE int_constant
## LR(1) items:
typedefn -> EQUAL LT RANGE int_constant . int_constant GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On MINUS shift to state 617
-- On INTEGER shift to state 619
-- On int_constant shift to state 621
## Reductions:

State 621:
## Known stack suffix:
## EQUAL LT RANGE int_constant int_constant
## LR(1) items:
typedefn -> EQUAL LT RANGE int_constant int_constant . GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On GT shift to state 622
## Reductions:

State 622:
## Known stack suffix:
## EQUAL LT RANGE int_constant int_constant GT
## LR(1) items:
typedefn -> EQUAL LT RANGE int_constant int_constant GT . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On VAL reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On USE reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On TYPE reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On SCOPE reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On PREDICATE reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On META reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On LET reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On LEMMA reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On INVARIANT reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On INDUCTIVE reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On IMPORT reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On GOAL reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On FUNCTION reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On EXCEPTION reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On EOF reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On END reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On CONSTANT reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On COINDUCTIVE reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On CLONE reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On BY reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT
-- On AXIOM reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT

State 623:
## Known stack suffix:
## EQUAL LT FLOAT
## LR(1) items:
typedefn -> EQUAL LT FLOAT . INTEGER INTEGER GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On INTEGER shift to state 624
## Reductions:

State 624:
## Known stack suffix:
## EQUAL LT FLOAT INTEGER
## LR(1) items:
typedefn -> EQUAL LT FLOAT INTEGER . INTEGER GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On INTEGER shift to state 625
## Reductions:

State 625:
## Known stack suffix:
## EQUAL LT FLOAT INTEGER INTEGER
## LR(1) items:
typedefn -> EQUAL LT FLOAT INTEGER INTEGER . GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On GT shift to state 626
## Reductions:

State 626:
## Known stack suffix:
## EQUAL LT FLOAT INTEGER INTEGER GT
## LR(1) items:
typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On VAL reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On USE reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On TYPE reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On SCOPE reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On PREDICATE reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On META reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On LET reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On LEMMA reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On INVARIANT reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On INDUCTIVE reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On IMPORT reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On GOAL reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On FUNCTION reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On EXCEPTION reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On EOF reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On END reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On CONSTANT reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On COINDUCTIVE reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On CLONE reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On BY reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT
-- On AXIOM reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT

State 627:
## Known stack suffix:
## EQUAL vis_mut
## LR(1) items:
typedefn -> EQUAL vis_mut . bar_list1(type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL vis_mut . LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL vis_mut . ty [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On UIDENT shift to state 628
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 629
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 645
-- On CORE_LIDENT shift to state 39
-- On BAR shift to state 646
-- On uqualid shift to state 84
-- On uident_nq shift to state 649
-- On uident shift to state 89
-- On type_case shift to state 651
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 657
-- On separated_nonempty_list(BAR,type_case) shift to state 658
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On bar_list1(type_case) shift to state 659
-- On attrs(uident_nq) shift to state 654
## Reductions:

State 628:
## Known stack suffix:
## UIDENT
## LR(1) items:
uident -> UIDENT . [ DOT ]
uident_nq -> UIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WITH reduce production uident_nq -> UIDENT
-- On VAL reduce production uident_nq -> UIDENT
-- On USE reduce production uident_nq -> UIDENT
-- On UNDERSCORE reduce production uident_nq -> UIDENT
-- On UIDENT reduce production uident_nq -> UIDENT
-- On TYPE reduce production uident_nq -> UIDENT
-- On SCOPE reduce production uident_nq -> UIDENT
-- On RANGE reduce production uident_nq -> UIDENT
-- On QUOTE_LIDENT reduce production uident_nq -> UIDENT
-- On PREDICATE reduce production uident_nq -> UIDENT
-- On POSITION reduce production uident_nq -> UIDENT
-- On META reduce production uident_nq -> UIDENT
-- On LIDENT reduce production uident_nq -> UIDENT
-- On LET reduce production uident_nq -> UIDENT
-- On LEMMA reduce production uident_nq -> UIDENT
-- On LEFTPAR reduce production uident_nq -> UIDENT
-- On LEFTBRC reduce production uident_nq -> UIDENT
-- On INVARIANT reduce production uident_nq -> UIDENT
-- On INDUCTIVE reduce production uident_nq -> UIDENT
-- On IMPORT reduce production uident_nq -> UIDENT
-- On GOAL reduce production uident_nq -> UIDENT
-- On FUNCTION reduce production uident_nq -> UIDENT
-- On FLOAT reduce production uident_nq -> UIDENT
-- On EXCEPTION reduce production uident_nq -> UIDENT
-- On EOF reduce production uident_nq -> UIDENT
-- On END reduce production uident_nq -> UIDENT
-- On DOT reduce production uident -> UIDENT
-- On CORE_UIDENT reduce production uident_nq -> UIDENT
-- On CORE_LIDENT reduce production uident_nq -> UIDENT
-- On CONSTANT reduce production uident_nq -> UIDENT
-- On COINDUCTIVE reduce production uident_nq -> UIDENT
-- On CLONE reduce production uident_nq -> UIDENT
-- On BY reduce production uident_nq -> UIDENT
-- On BAR reduce production uident_nq -> UIDENT
-- On AXIOM reduce production uident_nq -> UIDENT
-- On ATTRIBUTE reduce production uident_nq -> UIDENT

State 629:
## Known stack suffix:
## EQUAL vis_mut LEFTBRC
## LR(1) items:
ty_block -> LEFTBRC . ty RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ARROW ]
typedefn -> EQUAL vis_mut LEFTBRC . loption(semicolon_list1(type_field)) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On MUTABLE shift to state 630
-- On LIDENT shift to state 151
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 632
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 153
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On type_field shift to state 634
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 92
-- On semicolon_list1(type_field) shift to state 642
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On loption(semicolon_list1(type_field)) shift to state 643
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 167
-- On lident shift to state 101
-- On field_modifiers shift to state 637
-- On attrs(lident_nq) shift to state 640
## Reductions:
-- On RIGHTBRC reduce production loption(semicolon_list1(type_field)) ->

State 630:
## Known stack suffix:
## MUTABLE
## LR(1) items:
field_modifiers -> MUTABLE . [ RANGE LIDENT FLOAT CORE_LIDENT ]
field_modifiers -> MUTABLE . GHOST [ RANGE LIDENT FLOAT CORE_LIDENT ]
## Transitions:
-- On GHOST shift to state 631
## Reductions:
-- On RANGE reduce production field_modifiers -> MUTABLE
-- On LIDENT reduce production field_modifiers -> MUTABLE
-- On FLOAT reduce production field_modifiers -> MUTABLE
-- On CORE_LIDENT reduce production field_modifiers -> MUTABLE

State 631:
## Known stack suffix:
## MUTABLE GHOST
## LR(1) items:
field_modifiers -> MUTABLE GHOST . [ RANGE LIDENT FLOAT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On RANGE reduce production field_modifiers -> MUTABLE GHOST
-- On LIDENT reduce production field_modifiers -> MUTABLE GHOST
-- On FLOAT reduce production field_modifiers -> MUTABLE GHOST
-- On CORE_LIDENT reduce production field_modifiers -> MUTABLE GHOST

State 632:
## Known stack suffix:
## GHOST
## LR(1) items:
field_modifiers -> GHOST . [ RANGE LIDENT FLOAT CORE_LIDENT ]
field_modifiers -> GHOST . MUTABLE [ RANGE LIDENT FLOAT CORE_LIDENT ]
## Transitions:
-- On MUTABLE shift to state 633
## Reductions:
-- On RANGE reduce production field_modifiers -> GHOST
-- On LIDENT reduce production field_modifiers -> GHOST
-- On FLOAT reduce production field_modifiers -> GHOST
-- On CORE_LIDENT reduce production field_modifiers -> GHOST

State 633:
## Known stack suffix:
## GHOST MUTABLE
## LR(1) items:
field_modifiers -> GHOST MUTABLE . [ RANGE LIDENT FLOAT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On RANGE reduce production field_modifiers -> GHOST MUTABLE
-- On LIDENT reduce production field_modifiers -> GHOST MUTABLE
-- On FLOAT reduce production field_modifiers -> GHOST MUTABLE
-- On CORE_LIDENT reduce production field_modifiers -> GHOST MUTABLE

State 634:
## Known stack suffix:
## type_field
## LR(1) items:
semicolon_list1(type_field) -> type_field . [ RIGHTBRC ]
semicolon_list1(type_field) -> type_field . SEMICOLON [ RIGHTBRC ]
semicolon_list1(type_field) -> type_field . SEMICOLON semicolon_list1(type_field) [ RIGHTBRC ]
## Transitions:
-- On SEMICOLON shift to state 635
## Reductions:
-- On RIGHTBRC reduce production semicolon_list1(type_field) -> type_field

State 635:
## Known stack suffix:
## type_field SEMICOLON
## LR(1) items:
semicolon_list1(type_field) -> type_field SEMICOLON . [ RIGHTBRC ]
semicolon_list1(type_field) -> type_field SEMICOLON . semicolon_list1(type_field) [ RIGHTBRC ]
## Transitions:
-- On RANGE shift to state 2
-- On MUTABLE shift to state 630
-- On LIDENT shift to state 60
-- On GHOST shift to state 632
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On type_field shift to state 634
-- On semicolon_list1(type_field) shift to state 636
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On field_modifiers shift to state 637
-- On attrs(lident_nq) shift to state 640
## Reductions:
-- On RIGHTBRC reduce production semicolon_list1(type_field) -> type_field SEMICOLON

State 636:
## Known stack suffix:
## type_field SEMICOLON semicolon_list1(type_field)
## LR(1) items:
semicolon_list1(type_field) -> type_field SEMICOLON semicolon_list1(type_field) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production semicolon_list1(type_field) -> type_field SEMICOLON semicolon_list1(type_field)

State 637:
## Known stack suffix:
## field_modifiers
## LR(1) items:
type_field -> field_modifiers . attrs(lident_nq) cast [ SEMICOLON RIGHTBRC ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 638
## Reductions:

State 638:
## Known stack suffix:
## field_modifiers attrs(lident_nq)
## LR(1) items:
type_field -> field_modifiers attrs(lident_nq) . cast [ SEMICOLON RIGHTBRC ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 639
## Reductions:

State 639:
## Known stack suffix:
## field_modifiers attrs(lident_nq) cast
## LR(1) items:
type_field -> field_modifiers attrs(lident_nq) cast . [ SEMICOLON RIGHTBRC ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production type_field -> field_modifiers attrs(lident_nq) cast
-- On RIGHTBRC reduce production type_field -> field_modifiers attrs(lident_nq) cast

State 640:
## Known stack suffix:
## attrs(lident_nq)
## LR(1) items:
type_field -> attrs(lident_nq) . cast [ SEMICOLON RIGHTBRC ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 641
## Reductions:

State 641:
## Known stack suffix:
## attrs(lident_nq) cast
## LR(1) items:
type_field -> attrs(lident_nq) cast . [ SEMICOLON RIGHTBRC ]
## Transitions:
## Reductions:
-- On SEMICOLON reduce production type_field -> attrs(lident_nq) cast
-- On RIGHTBRC reduce production type_field -> attrs(lident_nq) cast

State 642:
## Known stack suffix:
## semicolon_list1(type_field)
## LR(1) items:
loption(semicolon_list1(type_field)) -> semicolon_list1(type_field) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production loption(semicolon_list1(type_field)) -> semicolon_list1(type_field)

State 643:
## Known stack suffix:
## EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field))
## LR(1) items:
typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) . RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On RIGHTBRC shift to state 644
## Reductions:

State 644:
## Known stack suffix:
## EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
## LR(1) items:
typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On VAL reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On USE reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On TYPE reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On SCOPE reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On PREDICATE reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On META reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On LET reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On LEMMA reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On INVARIANT reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On INDUCTIVE reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On IMPORT reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On GOAL reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On FUNCTION reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On EXCEPTION reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On EOF reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On END reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On CONSTANT reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On COINDUCTIVE reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On CLONE reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On BY reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
-- On AXIOM reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC

State 645:
## Known stack suffix:
## CORE_UIDENT
## LR(1) items:
uident -> CORE_UIDENT . [ DOT ]
uident_nq -> CORE_UIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WITH reduce production uident_nq -> CORE_UIDENT
-- On VAL reduce production uident_nq -> CORE_UIDENT
-- On USE reduce production uident_nq -> CORE_UIDENT
-- On UNDERSCORE reduce production uident_nq -> CORE_UIDENT
-- On UIDENT reduce production uident_nq -> CORE_UIDENT
-- On TYPE reduce production uident_nq -> CORE_UIDENT
-- On SCOPE reduce production uident_nq -> CORE_UIDENT
-- On RANGE reduce production uident_nq -> CORE_UIDENT
-- On QUOTE_LIDENT reduce production uident_nq -> CORE_UIDENT
-- On PREDICATE reduce production uident_nq -> CORE_UIDENT
-- On POSITION reduce production uident_nq -> CORE_UIDENT
-- On META reduce production uident_nq -> CORE_UIDENT
-- On LIDENT reduce production uident_nq -> CORE_UIDENT
-- On LET reduce production uident_nq -> CORE_UIDENT
-- On LEMMA reduce production uident_nq -> CORE_UIDENT
-- On LEFTPAR reduce production uident_nq -> CORE_UIDENT
-- On LEFTBRC reduce production uident_nq -> CORE_UIDENT
-- On INVARIANT reduce production uident_nq -> CORE_UIDENT
-- On INDUCTIVE reduce production uident_nq -> CORE_UIDENT
-- On IMPORT reduce production uident_nq -> CORE_UIDENT
-- On GOAL reduce production uident_nq -> CORE_UIDENT
-- On FUNCTION reduce production uident_nq -> CORE_UIDENT
-- On FLOAT reduce production uident_nq -> CORE_UIDENT
-- On EXCEPTION reduce production uident_nq -> CORE_UIDENT
-- On EOF reduce production uident_nq -> CORE_UIDENT
-- On END reduce production uident_nq -> CORE_UIDENT
-- On DOT reduce production uident -> CORE_UIDENT
-- On CORE_UIDENT reduce production uident_nq -> CORE_UIDENT
-- On CORE_LIDENT reduce production uident_nq -> CORE_UIDENT
-- On CONSTANT reduce production uident_nq -> CORE_UIDENT
-- On COINDUCTIVE reduce production uident_nq -> CORE_UIDENT
-- On CLONE reduce production uident_nq -> CORE_UIDENT
-- On BY reduce production uident_nq -> CORE_UIDENT
-- On BAR reduce production uident_nq -> CORE_UIDENT
-- On AXIOM reduce production uident_nq -> CORE_UIDENT
-- On ATTRIBUTE reduce production uident_nq -> CORE_UIDENT

State 646:
## Known stack suffix:
## BAR
## LR(1) items:
bar_list1(type_case) -> BAR . separated_nonempty_list(BAR,type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On CORE_UIDENT shift to state 648
-- On uident_nq shift to state 649
-- On type_case shift to state 651
-- On separated_nonempty_list(BAR,type_case) shift to state 656
-- On attrs(uident_nq) shift to state 654
## Reductions:

State 647:
## Known stack suffix:
## UIDENT
## LR(1) items:
uident_nq -> UIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WITH reduce production uident_nq -> UIDENT
-- On VAL reduce production uident_nq -> UIDENT
-- On USE reduce production uident_nq -> UIDENT
-- On UNDERSCORE reduce production uident_nq -> UIDENT
-- On UIDENT reduce production uident_nq -> UIDENT
-- On TYPE reduce production uident_nq -> UIDENT
-- On SCOPE reduce production uident_nq -> UIDENT
-- On RANGE reduce production uident_nq -> UIDENT
-- On QUOTE_LIDENT reduce production uident_nq -> UIDENT
-- On PREDICATE reduce production uident_nq -> UIDENT
-- On POSITION reduce production uident_nq -> UIDENT
-- On META reduce production uident_nq -> UIDENT
-- On LIDENT reduce production uident_nq -> UIDENT
-- On LET reduce production uident_nq -> UIDENT
-- On LEMMA reduce production uident_nq -> UIDENT
-- On LEFTPAR reduce production uident_nq -> UIDENT
-- On LEFTBRC reduce production uident_nq -> UIDENT
-- On INVARIANT reduce production uident_nq -> UIDENT
-- On INDUCTIVE reduce production uident_nq -> UIDENT
-- On IMPORT reduce production uident_nq -> UIDENT
-- On GOAL reduce production uident_nq -> UIDENT
-- On GHOST reduce production uident_nq -> UIDENT
-- On FUNCTION reduce production uident_nq -> UIDENT
-- On FLOAT reduce production uident_nq -> UIDENT
-- On EXCEPTION reduce production uident_nq -> UIDENT
-- On EOF reduce production uident_nq -> UIDENT
-- On END reduce production uident_nq -> UIDENT
-- On CORE_UIDENT reduce production uident_nq -> UIDENT
-- On CORE_LIDENT reduce production uident_nq -> UIDENT
-- On CONSTANT reduce production uident_nq -> UIDENT
-- On COLON reduce production uident_nq -> UIDENT
-- On COINDUCTIVE reduce production uident_nq -> UIDENT
-- On CLONE reduce production uident_nq -> UIDENT
-- On BY reduce production uident_nq -> UIDENT
-- On BAR reduce production uident_nq -> UIDENT
-- On AXIOM reduce production uident_nq -> UIDENT
-- On ATTRIBUTE reduce production uident_nq -> UIDENT

State 648:
## Known stack suffix:
## CORE_UIDENT
## LR(1) items:
uident_nq -> CORE_UIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WITH reduce production uident_nq -> CORE_UIDENT
-- On VAL reduce production uident_nq -> CORE_UIDENT
-- On USE reduce production uident_nq -> CORE_UIDENT
-- On UNDERSCORE reduce production uident_nq -> CORE_UIDENT
-- On UIDENT reduce production uident_nq -> CORE_UIDENT
-- On TYPE reduce production uident_nq -> CORE_UIDENT
-- On SCOPE reduce production uident_nq -> CORE_UIDENT
-- On RANGE reduce production uident_nq -> CORE_UIDENT
-- On QUOTE_LIDENT reduce production uident_nq -> CORE_UIDENT
-- On PREDICATE reduce production uident_nq -> CORE_UIDENT
-- On POSITION reduce production uident_nq -> CORE_UIDENT
-- On META reduce production uident_nq -> CORE_UIDENT
-- On LIDENT reduce production uident_nq -> CORE_UIDENT
-- On LET reduce production uident_nq -> CORE_UIDENT
-- On LEMMA reduce production uident_nq -> CORE_UIDENT
-- On LEFTPAR reduce production uident_nq -> CORE_UIDENT
-- On LEFTBRC reduce production uident_nq -> CORE_UIDENT
-- On INVARIANT reduce production uident_nq -> CORE_UIDENT
-- On INDUCTIVE reduce production uident_nq -> CORE_UIDENT
-- On IMPORT reduce production uident_nq -> CORE_UIDENT
-- On GOAL reduce production uident_nq -> CORE_UIDENT
-- On GHOST reduce production uident_nq -> CORE_UIDENT
-- On FUNCTION reduce production uident_nq -> CORE_UIDENT
-- On FLOAT reduce production uident_nq -> CORE_UIDENT
-- On EXCEPTION reduce production uident_nq -> CORE_UIDENT
-- On EOF reduce production uident_nq -> CORE_UIDENT
-- On END reduce production uident_nq -> CORE_UIDENT
-- On CORE_UIDENT reduce production uident_nq -> CORE_UIDENT
-- On CORE_LIDENT reduce production uident_nq -> CORE_UIDENT
-- On CONSTANT reduce production uident_nq -> CORE_UIDENT
-- On COLON reduce production uident_nq -> CORE_UIDENT
-- On COINDUCTIVE reduce production uident_nq -> CORE_UIDENT
-- On CLONE reduce production uident_nq -> CORE_UIDENT
-- On BY reduce production uident_nq -> CORE_UIDENT
-- On BAR reduce production uident_nq -> CORE_UIDENT
-- On AXIOM reduce production uident_nq -> CORE_UIDENT
-- On ATTRIBUTE reduce production uident_nq -> CORE_UIDENT

State 649:
## Known stack suffix:
## uident_nq
## LR(1) items:
attrs(uident_nq) -> uident_nq . list(attr) [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 650
-- On attr shift to state 71
## Reductions:
-- On WITH reduce production list(attr) ->
-- On VAL reduce production list(attr) ->
-- On USE reduce production list(attr) ->
-- On UNDERSCORE reduce production list(attr) ->
-- On UIDENT reduce production list(attr) ->
-- On TYPE reduce production list(attr) ->
-- On SCOPE reduce production list(attr) ->
-- On RANGE reduce production list(attr) ->
-- On QUOTE_LIDENT reduce production list(attr) ->
-- On PREDICATE reduce production list(attr) ->
-- On META reduce production list(attr) ->
-- On LIDENT reduce production list(attr) ->
-- On LET reduce production list(attr) ->
-- On LEMMA reduce production list(attr) ->
-- On LEFTPAR reduce production list(attr) ->
-- On LEFTBRC reduce production list(attr) ->
-- On INVARIANT reduce production list(attr) ->
-- On INDUCTIVE reduce production list(attr) ->
-- On IMPORT reduce production list(attr) ->
-- On GOAL reduce production list(attr) ->
-- On GHOST reduce production list(attr) ->
-- On FUNCTION reduce production list(attr) ->
-- On FLOAT reduce production list(attr) ->
-- On EXCEPTION reduce production list(attr) ->
-- On EOF reduce production list(attr) ->
-- On END reduce production list(attr) ->
-- On CORE_UIDENT reduce production list(attr) ->
-- On CORE_LIDENT reduce production list(attr) ->
-- On CONSTANT reduce production list(attr) ->
-- On COINDUCTIVE reduce production list(attr) ->
-- On CLONE reduce production list(attr) ->
-- On BY reduce production list(attr) ->
-- On BAR reduce production list(attr) ->
-- On AXIOM reduce production list(attr) ->

State 650:
## Known stack suffix:
## uident_nq list(attr)
## LR(1) items:
attrs(uident_nq) -> uident_nq list(attr) . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On VAL reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On USE reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On UNDERSCORE reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On UIDENT reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On TYPE reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On SCOPE reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On RANGE reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On QUOTE_LIDENT reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On PREDICATE reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On META reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On LIDENT reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On LET reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On LEMMA reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On LEFTPAR reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On LEFTBRC reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On INVARIANT reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On INDUCTIVE reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On IMPORT reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On GOAL reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On GHOST reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On FUNCTION reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On FLOAT reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On EXCEPTION reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On EOF reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On END reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On CORE_UIDENT reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On CORE_LIDENT reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On CONSTANT reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On COINDUCTIVE reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On CLONE reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On BY reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On BAR reduce production attrs(uident_nq) -> uident_nq list(attr)
-- On AXIOM reduce production attrs(uident_nq) -> uident_nq list(attr)

State 651:
## Known stack suffix:
## type_case
## LR(1) items:
separated_nonempty_list(BAR,type_case) -> type_case . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
separated_nonempty_list(BAR,type_case) -> type_case . BAR separated_nonempty_list(BAR,type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On BAR shift to state 652
## Reductions:
-- On WITH reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On VAL reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On USE reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On TYPE reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On SCOPE reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On PREDICATE reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On META reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On LET reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On LEMMA reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On INVARIANT reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On INDUCTIVE reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On IMPORT reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On GOAL reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On FUNCTION reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On EXCEPTION reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On EOF reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On END reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On CONSTANT reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On COINDUCTIVE reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On CLONE reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On BY reduce production separated_nonempty_list(BAR,type_case) -> type_case
-- On AXIOM reduce production separated_nonempty_list(BAR,type_case) -> type_case

State 652:
## Known stack suffix:
## type_case BAR
## LR(1) items:
separated_nonempty_list(BAR,type_case) -> type_case BAR . separated_nonempty_list(BAR,type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On CORE_UIDENT shift to state 648
-- On uident_nq shift to state 649
-- On type_case shift to state 651
-- On separated_nonempty_list(BAR,type_case) shift to state 653
-- On attrs(uident_nq) shift to state 654
## Reductions:

State 653:
## Known stack suffix:
## type_case BAR separated_nonempty_list(BAR,type_case)
## LR(1) items:
separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On VAL reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On USE reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On TYPE reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On SCOPE reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On PREDICATE reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On META reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On LET reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On LEMMA reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On INVARIANT reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On INDUCTIVE reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On IMPORT reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On GOAL reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On FUNCTION reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On EXCEPTION reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On EOF reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On END reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On CONSTANT reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On COINDUCTIVE reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On CLONE reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On BY reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)
-- On AXIOM reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)

State 654:
## Known stack suffix:
## attrs(uident_nq)
## LR(1) items:
type_case -> attrs(uident_nq) . params [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 655
-- On param shift to state 569
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WITH reduce production list(param) ->
-- On VAL reduce production list(param) ->
-- On USE reduce production list(param) ->
-- On TYPE reduce production list(param) ->
-- On SCOPE reduce production list(param) ->
-- On PREDICATE reduce production list(param) ->
-- On META reduce production list(param) ->
-- On LET reduce production list(param) ->
-- On LEMMA reduce production list(param) ->
-- On INVARIANT reduce production list(param) ->
-- On INDUCTIVE reduce production list(param) ->
-- On IMPORT reduce production list(param) ->
-- On GOAL reduce production list(param) ->
-- On FUNCTION reduce production list(param) ->
-- On EXCEPTION reduce production list(param) ->
-- On EOF reduce production list(param) ->
-- On END reduce production list(param) ->
-- On CONSTANT reduce production list(param) ->
-- On COINDUCTIVE reduce production list(param) ->
-- On CLONE reduce production list(param) ->
-- On BY reduce production list(param) ->
-- On BAR reduce production list(param) ->
-- On AXIOM reduce production list(param) ->

State 655:
## Known stack suffix:
## attrs(uident_nq) params
## LR(1) items:
type_case -> attrs(uident_nq) params . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production type_case -> attrs(uident_nq) params
-- On VAL reduce production type_case -> attrs(uident_nq) params
-- On USE reduce production type_case -> attrs(uident_nq) params
-- On TYPE reduce production type_case -> attrs(uident_nq) params
-- On SCOPE reduce production type_case -> attrs(uident_nq) params
-- On PREDICATE reduce production type_case -> attrs(uident_nq) params
-- On META reduce production type_case -> attrs(uident_nq) params
-- On LET reduce production type_case -> attrs(uident_nq) params
-- On LEMMA reduce production type_case -> attrs(uident_nq) params
-- On INVARIANT reduce production type_case -> attrs(uident_nq) params
-- On INDUCTIVE reduce production type_case -> attrs(uident_nq) params
-- On IMPORT reduce production type_case -> attrs(uident_nq) params
-- On GOAL reduce production type_case -> attrs(uident_nq) params
-- On FUNCTION reduce production type_case -> attrs(uident_nq) params
-- On EXCEPTION reduce production type_case -> attrs(uident_nq) params
-- On EOF reduce production type_case -> attrs(uident_nq) params
-- On END reduce production type_case -> attrs(uident_nq) params
-- On CONSTANT reduce production type_case -> attrs(uident_nq) params
-- On COINDUCTIVE reduce production type_case -> attrs(uident_nq) params
-- On CLONE reduce production type_case -> attrs(uident_nq) params
-- On BY reduce production type_case -> attrs(uident_nq) params
-- On BAR reduce production type_case -> attrs(uident_nq) params
-- On AXIOM reduce production type_case -> attrs(uident_nq) params

State 656:
## Known stack suffix:
## BAR separated_nonempty_list(BAR,type_case)
## LR(1) items:
bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On VAL reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On USE reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On TYPE reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On SCOPE reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On PREDICATE reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On META reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On LET reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On LEMMA reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On INVARIANT reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On INDUCTIVE reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On IMPORT reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On GOAL reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On FUNCTION reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On EXCEPTION reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On EOF reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On END reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On CONSTANT reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On COINDUCTIVE reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On CLONE reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On BY reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)
-- On AXIOM reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)

State 657:
## Known stack suffix:
## EQUAL vis_mut ty
## LR(1) items:
ty -> ty . ARROW ty [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ARROW ]
typedefn -> EQUAL vis_mut ty . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On WITH reduce production typedefn -> EQUAL vis_mut ty
-- On VAL reduce production typedefn -> EQUAL vis_mut ty
-- On USE reduce production typedefn -> EQUAL vis_mut ty
-- On TYPE reduce production typedefn -> EQUAL vis_mut ty
-- On SCOPE reduce production typedefn -> EQUAL vis_mut ty
-- On PREDICATE reduce production typedefn -> EQUAL vis_mut ty
-- On META reduce production typedefn -> EQUAL vis_mut ty
-- On LET reduce production typedefn -> EQUAL vis_mut ty
-- On LEMMA reduce production typedefn -> EQUAL vis_mut ty
-- On INVARIANT reduce production typedefn -> EQUAL vis_mut ty
-- On INDUCTIVE reduce production typedefn -> EQUAL vis_mut ty
-- On IMPORT reduce production typedefn -> EQUAL vis_mut ty
-- On GOAL reduce production typedefn -> EQUAL vis_mut ty
-- On FUNCTION reduce production typedefn -> EQUAL vis_mut ty
-- On EXCEPTION reduce production typedefn -> EQUAL vis_mut ty
-- On EOF reduce production typedefn -> EQUAL vis_mut ty
-- On END reduce production typedefn -> EQUAL vis_mut ty
-- On CONSTANT reduce production typedefn -> EQUAL vis_mut ty
-- On COINDUCTIVE reduce production typedefn -> EQUAL vis_mut ty
-- On CLONE reduce production typedefn -> EQUAL vis_mut ty
-- On BY reduce production typedefn -> EQUAL vis_mut ty
-- On AXIOM reduce production typedefn -> EQUAL vis_mut ty

State 658:
## Known stack suffix:
## separated_nonempty_list(BAR,type_case)
## LR(1) items:
bar_list1(type_case) -> separated_nonempty_list(BAR,type_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On VAL reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On USE reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On TYPE reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On SCOPE reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On PREDICATE reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On META reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On LET reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On LEMMA reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On INVARIANT reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On INDUCTIVE reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On IMPORT reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On GOAL reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On FUNCTION reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On EXCEPTION reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On EOF reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On END reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On CONSTANT reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On COINDUCTIVE reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On CLONE reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On BY reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)
-- On AXIOM reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)

State 659:
## Known stack suffix:
## EQUAL vis_mut bar_list1(type_case)
## LR(1) items:
typedefn -> EQUAL vis_mut bar_list1(type_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On VAL reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On USE reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On TYPE reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On SCOPE reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On PREDICATE reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On META reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On LET reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On LEMMA reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On INVARIANT reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On INDUCTIVE reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On IMPORT reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On GOAL reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On FUNCTION reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On EXCEPTION reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On EOF reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On END reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On CONSTANT reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On COINDUCTIVE reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On CLONE reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On BY reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)
-- On AXIOM reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)

State 660:
## Known stack suffix:
## abstract
## LR(1) items:
vis_mut -> abstract . [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
vis_mut -> abstract . MUTABLE [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## Transitions:
-- On MUTABLE shift to state 661
## Reductions:
-- On UIDENT reduce production vis_mut -> abstract
-- On RANGE reduce production vis_mut -> abstract
-- On QUOTE_LIDENT reduce production vis_mut -> abstract
-- On LIDENT reduce production vis_mut -> abstract
-- On LEFTPAR reduce production vis_mut -> abstract
-- On LEFTBRC reduce production vis_mut -> abstract
-- On FLOAT reduce production vis_mut -> abstract
-- On CORE_UIDENT reduce production vis_mut -> abstract
-- On CORE_LIDENT reduce production vis_mut -> abstract
-- On BAR reduce production vis_mut -> abstract

State 661:
## Known stack suffix:
## abstract MUTABLE
## LR(1) items:
vis_mut -> abstract MUTABLE . [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## Transitions:
## Reductions:
-- On UIDENT reduce production vis_mut -> abstract MUTABLE
-- On RANGE reduce production vis_mut -> abstract MUTABLE
-- On QUOTE_LIDENT reduce production vis_mut -> abstract MUTABLE
-- On LIDENT reduce production vis_mut -> abstract MUTABLE
-- On LEFTPAR reduce production vis_mut -> abstract MUTABLE
-- On LEFTBRC reduce production vis_mut -> abstract MUTABLE
-- On FLOAT reduce production vis_mut -> abstract MUTABLE
-- On CORE_UIDENT reduce production vis_mut -> abstract MUTABLE
-- On CORE_LIDENT reduce production vis_mut -> abstract MUTABLE
-- On BAR reduce production vis_mut -> abstract MUTABLE

State 662:
## Known stack suffix:
## attrs(lident_nq) list(ty_var) typedefn
## LR(1) items:
type_decl -> attrs(lident_nq) list(ty_var) typedefn . list(invariant) type_witness [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On INVARIANT shift to state 663
-- On list(invariant) shift to state 667
-- On invariant shift to state 858
## Reductions:
-- On WITH reduce production list(invariant) ->
-- On VAL reduce production list(invariant) ->
-- On USE reduce production list(invariant) ->
-- On TYPE reduce production list(invariant) ->
-- On SCOPE reduce production list(invariant) ->
-- On PREDICATE reduce production list(invariant) ->
-- On META reduce production list(invariant) ->
-- On LET reduce production list(invariant) ->
-- On LEMMA reduce production list(invariant) ->
-- On INDUCTIVE reduce production list(invariant) ->
-- On IMPORT reduce production list(invariant) ->
-- On GOAL reduce production list(invariant) ->
-- On FUNCTION reduce production list(invariant) ->
-- On EXCEPTION reduce production list(invariant) ->
-- On EOF reduce production list(invariant) ->
-- On END reduce production list(invariant) ->
-- On CONSTANT reduce production list(invariant) ->
-- On COINDUCTIVE reduce production list(invariant) ->
-- On CLONE reduce production list(invariant) ->
-- On BY reduce production list(invariant) ->
-- On AXIOM reduce production list(invariant) ->

State 663:
## Known stack suffix:
## INVARIANT
## LR(1) items:
invariant -> INVARIANT . LEFTBRC term RIGHTBRC [ WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 664
## Reductions:

State 664:
## Known stack suffix:
## INVARIANT LEFTBRC
## LR(1) items:
invariant -> INVARIANT LEFTBRC . term RIGHTBRC [ WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 665
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 665:
## Known stack suffix:
## INVARIANT LEFTBRC term
## LR(1) items:
invariant -> INVARIANT LEFTBRC term . RIGHTBRC [ WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 666
## Reductions:

State 666:
## Known stack suffix:
## INVARIANT LEFTBRC term RIGHTBRC
## LR(1) items:
invariant -> INVARIANT LEFTBRC term RIGHTBRC . [ WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WITH reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On WHILE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On VARIANT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On VAL reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On USE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On UIDENT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On TYPE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On TRY reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On TRUE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On SCOPE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On RETURN reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On REAL reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On RANGE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On RAISE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On PURE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On PREDICATE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On POSITION reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On OPPREF reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On OP4 reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On OP3 reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On OP2 reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On OP1 reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On NOT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On MINUS reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On META reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On MATCH reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On LT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On LIDENT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On LET reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On LEMMA reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On LEFTPAR reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On LEFTBRC reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On LABEL reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On INVARIANT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On INTEGER reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On INDUCTIVE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On IMPORT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On IF reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On GT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On GOAL reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On GHOST reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On FUNCTION reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On FUN reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On FOR reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On FLOAT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On FALSE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On EXCEPTION reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On EOF reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On END reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On DONE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On CORE_UIDENT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On CORE_LIDENT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On CONTINUE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On CONSTANT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On COINDUCTIVE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On CLONE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On CHECK reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On BY reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On BREAK reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On BEGIN reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On AXIOM reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On ATTRIBUTE reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On ASSUME reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On ASSERT reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On ANY reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC
-- On ABSURD reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC

State 667:
## Known stack suffix:
## attrs(lident_nq) list(ty_var) typedefn list(invariant)
## LR(1) items:
type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) . type_witness [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On BY shift to state 668
-- On type_witness shift to state 993
## Reductions:
-- On WITH reduce production type_witness ->
-- On VAL reduce production type_witness ->
-- On USE reduce production type_witness ->
-- On TYPE reduce production type_witness ->
-- On SCOPE reduce production type_witness ->
-- On PREDICATE reduce production type_witness ->
-- On META reduce production type_witness ->
-- On LET reduce production type_witness ->
-- On LEMMA reduce production type_witness ->
-- On INDUCTIVE reduce production type_witness ->
-- On IMPORT reduce production type_witness ->
-- On GOAL reduce production type_witness ->
-- On FUNCTION reduce production type_witness ->
-- On EXCEPTION reduce production type_witness ->
-- On EOF reduce production type_witness ->
-- On END reduce production type_witness ->
-- On CONSTANT reduce production type_witness ->
-- On COINDUCTIVE reduce production type_witness ->
-- On CLONE reduce production type_witness ->
-- On AXIOM reduce production type_witness ->

State 668:
## Known stack suffix:
## BY
## LR(1) items:
type_witness -> BY . LEFTBRC field_list1(expr) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On LEFTBRC shift to state 669
## Reductions:

State 669:
## Known stack suffix:
## BY LEFTBRC
## LR(1) items:
type_witness -> BY LEFTBRC . field_list1(expr) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,expr)) shift to state 670
-- On lqualid shift to state 671
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On field_list1(expr) shift to state 991
## Reductions:

State 670:
## Known stack suffix:
## semicolon_list1(separated_pair(lqualid,EQUAL,expr))
## LR(1) items:
field_list1(expr) -> semicolon_list1(separated_pair(lqualid,EQUAL,expr)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production field_list1(expr) -> semicolon_list1(separated_pair(lqualid,EQUAL,expr))

State 671:
## Known stack suffix:
## lqualid
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
## Transitions:
-- On EQUAL shift to state 672
## Reductions:

State 672:
## Known stack suffix:
## lqualid EQUAL
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL . expr [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL . expr SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL . expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 988
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 673:
## Known stack suffix:
## WHILE
## LR(1) items:
single_expr_ -> WHILE . seq_expr DO loop_annotation loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 979
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 674:
## Known stack suffix:
## VAL
## LR(1) items:
single_expr_ -> VAL . ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On GHOST shift to state 53
-- On ghost shift to state 675
## Reductions:
-- On RANGE reduce production ghost ->
-- On PREDICATE reduce production ghost ->
-- On LIDENT reduce production ghost ->
-- On LEMMA reduce production ghost ->
-- On LEFTPAR reduce production ghost ->
-- On FUNCTION reduce production ghost ->
-- On FLOAT reduce production ghost ->
-- On CORE_LIDENT reduce production ghost ->
-- On CONSTANT reduce production ghost ->

State 675:
## Known stack suffix:
## VAL ghost
## LR(1) items:
single_expr_ -> VAL ghost . kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On PREDICATE shift to state 55
-- On LEMMA shift to state 56
-- On FUNCTION shift to state 57
-- On CONSTANT shift to state 58
-- On kind shift to state 676
## Reductions:
-- On RANGE reduce production kind ->
-- On LIDENT reduce production kind ->
-- On LEFTPAR reduce production kind ->
-- On FLOAT reduce production kind ->
-- On CORE_LIDENT reduce production kind ->

State 676:
## Known stack suffix:
## VAL ghost kind
## LR(1) items:
single_expr_ -> VAL ghost kind . attrs(lident_rich) mk_expr(val_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On attrs(lident_rich) shift to state 677
## Reductions:

State 677:
## Known stack suffix:
## VAL ghost kind attrs(lident_rich)
## LR(1) items:
single_expr_ -> VAL ghost kind attrs(lident_rich) . mk_expr(val_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On val_defn shift to state 145
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 147
-- On param shift to state 569
-- On mk_expr(val_defn) shift to state 678
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WRITES reduce production list(param) ->
-- On VARIANT reduce production list(param) ->
-- On RETURNS reduce production list(param) ->
-- On REQUIRES reduce production list(param) ->
-- On READS reduce production list(param) ->
-- On RAISES reduce production list(param) ->
-- On IN reduce production list(param) ->
-- On ENSURES reduce production list(param) ->
-- On DIVERGES reduce production list(param) ->
-- On COLON reduce production list(param) ->
-- On ALIAS reduce production list(param) ->

State 678:
## Known stack suffix:
## VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
## LR(1) items:
single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 679
## Reductions:

State 679:
## Known stack suffix:
## VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN
## LR(1) items:
single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 978
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 680:
## Known stack suffix:
## TRY
## LR(1) items:
single_expr_ -> TRY . seq_expr WITH bar_list1(exn_handler) END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 968
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 681:
## Known stack suffix:
## TRUE
## LR(1) items:
expr_arg_ -> TRUE . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_arg_ -> TRUE
-- On WITH reduce production expr_arg_ -> TRUE
-- On VARIANT reduce production expr_arg_ -> TRUE
-- On VAL reduce production expr_arg_ -> TRUE
-- On USE reduce production expr_arg_ -> TRUE
-- On UIDENT reduce production expr_arg_ -> TRUE
-- On TYPE reduce production expr_arg_ -> TRUE
-- On TRUE reduce production expr_arg_ -> TRUE
-- On TO reduce production expr_arg_ -> TRUE
-- On THEN reduce production expr_arg_ -> TRUE
-- On SEMICOLON reduce production expr_arg_ -> TRUE
-- On SCOPE reduce production expr_arg_ -> TRUE
-- On RIGHTSQ_QUOTE reduce production expr_arg_ -> TRUE
-- On RIGHTSQ reduce production expr_arg_ -> TRUE
-- On RIGHTPAR reduce production expr_arg_ -> TRUE
-- On RIGHTBRC reduce production expr_arg_ -> TRUE
-- On RETURNS reduce production expr_arg_ -> TRUE
-- On REQUIRES reduce production expr_arg_ -> TRUE
-- On REAL reduce production expr_arg_ -> TRUE
-- On READS reduce production expr_arg_ -> TRUE
-- On RANGE reduce production expr_arg_ -> TRUE
-- On RAISES reduce production expr_arg_ -> TRUE
-- On PURE reduce production expr_arg_ -> TRUE
-- On PREDICATE reduce production expr_arg_ -> TRUE
-- On OPPREF reduce production expr_arg_ -> TRUE
-- On OP4 reduce production expr_arg_ -> TRUE
-- On OP3 reduce production expr_arg_ -> TRUE
-- On OP2 reduce production expr_arg_ -> TRUE
-- On OP1 reduce production expr_arg_ -> TRUE
-- On MINUS reduce production expr_arg_ -> TRUE
-- On META reduce production expr_arg_ -> TRUE
-- On LTGT reduce production expr_arg_ -> TRUE
-- On LT reduce production expr_arg_ -> TRUE
-- On LIDENT reduce production expr_arg_ -> TRUE
-- On LET reduce production expr_arg_ -> TRUE
-- On LEMMA reduce production expr_arg_ -> TRUE
-- On LEFTSQ reduce production expr_arg_ -> TRUE
-- On LEFTPAR reduce production expr_arg_ -> TRUE
-- On LEFTBRC reduce production expr_arg_ -> TRUE
-- On LARROW reduce production expr_arg_ -> TRUE
-- On INTEGER reduce production expr_arg_ -> TRUE
-- On INDUCTIVE reduce production expr_arg_ -> TRUE
-- On IN reduce production expr_arg_ -> TRUE
-- On IMPORT reduce production expr_arg_ -> TRUE
-- On GT reduce production expr_arg_ -> TRUE
-- On GOAL reduce production expr_arg_ -> TRUE
-- On FUNCTION reduce production expr_arg_ -> TRUE
-- On FLOAT reduce production expr_arg_ -> TRUE
-- On FALSE reduce production expr_arg_ -> TRUE
-- On EXCEPTION reduce production expr_arg_ -> TRUE
-- On EQUAL reduce production expr_arg_ -> TRUE
-- On EOF reduce production expr_arg_ -> TRUE
-- On ENSURES reduce production expr_arg_ -> TRUE
-- On END reduce production expr_arg_ -> TRUE
-- On ELSE reduce production expr_arg_ -> TRUE
-- On DOWNTO reduce production expr_arg_ -> TRUE
-- On DOTDOT reduce production expr_arg_ -> TRUE
-- On DONE reduce production expr_arg_ -> TRUE
-- On DO reduce production expr_arg_ -> TRUE
-- On DIVERGES reduce production expr_arg_ -> TRUE
-- On CORE_UIDENT reduce production expr_arg_ -> TRUE
-- On CORE_LIDENT reduce production expr_arg_ -> TRUE
-- On CONSTANT reduce production expr_arg_ -> TRUE
-- On COMMA reduce production expr_arg_ -> TRUE
-- On COLON reduce production expr_arg_ -> TRUE
-- On COINDUCTIVE reduce production expr_arg_ -> TRUE
-- On CLONE reduce production expr_arg_ -> TRUE
-- On BEGIN reduce production expr_arg_ -> TRUE
-- On BARBAR reduce production expr_arg_ -> TRUE
-- On BAR reduce production expr_arg_ -> TRUE
-- On AXIOM reduce production expr_arg_ -> TRUE
-- On AMPAMP reduce production expr_arg_ -> TRUE
-- On ALIAS reduce production expr_arg_ -> TRUE

State 682:
## Known stack suffix:
## RETURN
## LR(1) items:
single_expr_ -> RETURN . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> RETURN . contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 967
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:
-- On WRITES reduce production single_expr_ -> RETURN
-- On WITH reduce production single_expr_ -> RETURN
-- On VARIANT reduce production single_expr_ -> RETURN
-- On VAL reduce production single_expr_ -> RETURN
-- On USE reduce production single_expr_ -> RETURN
-- On TYPE reduce production single_expr_ -> RETURN
-- On TO reduce production single_expr_ -> RETURN
-- On THEN reduce production single_expr_ -> RETURN
-- On SEMICOLON reduce production single_expr_ -> RETURN
-- On SCOPE reduce production single_expr_ -> RETURN
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> RETURN
-- On RIGHTSQ reduce production single_expr_ -> RETURN
-- On RIGHTPAR reduce production single_expr_ -> RETURN
-- On RIGHTBRC reduce production single_expr_ -> RETURN
-- On RETURNS reduce production single_expr_ -> RETURN
-- On REQUIRES reduce production single_expr_ -> RETURN
-- On READS reduce production single_expr_ -> RETURN
-- On RAISES reduce production single_expr_ -> RETURN
-- On PREDICATE reduce production single_expr_ -> RETURN
-- On META reduce production single_expr_ -> RETURN
-- On LTGT reduce production single_expr_ -> RETURN
-- On LET reduce production single_expr_ -> RETURN
-- On LEMMA reduce production single_expr_ -> RETURN
-- On LARROW reduce production single_expr_ -> RETURN
-- On INDUCTIVE reduce production single_expr_ -> RETURN
-- On IN reduce production single_expr_ -> RETURN
-- On IMPORT reduce production single_expr_ -> RETURN
-- On GOAL reduce production single_expr_ -> RETURN
-- On FUNCTION reduce production single_expr_ -> RETURN
-- On EXCEPTION reduce production single_expr_ -> RETURN
-- On EQUAL reduce production single_expr_ -> RETURN
-- On EOF reduce production single_expr_ -> RETURN
-- On ENSURES reduce production single_expr_ -> RETURN
-- On END reduce production single_expr_ -> RETURN
-- On ELSE reduce production single_expr_ -> RETURN
-- On DOWNTO reduce production single_expr_ -> RETURN
-- On DOTDOT reduce production single_expr_ -> RETURN
-- On DONE reduce production single_expr_ -> RETURN
-- On DO reduce production single_expr_ -> RETURN
-- On DIVERGES reduce production single_expr_ -> RETURN
-- On CONSTANT reduce production single_expr_ -> RETURN
-- On COMMA reduce production single_expr_ -> RETURN
-- On COLON reduce production single_expr_ -> RETURN
-- On COINDUCTIVE reduce production single_expr_ -> RETURN
-- On CLONE reduce production single_expr_ -> RETURN
-- On BARBAR reduce production single_expr_ -> RETURN
-- On BAR reduce production single_expr_ -> RETURN
-- On AXIOM reduce production single_expr_ -> RETURN
-- On AMPAMP reduce production single_expr_ -> RETURN
-- On ALIAS reduce production single_expr_ -> RETURN

State 683:
## Known stack suffix:
## RAISE
## LR(1) items:
single_expr_ -> RAISE . uqualid option(expr_arg) [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> RAISE . LEFTPAR uqualid option(expr_arg) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On LEFTPAR shift to state 684
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 965
-- On uident shift to state 89
## Reductions:

State 684:
## Known stack suffix:
## RAISE LEFTPAR
## LR(1) items:
single_expr_ -> RAISE LEFTPAR . uqualid option(expr_arg) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 685
-- On uident shift to state 89
## Reductions:

State 685:
## Known stack suffix:
## RAISE LEFTPAR uqualid
## LR(1) items:
single_expr_ -> RAISE LEFTPAR uqualid . option(expr_arg) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
uqualid -> uqualid . DOT uident [ UIDENT TRUE RIGHTPAR REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE DOT CORE_UIDENT CORE_LIDENT BEGIN ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On DOT shift to state 526
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On qualid shift to state 744
-- On option(expr_arg) shift to state 962
-- On numeral shift to state 745
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 964
## Reductions:
-- On RIGHTPAR reduce production option(expr_arg) ->

State 686:
## Known stack suffix:
## PURE
## LR(1) items:
expr_sub_ -> PURE . LEFTBRC term RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On LEFTBRC shift to state 687
## Reductions:

State 687:
## Known stack suffix:
## PURE LEFTBRC
## LR(1) items:
expr_sub_ -> PURE LEFTBRC . term RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 688
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 688:
## Known stack suffix:
## PURE LEFTBRC term
## LR(1) items:
expr_sub_ -> PURE LEFTBRC term . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 689
## Reductions:

State 689:
## Known stack suffix:
## PURE LEFTBRC term RIGHTBRC
## LR(1) items:
expr_sub_ -> PURE LEFTBRC term RIGHTBRC . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On WITH reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On VARIANT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On VAL reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On USE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On UIDENT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On TYPE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On TRUE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On TO reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On THEN reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On SEMICOLON reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On SCOPE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On RIGHTSQ reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On RIGHTPAR reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On RIGHTBRC reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On RETURNS reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On REQUIRES reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On REAL reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On READS reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On RANGE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On RAISES reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On PURE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On PREDICATE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On OPPREF reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On OP4 reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On OP3 reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On OP2 reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On OP1 reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On MINUS reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On META reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On LTGT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On LT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On LIDENT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On LET reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On LEMMA reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On LEFTSQ reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On LEFTPAR reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On LEFTBRC reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On LARROW reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On INTEGER reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On INDUCTIVE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On IN reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On IMPORT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On GT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On GOAL reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On FUNCTION reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On FLOAT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On FALSE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On EXCEPTION reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On EQUAL reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On EOF reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On ENSURES reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On END reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On ELSE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On DOWNTO reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On DOTDOT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On DOT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On DONE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On DO reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On DIVERGES reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On CORE_UIDENT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On CORE_LIDENT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On CONSTANT reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On COMMA reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On COLON reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On COINDUCTIVE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On CLONE reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On BEGIN reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On BARBAR reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On BAR reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On AXIOM reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On AMPAMP reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC
-- On ALIAS reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC

State 690:
## Known stack suffix:
## OPPREF
## LR(1) items:
expr_arg_ -> OPPREF . expr_arg [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_dot_ -> OPPREF . expr_dot [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On qualid shift to state 744
-- On numeral shift to state 745
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 957
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 958
## Reductions:

State 691:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
expr_block_ -> LEFTPAR . seq_expr RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR_USCORE [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR_QUOTE [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RIGHTPAR shift to state 692
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 693
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 959
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTSQ shift to state 15
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On EQUAL shift to state 30
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 960
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 488
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op_str shift to state 33
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 692:
## Known stack suffix:
## LEFTPAR RIGHTPAR
## LR(1) items:
expr_block_ -> LEFTPAR RIGHTPAR . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On WITH reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On VARIANT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On VAL reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On USE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On UIDENT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On TYPE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On TRUE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On TO reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On THEN reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On SEMICOLON reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On SCOPE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On RIGHTSQ reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On RIGHTPAR reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On RIGHTBRC reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On RETURNS reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On REQUIRES reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On REAL reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On READS reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On RANGE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On RAISES reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On PURE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On PREDICATE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On OPPREF reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On OP4 reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On OP3 reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On OP2 reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On OP1 reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On MINUS reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On META reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On LTGT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On LT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On LIDENT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On LET reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On LEMMA reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On LEFTSQ reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On LEFTPAR reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On LEFTBRC reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On LARROW reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On INTEGER reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On INDUCTIVE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On IN reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On IMPORT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On GT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On GOAL reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On FUNCTION reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On FLOAT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On FALSE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On EXCEPTION reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On EQUAL reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On EOF reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On ENSURES reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On END reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On ELSE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On DOWNTO reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On DOTDOT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On DOT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On DONE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On DO reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On DIVERGES reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On CORE_UIDENT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On CORE_LIDENT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On CONSTANT reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On COMMA reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On COLON reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On COINDUCTIVE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On CLONE reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On BEGIN reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On BARBAR reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On BAR reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On AXIOM reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On AMPAMP reduce production expr_block_ -> LEFTPAR RIGHTPAR
-- On ALIAS reduce production expr_block_ -> LEFTPAR RIGHTPAR

State 693:
## Known stack suffix:
## OPPREF
## LR(1) items:
expr_arg_ -> OPPREF . expr_arg [ WRITES VARIANT UIDENT TRUE SEMICOLON RIGHTPAR RETURNS REQUIRES REAL READS RANGE RAISES PURE OPPREF OP4 OP3 OP2 OP1 MINUS LTGT LT LIDENT LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER GT FLOAT FALSE EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COMMA COLON BEGIN BARBAR AMPAMP ALIAS ]
expr_dot_ -> OPPREF . expr_dot [ DOT ]
lident_op_str -> OPPREF . option(UNDERSCORE) [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 6
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On qualid shift to state 744
-- On option(UNDERSCORE) shift to state 7
-- On numeral shift to state 745
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 957
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 958
## Reductions:
-- On RIGHTPAR_USCORE reduce production option(UNDERSCORE) ->
-- On RIGHTPAR_QUOTE reduce production option(UNDERSCORE) ->
-- On RIGHTPAR reduce production option(UNDERSCORE) ->

State 694:
## Known stack suffix:
## LEFTBRC
## LR(1) items:
expr_block_ -> LEFTBRC . field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> LEFTBRC . expr_arg WITH field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_pure_ -> LEFTBRC . qualid RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 740
-- On uident shift to state 302
-- On semicolon_list1(separated_pair(lqualid,EQUAL,expr)) shift to state 670
-- On qualid shift to state 956
-- On numeral shift to state 745
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 748
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 480
-- On ident shift to state 355
-- On field_list1(expr) shift to state 751
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 772
## Reductions:

State 695:
## Known stack suffix:
## FALSE
## LR(1) items:
expr_arg_ -> FALSE . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_arg_ -> FALSE
-- On WITH reduce production expr_arg_ -> FALSE
-- On VARIANT reduce production expr_arg_ -> FALSE
-- On VAL reduce production expr_arg_ -> FALSE
-- On USE reduce production expr_arg_ -> FALSE
-- On UIDENT reduce production expr_arg_ -> FALSE
-- On TYPE reduce production expr_arg_ -> FALSE
-- On TRUE reduce production expr_arg_ -> FALSE
-- On TO reduce production expr_arg_ -> FALSE
-- On THEN reduce production expr_arg_ -> FALSE
-- On SEMICOLON reduce production expr_arg_ -> FALSE
-- On SCOPE reduce production expr_arg_ -> FALSE
-- On RIGHTSQ_QUOTE reduce production expr_arg_ -> FALSE
-- On RIGHTSQ reduce production expr_arg_ -> FALSE
-- On RIGHTPAR reduce production expr_arg_ -> FALSE
-- On RIGHTBRC reduce production expr_arg_ -> FALSE
-- On RETURNS reduce production expr_arg_ -> FALSE
-- On REQUIRES reduce production expr_arg_ -> FALSE
-- On REAL reduce production expr_arg_ -> FALSE
-- On READS reduce production expr_arg_ -> FALSE
-- On RANGE reduce production expr_arg_ -> FALSE
-- On RAISES reduce production expr_arg_ -> FALSE
-- On PURE reduce production expr_arg_ -> FALSE
-- On PREDICATE reduce production expr_arg_ -> FALSE
-- On OPPREF reduce production expr_arg_ -> FALSE
-- On OP4 reduce production expr_arg_ -> FALSE
-- On OP3 reduce production expr_arg_ -> FALSE
-- On OP2 reduce production expr_arg_ -> FALSE
-- On OP1 reduce production expr_arg_ -> FALSE
-- On MINUS reduce production expr_arg_ -> FALSE
-- On META reduce production expr_arg_ -> FALSE
-- On LTGT reduce production expr_arg_ -> FALSE
-- On LT reduce production expr_arg_ -> FALSE
-- On LIDENT reduce production expr_arg_ -> FALSE
-- On LET reduce production expr_arg_ -> FALSE
-- On LEMMA reduce production expr_arg_ -> FALSE
-- On LEFTSQ reduce production expr_arg_ -> FALSE
-- On LEFTPAR reduce production expr_arg_ -> FALSE
-- On LEFTBRC reduce production expr_arg_ -> FALSE
-- On LARROW reduce production expr_arg_ -> FALSE
-- On INTEGER reduce production expr_arg_ -> FALSE
-- On INDUCTIVE reduce production expr_arg_ -> FALSE
-- On IN reduce production expr_arg_ -> FALSE
-- On IMPORT reduce production expr_arg_ -> FALSE
-- On GT reduce production expr_arg_ -> FALSE
-- On GOAL reduce production expr_arg_ -> FALSE
-- On FUNCTION reduce production expr_arg_ -> FALSE
-- On FLOAT reduce production expr_arg_ -> FALSE
-- On FALSE reduce production expr_arg_ -> FALSE
-- On EXCEPTION reduce production expr_arg_ -> FALSE
-- On EQUAL reduce production expr_arg_ -> FALSE
-- On EOF reduce production expr_arg_ -> FALSE
-- On ENSURES reduce production expr_arg_ -> FALSE
-- On END reduce production expr_arg_ -> FALSE
-- On ELSE reduce production expr_arg_ -> FALSE
-- On DOWNTO reduce production expr_arg_ -> FALSE
-- On DOTDOT reduce production expr_arg_ -> FALSE
-- On DONE reduce production expr_arg_ -> FALSE
-- On DO reduce production expr_arg_ -> FALSE
-- On DIVERGES reduce production expr_arg_ -> FALSE
-- On CORE_UIDENT reduce production expr_arg_ -> FALSE
-- On CORE_LIDENT reduce production expr_arg_ -> FALSE
-- On CONSTANT reduce production expr_arg_ -> FALSE
-- On COMMA reduce production expr_arg_ -> FALSE
-- On COLON reduce production expr_arg_ -> FALSE
-- On COINDUCTIVE reduce production expr_arg_ -> FALSE
-- On CLONE reduce production expr_arg_ -> FALSE
-- On BEGIN reduce production expr_arg_ -> FALSE
-- On BARBAR reduce production expr_arg_ -> FALSE
-- On BAR reduce production expr_arg_ -> FALSE
-- On AXIOM reduce production expr_arg_ -> FALSE
-- On AMPAMP reduce production expr_arg_ -> FALSE
-- On ALIAS reduce production expr_arg_ -> FALSE

State 696:
## Known stack suffix:
## BEGIN
## LR(1) items:
expr_block_ -> BEGIN . single_spec spec seq_expr END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> BEGIN . single_spec spec END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> BEGIN . seq_expr END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> BEGIN . END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On WHILE shift to state 673
-- On VARIANT shift to state 493
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURNS shift to state 505
-- On RETURN shift to state 682
-- On REQUIRES shift to state 509
-- On REAL shift to state 200
-- On READS shift to state 513
-- On RANGE shift to state 2
-- On RAISES shift to state 522
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On ENSURES shift to state 547
-- On END shift to state 948
-- On DIVERGES shift to state 552
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ALIAS shift to state 553
-- On ABSURD shift to state 736
-- On variant shift to state 565
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_spec shift to state 949
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 954
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 697:
## Known stack suffix:
## NOT
## LR(1) items:
single_expr_ -> NOT . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 947
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 698:
## Known stack suffix:
## MINUS
## LR(1) items:
prefix_op -> MINUS . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
single_expr_ -> MINUS . INTEGER [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> MINUS . REAL [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On REAL shift to state 699
-- On INTEGER shift to state 700
## Reductions:
-- On WHILE reduce production prefix_op -> MINUS
-- On VAL reduce production prefix_op -> MINUS
-- On UIDENT reduce production prefix_op -> MINUS
-- On TRY reduce production prefix_op -> MINUS
-- On TRUE reduce production prefix_op -> MINUS
-- On RETURN reduce production prefix_op -> MINUS
-- On RANGE reduce production prefix_op -> MINUS
-- On RAISE reduce production prefix_op -> MINUS
-- On PURE reduce production prefix_op -> MINUS
-- On POSITION reduce production prefix_op -> MINUS
-- On OPPREF reduce production prefix_op -> MINUS
-- On OP4 reduce production prefix_op -> MINUS
-- On OP3 reduce production prefix_op -> MINUS
-- On OP2 reduce production prefix_op -> MINUS
-- On OP1 reduce production prefix_op -> MINUS
-- On NOT reduce production prefix_op -> MINUS
-- On MINUS reduce production prefix_op -> MINUS
-- On MATCH reduce production prefix_op -> MINUS
-- On LT reduce production prefix_op -> MINUS
-- On LIDENT reduce production prefix_op -> MINUS
-- On LET reduce production prefix_op -> MINUS
-- On LEFTPAR reduce production prefix_op -> MINUS
-- On LEFTBRC reduce production prefix_op -> MINUS
-- On LABEL reduce production prefix_op -> MINUS
-- On IF reduce production prefix_op -> MINUS
-- On GT reduce production prefix_op -> MINUS
-- On GHOST reduce production prefix_op -> MINUS
-- On FUN reduce production prefix_op -> MINUS
-- On FOR reduce production prefix_op -> MINUS
-- On FLOAT reduce production prefix_op -> MINUS
-- On FALSE reduce production prefix_op -> MINUS
-- On EXCEPTION reduce production prefix_op -> MINUS
-- On CORE_UIDENT reduce production prefix_op -> MINUS
-- On CORE_LIDENT reduce production prefix_op -> MINUS
-- On CONTINUE reduce production prefix_op -> MINUS
-- On CHECK reduce production prefix_op -> MINUS
-- On BREAK reduce production prefix_op -> MINUS
-- On BEGIN reduce production prefix_op -> MINUS
-- On ATTRIBUTE reduce production prefix_op -> MINUS
-- On ASSUME reduce production prefix_op -> MINUS
-- On ASSERT reduce production prefix_op -> MINUS
-- On ANY reduce production prefix_op -> MINUS
-- On ABSURD reduce production prefix_op -> MINUS

State 699:
## Known stack suffix:
## MINUS REAL
## LR(1) items:
single_expr_ -> MINUS REAL . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> MINUS REAL
-- On WITH reduce production single_expr_ -> MINUS REAL
-- On VARIANT reduce production single_expr_ -> MINUS REAL
-- On VAL reduce production single_expr_ -> MINUS REAL
-- On USE reduce production single_expr_ -> MINUS REAL
-- On TYPE reduce production single_expr_ -> MINUS REAL
-- On TO reduce production single_expr_ -> MINUS REAL
-- On THEN reduce production single_expr_ -> MINUS REAL
-- On SEMICOLON reduce production single_expr_ -> MINUS REAL
-- On SCOPE reduce production single_expr_ -> MINUS REAL
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> MINUS REAL
-- On RIGHTSQ reduce production single_expr_ -> MINUS REAL
-- On RIGHTPAR reduce production single_expr_ -> MINUS REAL
-- On RIGHTBRC reduce production single_expr_ -> MINUS REAL
-- On RETURNS reduce production single_expr_ -> MINUS REAL
-- On REQUIRES reduce production single_expr_ -> MINUS REAL
-- On READS reduce production single_expr_ -> MINUS REAL
-- On RAISES reduce production single_expr_ -> MINUS REAL
-- On PREDICATE reduce production single_expr_ -> MINUS REAL
-- On OP4 reduce production single_expr_ -> MINUS REAL
-- On OP3 reduce production single_expr_ -> MINUS REAL
-- On OP2 reduce production single_expr_ -> MINUS REAL
-- On OP1 reduce production single_expr_ -> MINUS REAL
-- On MINUS reduce production single_expr_ -> MINUS REAL
-- On META reduce production single_expr_ -> MINUS REAL
-- On LTGT reduce production single_expr_ -> MINUS REAL
-- On LT reduce production single_expr_ -> MINUS REAL
-- On LET reduce production single_expr_ -> MINUS REAL
-- On LEMMA reduce production single_expr_ -> MINUS REAL
-- On LARROW reduce production single_expr_ -> MINUS REAL
-- On INDUCTIVE reduce production single_expr_ -> MINUS REAL
-- On IN reduce production single_expr_ -> MINUS REAL
-- On IMPORT reduce production single_expr_ -> MINUS REAL
-- On GT reduce production single_expr_ -> MINUS REAL
-- On GOAL reduce production single_expr_ -> MINUS REAL
-- On FUNCTION reduce production single_expr_ -> MINUS REAL
-- On EXCEPTION reduce production single_expr_ -> MINUS REAL
-- On EQUAL reduce production single_expr_ -> MINUS REAL
-- On EOF reduce production single_expr_ -> MINUS REAL
-- On ENSURES reduce production single_expr_ -> MINUS REAL
-- On END reduce production single_expr_ -> MINUS REAL
-- On ELSE reduce production single_expr_ -> MINUS REAL
-- On DOWNTO reduce production single_expr_ -> MINUS REAL
-- On DOTDOT reduce production single_expr_ -> MINUS REAL
-- On DONE reduce production single_expr_ -> MINUS REAL
-- On DO reduce production single_expr_ -> MINUS REAL
-- On DIVERGES reduce production single_expr_ -> MINUS REAL
-- On CONSTANT reduce production single_expr_ -> MINUS REAL
-- On COMMA reduce production single_expr_ -> MINUS REAL
-- On COLON reduce production single_expr_ -> MINUS REAL
-- On COINDUCTIVE reduce production single_expr_ -> MINUS REAL
-- On CLONE reduce production single_expr_ -> MINUS REAL
-- On BARBAR reduce production single_expr_ -> MINUS REAL
-- On BAR reduce production single_expr_ -> MINUS REAL
-- On AXIOM reduce production single_expr_ -> MINUS REAL
-- On AMPAMP reduce production single_expr_ -> MINUS REAL
-- On ALIAS reduce production single_expr_ -> MINUS REAL

State 700:
## Known stack suffix:
## MINUS INTEGER
## LR(1) items:
single_expr_ -> MINUS INTEGER . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> MINUS INTEGER
-- On WITH reduce production single_expr_ -> MINUS INTEGER
-- On VARIANT reduce production single_expr_ -> MINUS INTEGER
-- On VAL reduce production single_expr_ -> MINUS INTEGER
-- On USE reduce production single_expr_ -> MINUS INTEGER
-- On TYPE reduce production single_expr_ -> MINUS INTEGER
-- On TO reduce production single_expr_ -> MINUS INTEGER
-- On THEN reduce production single_expr_ -> MINUS INTEGER
-- On SEMICOLON reduce production single_expr_ -> MINUS INTEGER
-- On SCOPE reduce production single_expr_ -> MINUS INTEGER
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> MINUS INTEGER
-- On RIGHTSQ reduce production single_expr_ -> MINUS INTEGER
-- On RIGHTPAR reduce production single_expr_ -> MINUS INTEGER
-- On RIGHTBRC reduce production single_expr_ -> MINUS INTEGER
-- On RETURNS reduce production single_expr_ -> MINUS INTEGER
-- On REQUIRES reduce production single_expr_ -> MINUS INTEGER
-- On READS reduce production single_expr_ -> MINUS INTEGER
-- On RAISES reduce production single_expr_ -> MINUS INTEGER
-- On PREDICATE reduce production single_expr_ -> MINUS INTEGER
-- On OP4 reduce production single_expr_ -> MINUS INTEGER
-- On OP3 reduce production single_expr_ -> MINUS INTEGER
-- On OP2 reduce production single_expr_ -> MINUS INTEGER
-- On OP1 reduce production single_expr_ -> MINUS INTEGER
-- On MINUS reduce production single_expr_ -> MINUS INTEGER
-- On META reduce production single_expr_ -> MINUS INTEGER
-- On LTGT reduce production single_expr_ -> MINUS INTEGER
-- On LT reduce production single_expr_ -> MINUS INTEGER
-- On LET reduce production single_expr_ -> MINUS INTEGER
-- On LEMMA reduce production single_expr_ -> MINUS INTEGER
-- On LARROW reduce production single_expr_ -> MINUS INTEGER
-- On INDUCTIVE reduce production single_expr_ -> MINUS INTEGER
-- On IN reduce production single_expr_ -> MINUS INTEGER
-- On IMPORT reduce production single_expr_ -> MINUS INTEGER
-- On GT reduce production single_expr_ -> MINUS INTEGER
-- On GOAL reduce production single_expr_ -> MINUS INTEGER
-- On FUNCTION reduce production single_expr_ -> MINUS INTEGER
-- On EXCEPTION reduce production single_expr_ -> MINUS INTEGER
-- On EQUAL reduce production single_expr_ -> MINUS INTEGER
-- On EOF reduce production single_expr_ -> MINUS INTEGER
-- On ENSURES reduce production single_expr_ -> MINUS INTEGER
-- On END reduce production single_expr_ -> MINUS INTEGER
-- On ELSE reduce production single_expr_ -> MINUS INTEGER
-- On DOWNTO reduce production single_expr_ -> MINUS INTEGER
-- On DOTDOT reduce production single_expr_ -> MINUS INTEGER
-- On DONE reduce production single_expr_ -> MINUS INTEGER
-- On DO reduce production single_expr_ -> MINUS INTEGER
-- On DIVERGES reduce production single_expr_ -> MINUS INTEGER
-- On CONSTANT reduce production single_expr_ -> MINUS INTEGER
-- On COMMA reduce production single_expr_ -> MINUS INTEGER
-- On COLON reduce production single_expr_ -> MINUS INTEGER
-- On COINDUCTIVE reduce production single_expr_ -> MINUS INTEGER
-- On CLONE reduce production single_expr_ -> MINUS INTEGER
-- On BARBAR reduce production single_expr_ -> MINUS INTEGER
-- On BAR reduce production single_expr_ -> MINUS INTEGER
-- On AXIOM reduce production single_expr_ -> MINUS INTEGER
-- On AMPAMP reduce production single_expr_ -> MINUS INTEGER
-- On ALIAS reduce production single_expr_ -> MINUS INTEGER

State 701:
## Known stack suffix:
## MATCH
## LR(1) items:
single_expr_ -> MATCH . seq_expr WITH ext_match_cases END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 925
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 702:
## Known stack suffix:
## LET
## LR(1) items:
single_expr_ -> LET . ghost kind let_pattern EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET . ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET . ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET . ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET . REC with_list1(rec_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On REC shift to state 703
-- On GHOST shift to state 53
-- On ghost shift to state 882
## Reductions:
-- On UNDERSCORE reduce production ghost ->
-- On UIDENT reduce production ghost ->
-- On RANGE reduce production ghost ->
-- On PREDICATE reduce production ghost ->
-- On LIDENT reduce production ghost ->
-- On LEMMA reduce production ghost ->
-- On LEFTPAR reduce production ghost ->
-- On LEFTBRC reduce production ghost ->
-- On FUNCTION reduce production ghost ->
-- On FLOAT reduce production ghost ->
-- On CORE_UIDENT reduce production ghost ->
-- On CORE_LIDENT reduce production ghost ->
-- On CONSTANT reduce production ghost ->

State 703:
## Known stack suffix:
## LET REC
## LR(1) items:
single_expr_ -> LET REC . with_list1(rec_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On GHOST shift to state 53
-- On with_list1(rec_defn) shift to state 704
-- On separated_nonempty_list(WITH,rec_defn) shift to state 869
-- On rec_defn shift to state 870
-- On ghost shift to state 873
## Reductions:
-- On RANGE reduce production ghost ->
-- On PREDICATE reduce production ghost ->
-- On LIDENT reduce production ghost ->
-- On LEMMA reduce production ghost ->
-- On LEFTPAR reduce production ghost ->
-- On FUNCTION reduce production ghost ->
-- On FLOAT reduce production ghost ->
-- On CORE_LIDENT reduce production ghost ->
-- On CONSTANT reduce production ghost ->

State 704:
## Known stack suffix:
## LET REC with_list1(rec_defn)
## LR(1) items:
single_expr_ -> LET REC with_list1(rec_defn) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 705
## Reductions:

State 705:
## Known stack suffix:
## LET REC with_list1(rec_defn) IN
## LR(1) items:
single_expr_ -> LET REC with_list1(rec_defn) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 868
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 706:
## Known stack suffix:
## LABEL
## LR(1) items:
single_expr_ -> LABEL . attrs(uident) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 707
-- On attrs(uident) shift to state 709
## Reductions:

State 707:
## Known stack suffix:
## uident
## LR(1) items:
attrs(uident) -> uident . list(attr) [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC IN GHOST FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 708
-- On attr shift to state 71
## Reductions:
-- On UIDENT reduce production list(attr) ->
-- On RANGE reduce production list(attr) ->
-- On QUOTE_LIDENT reduce production list(attr) ->
-- On LIDENT reduce production list(attr) ->
-- On LEFTPAR reduce production list(attr) ->
-- On LEFTBRC reduce production list(attr) ->
-- On IN reduce production list(attr) ->
-- On GHOST reduce production list(attr) ->
-- On FLOAT reduce production list(attr) ->
-- On CORE_UIDENT reduce production list(attr) ->
-- On CORE_LIDENT reduce production list(attr) ->

State 708:
## Known stack suffix:
## uident list(attr)
## LR(1) items:
attrs(uident) -> uident list(attr) . [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC IN GHOST FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UIDENT reduce production attrs(uident) -> uident list(attr)
-- On RANGE reduce production attrs(uident) -> uident list(attr)
-- On QUOTE_LIDENT reduce production attrs(uident) -> uident list(attr)
-- On LIDENT reduce production attrs(uident) -> uident list(attr)
-- On LEFTPAR reduce production attrs(uident) -> uident list(attr)
-- On LEFTBRC reduce production attrs(uident) -> uident list(attr)
-- On IN reduce production attrs(uident) -> uident list(attr)
-- On GHOST reduce production attrs(uident) -> uident list(attr)
-- On FLOAT reduce production attrs(uident) -> uident list(attr)
-- On CORE_UIDENT reduce production attrs(uident) -> uident list(attr)
-- On CORE_LIDENT reduce production attrs(uident) -> uident list(attr)

State 709:
## Known stack suffix:
## LABEL attrs(uident)
## LR(1) items:
single_expr_ -> LABEL attrs(uident) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 710
## Reductions:

State 710:
## Known stack suffix:
## LABEL attrs(uident) IN
## LR(1) items:
single_expr_ -> LABEL attrs(uident) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 867
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 711:
## Known stack suffix:
## IF
## LR(1) items:
single_expr_ -> IF . seq_expr THEN contract_expr ELSE contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> IF . seq_expr THEN contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 862
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 712:
## Known stack suffix:
## GHOST
## LR(1) items:
single_expr_ -> GHOST . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 861
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 713:
## Known stack suffix:
## FUN
## LR(1) items:
single_expr_ -> FUN . binders spec ARROW spec seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On binders shift to state 714
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:

State 714:
## Known stack suffix:
## FUN binders
## LR(1) items:
single_expr_ -> FUN binders . spec ARROW spec seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 715
-- On single_spec shift to state 567
## Reductions:
-- On ARROW reduce production spec ->

State 715:
## Known stack suffix:
## FUN binders spec
## LR(1) items:
single_expr_ -> FUN binders spec . ARROW spec seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On ARROW shift to state 716
## Reductions:

State 716:
## Known stack suffix:
## FUN binders spec ARROW
## LR(1) items:
single_expr_ -> FUN binders spec ARROW . spec seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 717
-- On single_spec shift to state 567
## Reductions:
-- On WHILE reduce production spec ->
-- On VAL reduce production spec ->
-- On UIDENT reduce production spec ->
-- On TRY reduce production spec ->
-- On TRUE reduce production spec ->
-- On RETURN reduce production spec ->
-- On REAL reduce production spec ->
-- On RANGE reduce production spec ->
-- On RAISE reduce production spec ->
-- On PURE reduce production spec ->
-- On POSITION reduce production spec ->
-- On OPPREF reduce production spec ->
-- On OP4 reduce production spec ->
-- On OP3 reduce production spec ->
-- On OP2 reduce production spec ->
-- On OP1 reduce production spec ->
-- On NOT reduce production spec ->
-- On MINUS reduce production spec ->
-- On MATCH reduce production spec ->
-- On LT reduce production spec ->
-- On LIDENT reduce production spec ->
-- On LET reduce production spec ->
-- On LEFTPAR reduce production spec ->
-- On LEFTBRC reduce production spec ->
-- On LABEL reduce production spec ->
-- On INTEGER reduce production spec ->
-- On IF reduce production spec ->
-- On GT reduce production spec ->
-- On GHOST reduce production spec ->
-- On FUN reduce production spec ->
-- On FOR reduce production spec ->
-- On FLOAT reduce production spec ->
-- On FALSE reduce production spec ->
-- On EXCEPTION reduce production spec ->
-- On CORE_UIDENT reduce production spec ->
-- On CORE_LIDENT reduce production spec ->
-- On CONTINUE reduce production spec ->
-- On CHECK reduce production spec ->
-- On BREAK reduce production spec ->
-- On BEGIN reduce production spec ->
-- On ATTRIBUTE reduce production spec ->
-- On ASSUME reduce production spec ->
-- On ASSERT reduce production spec ->
-- On ANY reduce production spec ->
-- On ABSURD reduce production spec ->

State 717:
## Known stack suffix:
## FUN binders spec ARROW spec
## LR(1) items:
single_expr_ -> FUN binders spec ARROW spec . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 860
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 718:
## Known stack suffix:
## FOR
## LR(1) items:
single_expr_ -> FOR . lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_nq shift to state 719
-- On lident_keyword shift to state 75
## Reductions:

State 719:
## Known stack suffix:
## FOR lident_nq
## LR(1) items:
single_expr_ -> FOR lident_nq . EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On EQUAL shift to state 720
## Reductions:

State 720:
## Known stack suffix:
## FOR lident_nq EQUAL
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL . seq_expr for_direction seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 848
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 721:
## Known stack suffix:
## EXCEPTION
## LR(1) items:
single_expr_ -> EXCEPTION . attrs(uident) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> EXCEPTION . attrs(uident) return IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 707
-- On attrs(uident) shift to state 722
## Reductions:

State 722:
## Known stack suffix:
## EXCEPTION attrs(uident)
## LR(1) items:
single_expr_ -> EXCEPTION attrs(uident) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> EXCEPTION attrs(uident) . return IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 723
-- On LEFTBRC shift to state 83
-- On IN shift to state 725
-- On GHOST shift to state 191
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 193
-- On return shift to state 845
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 723:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
return -> LEFTPAR . GHOST ty RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
return -> LEFTPAR . ret_ghost RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
ty_block -> LEFTPAR . comma_list2(ty) RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ARROW ]
ty_block -> LEFTPAR . RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ARROW ]
ty_block -> LEFTPAR . ty RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ARROW ]
## Transitions:
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 81
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 724
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 169
-- On ret_ghost shift to state 178
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list2(ty) shift to state 111
## Reductions:

State 724:
## Known stack suffix:
## LEFTPAR GHOST
## LR(1) items:
ret_ghost -> GHOST . ty COMMA ret_rest [ RIGHTPAR ]
return -> LEFTPAR GHOST . ty RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 154
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 725:
## Known stack suffix:
## EXCEPTION attrs(uident) IN
## LR(1) items:
single_expr_ -> EXCEPTION attrs(uident) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 835
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 726:
## Known stack suffix:
## CONTINUE
## LR(1) items:
single_expr_ -> CONTINUE . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> CONTINUE . uident [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 727
## Reductions:
-- On WRITES reduce production single_expr_ -> CONTINUE
-- On WITH reduce production single_expr_ -> CONTINUE
-- On VARIANT reduce production single_expr_ -> CONTINUE
-- On VAL reduce production single_expr_ -> CONTINUE
-- On USE reduce production single_expr_ -> CONTINUE
-- On TYPE reduce production single_expr_ -> CONTINUE
-- On TO reduce production single_expr_ -> CONTINUE
-- On THEN reduce production single_expr_ -> CONTINUE
-- On SEMICOLON reduce production single_expr_ -> CONTINUE
-- On SCOPE reduce production single_expr_ -> CONTINUE
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> CONTINUE
-- On RIGHTSQ reduce production single_expr_ -> CONTINUE
-- On RIGHTPAR reduce production single_expr_ -> CONTINUE
-- On RIGHTBRC reduce production single_expr_ -> CONTINUE
-- On RETURNS reduce production single_expr_ -> CONTINUE
-- On REQUIRES reduce production single_expr_ -> CONTINUE
-- On READS reduce production single_expr_ -> CONTINUE
-- On RAISES reduce production single_expr_ -> CONTINUE
-- On PREDICATE reduce production single_expr_ -> CONTINUE
-- On OP4 reduce production single_expr_ -> CONTINUE
-- On OP3 reduce production single_expr_ -> CONTINUE
-- On OP2 reduce production single_expr_ -> CONTINUE
-- On OP1 reduce production single_expr_ -> CONTINUE
-- On MINUS reduce production single_expr_ -> CONTINUE
-- On META reduce production single_expr_ -> CONTINUE
-- On LTGT reduce production single_expr_ -> CONTINUE
-- On LT reduce production single_expr_ -> CONTINUE
-- On LET reduce production single_expr_ -> CONTINUE
-- On LEMMA reduce production single_expr_ -> CONTINUE
-- On LARROW reduce production single_expr_ -> CONTINUE
-- On INDUCTIVE reduce production single_expr_ -> CONTINUE
-- On IN reduce production single_expr_ -> CONTINUE
-- On IMPORT reduce production single_expr_ -> CONTINUE
-- On GT reduce production single_expr_ -> CONTINUE
-- On GOAL reduce production single_expr_ -> CONTINUE
-- On FUNCTION reduce production single_expr_ -> CONTINUE
-- On EXCEPTION reduce production single_expr_ -> CONTINUE
-- On EQUAL reduce production single_expr_ -> CONTINUE
-- On EOF reduce production single_expr_ -> CONTINUE
-- On ENSURES reduce production single_expr_ -> CONTINUE
-- On END reduce production single_expr_ -> CONTINUE
-- On ELSE reduce production single_expr_ -> CONTINUE
-- On DOWNTO reduce production single_expr_ -> CONTINUE
-- On DOTDOT reduce production single_expr_ -> CONTINUE
-- On DONE reduce production single_expr_ -> CONTINUE
-- On DO reduce production single_expr_ -> CONTINUE
-- On DIVERGES reduce production single_expr_ -> CONTINUE
-- On CONSTANT reduce production single_expr_ -> CONTINUE
-- On COMMA reduce production single_expr_ -> CONTINUE
-- On COLON reduce production single_expr_ -> CONTINUE
-- On COINDUCTIVE reduce production single_expr_ -> CONTINUE
-- On CLONE reduce production single_expr_ -> CONTINUE
-- On BARBAR reduce production single_expr_ -> CONTINUE
-- On BAR reduce production single_expr_ -> CONTINUE
-- On AXIOM reduce production single_expr_ -> CONTINUE
-- On AMPAMP reduce production single_expr_ -> CONTINUE
-- On ALIAS reduce production single_expr_ -> CONTINUE

State 727:
## Known stack suffix:
## CONTINUE uident
## LR(1) items:
single_expr_ -> CONTINUE uident . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> CONTINUE uident
-- On WITH reduce production single_expr_ -> CONTINUE uident
-- On VARIANT reduce production single_expr_ -> CONTINUE uident
-- On VAL reduce production single_expr_ -> CONTINUE uident
-- On USE reduce production single_expr_ -> CONTINUE uident
-- On TYPE reduce production single_expr_ -> CONTINUE uident
-- On TO reduce production single_expr_ -> CONTINUE uident
-- On THEN reduce production single_expr_ -> CONTINUE uident
-- On SEMICOLON reduce production single_expr_ -> CONTINUE uident
-- On SCOPE reduce production single_expr_ -> CONTINUE uident
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> CONTINUE uident
-- On RIGHTSQ reduce production single_expr_ -> CONTINUE uident
-- On RIGHTPAR reduce production single_expr_ -> CONTINUE uident
-- On RIGHTBRC reduce production single_expr_ -> CONTINUE uident
-- On RETURNS reduce production single_expr_ -> CONTINUE uident
-- On REQUIRES reduce production single_expr_ -> CONTINUE uident
-- On READS reduce production single_expr_ -> CONTINUE uident
-- On RAISES reduce production single_expr_ -> CONTINUE uident
-- On PREDICATE reduce production single_expr_ -> CONTINUE uident
-- On OP4 reduce production single_expr_ -> CONTINUE uident
-- On OP3 reduce production single_expr_ -> CONTINUE uident
-- On OP2 reduce production single_expr_ -> CONTINUE uident
-- On OP1 reduce production single_expr_ -> CONTINUE uident
-- On MINUS reduce production single_expr_ -> CONTINUE uident
-- On META reduce production single_expr_ -> CONTINUE uident
-- On LTGT reduce production single_expr_ -> CONTINUE uident
-- On LT reduce production single_expr_ -> CONTINUE uident
-- On LET reduce production single_expr_ -> CONTINUE uident
-- On LEMMA reduce production single_expr_ -> CONTINUE uident
-- On LARROW reduce production single_expr_ -> CONTINUE uident
-- On INDUCTIVE reduce production single_expr_ -> CONTINUE uident
-- On IN reduce production single_expr_ -> CONTINUE uident
-- On IMPORT reduce production single_expr_ -> CONTINUE uident
-- On GT reduce production single_expr_ -> CONTINUE uident
-- On GOAL reduce production single_expr_ -> CONTINUE uident
-- On FUNCTION reduce production single_expr_ -> CONTINUE uident
-- On EXCEPTION reduce production single_expr_ -> CONTINUE uident
-- On EQUAL reduce production single_expr_ -> CONTINUE uident
-- On EOF reduce production single_expr_ -> CONTINUE uident
-- On ENSURES reduce production single_expr_ -> CONTINUE uident
-- On END reduce production single_expr_ -> CONTINUE uident
-- On ELSE reduce production single_expr_ -> CONTINUE uident
-- On DOWNTO reduce production single_expr_ -> CONTINUE uident
-- On DOTDOT reduce production single_expr_ -> CONTINUE uident
-- On DONE reduce production single_expr_ -> CONTINUE uident
-- On DO reduce production single_expr_ -> CONTINUE uident
-- On DIVERGES reduce production single_expr_ -> CONTINUE uident
-- On CONSTANT reduce production single_expr_ -> CONTINUE uident
-- On COMMA reduce production single_expr_ -> CONTINUE uident
-- On COLON reduce production single_expr_ -> CONTINUE uident
-- On COINDUCTIVE reduce production single_expr_ -> CONTINUE uident
-- On CLONE reduce production single_expr_ -> CONTINUE uident
-- On BARBAR reduce production single_expr_ -> CONTINUE uident
-- On BAR reduce production single_expr_ -> CONTINUE uident
-- On AXIOM reduce production single_expr_ -> CONTINUE uident
-- On AMPAMP reduce production single_expr_ -> CONTINUE uident
-- On ALIAS reduce production single_expr_ -> CONTINUE uident

State 728:
## Known stack suffix:
## CHECK
## LR(1) items:
assertion_kind -> CHECK . [ LEFTBRC ]
## Transitions:
## Reductions:
-- On LEFTBRC reduce production assertion_kind -> CHECK

State 729:
## Known stack suffix:
## BREAK
## LR(1) items:
single_expr_ -> BREAK . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> BREAK . uident [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 730
## Reductions:
-- On WRITES reduce production single_expr_ -> BREAK
-- On WITH reduce production single_expr_ -> BREAK
-- On VARIANT reduce production single_expr_ -> BREAK
-- On VAL reduce production single_expr_ -> BREAK
-- On USE reduce production single_expr_ -> BREAK
-- On TYPE reduce production single_expr_ -> BREAK
-- On TO reduce production single_expr_ -> BREAK
-- On THEN reduce production single_expr_ -> BREAK
-- On SEMICOLON reduce production single_expr_ -> BREAK
-- On SCOPE reduce production single_expr_ -> BREAK
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> BREAK
-- On RIGHTSQ reduce production single_expr_ -> BREAK
-- On RIGHTPAR reduce production single_expr_ -> BREAK
-- On RIGHTBRC reduce production single_expr_ -> BREAK
-- On RETURNS reduce production single_expr_ -> BREAK
-- On REQUIRES reduce production single_expr_ -> BREAK
-- On READS reduce production single_expr_ -> BREAK
-- On RAISES reduce production single_expr_ -> BREAK
-- On PREDICATE reduce production single_expr_ -> BREAK
-- On OP4 reduce production single_expr_ -> BREAK
-- On OP3 reduce production single_expr_ -> BREAK
-- On OP2 reduce production single_expr_ -> BREAK
-- On OP1 reduce production single_expr_ -> BREAK
-- On MINUS reduce production single_expr_ -> BREAK
-- On META reduce production single_expr_ -> BREAK
-- On LTGT reduce production single_expr_ -> BREAK
-- On LT reduce production single_expr_ -> BREAK
-- On LET reduce production single_expr_ -> BREAK
-- On LEMMA reduce production single_expr_ -> BREAK
-- On LARROW reduce production single_expr_ -> BREAK
-- On INDUCTIVE reduce production single_expr_ -> BREAK
-- On IN reduce production single_expr_ -> BREAK
-- On IMPORT reduce production single_expr_ -> BREAK
-- On GT reduce production single_expr_ -> BREAK
-- On GOAL reduce production single_expr_ -> BREAK
-- On FUNCTION reduce production single_expr_ -> BREAK
-- On EXCEPTION reduce production single_expr_ -> BREAK
-- On EQUAL reduce production single_expr_ -> BREAK
-- On EOF reduce production single_expr_ -> BREAK
-- On ENSURES reduce production single_expr_ -> BREAK
-- On END reduce production single_expr_ -> BREAK
-- On ELSE reduce production single_expr_ -> BREAK
-- On DOWNTO reduce production single_expr_ -> BREAK
-- On DOTDOT reduce production single_expr_ -> BREAK
-- On DONE reduce production single_expr_ -> BREAK
-- On DO reduce production single_expr_ -> BREAK
-- On DIVERGES reduce production single_expr_ -> BREAK
-- On CONSTANT reduce production single_expr_ -> BREAK
-- On COMMA reduce production single_expr_ -> BREAK
-- On COLON reduce production single_expr_ -> BREAK
-- On COINDUCTIVE reduce production single_expr_ -> BREAK
-- On CLONE reduce production single_expr_ -> BREAK
-- On BARBAR reduce production single_expr_ -> BREAK
-- On BAR reduce production single_expr_ -> BREAK
-- On AXIOM reduce production single_expr_ -> BREAK
-- On AMPAMP reduce production single_expr_ -> BREAK
-- On ALIAS reduce production single_expr_ -> BREAK

State 730:
## Known stack suffix:
## BREAK uident
## LR(1) items:
single_expr_ -> BREAK uident . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> BREAK uident
-- On WITH reduce production single_expr_ -> BREAK uident
-- On VARIANT reduce production single_expr_ -> BREAK uident
-- On VAL reduce production single_expr_ -> BREAK uident
-- On USE reduce production single_expr_ -> BREAK uident
-- On TYPE reduce production single_expr_ -> BREAK uident
-- On TO reduce production single_expr_ -> BREAK uident
-- On THEN reduce production single_expr_ -> BREAK uident
-- On SEMICOLON reduce production single_expr_ -> BREAK uident
-- On SCOPE reduce production single_expr_ -> BREAK uident
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> BREAK uident
-- On RIGHTSQ reduce production single_expr_ -> BREAK uident
-- On RIGHTPAR reduce production single_expr_ -> BREAK uident
-- On RIGHTBRC reduce production single_expr_ -> BREAK uident
-- On RETURNS reduce production single_expr_ -> BREAK uident
-- On REQUIRES reduce production single_expr_ -> BREAK uident
-- On READS reduce production single_expr_ -> BREAK uident
-- On RAISES reduce production single_expr_ -> BREAK uident
-- On PREDICATE reduce production single_expr_ -> BREAK uident
-- On OP4 reduce production single_expr_ -> BREAK uident
-- On OP3 reduce production single_expr_ -> BREAK uident
-- On OP2 reduce production single_expr_ -> BREAK uident
-- On OP1 reduce production single_expr_ -> BREAK uident
-- On MINUS reduce production single_expr_ -> BREAK uident
-- On META reduce production single_expr_ -> BREAK uident
-- On LTGT reduce production single_expr_ -> BREAK uident
-- On LT reduce production single_expr_ -> BREAK uident
-- On LET reduce production single_expr_ -> BREAK uident
-- On LEMMA reduce production single_expr_ -> BREAK uident
-- On LARROW reduce production single_expr_ -> BREAK uident
-- On INDUCTIVE reduce production single_expr_ -> BREAK uident
-- On IN reduce production single_expr_ -> BREAK uident
-- On IMPORT reduce production single_expr_ -> BREAK uident
-- On GT reduce production single_expr_ -> BREAK uident
-- On GOAL reduce production single_expr_ -> BREAK uident
-- On FUNCTION reduce production single_expr_ -> BREAK uident
-- On EXCEPTION reduce production single_expr_ -> BREAK uident
-- On EQUAL reduce production single_expr_ -> BREAK uident
-- On EOF reduce production single_expr_ -> BREAK uident
-- On ENSURES reduce production single_expr_ -> BREAK uident
-- On END reduce production single_expr_ -> BREAK uident
-- On ELSE reduce production single_expr_ -> BREAK uident
-- On DOWNTO reduce production single_expr_ -> BREAK uident
-- On DOTDOT reduce production single_expr_ -> BREAK uident
-- On DONE reduce production single_expr_ -> BREAK uident
-- On DO reduce production single_expr_ -> BREAK uident
-- On DIVERGES reduce production single_expr_ -> BREAK uident
-- On CONSTANT reduce production single_expr_ -> BREAK uident
-- On COMMA reduce production single_expr_ -> BREAK uident
-- On COLON reduce production single_expr_ -> BREAK uident
-- On COINDUCTIVE reduce production single_expr_ -> BREAK uident
-- On CLONE reduce production single_expr_ -> BREAK uident
-- On BARBAR reduce production single_expr_ -> BREAK uident
-- On BAR reduce production single_expr_ -> BREAK uident
-- On AXIOM reduce production single_expr_ -> BREAK uident
-- On AMPAMP reduce production single_expr_ -> BREAK uident
-- On ALIAS reduce production single_expr_ -> BREAK uident

State 731:
## Known stack suffix:
## ASSUME
## LR(1) items:
assertion_kind -> ASSUME . [ LEFTBRC ]
## Transitions:
## Reductions:
-- On LEFTBRC reduce production assertion_kind -> ASSUME

State 732:
## Known stack suffix:
## ASSERT
## LR(1) items:
assertion_kind -> ASSERT . [ LEFTBRC ]
## Transitions:
## Reductions:
-- On LEFTBRC reduce production assertion_kind -> ASSERT

State 733:
## Known stack suffix:
## ANY
## LR(1) items:
single_expr_ -> ANY . return_named spec [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 149
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 191
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 193
-- On return_named shift to state 734
-- On return shift to state 195
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 734:
## Known stack suffix:
## ANY return_named
## LR(1) items:
single_expr_ -> ANY return_named . spec [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 735
-- On single_spec shift to state 567
## Reductions:
-- On WITH reduce production spec ->
-- On VAL reduce production spec ->
-- On USE reduce production spec ->
-- On TYPE reduce production spec ->
-- On TO reduce production spec ->
-- On THEN reduce production spec ->
-- On SEMICOLON reduce production spec ->
-- On SCOPE reduce production spec ->
-- On RIGHTSQ_QUOTE reduce production spec ->
-- On RIGHTSQ reduce production spec ->
-- On RIGHTPAR reduce production spec ->
-- On RIGHTBRC reduce production spec ->
-- On PREDICATE reduce production spec ->
-- On OP4 reduce production spec ->
-- On OP3 reduce production spec ->
-- On OP2 reduce production spec ->
-- On OP1 reduce production spec ->
-- On MINUS reduce production spec ->
-- On META reduce production spec ->
-- On LTGT reduce production spec ->
-- On LT reduce production spec ->
-- On LET reduce production spec ->
-- On LEMMA reduce production spec ->
-- On LARROW reduce production spec ->
-- On INDUCTIVE reduce production spec ->
-- On IN reduce production spec ->
-- On IMPORT reduce production spec ->
-- On GT reduce production spec ->
-- On GOAL reduce production spec ->
-- On FUNCTION reduce production spec ->
-- On EXCEPTION reduce production spec ->
-- On EQUAL reduce production spec ->
-- On EOF reduce production spec ->
-- On END reduce production spec ->
-- On ELSE reduce production spec ->
-- On DOWNTO reduce production spec ->
-- On DOTDOT reduce production spec ->
-- On DONE reduce production spec ->
-- On DO reduce production spec ->
-- On CONSTANT reduce production spec ->
-- On COMMA reduce production spec ->
-- On COLON reduce production spec ->
-- On COINDUCTIVE reduce production spec ->
-- On CLONE reduce production spec ->
-- On BARBAR reduce production spec ->
-- On BAR reduce production spec ->
-- On AXIOM reduce production spec ->
-- On AMPAMP reduce production spec ->

State 735:
## Known stack suffix:
## ANY return_named spec
## LR(1) items:
single_expr_ -> ANY return_named spec . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> ANY return_named spec
-- On WITH reduce production single_expr_ -> ANY return_named spec
-- On VARIANT reduce production single_expr_ -> ANY return_named spec
-- On VAL reduce production single_expr_ -> ANY return_named spec
-- On USE reduce production single_expr_ -> ANY return_named spec
-- On TYPE reduce production single_expr_ -> ANY return_named spec
-- On TO reduce production single_expr_ -> ANY return_named spec
-- On THEN reduce production single_expr_ -> ANY return_named spec
-- On SEMICOLON reduce production single_expr_ -> ANY return_named spec
-- On SCOPE reduce production single_expr_ -> ANY return_named spec
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> ANY return_named spec
-- On RIGHTSQ reduce production single_expr_ -> ANY return_named spec
-- On RIGHTPAR reduce production single_expr_ -> ANY return_named spec
-- On RIGHTBRC reduce production single_expr_ -> ANY return_named spec
-- On RETURNS reduce production single_expr_ -> ANY return_named spec
-- On REQUIRES reduce production single_expr_ -> ANY return_named spec
-- On READS reduce production single_expr_ -> ANY return_named spec
-- On RAISES reduce production single_expr_ -> ANY return_named spec
-- On PREDICATE reduce production single_expr_ -> ANY return_named spec
-- On OP4 reduce production single_expr_ -> ANY return_named spec
-- On OP3 reduce production single_expr_ -> ANY return_named spec
-- On OP2 reduce production single_expr_ -> ANY return_named spec
-- On OP1 reduce production single_expr_ -> ANY return_named spec
-- On MINUS reduce production single_expr_ -> ANY return_named spec
-- On META reduce production single_expr_ -> ANY return_named spec
-- On LTGT reduce production single_expr_ -> ANY return_named spec
-- On LT reduce production single_expr_ -> ANY return_named spec
-- On LET reduce production single_expr_ -> ANY return_named spec
-- On LEMMA reduce production single_expr_ -> ANY return_named spec
-- On LARROW reduce production single_expr_ -> ANY return_named spec
-- On INDUCTIVE reduce production single_expr_ -> ANY return_named spec
-- On IN reduce production single_expr_ -> ANY return_named spec
-- On IMPORT reduce production single_expr_ -> ANY return_named spec
-- On GT reduce production single_expr_ -> ANY return_named spec
-- On GOAL reduce production single_expr_ -> ANY return_named spec
-- On FUNCTION reduce production single_expr_ -> ANY return_named spec
-- On EXCEPTION reduce production single_expr_ -> ANY return_named spec
-- On EQUAL reduce production single_expr_ -> ANY return_named spec
-- On EOF reduce production single_expr_ -> ANY return_named spec
-- On ENSURES reduce production single_expr_ -> ANY return_named spec
-- On END reduce production single_expr_ -> ANY return_named spec
-- On ELSE reduce production single_expr_ -> ANY return_named spec
-- On DOWNTO reduce production single_expr_ -> ANY return_named spec
-- On DOTDOT reduce production single_expr_ -> ANY return_named spec
-- On DONE reduce production single_expr_ -> ANY return_named spec
-- On DO reduce production single_expr_ -> ANY return_named spec
-- On DIVERGES reduce production single_expr_ -> ANY return_named spec
-- On CONSTANT reduce production single_expr_ -> ANY return_named spec
-- On COMMA reduce production single_expr_ -> ANY return_named spec
-- On COLON reduce production single_expr_ -> ANY return_named spec
-- On COINDUCTIVE reduce production single_expr_ -> ANY return_named spec
-- On CLONE reduce production single_expr_ -> ANY return_named spec
-- On BARBAR reduce production single_expr_ -> ANY return_named spec
-- On BAR reduce production single_expr_ -> ANY return_named spec
-- On AXIOM reduce production single_expr_ -> ANY return_named spec
-- On AMPAMP reduce production single_expr_ -> ANY return_named spec
-- On ALIAS reduce production single_expr_ -> ANY return_named spec

State 736:
## Known stack suffix:
## ABSURD
## LR(1) items:
single_expr_ -> ABSURD . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> ABSURD
-- On WITH reduce production single_expr_ -> ABSURD
-- On VARIANT reduce production single_expr_ -> ABSURD
-- On VAL reduce production single_expr_ -> ABSURD
-- On USE reduce production single_expr_ -> ABSURD
-- On TYPE reduce production single_expr_ -> ABSURD
-- On TO reduce production single_expr_ -> ABSURD
-- On THEN reduce production single_expr_ -> ABSURD
-- On SEMICOLON reduce production single_expr_ -> ABSURD
-- On SCOPE reduce production single_expr_ -> ABSURD
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> ABSURD
-- On RIGHTSQ reduce production single_expr_ -> ABSURD
-- On RIGHTPAR reduce production single_expr_ -> ABSURD
-- On RIGHTBRC reduce production single_expr_ -> ABSURD
-- On RETURNS reduce production single_expr_ -> ABSURD
-- On REQUIRES reduce production single_expr_ -> ABSURD
-- On READS reduce production single_expr_ -> ABSURD
-- On RAISES reduce production single_expr_ -> ABSURD
-- On PREDICATE reduce production single_expr_ -> ABSURD
-- On OP4 reduce production single_expr_ -> ABSURD
-- On OP3 reduce production single_expr_ -> ABSURD
-- On OP2 reduce production single_expr_ -> ABSURD
-- On OP1 reduce production single_expr_ -> ABSURD
-- On MINUS reduce production single_expr_ -> ABSURD
-- On META reduce production single_expr_ -> ABSURD
-- On LTGT reduce production single_expr_ -> ABSURD
-- On LT reduce production single_expr_ -> ABSURD
-- On LET reduce production single_expr_ -> ABSURD
-- On LEMMA reduce production single_expr_ -> ABSURD
-- On LARROW reduce production single_expr_ -> ABSURD
-- On INDUCTIVE reduce production single_expr_ -> ABSURD
-- On IN reduce production single_expr_ -> ABSURD
-- On IMPORT reduce production single_expr_ -> ABSURD
-- On GT reduce production single_expr_ -> ABSURD
-- On GOAL reduce production single_expr_ -> ABSURD
-- On FUNCTION reduce production single_expr_ -> ABSURD
-- On EXCEPTION reduce production single_expr_ -> ABSURD
-- On EQUAL reduce production single_expr_ -> ABSURD
-- On EOF reduce production single_expr_ -> ABSURD
-- On ENSURES reduce production single_expr_ -> ABSURD
-- On END reduce production single_expr_ -> ABSURD
-- On ELSE reduce production single_expr_ -> ABSURD
-- On DOWNTO reduce production single_expr_ -> ABSURD
-- On DOTDOT reduce production single_expr_ -> ABSURD
-- On DONE reduce production single_expr_ -> ABSURD
-- On DO reduce production single_expr_ -> ABSURD
-- On DIVERGES reduce production single_expr_ -> ABSURD
-- On CONSTANT reduce production single_expr_ -> ABSURD
-- On COMMA reduce production single_expr_ -> ABSURD
-- On COLON reduce production single_expr_ -> ABSURD
-- On COINDUCTIVE reduce production single_expr_ -> ABSURD
-- On CLONE reduce production single_expr_ -> ABSURD
-- On BARBAR reduce production single_expr_ -> ABSURD
-- On BAR reduce production single_expr_ -> ABSURD
-- On AXIOM reduce production single_expr_ -> ABSURD
-- On AMPAMP reduce production single_expr_ -> ABSURD
-- On ALIAS reduce production single_expr_ -> ABSURD

State 737:
## Known stack suffix:
## uqualid
## LR(1) items:
expr_pure_ -> uqualid . DOT LEFTBRC ident RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> uqualid . DOT mk_expr(expr_block_) [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lqualid -> uqualid . DOT lident [ DOT ]
qualid -> uqualid . DOT ident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 738
## Reductions:

State 738:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
expr_pure_ -> uqualid DOT . LEFTBRC ident RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> uqualid DOT . mk_expr(expr_block_) [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lqualid -> uqualid DOT . lident [ DOT ]
qualid -> uqualid DOT . ident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 739
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uident shift to state 297
-- On mk_expr(expr_block_) shift to state 742
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 300
-- On ident shift to state 301
-- On expr_block_ shift to state 743
## Reductions:

State 739:
## Known stack suffix:
## uqualid DOT LEFTBRC
## LR(1) items:
expr_block_ -> LEFTBRC . field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> LEFTBRC . expr_arg WITH field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_pure_ -> uqualid DOT LEFTBRC . ident RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 740
-- On uident shift to state 302
-- On semicolon_list1(separated_pair(lqualid,EQUAL,expr)) shift to state 670
-- On qualid shift to state 744
-- On numeral shift to state 745
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 748
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 480
-- On ident shift to state 749
-- On field_list1(expr) shift to state 751
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 772
## Reductions:

State 740:
## Known stack suffix:
## uqualid
## LR(1) items:
expr_pure_ -> uqualid . DOT LEFTBRC ident RIGHTBRC [ WITH LEFTSQ DOT ]
expr_sub_ -> uqualid . DOT mk_expr(expr_block_) [ WITH LEFTSQ DOT ]
lqualid -> uqualid . DOT lident [ EQUAL DOT ]
qualid -> uqualid . DOT ident [ WITH RIGHTBRC LEFTSQ ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 741
## Reductions:

State 741:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
expr_pure_ -> uqualid DOT . LEFTBRC ident RIGHTBRC [ WITH LEFTSQ DOT ]
expr_sub_ -> uqualid DOT . mk_expr(expr_block_) [ WITH LEFTSQ DOT ]
lqualid -> uqualid DOT . lident [ EQUAL DOT ]
qualid -> uqualid DOT . ident [ WITH RIGHTBRC LEFTSQ ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 739
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uident shift to state 297
-- On mk_expr(expr_block_) shift to state 742
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 468
-- On ident shift to state 301
-- On expr_block_ shift to state 743
## Reductions:

State 742:
## Known stack suffix:
## uqualid DOT mk_expr(expr_block_)
## LR(1) items:
expr_sub_ -> uqualid DOT mk_expr(expr_block_) . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On WITH reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On VARIANT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On VAL reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On USE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On UIDENT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On TYPE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On TRUE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On TO reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On THEN reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On SEMICOLON reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On SCOPE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On RIGHTSQ_QUOTE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On RIGHTSQ reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On RIGHTPAR reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On RIGHTBRC reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On RETURNS reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On REQUIRES reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On REAL reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On READS reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On RANGE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On RAISES reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On PURE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On PREDICATE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On OPPREF reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On OP4 reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On OP3 reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On OP2 reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On OP1 reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On MINUS reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On META reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On LTGT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On LT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On LIDENT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On LET reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On LEMMA reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On LEFTSQ reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On LEFTPAR reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On LEFTBRC reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On LARROW reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On INTEGER reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On INDUCTIVE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On IN reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On IMPORT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On GT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On GOAL reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On FUNCTION reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On FLOAT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On FALSE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On EXCEPTION reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On EQUAL reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On EOF reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On ENSURES reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On END reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On ELSE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On DOWNTO reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On DOTDOT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On DOT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On DONE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On DO reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On DIVERGES reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On CORE_UIDENT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On CORE_LIDENT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On CONSTANT reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On COMMA reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On COLON reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On COINDUCTIVE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On CLONE reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On BEGIN reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On BARBAR reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On BAR reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On AXIOM reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On AMPAMP reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)
-- On ALIAS reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)

State 743:
## Known stack suffix:
## expr_block_
## LR(1) items:
mk_expr(expr_block_) -> expr_block_ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production mk_expr(expr_block_) -> expr_block_
-- On WITH reduce production mk_expr(expr_block_) -> expr_block_
-- On VARIANT reduce production mk_expr(expr_block_) -> expr_block_
-- On VAL reduce production mk_expr(expr_block_) -> expr_block_
-- On USE reduce production mk_expr(expr_block_) -> expr_block_
-- On UIDENT reduce production mk_expr(expr_block_) -> expr_block_
-- On TYPE reduce production mk_expr(expr_block_) -> expr_block_
-- On TRUE reduce production mk_expr(expr_block_) -> expr_block_
-- On TO reduce production mk_expr(expr_block_) -> expr_block_
-- On THEN reduce production mk_expr(expr_block_) -> expr_block_
-- On SEMICOLON reduce production mk_expr(expr_block_) -> expr_block_
-- On SCOPE reduce production mk_expr(expr_block_) -> expr_block_
-- On RIGHTSQ_QUOTE reduce production mk_expr(expr_block_) -> expr_block_
-- On RIGHTSQ reduce production mk_expr(expr_block_) -> expr_block_
-- On RIGHTPAR reduce production mk_expr(expr_block_) -> expr_block_
-- On RIGHTBRC reduce production mk_expr(expr_block_) -> expr_block_
-- On RETURNS reduce production mk_expr(expr_block_) -> expr_block_
-- On REQUIRES reduce production mk_expr(expr_block_) -> expr_block_
-- On REAL reduce production mk_expr(expr_block_) -> expr_block_
-- On READS reduce production mk_expr(expr_block_) -> expr_block_
-- On RANGE reduce production mk_expr(expr_block_) -> expr_block_
-- On RAISES reduce production mk_expr(expr_block_) -> expr_block_
-- On PURE reduce production mk_expr(expr_block_) -> expr_block_
-- On PREDICATE reduce production mk_expr(expr_block_) -> expr_block_
-- On OPPREF reduce production mk_expr(expr_block_) -> expr_block_
-- On OP4 reduce production mk_expr(expr_block_) -> expr_block_
-- On OP3 reduce production mk_expr(expr_block_) -> expr_block_
-- On OP2 reduce production mk_expr(expr_block_) -> expr_block_
-- On OP1 reduce production mk_expr(expr_block_) -> expr_block_
-- On MINUS reduce production mk_expr(expr_block_) -> expr_block_
-- On META reduce production mk_expr(expr_block_) -> expr_block_
-- On LTGT reduce production mk_expr(expr_block_) -> expr_block_
-- On LT reduce production mk_expr(expr_block_) -> expr_block_
-- On LIDENT reduce production mk_expr(expr_block_) -> expr_block_
-- On LET reduce production mk_expr(expr_block_) -> expr_block_
-- On LEMMA reduce production mk_expr(expr_block_) -> expr_block_
-- On LEFTSQ reduce production mk_expr(expr_block_) -> expr_block_
-- On LEFTPAR reduce production mk_expr(expr_block_) -> expr_block_
-- On LEFTBRC reduce production mk_expr(expr_block_) -> expr_block_
-- On LARROW reduce production mk_expr(expr_block_) -> expr_block_
-- On INTEGER reduce production mk_expr(expr_block_) -> expr_block_
-- On INDUCTIVE reduce production mk_expr(expr_block_) -> expr_block_
-- On IN reduce production mk_expr(expr_block_) -> expr_block_
-- On IMPORT reduce production mk_expr(expr_block_) -> expr_block_
-- On GT reduce production mk_expr(expr_block_) -> expr_block_
-- On GOAL reduce production mk_expr(expr_block_) -> expr_block_
-- On FUNCTION reduce production mk_expr(expr_block_) -> expr_block_
-- On FLOAT reduce production mk_expr(expr_block_) -> expr_block_
-- On FALSE reduce production mk_expr(expr_block_) -> expr_block_
-- On EXCEPTION reduce production mk_expr(expr_block_) -> expr_block_
-- On EQUAL reduce production mk_expr(expr_block_) -> expr_block_
-- On EOF reduce production mk_expr(expr_block_) -> expr_block_
-- On ENSURES reduce production mk_expr(expr_block_) -> expr_block_
-- On END reduce production mk_expr(expr_block_) -> expr_block_
-- On ELSE reduce production mk_expr(expr_block_) -> expr_block_
-- On DOWNTO reduce production mk_expr(expr_block_) -> expr_block_
-- On DOTDOT reduce production mk_expr(expr_block_) -> expr_block_
-- On DOT reduce production mk_expr(expr_block_) -> expr_block_
-- On DONE reduce production mk_expr(expr_block_) -> expr_block_
-- On DO reduce production mk_expr(expr_block_) -> expr_block_
-- On DIVERGES reduce production mk_expr(expr_block_) -> expr_block_
-- On CORE_UIDENT reduce production mk_expr(expr_block_) -> expr_block_
-- On CORE_LIDENT reduce production mk_expr(expr_block_) -> expr_block_
-- On CONSTANT reduce production mk_expr(expr_block_) -> expr_block_
-- On COMMA reduce production mk_expr(expr_block_) -> expr_block_
-- On COLON reduce production mk_expr(expr_block_) -> expr_block_
-- On COINDUCTIVE reduce production mk_expr(expr_block_) -> expr_block_
-- On CLONE reduce production mk_expr(expr_block_) -> expr_block_
-- On BEGIN reduce production mk_expr(expr_block_) -> expr_block_
-- On BARBAR reduce production mk_expr(expr_block_) -> expr_block_
-- On BAR reduce production mk_expr(expr_block_) -> expr_block_
-- On AXIOM reduce production mk_expr(expr_block_) -> expr_block_
-- On AMPAMP reduce production mk_expr(expr_block_) -> expr_block_
-- On ALIAS reduce production mk_expr(expr_block_) -> expr_block_

State 744:
## Known stack suffix:
## qualid
## LR(1) items:
expr_arg_ -> qualid . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_arg_ -> qualid
-- On WITH reduce production expr_arg_ -> qualid
-- On VARIANT reduce production expr_arg_ -> qualid
-- On VAL reduce production expr_arg_ -> qualid
-- On USE reduce production expr_arg_ -> qualid
-- On UIDENT reduce production expr_arg_ -> qualid
-- On TYPE reduce production expr_arg_ -> qualid
-- On TRUE reduce production expr_arg_ -> qualid
-- On TO reduce production expr_arg_ -> qualid
-- On THEN reduce production expr_arg_ -> qualid
-- On SEMICOLON reduce production expr_arg_ -> qualid
-- On SCOPE reduce production expr_arg_ -> qualid
-- On RIGHTSQ_QUOTE reduce production expr_arg_ -> qualid
-- On RIGHTSQ reduce production expr_arg_ -> qualid
-- On RIGHTPAR reduce production expr_arg_ -> qualid
-- On RIGHTBRC reduce production expr_arg_ -> qualid
-- On RETURNS reduce production expr_arg_ -> qualid
-- On REQUIRES reduce production expr_arg_ -> qualid
-- On REAL reduce production expr_arg_ -> qualid
-- On READS reduce production expr_arg_ -> qualid
-- On RANGE reduce production expr_arg_ -> qualid
-- On RAISES reduce production expr_arg_ -> qualid
-- On PURE reduce production expr_arg_ -> qualid
-- On PREDICATE reduce production expr_arg_ -> qualid
-- On OPPREF reduce production expr_arg_ -> qualid
-- On OP4 reduce production expr_arg_ -> qualid
-- On OP3 reduce production expr_arg_ -> qualid
-- On OP2 reduce production expr_arg_ -> qualid
-- On OP1 reduce production expr_arg_ -> qualid
-- On MINUS reduce production expr_arg_ -> qualid
-- On META reduce production expr_arg_ -> qualid
-- On LTGT reduce production expr_arg_ -> qualid
-- On LT reduce production expr_arg_ -> qualid
-- On LIDENT reduce production expr_arg_ -> qualid
-- On LET reduce production expr_arg_ -> qualid
-- On LEMMA reduce production expr_arg_ -> qualid
-- On LEFTSQ reduce production expr_arg_ -> qualid
-- On LEFTPAR reduce production expr_arg_ -> qualid
-- On LEFTBRC reduce production expr_arg_ -> qualid
-- On LARROW reduce production expr_arg_ -> qualid
-- On INTEGER reduce production expr_arg_ -> qualid
-- On INDUCTIVE reduce production expr_arg_ -> qualid
-- On IN reduce production expr_arg_ -> qualid
-- On IMPORT reduce production expr_arg_ -> qualid
-- On GT reduce production expr_arg_ -> qualid
-- On GOAL reduce production expr_arg_ -> qualid
-- On FUNCTION reduce production expr_arg_ -> qualid
-- On FLOAT reduce production expr_arg_ -> qualid
-- On FALSE reduce production expr_arg_ -> qualid
-- On EXCEPTION reduce production expr_arg_ -> qualid
-- On EQUAL reduce production expr_arg_ -> qualid
-- On EOF reduce production expr_arg_ -> qualid
-- On ENSURES reduce production expr_arg_ -> qualid
-- On END reduce production expr_arg_ -> qualid
-- On ELSE reduce production expr_arg_ -> qualid
-- On DOWNTO reduce production expr_arg_ -> qualid
-- On DOTDOT reduce production expr_arg_ -> qualid
-- On DONE reduce production expr_arg_ -> qualid
-- On DO reduce production expr_arg_ -> qualid
-- On DIVERGES reduce production expr_arg_ -> qualid
-- On CORE_UIDENT reduce production expr_arg_ -> qualid
-- On CORE_LIDENT reduce production expr_arg_ -> qualid
-- On CONSTANT reduce production expr_arg_ -> qualid
-- On COMMA reduce production expr_arg_ -> qualid
-- On COLON reduce production expr_arg_ -> qualid
-- On COINDUCTIVE reduce production expr_arg_ -> qualid
-- On CLONE reduce production expr_arg_ -> qualid
-- On BEGIN reduce production expr_arg_ -> qualid
-- On BARBAR reduce production expr_arg_ -> qualid
-- On BAR reduce production expr_arg_ -> qualid
-- On AXIOM reduce production expr_arg_ -> qualid
-- On AMPAMP reduce production expr_arg_ -> qualid
-- On ALIAS reduce production expr_arg_ -> qualid

State 745:
## Known stack suffix:
## numeral
## LR(1) items:
expr_arg_ -> numeral . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_arg_ -> numeral
-- On WITH reduce production expr_arg_ -> numeral
-- On VARIANT reduce production expr_arg_ -> numeral
-- On VAL reduce production expr_arg_ -> numeral
-- On USE reduce production expr_arg_ -> numeral
-- On UIDENT reduce production expr_arg_ -> numeral
-- On TYPE reduce production expr_arg_ -> numeral
-- On TRUE reduce production expr_arg_ -> numeral
-- On TO reduce production expr_arg_ -> numeral
-- On THEN reduce production expr_arg_ -> numeral
-- On SEMICOLON reduce production expr_arg_ -> numeral
-- On SCOPE reduce production expr_arg_ -> numeral
-- On RIGHTSQ_QUOTE reduce production expr_arg_ -> numeral
-- On RIGHTSQ reduce production expr_arg_ -> numeral
-- On RIGHTPAR reduce production expr_arg_ -> numeral
-- On RIGHTBRC reduce production expr_arg_ -> numeral
-- On RETURNS reduce production expr_arg_ -> numeral
-- On REQUIRES reduce production expr_arg_ -> numeral
-- On REAL reduce production expr_arg_ -> numeral
-- On READS reduce production expr_arg_ -> numeral
-- On RANGE reduce production expr_arg_ -> numeral
-- On RAISES reduce production expr_arg_ -> numeral
-- On PURE reduce production expr_arg_ -> numeral
-- On PREDICATE reduce production expr_arg_ -> numeral
-- On OPPREF reduce production expr_arg_ -> numeral
-- On OP4 reduce production expr_arg_ -> numeral
-- On OP3 reduce production expr_arg_ -> numeral
-- On OP2 reduce production expr_arg_ -> numeral
-- On OP1 reduce production expr_arg_ -> numeral
-- On MINUS reduce production expr_arg_ -> numeral
-- On META reduce production expr_arg_ -> numeral
-- On LTGT reduce production expr_arg_ -> numeral
-- On LT reduce production expr_arg_ -> numeral
-- On LIDENT reduce production expr_arg_ -> numeral
-- On LET reduce production expr_arg_ -> numeral
-- On LEMMA reduce production expr_arg_ -> numeral
-- On LEFTSQ reduce production expr_arg_ -> numeral
-- On LEFTPAR reduce production expr_arg_ -> numeral
-- On LEFTBRC reduce production expr_arg_ -> numeral
-- On LARROW reduce production expr_arg_ -> numeral
-- On INTEGER reduce production expr_arg_ -> numeral
-- On INDUCTIVE reduce production expr_arg_ -> numeral
-- On IN reduce production expr_arg_ -> numeral
-- On IMPORT reduce production expr_arg_ -> numeral
-- On GT reduce production expr_arg_ -> numeral
-- On GOAL reduce production expr_arg_ -> numeral
-- On FUNCTION reduce production expr_arg_ -> numeral
-- On FLOAT reduce production expr_arg_ -> numeral
-- On FALSE reduce production expr_arg_ -> numeral
-- On EXCEPTION reduce production expr_arg_ -> numeral
-- On EQUAL reduce production expr_arg_ -> numeral
-- On EOF reduce production expr_arg_ -> numeral
-- On ENSURES reduce production expr_arg_ -> numeral
-- On END reduce production expr_arg_ -> numeral
-- On ELSE reduce production expr_arg_ -> numeral
-- On DOWNTO reduce production expr_arg_ -> numeral
-- On DOTDOT reduce production expr_arg_ -> numeral
-- On DONE reduce production expr_arg_ -> numeral
-- On DO reduce production expr_arg_ -> numeral
-- On DIVERGES reduce production expr_arg_ -> numeral
-- On CORE_UIDENT reduce production expr_arg_ -> numeral
-- On CORE_LIDENT reduce production expr_arg_ -> numeral
-- On CONSTANT reduce production expr_arg_ -> numeral
-- On COMMA reduce production expr_arg_ -> numeral
-- On COLON reduce production expr_arg_ -> numeral
-- On COINDUCTIVE reduce production expr_arg_ -> numeral
-- On CLONE reduce production expr_arg_ -> numeral
-- On BEGIN reduce production expr_arg_ -> numeral
-- On BARBAR reduce production expr_arg_ -> numeral
-- On BAR reduce production expr_arg_ -> numeral
-- On AXIOM reduce production expr_arg_ -> numeral
-- On AMPAMP reduce production expr_arg_ -> numeral
-- On ALIAS reduce production expr_arg_ -> numeral

State 746:
## Known stack suffix:
## mk_expr(expr_dot_)
## LR(1) items:
expr_dot -> mk_expr(expr_dot_) . [ DOT ]
## Transitions:
## Reductions:
-- On DOT reduce production expr_dot -> mk_expr(expr_dot_)

State 747:
## Known stack suffix:
## mk_expr(expr_arg_)
## LR(1) items:
expr_arg -> mk_expr(expr_arg_) . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_arg -> mk_expr(expr_arg_)
-- On WITH reduce production expr_arg -> mk_expr(expr_arg_)
-- On VARIANT reduce production expr_arg -> mk_expr(expr_arg_)
-- On VAL reduce production expr_arg -> mk_expr(expr_arg_)
-- On USE reduce production expr_arg -> mk_expr(expr_arg_)
-- On UIDENT reduce production expr_arg -> mk_expr(expr_arg_)
-- On TYPE reduce production expr_arg -> mk_expr(expr_arg_)
-- On TRUE reduce production expr_arg -> mk_expr(expr_arg_)
-- On TO reduce production expr_arg -> mk_expr(expr_arg_)
-- On THEN reduce production expr_arg -> mk_expr(expr_arg_)
-- On SEMICOLON reduce production expr_arg -> mk_expr(expr_arg_)
-- On SCOPE reduce production expr_arg -> mk_expr(expr_arg_)
-- On RIGHTSQ_QUOTE reduce production expr_arg -> mk_expr(expr_arg_)
-- On RIGHTSQ reduce production expr_arg -> mk_expr(expr_arg_)
-- On RIGHTPAR reduce production expr_arg -> mk_expr(expr_arg_)
-- On RIGHTBRC reduce production expr_arg -> mk_expr(expr_arg_)
-- On RETURNS reduce production expr_arg -> mk_expr(expr_arg_)
-- On REQUIRES reduce production expr_arg -> mk_expr(expr_arg_)
-- On REAL reduce production expr_arg -> mk_expr(expr_arg_)
-- On READS reduce production expr_arg -> mk_expr(expr_arg_)
-- On RANGE reduce production expr_arg -> mk_expr(expr_arg_)
-- On RAISES reduce production expr_arg -> mk_expr(expr_arg_)
-- On PURE reduce production expr_arg -> mk_expr(expr_arg_)
-- On PREDICATE reduce production expr_arg -> mk_expr(expr_arg_)
-- On OPPREF reduce production expr_arg -> mk_expr(expr_arg_)
-- On OP4 reduce production expr_arg -> mk_expr(expr_arg_)
-- On OP3 reduce production expr_arg -> mk_expr(expr_arg_)
-- On OP2 reduce production expr_arg -> mk_expr(expr_arg_)
-- On OP1 reduce production expr_arg -> mk_expr(expr_arg_)
-- On MINUS reduce production expr_arg -> mk_expr(expr_arg_)
-- On META reduce production expr_arg -> mk_expr(expr_arg_)
-- On LTGT reduce production expr_arg -> mk_expr(expr_arg_)
-- On LT reduce production expr_arg -> mk_expr(expr_arg_)
-- On LIDENT reduce production expr_arg -> mk_expr(expr_arg_)
-- On LET reduce production expr_arg -> mk_expr(expr_arg_)
-- On LEMMA reduce production expr_arg -> mk_expr(expr_arg_)
-- On LEFTSQ reduce production expr_arg -> mk_expr(expr_arg_)
-- On LEFTPAR reduce production expr_arg -> mk_expr(expr_arg_)
-- On LEFTBRC reduce production expr_arg -> mk_expr(expr_arg_)
-- On LARROW reduce production expr_arg -> mk_expr(expr_arg_)
-- On INTEGER reduce production expr_arg -> mk_expr(expr_arg_)
-- On INDUCTIVE reduce production expr_arg -> mk_expr(expr_arg_)
-- On IN reduce production expr_arg -> mk_expr(expr_arg_)
-- On IMPORT reduce production expr_arg -> mk_expr(expr_arg_)
-- On GT reduce production expr_arg -> mk_expr(expr_arg_)
-- On GOAL reduce production expr_arg -> mk_expr(expr_arg_)
-- On FUNCTION reduce production expr_arg -> mk_expr(expr_arg_)
-- On FLOAT reduce production expr_arg -> mk_expr(expr_arg_)
-- On FALSE reduce production expr_arg -> mk_expr(expr_arg_)
-- On EXCEPTION reduce production expr_arg -> mk_expr(expr_arg_)
-- On EQUAL reduce production expr_arg -> mk_expr(expr_arg_)
-- On EOF reduce production expr_arg -> mk_expr(expr_arg_)
-- On ENSURES reduce production expr_arg -> mk_expr(expr_arg_)
-- On END reduce production expr_arg -> mk_expr(expr_arg_)
-- On ELSE reduce production expr_arg -> mk_expr(expr_arg_)
-- On DOWNTO reduce production expr_arg -> mk_expr(expr_arg_)
-- On DOTDOT reduce production expr_arg -> mk_expr(expr_arg_)
-- On DONE reduce production expr_arg -> mk_expr(expr_arg_)
-- On DO reduce production expr_arg -> mk_expr(expr_arg_)
-- On DIVERGES reduce production expr_arg -> mk_expr(expr_arg_)
-- On CORE_UIDENT reduce production expr_arg -> mk_expr(expr_arg_)
-- On CORE_LIDENT reduce production expr_arg -> mk_expr(expr_arg_)
-- On CONSTANT reduce production expr_arg -> mk_expr(expr_arg_)
-- On COMMA reduce production expr_arg -> mk_expr(expr_arg_)
-- On COLON reduce production expr_arg -> mk_expr(expr_arg_)
-- On COINDUCTIVE reduce production expr_arg -> mk_expr(expr_arg_)
-- On CLONE reduce production expr_arg -> mk_expr(expr_arg_)
-- On BEGIN reduce production expr_arg -> mk_expr(expr_arg_)
-- On BARBAR reduce production expr_arg -> mk_expr(expr_arg_)
-- On BAR reduce production expr_arg -> mk_expr(expr_arg_)
-- On AXIOM reduce production expr_arg -> mk_expr(expr_arg_)
-- On AMPAMP reduce production expr_arg -> mk_expr(expr_arg_)
-- On ALIAS reduce production expr_arg -> mk_expr(expr_arg_)

State 748:
## Known stack suffix:
## lqualid
## LR(1) items:
expr_dot_ -> lqualid . [ DOT ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
## Transitions:
-- On EQUAL shift to state 672
## Reductions:
-- On DOT reduce production expr_dot_ -> lqualid

State 749:
## Known stack suffix:
## uqualid DOT LEFTBRC ident
## LR(1) items:
expr_pure_ -> uqualid DOT LEFTBRC ident . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
qualid -> ident . [ WITH LEFTSQ ]
## Transitions:
-- On RIGHTBRC shift to state 750
## Reductions:
-- On WITH reduce production qualid -> ident
-- On LEFTSQ reduce production qualid -> ident

State 750:
## Known stack suffix:
## uqualid DOT LEFTBRC ident RIGHTBRC
## LR(1) items:
expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On WITH reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On VARIANT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On VAL reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On USE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On UIDENT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On TYPE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On TRUE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On TO reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On THEN reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On SEMICOLON reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On SCOPE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On RIGHTSQ reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On RIGHTPAR reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On RIGHTBRC reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On RETURNS reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On REQUIRES reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On REAL reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On READS reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On RANGE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On RAISES reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On PURE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On PREDICATE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On OPPREF reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On OP4 reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On OP3 reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On OP2 reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On OP1 reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On MINUS reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On META reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On LTGT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On LT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On LIDENT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On LET reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On LEMMA reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On LEFTSQ reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On LEFTPAR reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On LEFTBRC reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On LARROW reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On INTEGER reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On INDUCTIVE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On IN reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On IMPORT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On GT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On GOAL reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On FUNCTION reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On FLOAT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On FALSE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On EXCEPTION reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On EQUAL reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On EOF reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On ENSURES reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On END reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On ELSE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On DOWNTO reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On DOTDOT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On DOT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On DONE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On DO reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On DIVERGES reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On CORE_UIDENT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On CORE_LIDENT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On CONSTANT reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On COMMA reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On COLON reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On COINDUCTIVE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On CLONE reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On BEGIN reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On BARBAR reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On BAR reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On AXIOM reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On AMPAMP reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC
-- On ALIAS reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC

State 751:
## Known stack suffix:
## LEFTBRC field_list1(expr)
## LR(1) items:
expr_block_ -> LEFTBRC field_list1(expr) . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 752
## Reductions:

State 752:
## Known stack suffix:
## LEFTBRC field_list1(expr) RIGHTBRC
## LR(1) items:
expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On WITH reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On VARIANT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On VAL reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On USE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On UIDENT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On TYPE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On TRUE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On TO reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On THEN reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On SEMICOLON reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On SCOPE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On RIGHTSQ reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On RIGHTPAR reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On RIGHTBRC reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On RETURNS reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On REQUIRES reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On REAL reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On READS reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On RANGE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On RAISES reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On PURE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On PREDICATE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On OPPREF reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On OP4 reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On OP3 reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On OP2 reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On OP1 reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On MINUS reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On META reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On LTGT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On LT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On LIDENT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On LET reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On LEMMA reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On LEFTSQ reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On LEFTPAR reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On LEFTBRC reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On LARROW reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On INTEGER reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On INDUCTIVE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On IN reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On IMPORT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On GT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On GOAL reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On FUNCTION reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On FLOAT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On FALSE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On EXCEPTION reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On EQUAL reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On EOF reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On ENSURES reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On END reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On ELSE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On DOWNTO reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On DOTDOT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On DOT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On DONE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On DO reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On DIVERGES reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On CORE_UIDENT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On CORE_LIDENT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On CONSTANT reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On COMMA reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On COLON reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On COINDUCTIVE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On CLONE reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On BEGIN reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On BARBAR reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On BAR reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On AXIOM reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On AMPAMP reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC
-- On ALIAS reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC

State 753:
## Known stack suffix:
## expr_sub_
## LR(1) items:
expr_arg_ -> expr_sub_ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_dot_ -> expr_sub_ . [ DOT ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_arg_ -> expr_sub_
-- On WITH reduce production expr_arg_ -> expr_sub_
-- On VARIANT reduce production expr_arg_ -> expr_sub_
-- On VAL reduce production expr_arg_ -> expr_sub_
-- On USE reduce production expr_arg_ -> expr_sub_
-- On UIDENT reduce production expr_arg_ -> expr_sub_
-- On TYPE reduce production expr_arg_ -> expr_sub_
-- On TRUE reduce production expr_arg_ -> expr_sub_
-- On TO reduce production expr_arg_ -> expr_sub_
-- On THEN reduce production expr_arg_ -> expr_sub_
-- On SEMICOLON reduce production expr_arg_ -> expr_sub_
-- On SCOPE reduce production expr_arg_ -> expr_sub_
-- On RIGHTSQ_QUOTE reduce production expr_arg_ -> expr_sub_
-- On RIGHTSQ reduce production expr_arg_ -> expr_sub_
-- On RIGHTPAR reduce production expr_arg_ -> expr_sub_
-- On RIGHTBRC reduce production expr_arg_ -> expr_sub_
-- On RETURNS reduce production expr_arg_ -> expr_sub_
-- On REQUIRES reduce production expr_arg_ -> expr_sub_
-- On REAL reduce production expr_arg_ -> expr_sub_
-- On READS reduce production expr_arg_ -> expr_sub_
-- On RANGE reduce production expr_arg_ -> expr_sub_
-- On RAISES reduce production expr_arg_ -> expr_sub_
-- On PURE reduce production expr_arg_ -> expr_sub_
-- On PREDICATE reduce production expr_arg_ -> expr_sub_
-- On OPPREF reduce production expr_arg_ -> expr_sub_
-- On OP4 reduce production expr_arg_ -> expr_sub_
-- On OP3 reduce production expr_arg_ -> expr_sub_
-- On OP2 reduce production expr_arg_ -> expr_sub_
-- On OP1 reduce production expr_arg_ -> expr_sub_
-- On MINUS reduce production expr_arg_ -> expr_sub_
-- On META reduce production expr_arg_ -> expr_sub_
-- On LTGT reduce production expr_arg_ -> expr_sub_
-- On LT reduce production expr_arg_ -> expr_sub_
-- On LIDENT reduce production expr_arg_ -> expr_sub_
-- On LET reduce production expr_arg_ -> expr_sub_
-- On LEMMA reduce production expr_arg_ -> expr_sub_
-- On LEFTSQ reduce production expr_arg_ -> expr_sub_
-- On LEFTPAR reduce production expr_arg_ -> expr_sub_
-- On LEFTBRC reduce production expr_arg_ -> expr_sub_
-- On LARROW reduce production expr_arg_ -> expr_sub_
-- On INTEGER reduce production expr_arg_ -> expr_sub_
-- On INDUCTIVE reduce production expr_arg_ -> expr_sub_
-- On IN reduce production expr_arg_ -> expr_sub_
-- On IMPORT reduce production expr_arg_ -> expr_sub_
-- On GT reduce production expr_arg_ -> expr_sub_
-- On GOAL reduce production expr_arg_ -> expr_sub_
-- On FUNCTION reduce production expr_arg_ -> expr_sub_
-- On FLOAT reduce production expr_arg_ -> expr_sub_
-- On FALSE reduce production expr_arg_ -> expr_sub_
-- On EXCEPTION reduce production expr_arg_ -> expr_sub_
-- On EQUAL reduce production expr_arg_ -> expr_sub_
-- On EOF reduce production expr_arg_ -> expr_sub_
-- On ENSURES reduce production expr_arg_ -> expr_sub_
-- On END reduce production expr_arg_ -> expr_sub_
-- On ELSE reduce production expr_arg_ -> expr_sub_
-- On DOWNTO reduce production expr_arg_ -> expr_sub_
-- On DOTDOT reduce production expr_arg_ -> expr_sub_
-- On DOT reduce production expr_dot_ -> expr_sub_
-- On DONE reduce production expr_arg_ -> expr_sub_
-- On DO reduce production expr_arg_ -> expr_sub_
-- On DIVERGES reduce production expr_arg_ -> expr_sub_
-- On CORE_UIDENT reduce production expr_arg_ -> expr_sub_
-- On CORE_LIDENT reduce production expr_arg_ -> expr_sub_
-- On CONSTANT reduce production expr_arg_ -> expr_sub_
-- On COMMA reduce production expr_arg_ -> expr_sub_
-- On COLON reduce production expr_arg_ -> expr_sub_
-- On COINDUCTIVE reduce production expr_arg_ -> expr_sub_
-- On CLONE reduce production expr_arg_ -> expr_sub_
-- On BEGIN reduce production expr_arg_ -> expr_sub_
-- On BARBAR reduce production expr_arg_ -> expr_sub_
-- On BAR reduce production expr_arg_ -> expr_sub_
-- On AXIOM reduce production expr_arg_ -> expr_sub_
-- On AMPAMP reduce production expr_arg_ -> expr_sub_
-- On ALIAS reduce production expr_arg_ -> expr_sub_

State 754:
## Known stack suffix:
## expr_pure_
## LR(1) items:
expr_sub_ -> expr_pure_ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_sub_ -> expr_pure_
-- On WITH reduce production expr_sub_ -> expr_pure_
-- On VARIANT reduce production expr_sub_ -> expr_pure_
-- On VAL reduce production expr_sub_ -> expr_pure_
-- On USE reduce production expr_sub_ -> expr_pure_
-- On UIDENT reduce production expr_sub_ -> expr_pure_
-- On TYPE reduce production expr_sub_ -> expr_pure_
-- On TRUE reduce production expr_sub_ -> expr_pure_
-- On TO reduce production expr_sub_ -> expr_pure_
-- On THEN reduce production expr_sub_ -> expr_pure_
-- On SEMICOLON reduce production expr_sub_ -> expr_pure_
-- On SCOPE reduce production expr_sub_ -> expr_pure_
-- On RIGHTSQ_QUOTE reduce production expr_sub_ -> expr_pure_
-- On RIGHTSQ reduce production expr_sub_ -> expr_pure_
-- On RIGHTPAR reduce production expr_sub_ -> expr_pure_
-- On RIGHTBRC reduce production expr_sub_ -> expr_pure_
-- On RETURNS reduce production expr_sub_ -> expr_pure_
-- On REQUIRES reduce production expr_sub_ -> expr_pure_
-- On REAL reduce production expr_sub_ -> expr_pure_
-- On READS reduce production expr_sub_ -> expr_pure_
-- On RANGE reduce production expr_sub_ -> expr_pure_
-- On RAISES reduce production expr_sub_ -> expr_pure_
-- On PURE reduce production expr_sub_ -> expr_pure_
-- On PREDICATE reduce production expr_sub_ -> expr_pure_
-- On OPPREF reduce production expr_sub_ -> expr_pure_
-- On OP4 reduce production expr_sub_ -> expr_pure_
-- On OP3 reduce production expr_sub_ -> expr_pure_
-- On OP2 reduce production expr_sub_ -> expr_pure_
-- On OP1 reduce production expr_sub_ -> expr_pure_
-- On MINUS reduce production expr_sub_ -> expr_pure_
-- On META reduce production expr_sub_ -> expr_pure_
-- On LTGT reduce production expr_sub_ -> expr_pure_
-- On LT reduce production expr_sub_ -> expr_pure_
-- On LIDENT reduce production expr_sub_ -> expr_pure_
-- On LET reduce production expr_sub_ -> expr_pure_
-- On LEMMA reduce production expr_sub_ -> expr_pure_
-- On LEFTSQ reduce production expr_sub_ -> expr_pure_
-- On LEFTPAR reduce production expr_sub_ -> expr_pure_
-- On LEFTBRC reduce production expr_sub_ -> expr_pure_
-- On LARROW reduce production expr_sub_ -> expr_pure_
-- On INTEGER reduce production expr_sub_ -> expr_pure_
-- On INDUCTIVE reduce production expr_sub_ -> expr_pure_
-- On IN reduce production expr_sub_ -> expr_pure_
-- On IMPORT reduce production expr_sub_ -> expr_pure_
-- On GT reduce production expr_sub_ -> expr_pure_
-- On GOAL reduce production expr_sub_ -> expr_pure_
-- On FUNCTION reduce production expr_sub_ -> expr_pure_
-- On FLOAT reduce production expr_sub_ -> expr_pure_
-- On FALSE reduce production expr_sub_ -> expr_pure_
-- On EXCEPTION reduce production expr_sub_ -> expr_pure_
-- On EQUAL reduce production expr_sub_ -> expr_pure_
-- On EOF reduce production expr_sub_ -> expr_pure_
-- On ENSURES reduce production expr_sub_ -> expr_pure_
-- On END reduce production expr_sub_ -> expr_pure_
-- On ELSE reduce production expr_sub_ -> expr_pure_
-- On DOWNTO reduce production expr_sub_ -> expr_pure_
-- On DOTDOT reduce production expr_sub_ -> expr_pure_
-- On DOT reduce production expr_sub_ -> expr_pure_
-- On DONE reduce production expr_sub_ -> expr_pure_
-- On DO reduce production expr_sub_ -> expr_pure_
-- On DIVERGES reduce production expr_sub_ -> expr_pure_
-- On CORE_UIDENT reduce production expr_sub_ -> expr_pure_
-- On CORE_LIDENT reduce production expr_sub_ -> expr_pure_
-- On CONSTANT reduce production expr_sub_ -> expr_pure_
-- On COMMA reduce production expr_sub_ -> expr_pure_
-- On COLON reduce production expr_sub_ -> expr_pure_
-- On COINDUCTIVE reduce production expr_sub_ -> expr_pure_
-- On CLONE reduce production expr_sub_ -> expr_pure_
-- On BEGIN reduce production expr_sub_ -> expr_pure_
-- On BARBAR reduce production expr_sub_ -> expr_pure_
-- On BAR reduce production expr_sub_ -> expr_pure_
-- On AXIOM reduce production expr_sub_ -> expr_pure_
-- On AMPAMP reduce production expr_sub_ -> expr_pure_
-- On ALIAS reduce production expr_sub_ -> expr_pure_

State 755:
## Known stack suffix:
## expr_dot_
## LR(1) items:
mk_expr(expr_dot_) -> expr_dot_ . [ DOT ]
## Transitions:
## Reductions:
-- On DOT reduce production mk_expr(expr_dot_) -> expr_dot_

State 756:
## Known stack suffix:
## expr_dot
## LR(1) items:
expr_sub_ -> expr_dot . DOT mk_expr(expr_pure_) [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_dot . DOT lqualid_rich [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On DOT shift to state 757
## Reductions:

State 757:
## Known stack suffix:
## expr_dot DOT
## LR(1) items:
expr_sub_ -> expr_dot DOT . mk_expr(expr_pure_) [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_dot DOT . lqualid_rich [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On LEFTBRC shift to state 758
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 763
-- On uident shift to state 89
-- On mk_expr(expr_pure_) shift to state 767
-- On lqualid_rich shift to state 768
-- On lident_op shift to state 312
-- On lident_keyword shift to state 43
-- On lident shift to state 313
-- On expr_pure_ shift to state 769
## Reductions:

State 758:
## Known stack suffix:
## LEFTBRC
## LR(1) items:
expr_pure_ -> LEFTBRC . qualid RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 761
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 759:
## Known stack suffix:
## uqualid
## LR(1) items:
qualid -> uqualid . DOT ident [ VAL USE TYPE SCOPE RIGHTBRC QUOTE_LIDENT PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 760
## Reductions:

State 760:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
qualid -> uqualid DOT . ident [ VAL USE TYPE SCOPE RIGHTBRC QUOTE_LIDENT PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 297
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 301
## Reductions:

State 761:
## Known stack suffix:
## LEFTBRC qualid
## LR(1) items:
expr_pure_ -> LEFTBRC qualid . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 762
## Reductions:

State 762:
## Known stack suffix:
## LEFTBRC qualid RIGHTBRC
## LR(1) items:
expr_pure_ -> LEFTBRC qualid RIGHTBRC . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On WITH reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On VARIANT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On VAL reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On USE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On UIDENT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On TYPE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On TRUE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On TO reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On THEN reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On SEMICOLON reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On SCOPE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On RIGHTSQ reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On RIGHTPAR reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On RIGHTBRC reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On RETURNS reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On REQUIRES reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On REAL reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On READS reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On RANGE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On RAISES reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On PURE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On PREDICATE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On OPPREF reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On OP4 reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On OP3 reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On OP2 reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On OP1 reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On MINUS reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On META reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On LTGT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On LT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On LIDENT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On LET reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On LEMMA reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On LEFTSQ reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On LEFTPAR reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On LEFTBRC reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On LARROW reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On INTEGER reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On INDUCTIVE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On IN reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On IMPORT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On GT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On GOAL reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On FUNCTION reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On FLOAT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On FALSE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On EXCEPTION reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On EQUAL reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On EOF reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On ENSURES reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On END reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On ELSE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On DOWNTO reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On DOTDOT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On DOT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On DONE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On DO reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On DIVERGES reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On CORE_UIDENT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On CORE_LIDENT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On CONSTANT reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On COMMA reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On COLON reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On COINDUCTIVE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On CLONE reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On BEGIN reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On BARBAR reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On BAR reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On AXIOM reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On AMPAMP reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC
-- On ALIAS reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC

State 763:
## Known stack suffix:
## uqualid
## LR(1) items:
expr_pure_ -> uqualid . DOT LEFTBRC ident RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lqualid_rich -> uqualid . DOT lident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lqualid_rich -> uqualid . DOT lident_op [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 764
## Reductions:

State 764:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
expr_pure_ -> uqualid DOT . LEFTBRC ident RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lqualid_rich -> uqualid DOT . lident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lqualid_rich -> uqualid DOT . lident_op [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On LEFTBRC shift to state 765
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 86
-- On lident_op shift to state 309
-- On lident_keyword shift to state 43
-- On lident shift to state 310
## Reductions:

State 765:
## Known stack suffix:
## uqualid DOT LEFTBRC
## LR(1) items:
expr_pure_ -> uqualid DOT LEFTBRC . ident RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 40
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 766
## Reductions:

State 766:
## Known stack suffix:
## uqualid DOT LEFTBRC ident
## LR(1) items:
expr_pure_ -> uqualid DOT LEFTBRC ident . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 750
## Reductions:

State 767:
## Known stack suffix:
## expr_dot DOT mk_expr(expr_pure_)
## LR(1) items:
expr_sub_ -> expr_dot DOT mk_expr(expr_pure_) . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On WITH reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On VARIANT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On VAL reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On USE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On UIDENT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On TYPE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On TRUE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On TO reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On THEN reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On SEMICOLON reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On SCOPE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On RIGHTSQ_QUOTE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On RIGHTSQ reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On RIGHTPAR reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On RIGHTBRC reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On RETURNS reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On REQUIRES reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On REAL reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On READS reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On RANGE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On RAISES reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On PURE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On PREDICATE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On OPPREF reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On OP4 reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On OP3 reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On OP2 reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On OP1 reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On MINUS reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On META reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On LTGT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On LT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On LIDENT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On LET reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On LEMMA reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On LEFTSQ reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On LEFTPAR reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On LEFTBRC reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On LARROW reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On INTEGER reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On INDUCTIVE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On IN reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On IMPORT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On GT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On GOAL reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On FUNCTION reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On FLOAT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On FALSE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On EXCEPTION reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On EQUAL reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On EOF reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On ENSURES reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On END reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On ELSE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On DOWNTO reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On DOTDOT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On DOT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On DONE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On DO reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On DIVERGES reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On CORE_UIDENT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On CORE_LIDENT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On CONSTANT reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On COMMA reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On COLON reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On COINDUCTIVE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On CLONE reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On BEGIN reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On BARBAR reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On BAR reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On AXIOM reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On AMPAMP reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)
-- On ALIAS reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)

State 768:
## Known stack suffix:
## expr_dot DOT lqualid_rich
## LR(1) items:
expr_sub_ -> expr_dot DOT lqualid_rich . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On WITH reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On VARIANT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On VAL reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On USE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On UIDENT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On TYPE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On TRUE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On TO reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On THEN reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On SEMICOLON reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On SCOPE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On RIGHTSQ_QUOTE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On RIGHTSQ reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On RIGHTPAR reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On RIGHTBRC reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On RETURNS reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On REQUIRES reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On REAL reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On READS reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On RANGE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On RAISES reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On PURE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On PREDICATE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On OPPREF reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On OP4 reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On OP3 reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On OP2 reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On OP1 reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On MINUS reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On META reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On LTGT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On LT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On LIDENT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On LET reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On LEMMA reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On LEFTSQ reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On LEFTPAR reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On LEFTBRC reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On LARROW reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On INTEGER reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On INDUCTIVE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On IN reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On IMPORT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On GT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On GOAL reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On FUNCTION reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On FLOAT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On FALSE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On EXCEPTION reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On EQUAL reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On EOF reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On ENSURES reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On END reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On ELSE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On DOWNTO reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On DOTDOT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On DOT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On DONE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On DO reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On DIVERGES reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On CORE_UIDENT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On CORE_LIDENT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On CONSTANT reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On COMMA reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On COLON reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On COINDUCTIVE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On CLONE reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On BEGIN reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On BARBAR reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On BAR reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On AXIOM reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On AMPAMP reduce production expr_sub_ -> expr_dot DOT lqualid_rich
-- On ALIAS reduce production expr_sub_ -> expr_dot DOT lqualid_rich

State 769:
## Known stack suffix:
## expr_pure_
## LR(1) items:
mk_expr(expr_pure_) -> expr_pure_ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production mk_expr(expr_pure_) -> expr_pure_
-- On WITH reduce production mk_expr(expr_pure_) -> expr_pure_
-- On VARIANT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On VAL reduce production mk_expr(expr_pure_) -> expr_pure_
-- On USE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On UIDENT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On TYPE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On TRUE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On TO reduce production mk_expr(expr_pure_) -> expr_pure_
-- On THEN reduce production mk_expr(expr_pure_) -> expr_pure_
-- On SEMICOLON reduce production mk_expr(expr_pure_) -> expr_pure_
-- On SCOPE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On RIGHTSQ_QUOTE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On RIGHTSQ reduce production mk_expr(expr_pure_) -> expr_pure_
-- On RIGHTPAR reduce production mk_expr(expr_pure_) -> expr_pure_
-- On RIGHTBRC reduce production mk_expr(expr_pure_) -> expr_pure_
-- On RETURNS reduce production mk_expr(expr_pure_) -> expr_pure_
-- On REQUIRES reduce production mk_expr(expr_pure_) -> expr_pure_
-- On REAL reduce production mk_expr(expr_pure_) -> expr_pure_
-- On READS reduce production mk_expr(expr_pure_) -> expr_pure_
-- On RANGE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On RAISES reduce production mk_expr(expr_pure_) -> expr_pure_
-- On PURE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On PREDICATE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On OPPREF reduce production mk_expr(expr_pure_) -> expr_pure_
-- On OP4 reduce production mk_expr(expr_pure_) -> expr_pure_
-- On OP3 reduce production mk_expr(expr_pure_) -> expr_pure_
-- On OP2 reduce production mk_expr(expr_pure_) -> expr_pure_
-- On OP1 reduce production mk_expr(expr_pure_) -> expr_pure_
-- On MINUS reduce production mk_expr(expr_pure_) -> expr_pure_
-- On META reduce production mk_expr(expr_pure_) -> expr_pure_
-- On LTGT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On LT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On LIDENT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On LET reduce production mk_expr(expr_pure_) -> expr_pure_
-- On LEMMA reduce production mk_expr(expr_pure_) -> expr_pure_
-- On LEFTSQ reduce production mk_expr(expr_pure_) -> expr_pure_
-- On LEFTPAR reduce production mk_expr(expr_pure_) -> expr_pure_
-- On LEFTBRC reduce production mk_expr(expr_pure_) -> expr_pure_
-- On LARROW reduce production mk_expr(expr_pure_) -> expr_pure_
-- On INTEGER reduce production mk_expr(expr_pure_) -> expr_pure_
-- On INDUCTIVE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On IN reduce production mk_expr(expr_pure_) -> expr_pure_
-- On IMPORT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On GT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On GOAL reduce production mk_expr(expr_pure_) -> expr_pure_
-- On FUNCTION reduce production mk_expr(expr_pure_) -> expr_pure_
-- On FLOAT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On FALSE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On EXCEPTION reduce production mk_expr(expr_pure_) -> expr_pure_
-- On EQUAL reduce production mk_expr(expr_pure_) -> expr_pure_
-- On EOF reduce production mk_expr(expr_pure_) -> expr_pure_
-- On ENSURES reduce production mk_expr(expr_pure_) -> expr_pure_
-- On END reduce production mk_expr(expr_pure_) -> expr_pure_
-- On ELSE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On DOWNTO reduce production mk_expr(expr_pure_) -> expr_pure_
-- On DOTDOT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On DOT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On DONE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On DO reduce production mk_expr(expr_pure_) -> expr_pure_
-- On DIVERGES reduce production mk_expr(expr_pure_) -> expr_pure_
-- On CORE_UIDENT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On CORE_LIDENT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On CONSTANT reduce production mk_expr(expr_pure_) -> expr_pure_
-- On COMMA reduce production mk_expr(expr_pure_) -> expr_pure_
-- On COLON reduce production mk_expr(expr_pure_) -> expr_pure_
-- On COINDUCTIVE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On CLONE reduce production mk_expr(expr_pure_) -> expr_pure_
-- On BEGIN reduce production mk_expr(expr_pure_) -> expr_pure_
-- On BARBAR reduce production mk_expr(expr_pure_) -> expr_pure_
-- On BAR reduce production mk_expr(expr_pure_) -> expr_pure_
-- On AXIOM reduce production mk_expr(expr_pure_) -> expr_pure_
-- On AMPAMP reduce production mk_expr(expr_pure_) -> expr_pure_
-- On ALIAS reduce production mk_expr(expr_pure_) -> expr_pure_

State 770:
## Known stack suffix:
## expr_block_
## LR(1) items:
expr_sub_ -> expr_block_ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_sub_ -> expr_block_
-- On WITH reduce production expr_sub_ -> expr_block_
-- On VARIANT reduce production expr_sub_ -> expr_block_
-- On VAL reduce production expr_sub_ -> expr_block_
-- On USE reduce production expr_sub_ -> expr_block_
-- On UIDENT reduce production expr_sub_ -> expr_block_
-- On TYPE reduce production expr_sub_ -> expr_block_
-- On TRUE reduce production expr_sub_ -> expr_block_
-- On TO reduce production expr_sub_ -> expr_block_
-- On THEN reduce production expr_sub_ -> expr_block_
-- On SEMICOLON reduce production expr_sub_ -> expr_block_
-- On SCOPE reduce production expr_sub_ -> expr_block_
-- On RIGHTSQ_QUOTE reduce production expr_sub_ -> expr_block_
-- On RIGHTSQ reduce production expr_sub_ -> expr_block_
-- On RIGHTPAR reduce production expr_sub_ -> expr_block_
-- On RIGHTBRC reduce production expr_sub_ -> expr_block_
-- On RETURNS reduce production expr_sub_ -> expr_block_
-- On REQUIRES reduce production expr_sub_ -> expr_block_
-- On REAL reduce production expr_sub_ -> expr_block_
-- On READS reduce production expr_sub_ -> expr_block_
-- On RANGE reduce production expr_sub_ -> expr_block_
-- On RAISES reduce production expr_sub_ -> expr_block_
-- On PURE reduce production expr_sub_ -> expr_block_
-- On PREDICATE reduce production expr_sub_ -> expr_block_
-- On OPPREF reduce production expr_sub_ -> expr_block_
-- On OP4 reduce production expr_sub_ -> expr_block_
-- On OP3 reduce production expr_sub_ -> expr_block_
-- On OP2 reduce production expr_sub_ -> expr_block_
-- On OP1 reduce production expr_sub_ -> expr_block_
-- On MINUS reduce production expr_sub_ -> expr_block_
-- On META reduce production expr_sub_ -> expr_block_
-- On LTGT reduce production expr_sub_ -> expr_block_
-- On LT reduce production expr_sub_ -> expr_block_
-- On LIDENT reduce production expr_sub_ -> expr_block_
-- On LET reduce production expr_sub_ -> expr_block_
-- On LEMMA reduce production expr_sub_ -> expr_block_
-- On LEFTSQ reduce production expr_sub_ -> expr_block_
-- On LEFTPAR reduce production expr_sub_ -> expr_block_
-- On LEFTBRC reduce production expr_sub_ -> expr_block_
-- On LARROW reduce production expr_sub_ -> expr_block_
-- On INTEGER reduce production expr_sub_ -> expr_block_
-- On INDUCTIVE reduce production expr_sub_ -> expr_block_
-- On IN reduce production expr_sub_ -> expr_block_
-- On IMPORT reduce production expr_sub_ -> expr_block_
-- On GT reduce production expr_sub_ -> expr_block_
-- On GOAL reduce production expr_sub_ -> expr_block_
-- On FUNCTION reduce production expr_sub_ -> expr_block_
-- On FLOAT reduce production expr_sub_ -> expr_block_
-- On FALSE reduce production expr_sub_ -> expr_block_
-- On EXCEPTION reduce production expr_sub_ -> expr_block_
-- On EQUAL reduce production expr_sub_ -> expr_block_
-- On EOF reduce production expr_sub_ -> expr_block_
-- On ENSURES reduce production expr_sub_ -> expr_block_
-- On END reduce production expr_sub_ -> expr_block_
-- On ELSE reduce production expr_sub_ -> expr_block_
-- On DOWNTO reduce production expr_sub_ -> expr_block_
-- On DOTDOT reduce production expr_sub_ -> expr_block_
-- On DOT reduce production expr_sub_ -> expr_block_
-- On DONE reduce production expr_sub_ -> expr_block_
-- On DO reduce production expr_sub_ -> expr_block_
-- On DIVERGES reduce production expr_sub_ -> expr_block_
-- On CORE_UIDENT reduce production expr_sub_ -> expr_block_
-- On CORE_LIDENT reduce production expr_sub_ -> expr_block_
-- On CONSTANT reduce production expr_sub_ -> expr_block_
-- On COMMA reduce production expr_sub_ -> expr_block_
-- On COLON reduce production expr_sub_ -> expr_block_
-- On COINDUCTIVE reduce production expr_sub_ -> expr_block_
-- On CLONE reduce production expr_sub_ -> expr_block_
-- On BEGIN reduce production expr_sub_ -> expr_block_
-- On BARBAR reduce production expr_sub_ -> expr_block_
-- On BAR reduce production expr_sub_ -> expr_block_
-- On AXIOM reduce production expr_sub_ -> expr_block_
-- On AMPAMP reduce production expr_sub_ -> expr_block_
-- On ALIAS reduce production expr_sub_ -> expr_block_

State 771:
## Known stack suffix:
## expr_arg_
## LR(1) items:
mk_expr(expr_arg_) -> expr_arg_ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production mk_expr(expr_arg_) -> expr_arg_
-- On WITH reduce production mk_expr(expr_arg_) -> expr_arg_
-- On VARIANT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On VAL reduce production mk_expr(expr_arg_) -> expr_arg_
-- On USE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On UIDENT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On TYPE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On TRUE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On TO reduce production mk_expr(expr_arg_) -> expr_arg_
-- On THEN reduce production mk_expr(expr_arg_) -> expr_arg_
-- On SEMICOLON reduce production mk_expr(expr_arg_) -> expr_arg_
-- On SCOPE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On RIGHTSQ_QUOTE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On RIGHTSQ reduce production mk_expr(expr_arg_) -> expr_arg_
-- On RIGHTPAR reduce production mk_expr(expr_arg_) -> expr_arg_
-- On RIGHTBRC reduce production mk_expr(expr_arg_) -> expr_arg_
-- On RETURNS reduce production mk_expr(expr_arg_) -> expr_arg_
-- On REQUIRES reduce production mk_expr(expr_arg_) -> expr_arg_
-- On REAL reduce production mk_expr(expr_arg_) -> expr_arg_
-- On READS reduce production mk_expr(expr_arg_) -> expr_arg_
-- On RANGE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On RAISES reduce production mk_expr(expr_arg_) -> expr_arg_
-- On PURE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On PREDICATE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On OPPREF reduce production mk_expr(expr_arg_) -> expr_arg_
-- On OP4 reduce production mk_expr(expr_arg_) -> expr_arg_
-- On OP3 reduce production mk_expr(expr_arg_) -> expr_arg_
-- On OP2 reduce production mk_expr(expr_arg_) -> expr_arg_
-- On OP1 reduce production mk_expr(expr_arg_) -> expr_arg_
-- On MINUS reduce production mk_expr(expr_arg_) -> expr_arg_
-- On META reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LTGT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LIDENT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LET reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LEMMA reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LEFTSQ reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LEFTPAR reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LEFTBRC reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LARROW reduce production mk_expr(expr_arg_) -> expr_arg_
-- On INTEGER reduce production mk_expr(expr_arg_) -> expr_arg_
-- On INDUCTIVE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On IN reduce production mk_expr(expr_arg_) -> expr_arg_
-- On IMPORT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On GT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On GOAL reduce production mk_expr(expr_arg_) -> expr_arg_
-- On FUNCTION reduce production mk_expr(expr_arg_) -> expr_arg_
-- On FLOAT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On FALSE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On EXCEPTION reduce production mk_expr(expr_arg_) -> expr_arg_
-- On EQUAL reduce production mk_expr(expr_arg_) -> expr_arg_
-- On EOF reduce production mk_expr(expr_arg_) -> expr_arg_
-- On ENSURES reduce production mk_expr(expr_arg_) -> expr_arg_
-- On END reduce production mk_expr(expr_arg_) -> expr_arg_
-- On ELSE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On DOWNTO reduce production mk_expr(expr_arg_) -> expr_arg_
-- On DOTDOT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On DONE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On DO reduce production mk_expr(expr_arg_) -> expr_arg_
-- On DIVERGES reduce production mk_expr(expr_arg_) -> expr_arg_
-- On CORE_UIDENT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On CORE_LIDENT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On CONSTANT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On COMMA reduce production mk_expr(expr_arg_) -> expr_arg_
-- On COLON reduce production mk_expr(expr_arg_) -> expr_arg_
-- On COINDUCTIVE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On CLONE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On BEGIN reduce production mk_expr(expr_arg_) -> expr_arg_
-- On BARBAR reduce production mk_expr(expr_arg_) -> expr_arg_
-- On BAR reduce production mk_expr(expr_arg_) -> expr_arg_
-- On AXIOM reduce production mk_expr(expr_arg_) -> expr_arg_
-- On AMPAMP reduce production mk_expr(expr_arg_) -> expr_arg_
-- On ALIAS reduce production mk_expr(expr_arg_) -> expr_arg_

State 772:
## Known stack suffix:
## LEFTBRC expr_arg
## LR(1) items:
expr_block_ -> LEFTBRC expr_arg . WITH field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr rightsq [ WITH LEFTSQ DOT ]
expr_sub_ -> expr_arg . LEFTSQ expr LARROW expr rightsq [ WITH LEFTSQ DOT ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT expr rightsq [ WITH LEFTSQ DOT ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT rightsq [ WITH LEFTSQ DOT ]
expr_sub_ -> expr_arg . LEFTSQ DOTDOT expr rightsq [ WITH LEFTSQ DOT ]
## Transitions:
-- On WITH shift to state 773
-- On LEFTSQ shift to state 776
## Reductions:

State 773:
## Known stack suffix:
## LEFTBRC expr_arg WITH
## LR(1) items:
expr_block_ -> LEFTBRC expr_arg WITH . field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,expr)) shift to state 670
-- On lqualid shift to state 671
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On field_list1(expr) shift to state 774
## Reductions:

State 774:
## Known stack suffix:
## LEFTBRC expr_arg WITH field_list1(expr)
## LR(1) items:
expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 775
## Reductions:

State 775:
## Known stack suffix:
## LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
## LR(1) items:
expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On WITH reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On VARIANT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On VAL reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On USE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On UIDENT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On TYPE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On TRUE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On TO reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On THEN reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On SEMICOLON reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On SCOPE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On RIGHTSQ reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On RIGHTPAR reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On RIGHTBRC reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On RETURNS reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On REQUIRES reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On REAL reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On READS reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On RANGE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On RAISES reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On PURE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On PREDICATE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On OPPREF reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On OP4 reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On OP3 reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On OP2 reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On OP1 reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On MINUS reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On META reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On LTGT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On LT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On LIDENT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On LET reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On LEMMA reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On LEFTSQ reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On LEFTPAR reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On LEFTBRC reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On LARROW reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On INTEGER reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On INDUCTIVE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On IN reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On IMPORT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On GT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On GOAL reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On FUNCTION reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On FLOAT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On FALSE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On EXCEPTION reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On EQUAL reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On EOF reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On ENSURES reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On END reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On ELSE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On DOWNTO reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On DOTDOT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On DOT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On DONE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On DO reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On DIVERGES reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On CORE_UIDENT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On CORE_LIDENT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On CONSTANT reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On COMMA reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On COLON reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On COINDUCTIVE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On CLONE reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On BEGIN reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On BARBAR reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On BAR reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On AXIOM reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On AMPAMP reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
-- On ALIAS reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC

State 776:
## Known stack suffix:
## expr_arg LEFTSQ
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ . expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ . expr LARROW expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ . expr DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ . expr DOTDOT rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ . DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On DOTDOT shift to state 777
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 826
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 777:
## Known stack suffix:
## expr_arg LEFTSQ DOTDOT
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ DOTDOT . expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 824
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 778:
## Known stack suffix:
## single_expr_
## LR(1) items:
mk_expr(single_expr_) -> single_expr_ . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production mk_expr(single_expr_) -> single_expr_
-- On WITH reduce production mk_expr(single_expr_) -> single_expr_
-- On VARIANT reduce production mk_expr(single_expr_) -> single_expr_
-- On VAL reduce production mk_expr(single_expr_) -> single_expr_
-- On USE reduce production mk_expr(single_expr_) -> single_expr_
-- On TYPE reduce production mk_expr(single_expr_) -> single_expr_
-- On TO reduce production mk_expr(single_expr_) -> single_expr_
-- On THEN reduce production mk_expr(single_expr_) -> single_expr_
-- On SEMICOLON reduce production mk_expr(single_expr_) -> single_expr_
-- On SCOPE reduce production mk_expr(single_expr_) -> single_expr_
-- On RIGHTSQ_QUOTE reduce production mk_expr(single_expr_) -> single_expr_
-- On RIGHTSQ reduce production mk_expr(single_expr_) -> single_expr_
-- On RIGHTPAR reduce production mk_expr(single_expr_) -> single_expr_
-- On RIGHTBRC reduce production mk_expr(single_expr_) -> single_expr_
-- On RETURNS reduce production mk_expr(single_expr_) -> single_expr_
-- On REQUIRES reduce production mk_expr(single_expr_) -> single_expr_
-- On READS reduce production mk_expr(single_expr_) -> single_expr_
-- On RAISES reduce production mk_expr(single_expr_) -> single_expr_
-- On PREDICATE reduce production mk_expr(single_expr_) -> single_expr_
-- On OP4 reduce production mk_expr(single_expr_) -> single_expr_
-- On OP3 reduce production mk_expr(single_expr_) -> single_expr_
-- On OP2 reduce production mk_expr(single_expr_) -> single_expr_
-- On OP1 reduce production mk_expr(single_expr_) -> single_expr_
-- On MINUS reduce production mk_expr(single_expr_) -> single_expr_
-- On META reduce production mk_expr(single_expr_) -> single_expr_
-- On LTGT reduce production mk_expr(single_expr_) -> single_expr_
-- On LT reduce production mk_expr(single_expr_) -> single_expr_
-- On LET reduce production mk_expr(single_expr_) -> single_expr_
-- On LEMMA reduce production mk_expr(single_expr_) -> single_expr_
-- On LARROW reduce production mk_expr(single_expr_) -> single_expr_
-- On INDUCTIVE reduce production mk_expr(single_expr_) -> single_expr_
-- On IN reduce production mk_expr(single_expr_) -> single_expr_
-- On IMPORT reduce production mk_expr(single_expr_) -> single_expr_
-- On GT reduce production mk_expr(single_expr_) -> single_expr_
-- On GOAL reduce production mk_expr(single_expr_) -> single_expr_
-- On FUNCTION reduce production mk_expr(single_expr_) -> single_expr_
-- On EXCEPTION reduce production mk_expr(single_expr_) -> single_expr_
-- On EQUAL reduce production mk_expr(single_expr_) -> single_expr_
-- On EOF reduce production mk_expr(single_expr_) -> single_expr_
-- On ENSURES reduce production mk_expr(single_expr_) -> single_expr_
-- On END reduce production mk_expr(single_expr_) -> single_expr_
-- On ELSE reduce production mk_expr(single_expr_) -> single_expr_
-- On DOWNTO reduce production mk_expr(single_expr_) -> single_expr_
-- On DOTDOT reduce production mk_expr(single_expr_) -> single_expr_
-- On DONE reduce production mk_expr(single_expr_) -> single_expr_
-- On DO reduce production mk_expr(single_expr_) -> single_expr_
-- On DIVERGES reduce production mk_expr(single_expr_) -> single_expr_
-- On CONSTANT reduce production mk_expr(single_expr_) -> single_expr_
-- On COMMA reduce production mk_expr(single_expr_) -> single_expr_
-- On COLON reduce production mk_expr(single_expr_) -> single_expr_
-- On COINDUCTIVE reduce production mk_expr(single_expr_) -> single_expr_
-- On CLONE reduce production mk_expr(single_expr_) -> single_expr_
-- On BARBAR reduce production mk_expr(single_expr_) -> single_expr_
-- On BAR reduce production mk_expr(single_expr_) -> single_expr_
-- On AXIOM reduce production mk_expr(single_expr_) -> single_expr_
-- On AMPAMP reduce production mk_expr(single_expr_) -> single_expr_
-- On ALIAS reduce production mk_expr(single_expr_) -> single_expr_

State 779:
## Known stack suffix:
## single_expr
## LR(1) items:
expr -> single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
expr -> single_expr . COMMA expr_list1 [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On COMMA shift to state 819
-- On COLON shift to state 132
-- On BARBAR shift to state 815
-- On AMPAMP shift to state 817
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production expr -> single_expr
-- On WITH reduce production expr -> single_expr
-- On VARIANT reduce production expr -> single_expr
-- On VAL reduce production expr -> single_expr
-- On USE reduce production expr -> single_expr
-- On TYPE reduce production expr -> single_expr
-- On TO reduce production expr -> single_expr
-- On THEN reduce production expr -> single_expr
-- On SEMICOLON reduce production expr -> single_expr
-- On SCOPE reduce production expr -> single_expr
-- On RIGHTSQ_QUOTE reduce production expr -> single_expr
-- On RIGHTSQ reduce production expr -> single_expr
-- On RIGHTPAR reduce production expr -> single_expr
-- On RIGHTBRC reduce production expr -> single_expr
-- On RETURNS reduce production expr -> single_expr
-- On REQUIRES reduce production expr -> single_expr
-- On READS reduce production expr -> single_expr
-- On RAISES reduce production expr -> single_expr
-- On PREDICATE reduce production expr -> single_expr
-- On META reduce production expr -> single_expr
-- On LET reduce production expr -> single_expr
-- On LEMMA reduce production expr -> single_expr
-- On LARROW reduce production expr -> single_expr
-- On INDUCTIVE reduce production expr -> single_expr
-- On IN reduce production expr -> single_expr
-- On IMPORT reduce production expr -> single_expr
-- On GOAL reduce production expr -> single_expr
-- On FUNCTION reduce production expr -> single_expr
-- On EXCEPTION reduce production expr -> single_expr
-- On EOF reduce production expr -> single_expr
-- On ENSURES reduce production expr -> single_expr
-- On END reduce production expr -> single_expr
-- On ELSE reduce production expr -> single_expr
-- On DOWNTO reduce production expr -> single_expr
-- On DOTDOT reduce production expr -> single_expr
-- On DONE reduce production expr -> single_expr
-- On DO reduce production expr -> single_expr
-- On DIVERGES reduce production expr -> single_expr
-- On CONSTANT reduce production expr -> single_expr
-- On COINDUCTIVE reduce production expr -> single_expr
-- On CLONE reduce production expr -> single_expr
-- On BAR reduce production expr -> single_expr
-- On AXIOM reduce production expr -> single_expr
-- On ALIAS reduce production expr -> single_expr

State 780:
## Known stack suffix:
## single_expr OP4
## LR(1) items:
single_expr_ -> single_expr OP4 . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 781
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 781:
## Known stack suffix:
## single_expr OP4 single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr OP4 single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> single_expr OP4 single_expr
-- On WITH reduce production single_expr_ -> single_expr OP4 single_expr
-- On VARIANT reduce production single_expr_ -> single_expr OP4 single_expr
-- On VAL reduce production single_expr_ -> single_expr OP4 single_expr
-- On USE reduce production single_expr_ -> single_expr OP4 single_expr
-- On TYPE reduce production single_expr_ -> single_expr OP4 single_expr
-- On TO reduce production single_expr_ -> single_expr OP4 single_expr
-- On THEN reduce production single_expr_ -> single_expr OP4 single_expr
-- On SEMICOLON reduce production single_expr_ -> single_expr OP4 single_expr
-- On SCOPE reduce production single_expr_ -> single_expr OP4 single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> single_expr OP4 single_expr
-- On RIGHTSQ reduce production single_expr_ -> single_expr OP4 single_expr
-- On RIGHTPAR reduce production single_expr_ -> single_expr OP4 single_expr
-- On RIGHTBRC reduce production single_expr_ -> single_expr OP4 single_expr
-- On RETURNS reduce production single_expr_ -> single_expr OP4 single_expr
-- On REQUIRES reduce production single_expr_ -> single_expr OP4 single_expr
-- On READS reduce production single_expr_ -> single_expr OP4 single_expr
-- On RAISES reduce production single_expr_ -> single_expr OP4 single_expr
-- On PREDICATE reduce production single_expr_ -> single_expr OP4 single_expr
-- On OP4 reduce production single_expr_ -> single_expr OP4 single_expr
-- On OP3 reduce production single_expr_ -> single_expr OP4 single_expr
-- On OP2 reduce production single_expr_ -> single_expr OP4 single_expr
-- On OP1 reduce production single_expr_ -> single_expr OP4 single_expr
-- On MINUS reduce production single_expr_ -> single_expr OP4 single_expr
-- On META reduce production single_expr_ -> single_expr OP4 single_expr
-- On LTGT reduce production single_expr_ -> single_expr OP4 single_expr
-- On LT reduce production single_expr_ -> single_expr OP4 single_expr
-- On LET reduce production single_expr_ -> single_expr OP4 single_expr
-- On LEMMA reduce production single_expr_ -> single_expr OP4 single_expr
-- On LARROW reduce production single_expr_ -> single_expr OP4 single_expr
-- On INDUCTIVE reduce production single_expr_ -> single_expr OP4 single_expr
-- On IN reduce production single_expr_ -> single_expr OP4 single_expr
-- On IMPORT reduce production single_expr_ -> single_expr OP4 single_expr
-- On GT reduce production single_expr_ -> single_expr OP4 single_expr
-- On GOAL reduce production single_expr_ -> single_expr OP4 single_expr
-- On FUNCTION reduce production single_expr_ -> single_expr OP4 single_expr
-- On EXCEPTION reduce production single_expr_ -> single_expr OP4 single_expr
-- On EQUAL reduce production single_expr_ -> single_expr OP4 single_expr
-- On EOF reduce production single_expr_ -> single_expr OP4 single_expr
-- On ENSURES reduce production single_expr_ -> single_expr OP4 single_expr
-- On END reduce production single_expr_ -> single_expr OP4 single_expr
-- On ELSE reduce production single_expr_ -> single_expr OP4 single_expr
-- On DOWNTO reduce production single_expr_ -> single_expr OP4 single_expr
-- On DOTDOT reduce production single_expr_ -> single_expr OP4 single_expr
-- On DONE reduce production single_expr_ -> single_expr OP4 single_expr
-- On DO reduce production single_expr_ -> single_expr OP4 single_expr
-- On DIVERGES reduce production single_expr_ -> single_expr OP4 single_expr
-- On CONSTANT reduce production single_expr_ -> single_expr OP4 single_expr
-- On COMMA reduce production single_expr_ -> single_expr OP4 single_expr
-- On COLON reduce production single_expr_ -> single_expr OP4 single_expr
-- On COINDUCTIVE reduce production single_expr_ -> single_expr OP4 single_expr
-- On CLONE reduce production single_expr_ -> single_expr OP4 single_expr
-- On BARBAR reduce production single_expr_ -> single_expr OP4 single_expr
-- On BAR reduce production single_expr_ -> single_expr OP4 single_expr
-- On AXIOM reduce production single_expr_ -> single_expr OP4 single_expr
-- On AMPAMP reduce production single_expr_ -> single_expr OP4 single_expr
-- On ALIAS reduce production single_expr_ -> single_expr OP4 single_expr

State 782:
## Known stack suffix:
## single_expr cast
## LR(1) items:
single_expr_ -> single_expr cast . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> single_expr cast
-- On WITH reduce production single_expr_ -> single_expr cast
-- On VARIANT reduce production single_expr_ -> single_expr cast
-- On VAL reduce production single_expr_ -> single_expr cast
-- On USE reduce production single_expr_ -> single_expr cast
-- On TYPE reduce production single_expr_ -> single_expr cast
-- On TO reduce production single_expr_ -> single_expr cast
-- On THEN reduce production single_expr_ -> single_expr cast
-- On SEMICOLON reduce production single_expr_ -> single_expr cast
-- On SCOPE reduce production single_expr_ -> single_expr cast
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> single_expr cast
-- On RIGHTSQ reduce production single_expr_ -> single_expr cast
-- On RIGHTPAR reduce production single_expr_ -> single_expr cast
-- On RIGHTBRC reduce production single_expr_ -> single_expr cast
-- On RETURNS reduce production single_expr_ -> single_expr cast
-- On REQUIRES reduce production single_expr_ -> single_expr cast
-- On READS reduce production single_expr_ -> single_expr cast
-- On RAISES reduce production single_expr_ -> single_expr cast
-- On PREDICATE reduce production single_expr_ -> single_expr cast
-- On OP4 reduce production single_expr_ -> single_expr cast
-- On OP3 reduce production single_expr_ -> single_expr cast
-- On OP2 reduce production single_expr_ -> single_expr cast
-- On OP1 reduce production single_expr_ -> single_expr cast
-- On MINUS reduce production single_expr_ -> single_expr cast
-- On META reduce production single_expr_ -> single_expr cast
-- On LTGT reduce production single_expr_ -> single_expr cast
-- On LT reduce production single_expr_ -> single_expr cast
-- On LET reduce production single_expr_ -> single_expr cast
-- On LEMMA reduce production single_expr_ -> single_expr cast
-- On LARROW reduce production single_expr_ -> single_expr cast
-- On INDUCTIVE reduce production single_expr_ -> single_expr cast
-- On IN reduce production single_expr_ -> single_expr cast
-- On IMPORT reduce production single_expr_ -> single_expr cast
-- On GT reduce production single_expr_ -> single_expr cast
-- On GOAL reduce production single_expr_ -> single_expr cast
-- On FUNCTION reduce production single_expr_ -> single_expr cast
-- On EXCEPTION reduce production single_expr_ -> single_expr cast
-- On EQUAL reduce production single_expr_ -> single_expr cast
-- On EOF reduce production single_expr_ -> single_expr cast
-- On ENSURES reduce production single_expr_ -> single_expr cast
-- On END reduce production single_expr_ -> single_expr cast
-- On ELSE reduce production single_expr_ -> single_expr cast
-- On DOWNTO reduce production single_expr_ -> single_expr cast
-- On DOTDOT reduce production single_expr_ -> single_expr cast
-- On DONE reduce production single_expr_ -> single_expr cast
-- On DO reduce production single_expr_ -> single_expr cast
-- On DIVERGES reduce production single_expr_ -> single_expr cast
-- On CONSTANT reduce production single_expr_ -> single_expr cast
-- On COMMA reduce production single_expr_ -> single_expr cast
-- On COLON reduce production single_expr_ -> single_expr cast
-- On COINDUCTIVE reduce production single_expr_ -> single_expr cast
-- On CLONE reduce production single_expr_ -> single_expr cast
-- On BARBAR reduce production single_expr_ -> single_expr cast
-- On BAR reduce production single_expr_ -> single_expr cast
-- On AXIOM reduce production single_expr_ -> single_expr cast
-- On AMPAMP reduce production single_expr_ -> single_expr cast
-- On ALIAS reduce production single_expr_ -> single_expr cast

State 783:
## Known stack suffix:
## prefix_op
## LR(1) items:
single_expr_ -> prefix_op . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 784
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 784:
## Known stack suffix:
## prefix_op single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> prefix_op single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> prefix_op single_expr
-- On WITH reduce production single_expr_ -> prefix_op single_expr
-- On VARIANT reduce production single_expr_ -> prefix_op single_expr
-- On VAL reduce production single_expr_ -> prefix_op single_expr
-- On USE reduce production single_expr_ -> prefix_op single_expr
-- On TYPE reduce production single_expr_ -> prefix_op single_expr
-- On TO reduce production single_expr_ -> prefix_op single_expr
-- On THEN reduce production single_expr_ -> prefix_op single_expr
-- On SEMICOLON reduce production single_expr_ -> prefix_op single_expr
-- On SCOPE reduce production single_expr_ -> prefix_op single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> prefix_op single_expr
-- On RIGHTSQ reduce production single_expr_ -> prefix_op single_expr
-- On RIGHTPAR reduce production single_expr_ -> prefix_op single_expr
-- On RIGHTBRC reduce production single_expr_ -> prefix_op single_expr
-- On RETURNS reduce production single_expr_ -> prefix_op single_expr
-- On REQUIRES reduce production single_expr_ -> prefix_op single_expr
-- On READS reduce production single_expr_ -> prefix_op single_expr
-- On RAISES reduce production single_expr_ -> prefix_op single_expr
-- On PREDICATE reduce production single_expr_ -> prefix_op single_expr
-- On OP4 reduce production single_expr_ -> prefix_op single_expr
-- On OP3 reduce production single_expr_ -> prefix_op single_expr
-- On OP2 reduce production single_expr_ -> prefix_op single_expr
-- On OP1 reduce production single_expr_ -> prefix_op single_expr
-- On MINUS reduce production single_expr_ -> prefix_op single_expr
-- On META reduce production single_expr_ -> prefix_op single_expr
-- On LTGT reduce production single_expr_ -> prefix_op single_expr
-- On LT reduce production single_expr_ -> prefix_op single_expr
-- On LET reduce production single_expr_ -> prefix_op single_expr
-- On LEMMA reduce production single_expr_ -> prefix_op single_expr
-- On LARROW reduce production single_expr_ -> prefix_op single_expr
-- On INDUCTIVE reduce production single_expr_ -> prefix_op single_expr
-- On IN reduce production single_expr_ -> prefix_op single_expr
-- On IMPORT reduce production single_expr_ -> prefix_op single_expr
-- On GT reduce production single_expr_ -> prefix_op single_expr
-- On GOAL reduce production single_expr_ -> prefix_op single_expr
-- On FUNCTION reduce production single_expr_ -> prefix_op single_expr
-- On EXCEPTION reduce production single_expr_ -> prefix_op single_expr
-- On EQUAL reduce production single_expr_ -> prefix_op single_expr
-- On EOF reduce production single_expr_ -> prefix_op single_expr
-- On ENSURES reduce production single_expr_ -> prefix_op single_expr
-- On END reduce production single_expr_ -> prefix_op single_expr
-- On ELSE reduce production single_expr_ -> prefix_op single_expr
-- On DOWNTO reduce production single_expr_ -> prefix_op single_expr
-- On DOTDOT reduce production single_expr_ -> prefix_op single_expr
-- On DONE reduce production single_expr_ -> prefix_op single_expr
-- On DO reduce production single_expr_ -> prefix_op single_expr
-- On DIVERGES reduce production single_expr_ -> prefix_op single_expr
-- On CONSTANT reduce production single_expr_ -> prefix_op single_expr
-- On COMMA reduce production single_expr_ -> prefix_op single_expr
-- On COLON reduce production single_expr_ -> prefix_op single_expr
-- On COINDUCTIVE reduce production single_expr_ -> prefix_op single_expr
-- On CLONE reduce production single_expr_ -> prefix_op single_expr
-- On BARBAR reduce production single_expr_ -> prefix_op single_expr
-- On BAR reduce production single_expr_ -> prefix_op single_expr
-- On AXIOM reduce production single_expr_ -> prefix_op single_expr
-- On AMPAMP reduce production single_expr_ -> prefix_op single_expr
-- On ALIAS reduce production single_expr_ -> prefix_op single_expr

State 785:
## Known stack suffix:
## mk_expr(single_expr_)
## LR(1) items:
single_expr -> mk_expr(single_expr_) . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr -> mk_expr(single_expr_)
-- On WITH reduce production single_expr -> mk_expr(single_expr_)
-- On VARIANT reduce production single_expr -> mk_expr(single_expr_)
-- On VAL reduce production single_expr -> mk_expr(single_expr_)
-- On USE reduce production single_expr -> mk_expr(single_expr_)
-- On TYPE reduce production single_expr -> mk_expr(single_expr_)
-- On TO reduce production single_expr -> mk_expr(single_expr_)
-- On THEN reduce production single_expr -> mk_expr(single_expr_)
-- On SEMICOLON reduce production single_expr -> mk_expr(single_expr_)
-- On SCOPE reduce production single_expr -> mk_expr(single_expr_)
-- On RIGHTSQ_QUOTE reduce production single_expr -> mk_expr(single_expr_)
-- On RIGHTSQ reduce production single_expr -> mk_expr(single_expr_)
-- On RIGHTPAR reduce production single_expr -> mk_expr(single_expr_)
-- On RIGHTBRC reduce production single_expr -> mk_expr(single_expr_)
-- On RETURNS reduce production single_expr -> mk_expr(single_expr_)
-- On REQUIRES reduce production single_expr -> mk_expr(single_expr_)
-- On READS reduce production single_expr -> mk_expr(single_expr_)
-- On RAISES reduce production single_expr -> mk_expr(single_expr_)
-- On PREDICATE reduce production single_expr -> mk_expr(single_expr_)
-- On OP4 reduce production single_expr -> mk_expr(single_expr_)
-- On OP3 reduce production single_expr -> mk_expr(single_expr_)
-- On OP2 reduce production single_expr -> mk_expr(single_expr_)
-- On OP1 reduce production single_expr -> mk_expr(single_expr_)
-- On MINUS reduce production single_expr -> mk_expr(single_expr_)
-- On META reduce production single_expr -> mk_expr(single_expr_)
-- On LTGT reduce production single_expr -> mk_expr(single_expr_)
-- On LT reduce production single_expr -> mk_expr(single_expr_)
-- On LET reduce production single_expr -> mk_expr(single_expr_)
-- On LEMMA reduce production single_expr -> mk_expr(single_expr_)
-- On LARROW reduce production single_expr -> mk_expr(single_expr_)
-- On INDUCTIVE reduce production single_expr -> mk_expr(single_expr_)
-- On IN reduce production single_expr -> mk_expr(single_expr_)
-- On IMPORT reduce production single_expr -> mk_expr(single_expr_)
-- On GT reduce production single_expr -> mk_expr(single_expr_)
-- On GOAL reduce production single_expr -> mk_expr(single_expr_)
-- On FUNCTION reduce production single_expr -> mk_expr(single_expr_)
-- On EXCEPTION reduce production single_expr -> mk_expr(single_expr_)
-- On EQUAL reduce production single_expr -> mk_expr(single_expr_)
-- On EOF reduce production single_expr -> mk_expr(single_expr_)
-- On ENSURES reduce production single_expr -> mk_expr(single_expr_)
-- On END reduce production single_expr -> mk_expr(single_expr_)
-- On ELSE reduce production single_expr -> mk_expr(single_expr_)
-- On DOWNTO reduce production single_expr -> mk_expr(single_expr_)
-- On DOTDOT reduce production single_expr -> mk_expr(single_expr_)
-- On DONE reduce production single_expr -> mk_expr(single_expr_)
-- On DO reduce production single_expr -> mk_expr(single_expr_)
-- On DIVERGES reduce production single_expr -> mk_expr(single_expr_)
-- On CONSTANT reduce production single_expr -> mk_expr(single_expr_)
-- On COMMA reduce production single_expr -> mk_expr(single_expr_)
-- On COLON reduce production single_expr -> mk_expr(single_expr_)
-- On COINDUCTIVE reduce production single_expr -> mk_expr(single_expr_)
-- On CLONE reduce production single_expr -> mk_expr(single_expr_)
-- On BARBAR reduce production single_expr -> mk_expr(single_expr_)
-- On BAR reduce production single_expr -> mk_expr(single_expr_)
-- On AXIOM reduce production single_expr -> mk_expr(single_expr_)
-- On AMPAMP reduce production single_expr -> mk_expr(single_expr_)
-- On ALIAS reduce production single_expr -> mk_expr(single_expr_)

State 786:
## Known stack suffix:
## lqualid
## LR(1) items:
expr_dot_ -> lqualid . [ DOT ]
## Transitions:
## Reductions:
-- On DOT reduce production expr_dot_ -> lqualid

State 787:
## Known stack suffix:
## expr_arg_
## LR(1) items:
mk_expr(expr_arg_) -> expr_arg_ . [ UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTSQ LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN ]
single_expr_ -> expr_arg_ . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> expr_arg_
-- On WITH reduce production single_expr_ -> expr_arg_
-- On VARIANT reduce production single_expr_ -> expr_arg_
-- On VAL reduce production single_expr_ -> expr_arg_
-- On USE reduce production single_expr_ -> expr_arg_
-- On UIDENT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On TYPE reduce production single_expr_ -> expr_arg_
-- On TRUE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On TO reduce production single_expr_ -> expr_arg_
-- On THEN reduce production single_expr_ -> expr_arg_
-- On SEMICOLON reduce production single_expr_ -> expr_arg_
-- On SCOPE reduce production single_expr_ -> expr_arg_
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> expr_arg_
-- On RIGHTSQ reduce production single_expr_ -> expr_arg_
-- On RIGHTPAR reduce production single_expr_ -> expr_arg_
-- On RIGHTBRC reduce production single_expr_ -> expr_arg_
-- On RETURNS reduce production single_expr_ -> expr_arg_
-- On REQUIRES reduce production single_expr_ -> expr_arg_
-- On REAL reduce production mk_expr(expr_arg_) -> expr_arg_
-- On READS reduce production single_expr_ -> expr_arg_
-- On RANGE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On RAISES reduce production single_expr_ -> expr_arg_
-- On PURE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On PREDICATE reduce production single_expr_ -> expr_arg_
-- On OPPREF reduce production mk_expr(expr_arg_) -> expr_arg_
-- On OP4 reduce production single_expr_ -> expr_arg_
-- On OP3 reduce production single_expr_ -> expr_arg_
-- On OP2 reduce production single_expr_ -> expr_arg_
-- On OP1 reduce production single_expr_ -> expr_arg_
-- On MINUS reduce production single_expr_ -> expr_arg_
-- On META reduce production single_expr_ -> expr_arg_
-- On LTGT reduce production single_expr_ -> expr_arg_
-- On LT reduce production single_expr_ -> expr_arg_
-- On LIDENT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LET reduce production single_expr_ -> expr_arg_
-- On LEMMA reduce production single_expr_ -> expr_arg_
-- On LEFTSQ reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LEFTPAR reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LEFTBRC reduce production mk_expr(expr_arg_) -> expr_arg_
-- On LARROW reduce production single_expr_ -> expr_arg_
-- On INTEGER reduce production mk_expr(expr_arg_) -> expr_arg_
-- On INDUCTIVE reduce production single_expr_ -> expr_arg_
-- On IN reduce production single_expr_ -> expr_arg_
-- On IMPORT reduce production single_expr_ -> expr_arg_
-- On GT reduce production single_expr_ -> expr_arg_
-- On GOAL reduce production single_expr_ -> expr_arg_
-- On FUNCTION reduce production single_expr_ -> expr_arg_
-- On FLOAT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On FALSE reduce production mk_expr(expr_arg_) -> expr_arg_
-- On EXCEPTION reduce production single_expr_ -> expr_arg_
-- On EQUAL reduce production single_expr_ -> expr_arg_
-- On EOF reduce production single_expr_ -> expr_arg_
-- On ENSURES reduce production single_expr_ -> expr_arg_
-- On END reduce production single_expr_ -> expr_arg_
-- On ELSE reduce production single_expr_ -> expr_arg_
-- On DOWNTO reduce production single_expr_ -> expr_arg_
-- On DOTDOT reduce production single_expr_ -> expr_arg_
-- On DONE reduce production single_expr_ -> expr_arg_
-- On DO reduce production single_expr_ -> expr_arg_
-- On DIVERGES reduce production single_expr_ -> expr_arg_
-- On CORE_UIDENT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On CORE_LIDENT reduce production mk_expr(expr_arg_) -> expr_arg_
-- On CONSTANT reduce production single_expr_ -> expr_arg_
-- On COMMA reduce production single_expr_ -> expr_arg_
-- On COLON reduce production single_expr_ -> expr_arg_
-- On COINDUCTIVE reduce production single_expr_ -> expr_arg_
-- On CLONE reduce production single_expr_ -> expr_arg_
-- On BEGIN reduce production mk_expr(expr_arg_) -> expr_arg_
-- On BARBAR reduce production single_expr_ -> expr_arg_
-- On BAR reduce production single_expr_ -> expr_arg_
-- On AXIOM reduce production single_expr_ -> expr_arg_
-- On AMPAMP reduce production single_expr_ -> expr_arg_
-- On ALIAS reduce production single_expr_ -> expr_arg_

State 788:
## Known stack suffix:
## expr_arg
## LR(1) items:
expr_sub_ -> expr_arg . LEFTSQ expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr LARROW expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> expr_arg . nonempty_list(located(expr_arg)) [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTSQ shift to state 776
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On qualid shift to state 744
-- On numeral shift to state 745
-- On nonempty_list(located(expr_arg)) shift to state 789
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On located(expr_arg) shift to state 790
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 792
## Reductions:

State 789:
## Known stack suffix:
## expr_arg nonempty_list(located(expr_arg))
## LR(1) items:
single_expr_ -> expr_arg nonempty_list(located(expr_arg)) . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On WITH reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On VARIANT reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On VAL reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On USE reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On TYPE reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On TO reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On THEN reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On SEMICOLON reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On SCOPE reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On RIGHTSQ reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On RIGHTPAR reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On RIGHTBRC reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On RETURNS reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On REQUIRES reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On READS reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On RAISES reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On PREDICATE reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On OP4 reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On OP3 reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On OP2 reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On OP1 reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On MINUS reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On META reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On LTGT reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On LT reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On LET reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On LEMMA reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On LARROW reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On INDUCTIVE reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On IN reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On IMPORT reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On GT reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On GOAL reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On FUNCTION reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On EXCEPTION reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On EQUAL reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On EOF reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On ENSURES reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On END reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On ELSE reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On DOWNTO reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On DOTDOT reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On DONE reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On DO reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On DIVERGES reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On CONSTANT reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On COMMA reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On COLON reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On COINDUCTIVE reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On CLONE reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On BARBAR reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On BAR reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On AXIOM reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On AMPAMP reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))
-- On ALIAS reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))

State 790:
## Known stack suffix:
## located(expr_arg)
## LR(1) items:
nonempty_list(located(expr_arg)) -> located(expr_arg) . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
nonempty_list(located(expr_arg)) -> located(expr_arg) . nonempty_list(located(expr_arg)) [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On qualid shift to state 744
-- On numeral shift to state 745
-- On nonempty_list(located(expr_arg)) shift to state 791
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On located(expr_arg) shift to state 790
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 792
## Reductions:
-- On WRITES reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On WITH reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On VARIANT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On VAL reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On USE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On TYPE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On TO reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On THEN reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On SEMICOLON reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On SCOPE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On RIGHTSQ_QUOTE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On RIGHTSQ reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On RIGHTPAR reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On RIGHTBRC reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On RETURNS reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On REQUIRES reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On READS reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On RAISES reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On PREDICATE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On OP4 reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On OP3 reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On OP2 reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On OP1 reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On MINUS reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On META reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On LTGT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On LT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On LET reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On LEMMA reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On LARROW reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On INDUCTIVE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On IN reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On IMPORT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On GT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On GOAL reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On FUNCTION reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On EXCEPTION reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On EQUAL reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On EOF reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On ENSURES reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On END reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On ELSE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On DOWNTO reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On DOTDOT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On DONE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On DO reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On DIVERGES reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On CONSTANT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On COMMA reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On COLON reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On COINDUCTIVE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On CLONE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On BARBAR reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On BAR reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On AXIOM reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On AMPAMP reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)
-- On ALIAS reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)

State 791:
## Known stack suffix:
## located(expr_arg) nonempty_list(located(expr_arg))
## LR(1) items:
nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg)) . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On WITH reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On VARIANT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On VAL reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On USE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On TYPE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On TO reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On THEN reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On SEMICOLON reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On SCOPE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On RIGHTSQ_QUOTE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On RIGHTSQ reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On RIGHTPAR reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On RIGHTBRC reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On RETURNS reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On REQUIRES reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On READS reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On RAISES reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On PREDICATE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On OP4 reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On OP3 reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On OP2 reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On OP1 reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On MINUS reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On META reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On LTGT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On LT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On LET reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On LEMMA reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On LARROW reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On INDUCTIVE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On IN reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On IMPORT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On GT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On GOAL reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On FUNCTION reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On EXCEPTION reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On EQUAL reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On EOF reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On ENSURES reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On END reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On ELSE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On DOWNTO reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On DOTDOT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On DONE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On DO reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On DIVERGES reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On CONSTANT reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On COMMA reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On COLON reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On COINDUCTIVE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On CLONE reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On BARBAR reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On BAR reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On AXIOM reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On AMPAMP reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))
-- On ALIAS reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))

State 792:
## Known stack suffix:
## expr_arg
## LR(1) items:
expr_sub_ -> expr_arg . LEFTSQ expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr LARROW expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
located(expr_arg) -> expr_arg . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On LEFTSQ shift to state 776
## Reductions:
-- On WRITES reduce production located(expr_arg) -> expr_arg
-- On WITH reduce production located(expr_arg) -> expr_arg
-- On VARIANT reduce production located(expr_arg) -> expr_arg
-- On VAL reduce production located(expr_arg) -> expr_arg
-- On USE reduce production located(expr_arg) -> expr_arg
-- On UIDENT reduce production located(expr_arg) -> expr_arg
-- On TYPE reduce production located(expr_arg) -> expr_arg
-- On TRUE reduce production located(expr_arg) -> expr_arg
-- On TO reduce production located(expr_arg) -> expr_arg
-- On THEN reduce production located(expr_arg) -> expr_arg
-- On SEMICOLON reduce production located(expr_arg) -> expr_arg
-- On SCOPE reduce production located(expr_arg) -> expr_arg
-- On RIGHTSQ_QUOTE reduce production located(expr_arg) -> expr_arg
-- On RIGHTSQ reduce production located(expr_arg) -> expr_arg
-- On RIGHTPAR reduce production located(expr_arg) -> expr_arg
-- On RIGHTBRC reduce production located(expr_arg) -> expr_arg
-- On RETURNS reduce production located(expr_arg) -> expr_arg
-- On REQUIRES reduce production located(expr_arg) -> expr_arg
-- On REAL reduce production located(expr_arg) -> expr_arg
-- On READS reduce production located(expr_arg) -> expr_arg
-- On RANGE reduce production located(expr_arg) -> expr_arg
-- On RAISES reduce production located(expr_arg) -> expr_arg
-- On PURE reduce production located(expr_arg) -> expr_arg
-- On PREDICATE reduce production located(expr_arg) -> expr_arg
-- On OPPREF reduce production located(expr_arg) -> expr_arg
-- On OP4 reduce production located(expr_arg) -> expr_arg
-- On OP3 reduce production located(expr_arg) -> expr_arg
-- On OP2 reduce production located(expr_arg) -> expr_arg
-- On OP1 reduce production located(expr_arg) -> expr_arg
-- On MINUS reduce production located(expr_arg) -> expr_arg
-- On META reduce production located(expr_arg) -> expr_arg
-- On LTGT reduce production located(expr_arg) -> expr_arg
-- On LT reduce production located(expr_arg) -> expr_arg
-- On LIDENT reduce production located(expr_arg) -> expr_arg
-- On LET reduce production located(expr_arg) -> expr_arg
-- On LEMMA reduce production located(expr_arg) -> expr_arg
-- On LEFTPAR reduce production located(expr_arg) -> expr_arg
-- On LEFTBRC reduce production located(expr_arg) -> expr_arg
-- On LARROW reduce production located(expr_arg) -> expr_arg
-- On INTEGER reduce production located(expr_arg) -> expr_arg
-- On INDUCTIVE reduce production located(expr_arg) -> expr_arg
-- On IN reduce production located(expr_arg) -> expr_arg
-- On IMPORT reduce production located(expr_arg) -> expr_arg
-- On GT reduce production located(expr_arg) -> expr_arg
-- On GOAL reduce production located(expr_arg) -> expr_arg
-- On FUNCTION reduce production located(expr_arg) -> expr_arg
-- On FLOAT reduce production located(expr_arg) -> expr_arg
-- On FALSE reduce production located(expr_arg) -> expr_arg
-- On EXCEPTION reduce production located(expr_arg) -> expr_arg
-- On EQUAL reduce production located(expr_arg) -> expr_arg
-- On EOF reduce production located(expr_arg) -> expr_arg
-- On ENSURES reduce production located(expr_arg) -> expr_arg
-- On END reduce production located(expr_arg) -> expr_arg
-- On ELSE reduce production located(expr_arg) -> expr_arg
-- On DOWNTO reduce production located(expr_arg) -> expr_arg
-- On DOTDOT reduce production located(expr_arg) -> expr_arg
-- On DONE reduce production located(expr_arg) -> expr_arg
-- On DO reduce production located(expr_arg) -> expr_arg
-- On DIVERGES reduce production located(expr_arg) -> expr_arg
-- On CORE_UIDENT reduce production located(expr_arg) -> expr_arg
-- On CORE_LIDENT reduce production located(expr_arg) -> expr_arg
-- On CONSTANT reduce production located(expr_arg) -> expr_arg
-- On COMMA reduce production located(expr_arg) -> expr_arg
-- On COLON reduce production located(expr_arg) -> expr_arg
-- On COINDUCTIVE reduce production located(expr_arg) -> expr_arg
-- On CLONE reduce production located(expr_arg) -> expr_arg
-- On BEGIN reduce production located(expr_arg) -> expr_arg
-- On BARBAR reduce production located(expr_arg) -> expr_arg
-- On BAR reduce production located(expr_arg) -> expr_arg
-- On AXIOM reduce production located(expr_arg) -> expr_arg
-- On AMPAMP reduce production located(expr_arg) -> expr_arg
-- On ALIAS reduce production located(expr_arg) -> expr_arg

State 793:
## Known stack suffix:
## attr
## LR(1) items:
single_expr_ -> attr . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 794
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 794:
## Known stack suffix:
## attr single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> attr single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On COLON shift to state 132
-- On BARBAR shift to state 815
-- On AMPAMP shift to state 817
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> attr single_expr
-- On WITH reduce production single_expr_ -> attr single_expr
-- On VARIANT reduce production single_expr_ -> attr single_expr
-- On VAL reduce production single_expr_ -> attr single_expr
-- On USE reduce production single_expr_ -> attr single_expr
-- On TYPE reduce production single_expr_ -> attr single_expr
-- On TO reduce production single_expr_ -> attr single_expr
-- On THEN reduce production single_expr_ -> attr single_expr
-- On SEMICOLON reduce production single_expr_ -> attr single_expr
-- On SCOPE reduce production single_expr_ -> attr single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> attr single_expr
-- On RIGHTSQ reduce production single_expr_ -> attr single_expr
-- On RIGHTPAR reduce production single_expr_ -> attr single_expr
-- On RIGHTBRC reduce production single_expr_ -> attr single_expr
-- On RETURNS reduce production single_expr_ -> attr single_expr
-- On REQUIRES reduce production single_expr_ -> attr single_expr
-- On READS reduce production single_expr_ -> attr single_expr
-- On RAISES reduce production single_expr_ -> attr single_expr
-- On PREDICATE reduce production single_expr_ -> attr single_expr
-- On META reduce production single_expr_ -> attr single_expr
-- On LET reduce production single_expr_ -> attr single_expr
-- On LEMMA reduce production single_expr_ -> attr single_expr
-- On LARROW reduce production single_expr_ -> attr single_expr
-- On INDUCTIVE reduce production single_expr_ -> attr single_expr
-- On IN reduce production single_expr_ -> attr single_expr
-- On IMPORT reduce production single_expr_ -> attr single_expr
-- On GOAL reduce production single_expr_ -> attr single_expr
-- On FUNCTION reduce production single_expr_ -> attr single_expr
-- On EXCEPTION reduce production single_expr_ -> attr single_expr
-- On EOF reduce production single_expr_ -> attr single_expr
-- On ENSURES reduce production single_expr_ -> attr single_expr
-- On END reduce production single_expr_ -> attr single_expr
-- On ELSE reduce production single_expr_ -> attr single_expr
-- On DOWNTO reduce production single_expr_ -> attr single_expr
-- On DOTDOT reduce production single_expr_ -> attr single_expr
-- On DONE reduce production single_expr_ -> attr single_expr
-- On DO reduce production single_expr_ -> attr single_expr
-- On DIVERGES reduce production single_expr_ -> attr single_expr
-- On CONSTANT reduce production single_expr_ -> attr single_expr
-- On COMMA reduce production single_expr_ -> attr single_expr
-- On COINDUCTIVE reduce production single_expr_ -> attr single_expr
-- On CLONE reduce production single_expr_ -> attr single_expr
-- On BAR reduce production single_expr_ -> attr single_expr
-- On AXIOM reduce production single_expr_ -> attr single_expr
-- On ALIAS reduce production single_expr_ -> attr single_expr

State 795:
## Known stack suffix:
## single_expr OP3
## LR(1) items:
single_expr_ -> single_expr OP3 . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 796
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 796:
## Known stack suffix:
## single_expr OP3 single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr OP3 single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> single_expr OP3 single_expr
-- On WITH reduce production single_expr_ -> single_expr OP3 single_expr
-- On VARIANT reduce production single_expr_ -> single_expr OP3 single_expr
-- On VAL reduce production single_expr_ -> single_expr OP3 single_expr
-- On USE reduce production single_expr_ -> single_expr OP3 single_expr
-- On TYPE reduce production single_expr_ -> single_expr OP3 single_expr
-- On TO reduce production single_expr_ -> single_expr OP3 single_expr
-- On THEN reduce production single_expr_ -> single_expr OP3 single_expr
-- On SEMICOLON reduce production single_expr_ -> single_expr OP3 single_expr
-- On SCOPE reduce production single_expr_ -> single_expr OP3 single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> single_expr OP3 single_expr
-- On RIGHTSQ reduce production single_expr_ -> single_expr OP3 single_expr
-- On RIGHTPAR reduce production single_expr_ -> single_expr OP3 single_expr
-- On RIGHTBRC reduce production single_expr_ -> single_expr OP3 single_expr
-- On RETURNS reduce production single_expr_ -> single_expr OP3 single_expr
-- On REQUIRES reduce production single_expr_ -> single_expr OP3 single_expr
-- On READS reduce production single_expr_ -> single_expr OP3 single_expr
-- On RAISES reduce production single_expr_ -> single_expr OP3 single_expr
-- On PREDICATE reduce production single_expr_ -> single_expr OP3 single_expr
-- On OP3 reduce production single_expr_ -> single_expr OP3 single_expr
-- On OP2 reduce production single_expr_ -> single_expr OP3 single_expr
-- On OP1 reduce production single_expr_ -> single_expr OP3 single_expr
-- On MINUS reduce production single_expr_ -> single_expr OP3 single_expr
-- On META reduce production single_expr_ -> single_expr OP3 single_expr
-- On LTGT reduce production single_expr_ -> single_expr OP3 single_expr
-- On LT reduce production single_expr_ -> single_expr OP3 single_expr
-- On LET reduce production single_expr_ -> single_expr OP3 single_expr
-- On LEMMA reduce production single_expr_ -> single_expr OP3 single_expr
-- On LARROW reduce production single_expr_ -> single_expr OP3 single_expr
-- On INDUCTIVE reduce production single_expr_ -> single_expr OP3 single_expr
-- On IN reduce production single_expr_ -> single_expr OP3 single_expr
-- On IMPORT reduce production single_expr_ -> single_expr OP3 single_expr
-- On GT reduce production single_expr_ -> single_expr OP3 single_expr
-- On GOAL reduce production single_expr_ -> single_expr OP3 single_expr
-- On FUNCTION reduce production single_expr_ -> single_expr OP3 single_expr
-- On EXCEPTION reduce production single_expr_ -> single_expr OP3 single_expr
-- On EQUAL reduce production single_expr_ -> single_expr OP3 single_expr
-- On EOF reduce production single_expr_ -> single_expr OP3 single_expr
-- On ENSURES reduce production single_expr_ -> single_expr OP3 single_expr
-- On END reduce production single_expr_ -> single_expr OP3 single_expr
-- On ELSE reduce production single_expr_ -> single_expr OP3 single_expr
-- On DOWNTO reduce production single_expr_ -> single_expr OP3 single_expr
-- On DOTDOT reduce production single_expr_ -> single_expr OP3 single_expr
-- On DONE reduce production single_expr_ -> single_expr OP3 single_expr
-- On DO reduce production single_expr_ -> single_expr OP3 single_expr
-- On DIVERGES reduce production single_expr_ -> single_expr OP3 single_expr
-- On CONSTANT reduce production single_expr_ -> single_expr OP3 single_expr
-- On COMMA reduce production single_expr_ -> single_expr OP3 single_expr
-- On COLON reduce production single_expr_ -> single_expr OP3 single_expr
-- On COINDUCTIVE reduce production single_expr_ -> single_expr OP3 single_expr
-- On CLONE reduce production single_expr_ -> single_expr OP3 single_expr
-- On BARBAR reduce production single_expr_ -> single_expr OP3 single_expr
-- On BAR reduce production single_expr_ -> single_expr OP3 single_expr
-- On AXIOM reduce production single_expr_ -> single_expr OP3 single_expr
-- On AMPAMP reduce production single_expr_ -> single_expr OP3 single_expr
-- On ALIAS reduce production single_expr_ -> single_expr OP3 single_expr

State 797:
## Known stack suffix:
## assertion_kind
## LR(1) items:
single_expr_ -> assertion_kind . LEFTBRC term RIGHTBRC [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On LEFTBRC shift to state 798
## Reductions:

State 798:
## Known stack suffix:
## assertion_kind LEFTBRC
## LR(1) items:
single_expr_ -> assertion_kind LEFTBRC . term RIGHTBRC [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 799
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 799:
## Known stack suffix:
## assertion_kind LEFTBRC term
## LR(1) items:
single_expr_ -> assertion_kind LEFTBRC term . RIGHTBRC [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 800
## Reductions:

State 800:
## Known stack suffix:
## assertion_kind LEFTBRC term RIGHTBRC
## LR(1) items:
single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On WITH reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On VARIANT reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On VAL reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On USE reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On TYPE reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On TO reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On THEN reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On SEMICOLON reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On SCOPE reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On RIGHTSQ reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On RIGHTPAR reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On RIGHTBRC reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On RETURNS reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On REQUIRES reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On READS reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On RAISES reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On PREDICATE reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On OP4 reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On OP3 reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On OP2 reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On OP1 reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On MINUS reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On META reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On LTGT reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On LT reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On LET reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On LEMMA reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On LARROW reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On INDUCTIVE reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On IN reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On IMPORT reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On GT reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On GOAL reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On FUNCTION reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On EXCEPTION reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On EQUAL reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On EOF reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On ENSURES reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On END reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On ELSE reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On DOWNTO reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On DOTDOT reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On DONE reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On DO reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On DIVERGES reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On CONSTANT reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On COMMA reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On COLON reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On COINDUCTIVE reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On CLONE reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On BARBAR reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On BAR reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On AXIOM reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On AMPAMP reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC
-- On ALIAS reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC

State 801:
## Known stack suffix:
## single_expr OP2
## LR(1) items:
single_expr_ -> single_expr OP2 . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 802
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 802:
## Known stack suffix:
## single_expr OP2 single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr OP2 single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> single_expr OP2 single_expr
-- On WITH reduce production single_expr_ -> single_expr OP2 single_expr
-- On VARIANT reduce production single_expr_ -> single_expr OP2 single_expr
-- On VAL reduce production single_expr_ -> single_expr OP2 single_expr
-- On USE reduce production single_expr_ -> single_expr OP2 single_expr
-- On TYPE reduce production single_expr_ -> single_expr OP2 single_expr
-- On TO reduce production single_expr_ -> single_expr OP2 single_expr
-- On THEN reduce production single_expr_ -> single_expr OP2 single_expr
-- On SEMICOLON reduce production single_expr_ -> single_expr OP2 single_expr
-- On SCOPE reduce production single_expr_ -> single_expr OP2 single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> single_expr OP2 single_expr
-- On RIGHTSQ reduce production single_expr_ -> single_expr OP2 single_expr
-- On RIGHTPAR reduce production single_expr_ -> single_expr OP2 single_expr
-- On RIGHTBRC reduce production single_expr_ -> single_expr OP2 single_expr
-- On RETURNS reduce production single_expr_ -> single_expr OP2 single_expr
-- On REQUIRES reduce production single_expr_ -> single_expr OP2 single_expr
-- On READS reduce production single_expr_ -> single_expr OP2 single_expr
-- On RAISES reduce production single_expr_ -> single_expr OP2 single_expr
-- On PREDICATE reduce production single_expr_ -> single_expr OP2 single_expr
-- On OP2 reduce production single_expr_ -> single_expr OP2 single_expr
-- On OP1 reduce production single_expr_ -> single_expr OP2 single_expr
-- On MINUS reduce production single_expr_ -> single_expr OP2 single_expr
-- On META reduce production single_expr_ -> single_expr OP2 single_expr
-- On LTGT reduce production single_expr_ -> single_expr OP2 single_expr
-- On LT reduce production single_expr_ -> single_expr OP2 single_expr
-- On LET reduce production single_expr_ -> single_expr OP2 single_expr
-- On LEMMA reduce production single_expr_ -> single_expr OP2 single_expr
-- On LARROW reduce production single_expr_ -> single_expr OP2 single_expr
-- On INDUCTIVE reduce production single_expr_ -> single_expr OP2 single_expr
-- On IN reduce production single_expr_ -> single_expr OP2 single_expr
-- On IMPORT reduce production single_expr_ -> single_expr OP2 single_expr
-- On GT reduce production single_expr_ -> single_expr OP2 single_expr
-- On GOAL reduce production single_expr_ -> single_expr OP2 single_expr
-- On FUNCTION reduce production single_expr_ -> single_expr OP2 single_expr
-- On EXCEPTION reduce production single_expr_ -> single_expr OP2 single_expr
-- On EQUAL reduce production single_expr_ -> single_expr OP2 single_expr
-- On EOF reduce production single_expr_ -> single_expr OP2 single_expr
-- On ENSURES reduce production single_expr_ -> single_expr OP2 single_expr
-- On END reduce production single_expr_ -> single_expr OP2 single_expr
-- On ELSE reduce production single_expr_ -> single_expr OP2 single_expr
-- On DOWNTO reduce production single_expr_ -> single_expr OP2 single_expr
-- On DOTDOT reduce production single_expr_ -> single_expr OP2 single_expr
-- On DONE reduce production single_expr_ -> single_expr OP2 single_expr
-- On DO reduce production single_expr_ -> single_expr OP2 single_expr
-- On DIVERGES reduce production single_expr_ -> single_expr OP2 single_expr
-- On CONSTANT reduce production single_expr_ -> single_expr OP2 single_expr
-- On COMMA reduce production single_expr_ -> single_expr OP2 single_expr
-- On COLON reduce production single_expr_ -> single_expr OP2 single_expr
-- On COINDUCTIVE reduce production single_expr_ -> single_expr OP2 single_expr
-- On CLONE reduce production single_expr_ -> single_expr OP2 single_expr
-- On BARBAR reduce production single_expr_ -> single_expr OP2 single_expr
-- On BAR reduce production single_expr_ -> single_expr OP2 single_expr
-- On AXIOM reduce production single_expr_ -> single_expr OP2 single_expr
-- On AMPAMP reduce production single_expr_ -> single_expr OP2 single_expr
-- On ALIAS reduce production single_expr_ -> single_expr OP2 single_expr

State 803:
## Known stack suffix:
## single_expr OP1
## LR(1) items:
single_expr_ -> single_expr OP1 . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 804
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 804:
## Known stack suffix:
## single_expr OP1 single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr OP1 single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> single_expr OP1 single_expr
-- On WITH reduce production single_expr_ -> single_expr OP1 single_expr
-- On VARIANT reduce production single_expr_ -> single_expr OP1 single_expr
-- On VAL reduce production single_expr_ -> single_expr OP1 single_expr
-- On USE reduce production single_expr_ -> single_expr OP1 single_expr
-- On TYPE reduce production single_expr_ -> single_expr OP1 single_expr
-- On TO reduce production single_expr_ -> single_expr OP1 single_expr
-- On THEN reduce production single_expr_ -> single_expr OP1 single_expr
-- On SEMICOLON reduce production single_expr_ -> single_expr OP1 single_expr
-- On SCOPE reduce production single_expr_ -> single_expr OP1 single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> single_expr OP1 single_expr
-- On RIGHTSQ reduce production single_expr_ -> single_expr OP1 single_expr
-- On RIGHTPAR reduce production single_expr_ -> single_expr OP1 single_expr
-- On RIGHTBRC reduce production single_expr_ -> single_expr OP1 single_expr
-- On RETURNS reduce production single_expr_ -> single_expr OP1 single_expr
-- On REQUIRES reduce production single_expr_ -> single_expr OP1 single_expr
-- On READS reduce production single_expr_ -> single_expr OP1 single_expr
-- On RAISES reduce production single_expr_ -> single_expr OP1 single_expr
-- On PREDICATE reduce production single_expr_ -> single_expr OP1 single_expr
-- On META reduce production single_expr_ -> single_expr OP1 single_expr
-- On LET reduce production single_expr_ -> single_expr OP1 single_expr
-- On LEMMA reduce production single_expr_ -> single_expr OP1 single_expr
-- On LARROW reduce production single_expr_ -> single_expr OP1 single_expr
-- On INDUCTIVE reduce production single_expr_ -> single_expr OP1 single_expr
-- On IN reduce production single_expr_ -> single_expr OP1 single_expr
-- On IMPORT reduce production single_expr_ -> single_expr OP1 single_expr
-- On GOAL reduce production single_expr_ -> single_expr OP1 single_expr
-- On FUNCTION reduce production single_expr_ -> single_expr OP1 single_expr
-- On EXCEPTION reduce production single_expr_ -> single_expr OP1 single_expr
-- On EOF reduce production single_expr_ -> single_expr OP1 single_expr
-- On ENSURES reduce production single_expr_ -> single_expr OP1 single_expr
-- On END reduce production single_expr_ -> single_expr OP1 single_expr
-- On ELSE reduce production single_expr_ -> single_expr OP1 single_expr
-- On DOWNTO reduce production single_expr_ -> single_expr OP1 single_expr
-- On DOTDOT reduce production single_expr_ -> single_expr OP1 single_expr
-- On DONE reduce production single_expr_ -> single_expr OP1 single_expr
-- On DO reduce production single_expr_ -> single_expr OP1 single_expr
-- On DIVERGES reduce production single_expr_ -> single_expr OP1 single_expr
-- On CONSTANT reduce production single_expr_ -> single_expr OP1 single_expr
-- On COMMA reduce production single_expr_ -> single_expr OP1 single_expr
-- On COLON reduce production single_expr_ -> single_expr OP1 single_expr
-- On COINDUCTIVE reduce production single_expr_ -> single_expr OP1 single_expr
-- On CLONE reduce production single_expr_ -> single_expr OP1 single_expr
-- On BARBAR reduce production single_expr_ -> single_expr OP1 single_expr
-- On BAR reduce production single_expr_ -> single_expr OP1 single_expr
-- On AXIOM reduce production single_expr_ -> single_expr OP1 single_expr
-- On AMPAMP reduce production single_expr_ -> single_expr OP1 single_expr
-- On ALIAS reduce production single_expr_ -> single_expr OP1 single_expr

State 805:
## Known stack suffix:
## single_expr MINUS
## LR(1) items:
single_expr_ -> single_expr MINUS . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 806
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 806:
## Known stack suffix:
## single_expr MINUS single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr MINUS single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> single_expr MINUS single_expr
-- On WITH reduce production single_expr_ -> single_expr MINUS single_expr
-- On VARIANT reduce production single_expr_ -> single_expr MINUS single_expr
-- On VAL reduce production single_expr_ -> single_expr MINUS single_expr
-- On USE reduce production single_expr_ -> single_expr MINUS single_expr
-- On TYPE reduce production single_expr_ -> single_expr MINUS single_expr
-- On TO reduce production single_expr_ -> single_expr MINUS single_expr
-- On THEN reduce production single_expr_ -> single_expr MINUS single_expr
-- On SEMICOLON reduce production single_expr_ -> single_expr MINUS single_expr
-- On SCOPE reduce production single_expr_ -> single_expr MINUS single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> single_expr MINUS single_expr
-- On RIGHTSQ reduce production single_expr_ -> single_expr MINUS single_expr
-- On RIGHTPAR reduce production single_expr_ -> single_expr MINUS single_expr
-- On RIGHTBRC reduce production single_expr_ -> single_expr MINUS single_expr
-- On RETURNS reduce production single_expr_ -> single_expr MINUS single_expr
-- On REQUIRES reduce production single_expr_ -> single_expr MINUS single_expr
-- On READS reduce production single_expr_ -> single_expr MINUS single_expr
-- On RAISES reduce production single_expr_ -> single_expr MINUS single_expr
-- On PREDICATE reduce production single_expr_ -> single_expr MINUS single_expr
-- On OP2 reduce production single_expr_ -> single_expr MINUS single_expr
-- On OP1 reduce production single_expr_ -> single_expr MINUS single_expr
-- On MINUS reduce production single_expr_ -> single_expr MINUS single_expr
-- On META reduce production single_expr_ -> single_expr MINUS single_expr
-- On LTGT reduce production single_expr_ -> single_expr MINUS single_expr
-- On LT reduce production single_expr_ -> single_expr MINUS single_expr
-- On LET reduce production single_expr_ -> single_expr MINUS single_expr
-- On LEMMA reduce production single_expr_ -> single_expr MINUS single_expr
-- On LARROW reduce production single_expr_ -> single_expr MINUS single_expr
-- On INDUCTIVE reduce production single_expr_ -> single_expr MINUS single_expr
-- On IN reduce production single_expr_ -> single_expr MINUS single_expr
-- On IMPORT reduce production single_expr_ -> single_expr MINUS single_expr
-- On GT reduce production single_expr_ -> single_expr MINUS single_expr
-- On GOAL reduce production single_expr_ -> single_expr MINUS single_expr
-- On FUNCTION reduce production single_expr_ -> single_expr MINUS single_expr
-- On EXCEPTION reduce production single_expr_ -> single_expr MINUS single_expr
-- On EQUAL reduce production single_expr_ -> single_expr MINUS single_expr
-- On EOF reduce production single_expr_ -> single_expr MINUS single_expr
-- On ENSURES reduce production single_expr_ -> single_expr MINUS single_expr
-- On END reduce production single_expr_ -> single_expr MINUS single_expr
-- On ELSE reduce production single_expr_ -> single_expr MINUS single_expr
-- On DOWNTO reduce production single_expr_ -> single_expr MINUS single_expr
-- On DOTDOT reduce production single_expr_ -> single_expr MINUS single_expr
-- On DONE reduce production single_expr_ -> single_expr MINUS single_expr
-- On DO reduce production single_expr_ -> single_expr MINUS single_expr
-- On DIVERGES reduce production single_expr_ -> single_expr MINUS single_expr
-- On CONSTANT reduce production single_expr_ -> single_expr MINUS single_expr
-- On COMMA reduce production single_expr_ -> single_expr MINUS single_expr
-- On COLON reduce production single_expr_ -> single_expr MINUS single_expr
-- On COINDUCTIVE reduce production single_expr_ -> single_expr MINUS single_expr
-- On CLONE reduce production single_expr_ -> single_expr MINUS single_expr
-- On BARBAR reduce production single_expr_ -> single_expr MINUS single_expr
-- On BAR reduce production single_expr_ -> single_expr MINUS single_expr
-- On AXIOM reduce production single_expr_ -> single_expr MINUS single_expr
-- On AMPAMP reduce production single_expr_ -> single_expr MINUS single_expr
-- On ALIAS reduce production single_expr_ -> single_expr MINUS single_expr

State 807:
## Known stack suffix:
## single_expr LTGT
## LR(1) items:
single_expr_ -> single_expr LTGT . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 808
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 808:
## Known stack suffix:
## single_expr LTGT single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr LTGT single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> single_expr LTGT single_expr
-- On WITH reduce production single_expr_ -> single_expr LTGT single_expr
-- On VARIANT reduce production single_expr_ -> single_expr LTGT single_expr
-- On VAL reduce production single_expr_ -> single_expr LTGT single_expr
-- On USE reduce production single_expr_ -> single_expr LTGT single_expr
-- On TYPE reduce production single_expr_ -> single_expr LTGT single_expr
-- On TO reduce production single_expr_ -> single_expr LTGT single_expr
-- On THEN reduce production single_expr_ -> single_expr LTGT single_expr
-- On SEMICOLON reduce production single_expr_ -> single_expr LTGT single_expr
-- On SCOPE reduce production single_expr_ -> single_expr LTGT single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> single_expr LTGT single_expr
-- On RIGHTSQ reduce production single_expr_ -> single_expr LTGT single_expr
-- On RIGHTPAR reduce production single_expr_ -> single_expr LTGT single_expr
-- On RIGHTBRC reduce production single_expr_ -> single_expr LTGT single_expr
-- On RETURNS reduce production single_expr_ -> single_expr LTGT single_expr
-- On REQUIRES reduce production single_expr_ -> single_expr LTGT single_expr
-- On READS reduce production single_expr_ -> single_expr LTGT single_expr
-- On RAISES reduce production single_expr_ -> single_expr LTGT single_expr
-- On PREDICATE reduce production single_expr_ -> single_expr LTGT single_expr
-- On META reduce production single_expr_ -> single_expr LTGT single_expr
-- On LET reduce production single_expr_ -> single_expr LTGT single_expr
-- On LEMMA reduce production single_expr_ -> single_expr LTGT single_expr
-- On LARROW reduce production single_expr_ -> single_expr LTGT single_expr
-- On INDUCTIVE reduce production single_expr_ -> single_expr LTGT single_expr
-- On IN reduce production single_expr_ -> single_expr LTGT single_expr
-- On IMPORT reduce production single_expr_ -> single_expr LTGT single_expr
-- On GOAL reduce production single_expr_ -> single_expr LTGT single_expr
-- On FUNCTION reduce production single_expr_ -> single_expr LTGT single_expr
-- On EXCEPTION reduce production single_expr_ -> single_expr LTGT single_expr
-- On EOF reduce production single_expr_ -> single_expr LTGT single_expr
-- On ENSURES reduce production single_expr_ -> single_expr LTGT single_expr
-- On END reduce production single_expr_ -> single_expr LTGT single_expr
-- On ELSE reduce production single_expr_ -> single_expr LTGT single_expr
-- On DOWNTO reduce production single_expr_ -> single_expr LTGT single_expr
-- On DOTDOT reduce production single_expr_ -> single_expr LTGT single_expr
-- On DONE reduce production single_expr_ -> single_expr LTGT single_expr
-- On DO reduce production single_expr_ -> single_expr LTGT single_expr
-- On DIVERGES reduce production single_expr_ -> single_expr LTGT single_expr
-- On CONSTANT reduce production single_expr_ -> single_expr LTGT single_expr
-- On COMMA reduce production single_expr_ -> single_expr LTGT single_expr
-- On COLON reduce production single_expr_ -> single_expr LTGT single_expr
-- On COINDUCTIVE reduce production single_expr_ -> single_expr LTGT single_expr
-- On CLONE reduce production single_expr_ -> single_expr LTGT single_expr
-- On BARBAR reduce production single_expr_ -> single_expr LTGT single_expr
-- On BAR reduce production single_expr_ -> single_expr LTGT single_expr
-- On AXIOM reduce production single_expr_ -> single_expr LTGT single_expr
-- On AMPAMP reduce production single_expr_ -> single_expr LTGT single_expr
-- On ALIAS reduce production single_expr_ -> single_expr LTGT single_expr

State 809:
## Known stack suffix:
## single_expr LT
## LR(1) items:
single_expr_ -> single_expr LT . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 810
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 810:
## Known stack suffix:
## single_expr LT single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr LT single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> single_expr LT single_expr
-- On WITH reduce production single_expr_ -> single_expr LT single_expr
-- On VARIANT reduce production single_expr_ -> single_expr LT single_expr
-- On VAL reduce production single_expr_ -> single_expr LT single_expr
-- On USE reduce production single_expr_ -> single_expr LT single_expr
-- On TYPE reduce production single_expr_ -> single_expr LT single_expr
-- On TO reduce production single_expr_ -> single_expr LT single_expr
-- On THEN reduce production single_expr_ -> single_expr LT single_expr
-- On SEMICOLON reduce production single_expr_ -> single_expr LT single_expr
-- On SCOPE reduce production single_expr_ -> single_expr LT single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> single_expr LT single_expr
-- On RIGHTSQ reduce production single_expr_ -> single_expr LT single_expr
-- On RIGHTPAR reduce production single_expr_ -> single_expr LT single_expr
-- On RIGHTBRC reduce production single_expr_ -> single_expr LT single_expr
-- On RETURNS reduce production single_expr_ -> single_expr LT single_expr
-- On REQUIRES reduce production single_expr_ -> single_expr LT single_expr
-- On READS reduce production single_expr_ -> single_expr LT single_expr
-- On RAISES reduce production single_expr_ -> single_expr LT single_expr
-- On PREDICATE reduce production single_expr_ -> single_expr LT single_expr
-- On META reduce production single_expr_ -> single_expr LT single_expr
-- On LET reduce production single_expr_ -> single_expr LT single_expr
-- On LEMMA reduce production single_expr_ -> single_expr LT single_expr
-- On LARROW reduce production single_expr_ -> single_expr LT single_expr
-- On INDUCTIVE reduce production single_expr_ -> single_expr LT single_expr
-- On IN reduce production single_expr_ -> single_expr LT single_expr
-- On IMPORT reduce production single_expr_ -> single_expr LT single_expr
-- On GOAL reduce production single_expr_ -> single_expr LT single_expr
-- On FUNCTION reduce production single_expr_ -> single_expr LT single_expr
-- On EXCEPTION reduce production single_expr_ -> single_expr LT single_expr
-- On EOF reduce production single_expr_ -> single_expr LT single_expr
-- On ENSURES reduce production single_expr_ -> single_expr LT single_expr
-- On END reduce production single_expr_ -> single_expr LT single_expr
-- On ELSE reduce production single_expr_ -> single_expr LT single_expr
-- On DOWNTO reduce production single_expr_ -> single_expr LT single_expr
-- On DOTDOT reduce production single_expr_ -> single_expr LT single_expr
-- On DONE reduce production single_expr_ -> single_expr LT single_expr
-- On DO reduce production single_expr_ -> single_expr LT single_expr
-- On DIVERGES reduce production single_expr_ -> single_expr LT single_expr
-- On CONSTANT reduce production single_expr_ -> single_expr LT single_expr
-- On COMMA reduce production single_expr_ -> single_expr LT single_expr
-- On COLON reduce production single_expr_ -> single_expr LT single_expr
-- On COINDUCTIVE reduce production single_expr_ -> single_expr LT single_expr
-- On CLONE reduce production single_expr_ -> single_expr LT single_expr
-- On BARBAR reduce production single_expr_ -> single_expr LT single_expr
-- On BAR reduce production single_expr_ -> single_expr LT single_expr
-- On AXIOM reduce production single_expr_ -> single_expr LT single_expr
-- On AMPAMP reduce production single_expr_ -> single_expr LT single_expr
-- On ALIAS reduce production single_expr_ -> single_expr LT single_expr

State 811:
## Known stack suffix:
## single_expr GT
## LR(1) items:
single_expr_ -> single_expr GT . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 812
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 812:
## Known stack suffix:
## single_expr GT single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr GT single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> single_expr GT single_expr
-- On WITH reduce production single_expr_ -> single_expr GT single_expr
-- On VARIANT reduce production single_expr_ -> single_expr GT single_expr
-- On VAL reduce production single_expr_ -> single_expr GT single_expr
-- On USE reduce production single_expr_ -> single_expr GT single_expr
-- On TYPE reduce production single_expr_ -> single_expr GT single_expr
-- On TO reduce production single_expr_ -> single_expr GT single_expr
-- On THEN reduce production single_expr_ -> single_expr GT single_expr
-- On SEMICOLON reduce production single_expr_ -> single_expr GT single_expr
-- On SCOPE reduce production single_expr_ -> single_expr GT single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> single_expr GT single_expr
-- On RIGHTSQ reduce production single_expr_ -> single_expr GT single_expr
-- On RIGHTPAR reduce production single_expr_ -> single_expr GT single_expr
-- On RIGHTBRC reduce production single_expr_ -> single_expr GT single_expr
-- On RETURNS reduce production single_expr_ -> single_expr GT single_expr
-- On REQUIRES reduce production single_expr_ -> single_expr GT single_expr
-- On READS reduce production single_expr_ -> single_expr GT single_expr
-- On RAISES reduce production single_expr_ -> single_expr GT single_expr
-- On PREDICATE reduce production single_expr_ -> single_expr GT single_expr
-- On META reduce production single_expr_ -> single_expr GT single_expr
-- On LET reduce production single_expr_ -> single_expr GT single_expr
-- On LEMMA reduce production single_expr_ -> single_expr GT single_expr
-- On LARROW reduce production single_expr_ -> single_expr GT single_expr
-- On INDUCTIVE reduce production single_expr_ -> single_expr GT single_expr
-- On IN reduce production single_expr_ -> single_expr GT single_expr
-- On IMPORT reduce production single_expr_ -> single_expr GT single_expr
-- On GOAL reduce production single_expr_ -> single_expr GT single_expr
-- On FUNCTION reduce production single_expr_ -> single_expr GT single_expr
-- On EXCEPTION reduce production single_expr_ -> single_expr GT single_expr
-- On EOF reduce production single_expr_ -> single_expr GT single_expr
-- On ENSURES reduce production single_expr_ -> single_expr GT single_expr
-- On END reduce production single_expr_ -> single_expr GT single_expr
-- On ELSE reduce production single_expr_ -> single_expr GT single_expr
-- On DOWNTO reduce production single_expr_ -> single_expr GT single_expr
-- On DOTDOT reduce production single_expr_ -> single_expr GT single_expr
-- On DONE reduce production single_expr_ -> single_expr GT single_expr
-- On DO reduce production single_expr_ -> single_expr GT single_expr
-- On DIVERGES reduce production single_expr_ -> single_expr GT single_expr
-- On CONSTANT reduce production single_expr_ -> single_expr GT single_expr
-- On COMMA reduce production single_expr_ -> single_expr GT single_expr
-- On COLON reduce production single_expr_ -> single_expr GT single_expr
-- On COINDUCTIVE reduce production single_expr_ -> single_expr GT single_expr
-- On CLONE reduce production single_expr_ -> single_expr GT single_expr
-- On BARBAR reduce production single_expr_ -> single_expr GT single_expr
-- On BAR reduce production single_expr_ -> single_expr GT single_expr
-- On AXIOM reduce production single_expr_ -> single_expr GT single_expr
-- On AMPAMP reduce production single_expr_ -> single_expr GT single_expr
-- On ALIAS reduce production single_expr_ -> single_expr GT single_expr

State 813:
## Known stack suffix:
## single_expr EQUAL
## LR(1) items:
single_expr_ -> single_expr EQUAL . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 814
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 814:
## Known stack suffix:
## single_expr EQUAL single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr EQUAL single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> single_expr EQUAL single_expr
-- On WITH reduce production single_expr_ -> single_expr EQUAL single_expr
-- On VARIANT reduce production single_expr_ -> single_expr EQUAL single_expr
-- On VAL reduce production single_expr_ -> single_expr EQUAL single_expr
-- On USE reduce production single_expr_ -> single_expr EQUAL single_expr
-- On TYPE reduce production single_expr_ -> single_expr EQUAL single_expr
-- On TO reduce production single_expr_ -> single_expr EQUAL single_expr
-- On THEN reduce production single_expr_ -> single_expr EQUAL single_expr
-- On SEMICOLON reduce production single_expr_ -> single_expr EQUAL single_expr
-- On SCOPE reduce production single_expr_ -> single_expr EQUAL single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> single_expr EQUAL single_expr
-- On RIGHTSQ reduce production single_expr_ -> single_expr EQUAL single_expr
-- On RIGHTPAR reduce production single_expr_ -> single_expr EQUAL single_expr
-- On RIGHTBRC reduce production single_expr_ -> single_expr EQUAL single_expr
-- On RETURNS reduce production single_expr_ -> single_expr EQUAL single_expr
-- On REQUIRES reduce production single_expr_ -> single_expr EQUAL single_expr
-- On READS reduce production single_expr_ -> single_expr EQUAL single_expr
-- On RAISES reduce production single_expr_ -> single_expr EQUAL single_expr
-- On PREDICATE reduce production single_expr_ -> single_expr EQUAL single_expr
-- On META reduce production single_expr_ -> single_expr EQUAL single_expr
-- On LET reduce production single_expr_ -> single_expr EQUAL single_expr
-- On LEMMA reduce production single_expr_ -> single_expr EQUAL single_expr
-- On LARROW reduce production single_expr_ -> single_expr EQUAL single_expr
-- On INDUCTIVE reduce production single_expr_ -> single_expr EQUAL single_expr
-- On IN reduce production single_expr_ -> single_expr EQUAL single_expr
-- On IMPORT reduce production single_expr_ -> single_expr EQUAL single_expr
-- On GOAL reduce production single_expr_ -> single_expr EQUAL single_expr
-- On FUNCTION reduce production single_expr_ -> single_expr EQUAL single_expr
-- On EXCEPTION reduce production single_expr_ -> single_expr EQUAL single_expr
-- On EOF reduce production single_expr_ -> single_expr EQUAL single_expr
-- On ENSURES reduce production single_expr_ -> single_expr EQUAL single_expr
-- On END reduce production single_expr_ -> single_expr EQUAL single_expr
-- On ELSE reduce production single_expr_ -> single_expr EQUAL single_expr
-- On DOWNTO reduce production single_expr_ -> single_expr EQUAL single_expr
-- On DOTDOT reduce production single_expr_ -> single_expr EQUAL single_expr
-- On DONE reduce production single_expr_ -> single_expr EQUAL single_expr
-- On DO reduce production single_expr_ -> single_expr EQUAL single_expr
-- On DIVERGES reduce production single_expr_ -> single_expr EQUAL single_expr
-- On CONSTANT reduce production single_expr_ -> single_expr EQUAL single_expr
-- On COMMA reduce production single_expr_ -> single_expr EQUAL single_expr
-- On COLON reduce production single_expr_ -> single_expr EQUAL single_expr
-- On COINDUCTIVE reduce production single_expr_ -> single_expr EQUAL single_expr
-- On CLONE reduce production single_expr_ -> single_expr EQUAL single_expr
-- On BARBAR reduce production single_expr_ -> single_expr EQUAL single_expr
-- On BAR reduce production single_expr_ -> single_expr EQUAL single_expr
-- On AXIOM reduce production single_expr_ -> single_expr EQUAL single_expr
-- On AMPAMP reduce production single_expr_ -> single_expr EQUAL single_expr
-- On ALIAS reduce production single_expr_ -> single_expr EQUAL single_expr

State 815:
## Known stack suffix:
## single_expr BARBAR
## LR(1) items:
single_expr_ -> single_expr BARBAR . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 816
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 816:
## Known stack suffix:
## single_expr BARBAR single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr BARBAR single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On BARBAR shift to state 815
-- On AMPAMP shift to state 817
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> single_expr BARBAR single_expr
-- On WITH reduce production single_expr_ -> single_expr BARBAR single_expr
-- On VARIANT reduce production single_expr_ -> single_expr BARBAR single_expr
-- On VAL reduce production single_expr_ -> single_expr BARBAR single_expr
-- On USE reduce production single_expr_ -> single_expr BARBAR single_expr
-- On TYPE reduce production single_expr_ -> single_expr BARBAR single_expr
-- On TO reduce production single_expr_ -> single_expr BARBAR single_expr
-- On THEN reduce production single_expr_ -> single_expr BARBAR single_expr
-- On SEMICOLON reduce production single_expr_ -> single_expr BARBAR single_expr
-- On SCOPE reduce production single_expr_ -> single_expr BARBAR single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> single_expr BARBAR single_expr
-- On RIGHTSQ reduce production single_expr_ -> single_expr BARBAR single_expr
-- On RIGHTPAR reduce production single_expr_ -> single_expr BARBAR single_expr
-- On RIGHTBRC reduce production single_expr_ -> single_expr BARBAR single_expr
-- On RETURNS reduce production single_expr_ -> single_expr BARBAR single_expr
-- On REQUIRES reduce production single_expr_ -> single_expr BARBAR single_expr
-- On READS reduce production single_expr_ -> single_expr BARBAR single_expr
-- On RAISES reduce production single_expr_ -> single_expr BARBAR single_expr
-- On PREDICATE reduce production single_expr_ -> single_expr BARBAR single_expr
-- On META reduce production single_expr_ -> single_expr BARBAR single_expr
-- On LET reduce production single_expr_ -> single_expr BARBAR single_expr
-- On LEMMA reduce production single_expr_ -> single_expr BARBAR single_expr
-- On LARROW reduce production single_expr_ -> single_expr BARBAR single_expr
-- On INDUCTIVE reduce production single_expr_ -> single_expr BARBAR single_expr
-- On IN reduce production single_expr_ -> single_expr BARBAR single_expr
-- On IMPORT reduce production single_expr_ -> single_expr BARBAR single_expr
-- On GOAL reduce production single_expr_ -> single_expr BARBAR single_expr
-- On FUNCTION reduce production single_expr_ -> single_expr BARBAR single_expr
-- On EXCEPTION reduce production single_expr_ -> single_expr BARBAR single_expr
-- On EOF reduce production single_expr_ -> single_expr BARBAR single_expr
-- On ENSURES reduce production single_expr_ -> single_expr BARBAR single_expr
-- On END reduce production single_expr_ -> single_expr BARBAR single_expr
-- On ELSE reduce production single_expr_ -> single_expr BARBAR single_expr
-- On DOWNTO reduce production single_expr_ -> single_expr BARBAR single_expr
-- On DOTDOT reduce production single_expr_ -> single_expr BARBAR single_expr
-- On DONE reduce production single_expr_ -> single_expr BARBAR single_expr
-- On DO reduce production single_expr_ -> single_expr BARBAR single_expr
-- On DIVERGES reduce production single_expr_ -> single_expr BARBAR single_expr
-- On CONSTANT reduce production single_expr_ -> single_expr BARBAR single_expr
-- On COMMA reduce production single_expr_ -> single_expr BARBAR single_expr
-- On COLON reduce production single_expr_ -> single_expr BARBAR single_expr
-- On COINDUCTIVE reduce production single_expr_ -> single_expr BARBAR single_expr
-- On CLONE reduce production single_expr_ -> single_expr BARBAR single_expr
-- On BAR reduce production single_expr_ -> single_expr BARBAR single_expr
-- On AXIOM reduce production single_expr_ -> single_expr BARBAR single_expr
-- On ALIAS reduce production single_expr_ -> single_expr BARBAR single_expr

State 817:
## Known stack suffix:
## single_expr AMPAMP
## LR(1) items:
single_expr_ -> single_expr AMPAMP . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 818
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 818:
## Known stack suffix:
## single_expr AMPAMP single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr AMPAMP single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On AMPAMP shift to state 817
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On WITH reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On VARIANT reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On VAL reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On USE reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On TYPE reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On TO reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On THEN reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On SEMICOLON reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On SCOPE reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On RIGHTSQ reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On RIGHTPAR reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On RIGHTBRC reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On RETURNS reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On REQUIRES reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On READS reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On RAISES reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On PREDICATE reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On META reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On LET reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On LEMMA reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On LARROW reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On INDUCTIVE reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On IN reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On IMPORT reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On GOAL reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On FUNCTION reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On EXCEPTION reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On EOF reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On ENSURES reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On END reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On ELSE reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On DOWNTO reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On DOTDOT reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On DONE reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On DO reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On DIVERGES reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On CONSTANT reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On COMMA reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On COLON reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On COINDUCTIVE reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On CLONE reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On BARBAR reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On BAR reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On AXIOM reduce production single_expr_ -> single_expr AMPAMP single_expr
-- On ALIAS reduce production single_expr_ -> single_expr AMPAMP single_expr

State 819:
## Known stack suffix:
## single_expr COMMA
## LR(1) items:
expr -> single_expr COMMA . expr_list1 [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 820
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_list1 shift to state 823
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 820:
## Known stack suffix:
## single_expr
## LR(1) items:
expr_list1 -> single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_list1 -> single_expr . COMMA expr_list1 [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On COMMA shift to state 821
-- On COLON shift to state 132
-- On BARBAR shift to state 815
-- On AMPAMP shift to state 817
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production expr_list1 -> single_expr
-- On WITH reduce production expr_list1 -> single_expr
-- On VARIANT reduce production expr_list1 -> single_expr
-- On VAL reduce production expr_list1 -> single_expr
-- On USE reduce production expr_list1 -> single_expr
-- On TYPE reduce production expr_list1 -> single_expr
-- On TO reduce production expr_list1 -> single_expr
-- On THEN reduce production expr_list1 -> single_expr
-- On SEMICOLON reduce production expr_list1 -> single_expr
-- On SCOPE reduce production expr_list1 -> single_expr
-- On RIGHTSQ_QUOTE reduce production expr_list1 -> single_expr
-- On RIGHTSQ reduce production expr_list1 -> single_expr
-- On RIGHTPAR reduce production expr_list1 -> single_expr
-- On RIGHTBRC reduce production expr_list1 -> single_expr
-- On RETURNS reduce production expr_list1 -> single_expr
-- On REQUIRES reduce production expr_list1 -> single_expr
-- On READS reduce production expr_list1 -> single_expr
-- On RAISES reduce production expr_list1 -> single_expr
-- On PREDICATE reduce production expr_list1 -> single_expr
-- On META reduce production expr_list1 -> single_expr
-- On LET reduce production expr_list1 -> single_expr
-- On LEMMA reduce production expr_list1 -> single_expr
-- On LARROW reduce production expr_list1 -> single_expr
-- On INDUCTIVE reduce production expr_list1 -> single_expr
-- On IN reduce production expr_list1 -> single_expr
-- On IMPORT reduce production expr_list1 -> single_expr
-- On GOAL reduce production expr_list1 -> single_expr
-- On FUNCTION reduce production expr_list1 -> single_expr
-- On EXCEPTION reduce production expr_list1 -> single_expr
-- On EOF reduce production expr_list1 -> single_expr
-- On ENSURES reduce production expr_list1 -> single_expr
-- On END reduce production expr_list1 -> single_expr
-- On ELSE reduce production expr_list1 -> single_expr
-- On DOWNTO reduce production expr_list1 -> single_expr
-- On DOTDOT reduce production expr_list1 -> single_expr
-- On DONE reduce production expr_list1 -> single_expr
-- On DO reduce production expr_list1 -> single_expr
-- On DIVERGES reduce production expr_list1 -> single_expr
-- On CONSTANT reduce production expr_list1 -> single_expr
-- On COINDUCTIVE reduce production expr_list1 -> single_expr
-- On CLONE reduce production expr_list1 -> single_expr
-- On BAR reduce production expr_list1 -> single_expr
-- On AXIOM reduce production expr_list1 -> single_expr
-- On ALIAS reduce production expr_list1 -> single_expr

State 821:
## Known stack suffix:
## single_expr COMMA
## LR(1) items:
expr_list1 -> single_expr COMMA . expr_list1 [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 820
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_list1 shift to state 822
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 822:
## Known stack suffix:
## single_expr COMMA expr_list1
## LR(1) items:
expr_list1 -> single_expr COMMA expr_list1 . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_list1 -> single_expr COMMA expr_list1
-- On WITH reduce production expr_list1 -> single_expr COMMA expr_list1
-- On VARIANT reduce production expr_list1 -> single_expr COMMA expr_list1
-- On VAL reduce production expr_list1 -> single_expr COMMA expr_list1
-- On USE reduce production expr_list1 -> single_expr COMMA expr_list1
-- On TYPE reduce production expr_list1 -> single_expr COMMA expr_list1
-- On TO reduce production expr_list1 -> single_expr COMMA expr_list1
-- On THEN reduce production expr_list1 -> single_expr COMMA expr_list1
-- On SEMICOLON reduce production expr_list1 -> single_expr COMMA expr_list1
-- On SCOPE reduce production expr_list1 -> single_expr COMMA expr_list1
-- On RIGHTSQ_QUOTE reduce production expr_list1 -> single_expr COMMA expr_list1
-- On RIGHTSQ reduce production expr_list1 -> single_expr COMMA expr_list1
-- On RIGHTPAR reduce production expr_list1 -> single_expr COMMA expr_list1
-- On RIGHTBRC reduce production expr_list1 -> single_expr COMMA expr_list1
-- On RETURNS reduce production expr_list1 -> single_expr COMMA expr_list1
-- On REQUIRES reduce production expr_list1 -> single_expr COMMA expr_list1
-- On READS reduce production expr_list1 -> single_expr COMMA expr_list1
-- On RAISES reduce production expr_list1 -> single_expr COMMA expr_list1
-- On PREDICATE reduce production expr_list1 -> single_expr COMMA expr_list1
-- On OP4 reduce production expr_list1 -> single_expr COMMA expr_list1
-- On OP3 reduce production expr_list1 -> single_expr COMMA expr_list1
-- On OP2 reduce production expr_list1 -> single_expr COMMA expr_list1
-- On OP1 reduce production expr_list1 -> single_expr COMMA expr_list1
-- On MINUS reduce production expr_list1 -> single_expr COMMA expr_list1
-- On META reduce production expr_list1 -> single_expr COMMA expr_list1
-- On LTGT reduce production expr_list1 -> single_expr COMMA expr_list1
-- On LT reduce production expr_list1 -> single_expr COMMA expr_list1
-- On LET reduce production expr_list1 -> single_expr COMMA expr_list1
-- On LEMMA reduce production expr_list1 -> single_expr COMMA expr_list1
-- On LARROW reduce production expr_list1 -> single_expr COMMA expr_list1
-- On INDUCTIVE reduce production expr_list1 -> single_expr COMMA expr_list1
-- On IN reduce production expr_list1 -> single_expr COMMA expr_list1
-- On IMPORT reduce production expr_list1 -> single_expr COMMA expr_list1
-- On GT reduce production expr_list1 -> single_expr COMMA expr_list1
-- On GOAL reduce production expr_list1 -> single_expr COMMA expr_list1
-- On FUNCTION reduce production expr_list1 -> single_expr COMMA expr_list1
-- On EXCEPTION reduce production expr_list1 -> single_expr COMMA expr_list1
-- On EQUAL reduce production expr_list1 -> single_expr COMMA expr_list1
-- On EOF reduce production expr_list1 -> single_expr COMMA expr_list1
-- On ENSURES reduce production expr_list1 -> single_expr COMMA expr_list1
-- On END reduce production expr_list1 -> single_expr COMMA expr_list1
-- On ELSE reduce production expr_list1 -> single_expr COMMA expr_list1
-- On DOWNTO reduce production expr_list1 -> single_expr COMMA expr_list1
-- On DOTDOT reduce production expr_list1 -> single_expr COMMA expr_list1
-- On DONE reduce production expr_list1 -> single_expr COMMA expr_list1
-- On DO reduce production expr_list1 -> single_expr COMMA expr_list1
-- On DIVERGES reduce production expr_list1 -> single_expr COMMA expr_list1
-- On CONSTANT reduce production expr_list1 -> single_expr COMMA expr_list1
-- On COMMA reduce production expr_list1 -> single_expr COMMA expr_list1
-- On COLON reduce production expr_list1 -> single_expr COMMA expr_list1
-- On COINDUCTIVE reduce production expr_list1 -> single_expr COMMA expr_list1
-- On CLONE reduce production expr_list1 -> single_expr COMMA expr_list1
-- On BARBAR reduce production expr_list1 -> single_expr COMMA expr_list1
-- On BAR reduce production expr_list1 -> single_expr COMMA expr_list1
-- On AXIOM reduce production expr_list1 -> single_expr COMMA expr_list1
-- On AMPAMP reduce production expr_list1 -> single_expr COMMA expr_list1
-- On ALIAS reduce production expr_list1 -> single_expr COMMA expr_list1

State 823:
## Known stack suffix:
## single_expr COMMA expr_list1
## LR(1) items:
expr -> single_expr COMMA expr_list1 . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr -> single_expr COMMA expr_list1
-- On WITH reduce production expr -> single_expr COMMA expr_list1
-- On VARIANT reduce production expr -> single_expr COMMA expr_list1
-- On VAL reduce production expr -> single_expr COMMA expr_list1
-- On USE reduce production expr -> single_expr COMMA expr_list1
-- On TYPE reduce production expr -> single_expr COMMA expr_list1
-- On TO reduce production expr -> single_expr COMMA expr_list1
-- On THEN reduce production expr -> single_expr COMMA expr_list1
-- On SEMICOLON reduce production expr -> single_expr COMMA expr_list1
-- On SCOPE reduce production expr -> single_expr COMMA expr_list1
-- On RIGHTSQ_QUOTE reduce production expr -> single_expr COMMA expr_list1
-- On RIGHTSQ reduce production expr -> single_expr COMMA expr_list1
-- On RIGHTPAR reduce production expr -> single_expr COMMA expr_list1
-- On RIGHTBRC reduce production expr -> single_expr COMMA expr_list1
-- On RETURNS reduce production expr -> single_expr COMMA expr_list1
-- On REQUIRES reduce production expr -> single_expr COMMA expr_list1
-- On READS reduce production expr -> single_expr COMMA expr_list1
-- On RAISES reduce production expr -> single_expr COMMA expr_list1
-- On PREDICATE reduce production expr -> single_expr COMMA expr_list1
-- On OP4 reduce production expr -> single_expr COMMA expr_list1
-- On OP3 reduce production expr -> single_expr COMMA expr_list1
-- On OP2 reduce production expr -> single_expr COMMA expr_list1
-- On OP1 reduce production expr -> single_expr COMMA expr_list1
-- On MINUS reduce production expr -> single_expr COMMA expr_list1
-- On META reduce production expr -> single_expr COMMA expr_list1
-- On LTGT reduce production expr -> single_expr COMMA expr_list1
-- On LT reduce production expr -> single_expr COMMA expr_list1
-- On LET reduce production expr -> single_expr COMMA expr_list1
-- On LEMMA reduce production expr -> single_expr COMMA expr_list1
-- On LARROW reduce production expr -> single_expr COMMA expr_list1
-- On INDUCTIVE reduce production expr -> single_expr COMMA expr_list1
-- On IN reduce production expr -> single_expr COMMA expr_list1
-- On IMPORT reduce production expr -> single_expr COMMA expr_list1
-- On GT reduce production expr -> single_expr COMMA expr_list1
-- On GOAL reduce production expr -> single_expr COMMA expr_list1
-- On FUNCTION reduce production expr -> single_expr COMMA expr_list1
-- On EXCEPTION reduce production expr -> single_expr COMMA expr_list1
-- On EQUAL reduce production expr -> single_expr COMMA expr_list1
-- On EOF reduce production expr -> single_expr COMMA expr_list1
-- On ENSURES reduce production expr -> single_expr COMMA expr_list1
-- On END reduce production expr -> single_expr COMMA expr_list1
-- On ELSE reduce production expr -> single_expr COMMA expr_list1
-- On DOWNTO reduce production expr -> single_expr COMMA expr_list1
-- On DOTDOT reduce production expr -> single_expr COMMA expr_list1
-- On DONE reduce production expr -> single_expr COMMA expr_list1
-- On DO reduce production expr -> single_expr COMMA expr_list1
-- On DIVERGES reduce production expr -> single_expr COMMA expr_list1
-- On CONSTANT reduce production expr -> single_expr COMMA expr_list1
-- On COMMA reduce production expr -> single_expr COMMA expr_list1
-- On COLON reduce production expr -> single_expr COMMA expr_list1
-- On COINDUCTIVE reduce production expr -> single_expr COMMA expr_list1
-- On CLONE reduce production expr -> single_expr COMMA expr_list1
-- On BARBAR reduce production expr -> single_expr COMMA expr_list1
-- On BAR reduce production expr -> single_expr COMMA expr_list1
-- On AXIOM reduce production expr -> single_expr COMMA expr_list1
-- On AMPAMP reduce production expr -> single_expr COMMA expr_list1
-- On ALIAS reduce production expr -> single_expr COMMA expr_list1

State 824:
## Known stack suffix:
## expr_arg LEFTSQ DOTDOT expr
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ DOTDOT expr . rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 825
## Reductions:

State 825:
## Known stack suffix:
## expr_arg LEFTSQ DOTDOT expr rightsq
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On WITH reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On VARIANT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On VAL reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On USE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On UIDENT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On TYPE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On TRUE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On TO reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On THEN reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On SEMICOLON reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On SCOPE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On RIGHTSQ_QUOTE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On RIGHTSQ reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On RIGHTPAR reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On RIGHTBRC reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On RETURNS reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On REQUIRES reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On REAL reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On READS reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On RANGE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On RAISES reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On PURE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On PREDICATE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On OPPREF reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On OP4 reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On OP3 reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On OP2 reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On OP1 reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On MINUS reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On META reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On LTGT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On LT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On LIDENT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On LET reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On LEMMA reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On LEFTSQ reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On LEFTPAR reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On LEFTBRC reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On LARROW reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On INTEGER reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On INDUCTIVE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On IN reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On IMPORT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On GT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On GOAL reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On FUNCTION reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On FLOAT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On FALSE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On EXCEPTION reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On EQUAL reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On EOF reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On ENSURES reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On END reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On ELSE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On DOWNTO reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On DOTDOT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On DOT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On DONE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On DO reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On DIVERGES reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On CORE_UIDENT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On CORE_LIDENT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On CONSTANT reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On COMMA reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On COLON reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On COINDUCTIVE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On CLONE reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On BEGIN reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On BARBAR reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On BAR reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On AXIOM reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On AMPAMP reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq
-- On ALIAS reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq

State 826:
## Known stack suffix:
## expr_arg LEFTSQ expr
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr . rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ expr . LARROW expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ expr . DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ expr . DOTDOT rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On LARROW shift to state 827
-- On DOTDOT shift to state 830
-- On rightsq shift to state 834
## Reductions:

State 827:
## Known stack suffix:
## expr_arg LEFTSQ expr LARROW
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr LARROW . expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 828
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 828:
## Known stack suffix:
## expr_arg LEFTSQ expr LARROW expr
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr LARROW expr . rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 829
## Reductions:

State 829:
## Known stack suffix:
## expr_arg LEFTSQ expr LARROW expr rightsq
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On WITH reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On VARIANT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On VAL reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On USE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On UIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On TYPE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On TRUE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On TO reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On THEN reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On SEMICOLON reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On SCOPE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On RIGHTSQ_QUOTE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On RIGHTSQ reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On RIGHTPAR reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On RIGHTBRC reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On RETURNS reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On REQUIRES reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On REAL reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On READS reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On RANGE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On RAISES reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On PURE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On PREDICATE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On OPPREF reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On OP4 reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On OP3 reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On OP2 reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On OP1 reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On MINUS reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On META reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On LTGT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On LT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On LIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On LET reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On LEMMA reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On LEFTSQ reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On LEFTPAR reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On LEFTBRC reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On LARROW reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On INTEGER reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On INDUCTIVE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On IN reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On IMPORT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On GT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On GOAL reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On FUNCTION reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On FLOAT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On FALSE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On EXCEPTION reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On EQUAL reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On EOF reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On ENSURES reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On END reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On ELSE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On DOWNTO reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On DOTDOT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On DOT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On DONE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On DO reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On DIVERGES reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On CORE_UIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On CORE_LIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On CONSTANT reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On COMMA reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On COLON reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On COINDUCTIVE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On CLONE reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On BEGIN reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On BARBAR reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On BAR reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On AXIOM reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On AMPAMP reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq
-- On ALIAS reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq

State 830:
## Known stack suffix:
## expr_arg LEFTSQ expr DOTDOT
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr DOTDOT . expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ expr DOTDOT . rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On rightsq shift to state 831
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 832
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 831:
## Known stack suffix:
## expr_arg LEFTSQ expr DOTDOT rightsq
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On WITH reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On VARIANT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On VAL reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On USE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On UIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On TYPE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On TRUE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On TO reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On THEN reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On SEMICOLON reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On SCOPE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On RIGHTSQ_QUOTE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On RIGHTSQ reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On RIGHTPAR reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On RIGHTBRC reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On RETURNS reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On REQUIRES reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On REAL reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On READS reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On RANGE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On RAISES reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On PURE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On PREDICATE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On OPPREF reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On OP4 reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On OP3 reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On OP2 reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On OP1 reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On MINUS reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On META reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On LTGT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On LT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On LIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On LET reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On LEMMA reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On LEFTSQ reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On LEFTPAR reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On LEFTBRC reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On LARROW reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On INTEGER reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On INDUCTIVE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On IN reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On IMPORT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On GT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On GOAL reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On FUNCTION reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On FLOAT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On FALSE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On EXCEPTION reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On EQUAL reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On EOF reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On ENSURES reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On END reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On ELSE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On DOWNTO reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On DOTDOT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On DOT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On DONE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On DO reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On DIVERGES reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On CORE_UIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On CORE_LIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On CONSTANT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On COMMA reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On COLON reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On COINDUCTIVE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On CLONE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On BEGIN reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On BARBAR reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On BAR reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On AXIOM reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On AMPAMP reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq
-- On ALIAS reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq

State 832:
## Known stack suffix:
## expr_arg LEFTSQ expr DOTDOT expr
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr . rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 833
## Reductions:

State 833:
## Known stack suffix:
## expr_arg LEFTSQ expr DOTDOT expr rightsq
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On WITH reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On VARIANT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On VAL reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On USE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On UIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On TYPE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On TRUE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On TO reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On THEN reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On SEMICOLON reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On SCOPE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On RIGHTSQ_QUOTE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On RIGHTSQ reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On RIGHTPAR reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On RIGHTBRC reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On RETURNS reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On REQUIRES reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On REAL reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On READS reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On RANGE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On RAISES reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On PURE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On PREDICATE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On OPPREF reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On OP4 reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On OP3 reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On OP2 reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On OP1 reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On MINUS reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On META reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On LTGT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On LT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On LIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On LET reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On LEMMA reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On LEFTSQ reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On LEFTPAR reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On LEFTBRC reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On LARROW reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On INTEGER reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On INDUCTIVE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On IN reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On IMPORT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On GT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On GOAL reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On FUNCTION reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On FLOAT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On FALSE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On EXCEPTION reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On EQUAL reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On EOF reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On ENSURES reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On END reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On ELSE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On DOWNTO reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On DOTDOT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On DOT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On DONE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On DO reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On DIVERGES reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On CORE_UIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On CORE_LIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On CONSTANT reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On COMMA reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On COLON reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On COINDUCTIVE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On CLONE reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On BEGIN reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On BARBAR reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On BAR reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On AXIOM reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On AMPAMP reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq
-- On ALIAS reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq

State 834:
## Known stack suffix:
## expr_arg LEFTSQ expr rightsq
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr rightsq . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On WITH reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On VARIANT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On VAL reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On USE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On UIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On TYPE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On TRUE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On TO reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On THEN reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On SEMICOLON reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On SCOPE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On RIGHTSQ_QUOTE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On RIGHTSQ reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On RIGHTPAR reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On RIGHTBRC reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On RETURNS reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On REQUIRES reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On REAL reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On READS reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On RANGE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On RAISES reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On PURE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On PREDICATE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On OPPREF reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On OP4 reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On OP3 reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On OP2 reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On OP1 reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On MINUS reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On META reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On LTGT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On LT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On LIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On LET reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On LEMMA reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On LEFTSQ reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On LEFTPAR reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On LEFTBRC reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On LARROW reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On INTEGER reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On INDUCTIVE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On IN reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On IMPORT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On GT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On GOAL reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On FUNCTION reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On FLOAT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On FALSE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On EXCEPTION reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On EQUAL reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On EOF reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On ENSURES reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On END reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On ELSE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On DOWNTO reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On DOTDOT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On DOT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On DONE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On DO reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On DIVERGES reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On CORE_UIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On CORE_LIDENT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On CONSTANT reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On COMMA reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On COLON reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On COINDUCTIVE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On CLONE reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On BEGIN reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On BARBAR reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On BAR reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On AXIOM reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On AMPAMP reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq
-- On ALIAS reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq

State 835:
## Known stack suffix:
## EXCEPTION attrs(uident) IN seq_expr
## LR(1) items:
single_expr_ -> EXCEPTION attrs(uident) IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On WITH reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On VARIANT reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On VAL reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On USE reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On TYPE reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On TO reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On THEN reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On SEMICOLON reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On SCOPE reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On RIGHTSQ reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On RIGHTPAR reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On RIGHTBRC reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On RETURNS reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On REQUIRES reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On READS reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On RAISES reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On PREDICATE reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On OP4 reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On OP3 reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On OP2 reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On OP1 reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On MINUS reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On META reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On LTGT reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On LT reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On LET reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On LEMMA reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On LARROW reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On INDUCTIVE reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On IN reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On IMPORT reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On GT reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On GOAL reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On FUNCTION reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On EXCEPTION reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On EQUAL reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On EOF reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On ENSURES reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On END reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On ELSE reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On DOWNTO reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On DOTDOT reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On DONE reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On DO reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On DIVERGES reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On CONSTANT reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On COMMA reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On COLON reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On COINDUCTIVE reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On CLONE reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On BARBAR reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On BAR reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On AXIOM reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On AMPAMP reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr
-- On ALIAS reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr

State 836:
## Known stack suffix:
## expr
## LR(1) items:
assign_expr -> expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
assign_expr -> expr . LARROW expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On LARROW shift to state 837
## Reductions:
-- On WRITES reduce production assign_expr -> expr
-- On WITH reduce production assign_expr -> expr
-- On VARIANT reduce production assign_expr -> expr
-- On VAL reduce production assign_expr -> expr
-- On USE reduce production assign_expr -> expr
-- On TYPE reduce production assign_expr -> expr
-- On TO reduce production assign_expr -> expr
-- On THEN reduce production assign_expr -> expr
-- On SEMICOLON reduce production assign_expr -> expr
-- On SCOPE reduce production assign_expr -> expr
-- On RIGHTSQ_QUOTE reduce production assign_expr -> expr
-- On RIGHTSQ reduce production assign_expr -> expr
-- On RIGHTPAR reduce production assign_expr -> expr
-- On RIGHTBRC reduce production assign_expr -> expr
-- On RETURNS reduce production assign_expr -> expr
-- On REQUIRES reduce production assign_expr -> expr
-- On READS reduce production assign_expr -> expr
-- On RAISES reduce production assign_expr -> expr
-- On PREDICATE reduce production assign_expr -> expr
-- On OP4 reduce production assign_expr -> expr
-- On OP3 reduce production assign_expr -> expr
-- On OP2 reduce production assign_expr -> expr
-- On OP1 reduce production assign_expr -> expr
-- On MINUS reduce production assign_expr -> expr
-- On META reduce production assign_expr -> expr
-- On LTGT reduce production assign_expr -> expr
-- On LT reduce production assign_expr -> expr
-- On LET reduce production assign_expr -> expr
-- On LEMMA reduce production assign_expr -> expr
-- On INDUCTIVE reduce production assign_expr -> expr
-- On IN reduce production assign_expr -> expr
-- On IMPORT reduce production assign_expr -> expr
-- On GT reduce production assign_expr -> expr
-- On GOAL reduce production assign_expr -> expr
-- On FUNCTION reduce production assign_expr -> expr
-- On EXCEPTION reduce production assign_expr -> expr
-- On EQUAL reduce production assign_expr -> expr
-- On EOF reduce production assign_expr -> expr
-- On ENSURES reduce production assign_expr -> expr
-- On END reduce production assign_expr -> expr
-- On ELSE reduce production assign_expr -> expr
-- On DOWNTO reduce production assign_expr -> expr
-- On DOTDOT reduce production assign_expr -> expr
-- On DONE reduce production assign_expr -> expr
-- On DO reduce production assign_expr -> expr
-- On DIVERGES reduce production assign_expr -> expr
-- On CONSTANT reduce production assign_expr -> expr
-- On COMMA reduce production assign_expr -> expr
-- On COLON reduce production assign_expr -> expr
-- On COINDUCTIVE reduce production assign_expr -> expr
-- On CLONE reduce production assign_expr -> expr
-- On BARBAR reduce production assign_expr -> expr
-- On BAR reduce production assign_expr -> expr
-- On AXIOM reduce production assign_expr -> expr
-- On AMPAMP reduce production assign_expr -> expr
-- On ALIAS reduce production assign_expr -> expr

State 837:
## Known stack suffix:
## expr LARROW
## LR(1) items:
assign_expr -> expr LARROW . expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 838
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 838:
## Known stack suffix:
## expr LARROW expr
## LR(1) items:
assign_expr -> expr LARROW expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production assign_expr -> expr LARROW expr
-- On WITH reduce production assign_expr -> expr LARROW expr
-- On VARIANT reduce production assign_expr -> expr LARROW expr
-- On VAL reduce production assign_expr -> expr LARROW expr
-- On USE reduce production assign_expr -> expr LARROW expr
-- On TYPE reduce production assign_expr -> expr LARROW expr
-- On TO reduce production assign_expr -> expr LARROW expr
-- On THEN reduce production assign_expr -> expr LARROW expr
-- On SEMICOLON reduce production assign_expr -> expr LARROW expr
-- On SCOPE reduce production assign_expr -> expr LARROW expr
-- On RIGHTSQ_QUOTE reduce production assign_expr -> expr LARROW expr
-- On RIGHTSQ reduce production assign_expr -> expr LARROW expr
-- On RIGHTPAR reduce production assign_expr -> expr LARROW expr
-- On RIGHTBRC reduce production assign_expr -> expr LARROW expr
-- On RETURNS reduce production assign_expr -> expr LARROW expr
-- On REQUIRES reduce production assign_expr -> expr LARROW expr
-- On READS reduce production assign_expr -> expr LARROW expr
-- On RAISES reduce production assign_expr -> expr LARROW expr
-- On PREDICATE reduce production assign_expr -> expr LARROW expr
-- On OP4 reduce production assign_expr -> expr LARROW expr
-- On OP3 reduce production assign_expr -> expr LARROW expr
-- On OP2 reduce production assign_expr -> expr LARROW expr
-- On OP1 reduce production assign_expr -> expr LARROW expr
-- On MINUS reduce production assign_expr -> expr LARROW expr
-- On META reduce production assign_expr -> expr LARROW expr
-- On LTGT reduce production assign_expr -> expr LARROW expr
-- On LT reduce production assign_expr -> expr LARROW expr
-- On LET reduce production assign_expr -> expr LARROW expr
-- On LEMMA reduce production assign_expr -> expr LARROW expr
-- On LARROW reduce production assign_expr -> expr LARROW expr
-- On INDUCTIVE reduce production assign_expr -> expr LARROW expr
-- On IN reduce production assign_expr -> expr LARROW expr
-- On IMPORT reduce production assign_expr -> expr LARROW expr
-- On GT reduce production assign_expr -> expr LARROW expr
-- On GOAL reduce production assign_expr -> expr LARROW expr
-- On FUNCTION reduce production assign_expr -> expr LARROW expr
-- On EXCEPTION reduce production assign_expr -> expr LARROW expr
-- On EQUAL reduce production assign_expr -> expr LARROW expr
-- On EOF reduce production assign_expr -> expr LARROW expr
-- On ENSURES reduce production assign_expr -> expr LARROW expr
-- On END reduce production assign_expr -> expr LARROW expr
-- On ELSE reduce production assign_expr -> expr LARROW expr
-- On DOWNTO reduce production assign_expr -> expr LARROW expr
-- On DOTDOT reduce production assign_expr -> expr LARROW expr
-- On DONE reduce production assign_expr -> expr LARROW expr
-- On DO reduce production assign_expr -> expr LARROW expr
-- On DIVERGES reduce production assign_expr -> expr LARROW expr
-- On CONSTANT reduce production assign_expr -> expr LARROW expr
-- On COMMA reduce production assign_expr -> expr LARROW expr
-- On COLON reduce production assign_expr -> expr LARROW expr
-- On COINDUCTIVE reduce production assign_expr -> expr LARROW expr
-- On CLONE reduce production assign_expr -> expr LARROW expr
-- On BARBAR reduce production assign_expr -> expr LARROW expr
-- On BAR reduce production assign_expr -> expr LARROW expr
-- On AXIOM reduce production assign_expr -> expr LARROW expr
-- On AMPAMP reduce production assign_expr -> expr LARROW expr
-- On ALIAS reduce production assign_expr -> expr LARROW expr

State 839:
## Known stack suffix:
## contract_expr
## LR(1) items:
seq_expr -> contract_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
seq_expr -> contract_expr . SEMICOLON [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
seq_expr -> contract_expr . SEMICOLON seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On SEMICOLON shift to state 840
## Reductions:
-- On WRITES reduce production seq_expr -> contract_expr
-- On WITH reduce production seq_expr -> contract_expr
-- On VARIANT reduce production seq_expr -> contract_expr
-- On VAL reduce production seq_expr -> contract_expr
-- On USE reduce production seq_expr -> contract_expr
-- On TYPE reduce production seq_expr -> contract_expr
-- On TO reduce production seq_expr -> contract_expr
-- On THEN reduce production seq_expr -> contract_expr
-- On SCOPE reduce production seq_expr -> contract_expr
-- On RIGHTSQ_QUOTE reduce production seq_expr -> contract_expr
-- On RIGHTSQ reduce production seq_expr -> contract_expr
-- On RIGHTPAR reduce production seq_expr -> contract_expr
-- On RIGHTBRC reduce production seq_expr -> contract_expr
-- On RETURNS reduce production seq_expr -> contract_expr
-- On REQUIRES reduce production seq_expr -> contract_expr
-- On READS reduce production seq_expr -> contract_expr
-- On RAISES reduce production seq_expr -> contract_expr
-- On PREDICATE reduce production seq_expr -> contract_expr
-- On OP4 reduce production seq_expr -> contract_expr
-- On OP3 reduce production seq_expr -> contract_expr
-- On OP2 reduce production seq_expr -> contract_expr
-- On OP1 reduce production seq_expr -> contract_expr
-- On MINUS reduce production seq_expr -> contract_expr
-- On META reduce production seq_expr -> contract_expr
-- On LTGT reduce production seq_expr -> contract_expr
-- On LT reduce production seq_expr -> contract_expr
-- On LET reduce production seq_expr -> contract_expr
-- On LEMMA reduce production seq_expr -> contract_expr
-- On LARROW reduce production seq_expr -> contract_expr
-- On INDUCTIVE reduce production seq_expr -> contract_expr
-- On IN reduce production seq_expr -> contract_expr
-- On IMPORT reduce production seq_expr -> contract_expr
-- On GT reduce production seq_expr -> contract_expr
-- On GOAL reduce production seq_expr -> contract_expr
-- On FUNCTION reduce production seq_expr -> contract_expr
-- On EXCEPTION reduce production seq_expr -> contract_expr
-- On EQUAL reduce production seq_expr -> contract_expr
-- On EOF reduce production seq_expr -> contract_expr
-- On ENSURES reduce production seq_expr -> contract_expr
-- On END reduce production seq_expr -> contract_expr
-- On ELSE reduce production seq_expr -> contract_expr
-- On DOWNTO reduce production seq_expr -> contract_expr
-- On DOTDOT reduce production seq_expr -> contract_expr
-- On DONE reduce production seq_expr -> contract_expr
-- On DO reduce production seq_expr -> contract_expr
-- On DIVERGES reduce production seq_expr -> contract_expr
-- On CONSTANT reduce production seq_expr -> contract_expr
-- On COMMA reduce production seq_expr -> contract_expr
-- On COLON reduce production seq_expr -> contract_expr
-- On COINDUCTIVE reduce production seq_expr -> contract_expr
-- On CLONE reduce production seq_expr -> contract_expr
-- On BARBAR reduce production seq_expr -> contract_expr
-- On BAR reduce production seq_expr -> contract_expr
-- On AXIOM reduce production seq_expr -> contract_expr
-- On AMPAMP reduce production seq_expr -> contract_expr
-- On ALIAS reduce production seq_expr -> contract_expr

State 840:
## Known stack suffix:
## contract_expr SEMICOLON
## LR(1) items:
seq_expr -> contract_expr SEMICOLON . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
seq_expr -> contract_expr SEMICOLON . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 841
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:
-- On WRITES reduce production seq_expr -> contract_expr SEMICOLON
-- On WITH reduce production seq_expr -> contract_expr SEMICOLON
-- On VARIANT reduce production seq_expr -> contract_expr SEMICOLON
-- On USE reduce production seq_expr -> contract_expr SEMICOLON
-- On TYPE reduce production seq_expr -> contract_expr SEMICOLON
-- On TO reduce production seq_expr -> contract_expr SEMICOLON
-- On THEN reduce production seq_expr -> contract_expr SEMICOLON
-- On SEMICOLON reduce production seq_expr -> contract_expr SEMICOLON
-- On SCOPE reduce production seq_expr -> contract_expr SEMICOLON
-- On RIGHTSQ_QUOTE reduce production seq_expr -> contract_expr SEMICOLON
-- On RIGHTSQ reduce production seq_expr -> contract_expr SEMICOLON
-- On RIGHTPAR reduce production seq_expr -> contract_expr SEMICOLON
-- On RIGHTBRC reduce production seq_expr -> contract_expr SEMICOLON
-- On RETURNS reduce production seq_expr -> contract_expr SEMICOLON
-- On REQUIRES reduce production seq_expr -> contract_expr SEMICOLON
-- On READS reduce production seq_expr -> contract_expr SEMICOLON
-- On RAISES reduce production seq_expr -> contract_expr SEMICOLON
-- On PREDICATE reduce production seq_expr -> contract_expr SEMICOLON
-- On META reduce production seq_expr -> contract_expr SEMICOLON
-- On LTGT reduce production seq_expr -> contract_expr SEMICOLON
-- On LEMMA reduce production seq_expr -> contract_expr SEMICOLON
-- On LARROW reduce production seq_expr -> contract_expr SEMICOLON
-- On INDUCTIVE reduce production seq_expr -> contract_expr SEMICOLON
-- On IN reduce production seq_expr -> contract_expr SEMICOLON
-- On IMPORT reduce production seq_expr -> contract_expr SEMICOLON
-- On GOAL reduce production seq_expr -> contract_expr SEMICOLON
-- On FUNCTION reduce production seq_expr -> contract_expr SEMICOLON
-- On EQUAL reduce production seq_expr -> contract_expr SEMICOLON
-- On EOF reduce production seq_expr -> contract_expr SEMICOLON
-- On ENSURES reduce production seq_expr -> contract_expr SEMICOLON
-- On END reduce production seq_expr -> contract_expr SEMICOLON
-- On ELSE reduce production seq_expr -> contract_expr SEMICOLON
-- On DOWNTO reduce production seq_expr -> contract_expr SEMICOLON
-- On DOTDOT reduce production seq_expr -> contract_expr SEMICOLON
-- On DONE reduce production seq_expr -> contract_expr SEMICOLON
-- On DO reduce production seq_expr -> contract_expr SEMICOLON
-- On DIVERGES reduce production seq_expr -> contract_expr SEMICOLON
-- On CONSTANT reduce production seq_expr -> contract_expr SEMICOLON
-- On COMMA reduce production seq_expr -> contract_expr SEMICOLON
-- On COLON reduce production seq_expr -> contract_expr SEMICOLON
-- On COINDUCTIVE reduce production seq_expr -> contract_expr SEMICOLON
-- On CLONE reduce production seq_expr -> contract_expr SEMICOLON
-- On BARBAR reduce production seq_expr -> contract_expr SEMICOLON
-- On BAR reduce production seq_expr -> contract_expr SEMICOLON
-- On AXIOM reduce production seq_expr -> contract_expr SEMICOLON
-- On AMPAMP reduce production seq_expr -> contract_expr SEMICOLON
-- On ALIAS reduce production seq_expr -> contract_expr SEMICOLON

State 841:
## Known stack suffix:
## contract_expr SEMICOLON seq_expr
## LR(1) items:
seq_expr -> contract_expr SEMICOLON seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On WITH reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On VARIANT reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On VAL reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On USE reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On TYPE reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On TO reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On THEN reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On SEMICOLON reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On SCOPE reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On RIGHTSQ_QUOTE reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On RIGHTSQ reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On RIGHTPAR reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On RIGHTBRC reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On RETURNS reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On REQUIRES reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On READS reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On RAISES reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On PREDICATE reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On OP4 reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On OP3 reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On OP2 reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On OP1 reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On MINUS reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On META reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On LTGT reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On LT reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On LET reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On LEMMA reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On LARROW reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On INDUCTIVE reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On IN reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On IMPORT reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On GT reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On GOAL reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On FUNCTION reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On EXCEPTION reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On EQUAL reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On EOF reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On ENSURES reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On END reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On ELSE reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On DOWNTO reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On DOTDOT reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On DONE reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On DO reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On DIVERGES reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On CONSTANT reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On COMMA reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On COLON reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On COINDUCTIVE reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On CLONE reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On BARBAR reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On BAR reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On AXIOM reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On AMPAMP reduce production seq_expr -> contract_expr SEMICOLON seq_expr
-- On ALIAS reduce production seq_expr -> contract_expr SEMICOLON seq_expr

State 842:
## Known stack suffix:
## assign_expr
## LR(1) items:
contract_expr -> assign_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
contract_expr -> assign_expr . single_spec spec [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On single_spec shift to state 843
## Reductions:
-- On WITH reduce production contract_expr -> assign_expr
-- On VAL reduce production contract_expr -> assign_expr
-- On USE reduce production contract_expr -> assign_expr
-- On TYPE reduce production contract_expr -> assign_expr
-- On TO reduce production contract_expr -> assign_expr
-- On THEN reduce production contract_expr -> assign_expr
-- On SEMICOLON reduce production contract_expr -> assign_expr
-- On SCOPE reduce production contract_expr -> assign_expr
-- On RIGHTSQ_QUOTE reduce production contract_expr -> assign_expr
-- On RIGHTSQ reduce production contract_expr -> assign_expr
-- On RIGHTPAR reduce production contract_expr -> assign_expr
-- On RIGHTBRC reduce production contract_expr -> assign_expr
-- On PREDICATE reduce production contract_expr -> assign_expr
-- On OP4 reduce production contract_expr -> assign_expr
-- On OP3 reduce production contract_expr -> assign_expr
-- On OP2 reduce production contract_expr -> assign_expr
-- On OP1 reduce production contract_expr -> assign_expr
-- On MINUS reduce production contract_expr -> assign_expr
-- On META reduce production contract_expr -> assign_expr
-- On LTGT reduce production contract_expr -> assign_expr
-- On LT reduce production contract_expr -> assign_expr
-- On LET reduce production contract_expr -> assign_expr
-- On LEMMA reduce production contract_expr -> assign_expr
-- On LARROW reduce production contract_expr -> assign_expr
-- On INDUCTIVE reduce production contract_expr -> assign_expr
-- On IN reduce production contract_expr -> assign_expr
-- On IMPORT reduce production contract_expr -> assign_expr
-- On GT reduce production contract_expr -> assign_expr
-- On GOAL reduce production contract_expr -> assign_expr
-- On FUNCTION reduce production contract_expr -> assign_expr
-- On EXCEPTION reduce production contract_expr -> assign_expr
-- On EQUAL reduce production contract_expr -> assign_expr
-- On EOF reduce production contract_expr -> assign_expr
-- On END reduce production contract_expr -> assign_expr
-- On ELSE reduce production contract_expr -> assign_expr
-- On DOWNTO reduce production contract_expr -> assign_expr
-- On DOTDOT reduce production contract_expr -> assign_expr
-- On DONE reduce production contract_expr -> assign_expr
-- On DO reduce production contract_expr -> assign_expr
-- On CONSTANT reduce production contract_expr -> assign_expr
-- On COMMA reduce production contract_expr -> assign_expr
-- On COLON reduce production contract_expr -> assign_expr
-- On COINDUCTIVE reduce production contract_expr -> assign_expr
-- On CLONE reduce production contract_expr -> assign_expr
-- On BARBAR reduce production contract_expr -> assign_expr
-- On BAR reduce production contract_expr -> assign_expr
-- On AXIOM reduce production contract_expr -> assign_expr
-- On AMPAMP reduce production contract_expr -> assign_expr

State 843:
## Known stack suffix:
## assign_expr single_spec
## LR(1) items:
contract_expr -> assign_expr single_spec . spec [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 844
-- On single_spec shift to state 567
## Reductions:
-- On WITH reduce production spec ->
-- On VAL reduce production spec ->
-- On USE reduce production spec ->
-- On TYPE reduce production spec ->
-- On TO reduce production spec ->
-- On THEN reduce production spec ->
-- On SEMICOLON reduce production spec ->
-- On SCOPE reduce production spec ->
-- On RIGHTSQ_QUOTE reduce production spec ->
-- On RIGHTSQ reduce production spec ->
-- On RIGHTPAR reduce production spec ->
-- On RIGHTBRC reduce production spec ->
-- On PREDICATE reduce production spec ->
-- On OP4 reduce production spec ->
-- On OP3 reduce production spec ->
-- On OP2 reduce production spec ->
-- On OP1 reduce production spec ->
-- On MINUS reduce production spec ->
-- On META reduce production spec ->
-- On LTGT reduce production spec ->
-- On LT reduce production spec ->
-- On LET reduce production spec ->
-- On LEMMA reduce production spec ->
-- On LARROW reduce production spec ->
-- On INDUCTIVE reduce production spec ->
-- On IN reduce production spec ->
-- On IMPORT reduce production spec ->
-- On GT reduce production spec ->
-- On GOAL reduce production spec ->
-- On FUNCTION reduce production spec ->
-- On EXCEPTION reduce production spec ->
-- On EQUAL reduce production spec ->
-- On EOF reduce production spec ->
-- On END reduce production spec ->
-- On ELSE reduce production spec ->
-- On DOWNTO reduce production spec ->
-- On DOTDOT reduce production spec ->
-- On DONE reduce production spec ->
-- On DO reduce production spec ->
-- On CONSTANT reduce production spec ->
-- On COMMA reduce production spec ->
-- On COLON reduce production spec ->
-- On COINDUCTIVE reduce production spec ->
-- On CLONE reduce production spec ->
-- On BARBAR reduce production spec ->
-- On BAR reduce production spec ->
-- On AXIOM reduce production spec ->
-- On AMPAMP reduce production spec ->

State 844:
## Known stack suffix:
## assign_expr single_spec spec
## LR(1) items:
contract_expr -> assign_expr single_spec spec . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production contract_expr -> assign_expr single_spec spec
-- On WITH reduce production contract_expr -> assign_expr single_spec spec
-- On VARIANT reduce production contract_expr -> assign_expr single_spec spec
-- On VAL reduce production contract_expr -> assign_expr single_spec spec
-- On USE reduce production contract_expr -> assign_expr single_spec spec
-- On TYPE reduce production contract_expr -> assign_expr single_spec spec
-- On TO reduce production contract_expr -> assign_expr single_spec spec
-- On THEN reduce production contract_expr -> assign_expr single_spec spec
-- On SEMICOLON reduce production contract_expr -> assign_expr single_spec spec
-- On SCOPE reduce production contract_expr -> assign_expr single_spec spec
-- On RIGHTSQ_QUOTE reduce production contract_expr -> assign_expr single_spec spec
-- On RIGHTSQ reduce production contract_expr -> assign_expr single_spec spec
-- On RIGHTPAR reduce production contract_expr -> assign_expr single_spec spec
-- On RIGHTBRC reduce production contract_expr -> assign_expr single_spec spec
-- On RETURNS reduce production contract_expr -> assign_expr single_spec spec
-- On REQUIRES reduce production contract_expr -> assign_expr single_spec spec
-- On READS reduce production contract_expr -> assign_expr single_spec spec
-- On RAISES reduce production contract_expr -> assign_expr single_spec spec
-- On PREDICATE reduce production contract_expr -> assign_expr single_spec spec
-- On OP4 reduce production contract_expr -> assign_expr single_spec spec
-- On OP3 reduce production contract_expr -> assign_expr single_spec spec
-- On OP2 reduce production contract_expr -> assign_expr single_spec spec
-- On OP1 reduce production contract_expr -> assign_expr single_spec spec
-- On MINUS reduce production contract_expr -> assign_expr single_spec spec
-- On META reduce production contract_expr -> assign_expr single_spec spec
-- On LTGT reduce production contract_expr -> assign_expr single_spec spec
-- On LT reduce production contract_expr -> assign_expr single_spec spec
-- On LET reduce production contract_expr -> assign_expr single_spec spec
-- On LEMMA reduce production contract_expr -> assign_expr single_spec spec
-- On LARROW reduce production contract_expr -> assign_expr single_spec spec
-- On INDUCTIVE reduce production contract_expr -> assign_expr single_spec spec
-- On IN reduce production contract_expr -> assign_expr single_spec spec
-- On IMPORT reduce production contract_expr -> assign_expr single_spec spec
-- On GT reduce production contract_expr -> assign_expr single_spec spec
-- On GOAL reduce production contract_expr -> assign_expr single_spec spec
-- On FUNCTION reduce production contract_expr -> assign_expr single_spec spec
-- On EXCEPTION reduce production contract_expr -> assign_expr single_spec spec
-- On EQUAL reduce production contract_expr -> assign_expr single_spec spec
-- On EOF reduce production contract_expr -> assign_expr single_spec spec
-- On ENSURES reduce production contract_expr -> assign_expr single_spec spec
-- On END reduce production contract_expr -> assign_expr single_spec spec
-- On ELSE reduce production contract_expr -> assign_expr single_spec spec
-- On DOWNTO reduce production contract_expr -> assign_expr single_spec spec
-- On DOTDOT reduce production contract_expr -> assign_expr single_spec spec
-- On DONE reduce production contract_expr -> assign_expr single_spec spec
-- On DO reduce production contract_expr -> assign_expr single_spec spec
-- On DIVERGES reduce production contract_expr -> assign_expr single_spec spec
-- On CONSTANT reduce production contract_expr -> assign_expr single_spec spec
-- On COMMA reduce production contract_expr -> assign_expr single_spec spec
-- On COLON reduce production contract_expr -> assign_expr single_spec spec
-- On COINDUCTIVE reduce production contract_expr -> assign_expr single_spec spec
-- On CLONE reduce production contract_expr -> assign_expr single_spec spec
-- On BARBAR reduce production contract_expr -> assign_expr single_spec spec
-- On BAR reduce production contract_expr -> assign_expr single_spec spec
-- On AXIOM reduce production contract_expr -> assign_expr single_spec spec
-- On AMPAMP reduce production contract_expr -> assign_expr single_spec spec
-- On ALIAS reduce production contract_expr -> assign_expr single_spec spec

State 845:
## Known stack suffix:
## EXCEPTION attrs(uident) return
## LR(1) items:
single_expr_ -> EXCEPTION attrs(uident) return . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 846
## Reductions:

State 846:
## Known stack suffix:
## EXCEPTION attrs(uident) return IN
## LR(1) items:
single_expr_ -> EXCEPTION attrs(uident) return IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 847
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 847:
## Known stack suffix:
## EXCEPTION attrs(uident) return IN seq_expr
## LR(1) items:
single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On WITH reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On VARIANT reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On VAL reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On USE reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On TYPE reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On TO reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On THEN reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On SEMICOLON reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On SCOPE reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On RIGHTSQ reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On RIGHTPAR reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On RIGHTBRC reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On RETURNS reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On REQUIRES reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On READS reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On RAISES reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On PREDICATE reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On OP4 reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On OP3 reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On OP2 reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On OP1 reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On MINUS reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On META reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On LTGT reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On LT reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On LET reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On LEMMA reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On LARROW reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On INDUCTIVE reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On IN reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On IMPORT reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On GT reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On GOAL reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On FUNCTION reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On EXCEPTION reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On EQUAL reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On EOF reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On ENSURES reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On END reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On ELSE reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On DOWNTO reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On DOTDOT reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On DONE reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On DO reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On DIVERGES reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On CONSTANT reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On COMMA reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On COLON reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On COINDUCTIVE reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On CLONE reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On BARBAR reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On BAR reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On AXIOM reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On AMPAMP reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr
-- On ALIAS reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr

State 848:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr . for_direction seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On TO shift to state 849
-- On DOWNTO shift to state 850
-- On for_direction shift to state 851
## Reductions:

State 849:
## Known stack suffix:
## TO
## LR(1) items:
for_direction -> TO . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE reduce production for_direction -> TO
-- On VAL reduce production for_direction -> TO
-- On UIDENT reduce production for_direction -> TO
-- On TRY reduce production for_direction -> TO
-- On TRUE reduce production for_direction -> TO
-- On RETURN reduce production for_direction -> TO
-- On REAL reduce production for_direction -> TO
-- On RANGE reduce production for_direction -> TO
-- On RAISE reduce production for_direction -> TO
-- On PURE reduce production for_direction -> TO
-- On POSITION reduce production for_direction -> TO
-- On OPPREF reduce production for_direction -> TO
-- On OP4 reduce production for_direction -> TO
-- On OP3 reduce production for_direction -> TO
-- On OP2 reduce production for_direction -> TO
-- On OP1 reduce production for_direction -> TO
-- On NOT reduce production for_direction -> TO
-- On MINUS reduce production for_direction -> TO
-- On MATCH reduce production for_direction -> TO
-- On LT reduce production for_direction -> TO
-- On LIDENT reduce production for_direction -> TO
-- On LET reduce production for_direction -> TO
-- On LEFTPAR reduce production for_direction -> TO
-- On LEFTBRC reduce production for_direction -> TO
-- On LABEL reduce production for_direction -> TO
-- On INTEGER reduce production for_direction -> TO
-- On IF reduce production for_direction -> TO
-- On GT reduce production for_direction -> TO
-- On GHOST reduce production for_direction -> TO
-- On FUN reduce production for_direction -> TO
-- On FOR reduce production for_direction -> TO
-- On FLOAT reduce production for_direction -> TO
-- On FALSE reduce production for_direction -> TO
-- On EXCEPTION reduce production for_direction -> TO
-- On CORE_UIDENT reduce production for_direction -> TO
-- On CORE_LIDENT reduce production for_direction -> TO
-- On CONTINUE reduce production for_direction -> TO
-- On CHECK reduce production for_direction -> TO
-- On BREAK reduce production for_direction -> TO
-- On BEGIN reduce production for_direction -> TO
-- On ATTRIBUTE reduce production for_direction -> TO
-- On ASSUME reduce production for_direction -> TO
-- On ASSERT reduce production for_direction -> TO
-- On ANY reduce production for_direction -> TO
-- On ABSURD reduce production for_direction -> TO

State 850:
## Known stack suffix:
## DOWNTO
## LR(1) items:
for_direction -> DOWNTO . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE reduce production for_direction -> DOWNTO
-- On VAL reduce production for_direction -> DOWNTO
-- On UIDENT reduce production for_direction -> DOWNTO
-- On TRY reduce production for_direction -> DOWNTO
-- On TRUE reduce production for_direction -> DOWNTO
-- On RETURN reduce production for_direction -> DOWNTO
-- On REAL reduce production for_direction -> DOWNTO
-- On RANGE reduce production for_direction -> DOWNTO
-- On RAISE reduce production for_direction -> DOWNTO
-- On PURE reduce production for_direction -> DOWNTO
-- On POSITION reduce production for_direction -> DOWNTO
-- On OPPREF reduce production for_direction -> DOWNTO
-- On OP4 reduce production for_direction -> DOWNTO
-- On OP3 reduce production for_direction -> DOWNTO
-- On OP2 reduce production for_direction -> DOWNTO
-- On OP1 reduce production for_direction -> DOWNTO
-- On NOT reduce production for_direction -> DOWNTO
-- On MINUS reduce production for_direction -> DOWNTO
-- On MATCH reduce production for_direction -> DOWNTO
-- On LT reduce production for_direction -> DOWNTO
-- On LIDENT reduce production for_direction -> DOWNTO
-- On LET reduce production for_direction -> DOWNTO
-- On LEFTPAR reduce production for_direction -> DOWNTO
-- On LEFTBRC reduce production for_direction -> DOWNTO
-- On LABEL reduce production for_direction -> DOWNTO
-- On INTEGER reduce production for_direction -> DOWNTO
-- On IF reduce production for_direction -> DOWNTO
-- On GT reduce production for_direction -> DOWNTO
-- On GHOST reduce production for_direction -> DOWNTO
-- On FUN reduce production for_direction -> DOWNTO
-- On FOR reduce production for_direction -> DOWNTO
-- On FLOAT reduce production for_direction -> DOWNTO
-- On FALSE reduce production for_direction -> DOWNTO
-- On EXCEPTION reduce production for_direction -> DOWNTO
-- On CORE_UIDENT reduce production for_direction -> DOWNTO
-- On CORE_LIDENT reduce production for_direction -> DOWNTO
-- On CONTINUE reduce production for_direction -> DOWNTO
-- On CHECK reduce production for_direction -> DOWNTO
-- On BREAK reduce production for_direction -> DOWNTO
-- On BEGIN reduce production for_direction -> DOWNTO
-- On ATTRIBUTE reduce production for_direction -> DOWNTO
-- On ASSUME reduce production for_direction -> DOWNTO
-- On ASSERT reduce production for_direction -> DOWNTO
-- On ANY reduce production for_direction -> DOWNTO
-- On ABSURD reduce production for_direction -> DOWNTO

State 851:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr for_direction
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction . seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 852
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 852:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr . DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On DO shift to state 853
## Reductions:

State 853:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr DO
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO . list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On INVARIANT shift to state 663
-- On list(invariant) shift to state 854
-- On invariant shift to state 858
## Reductions:
-- On WHILE reduce production list(invariant) ->
-- On VAL reduce production list(invariant) ->
-- On UIDENT reduce production list(invariant) ->
-- On TRY reduce production list(invariant) ->
-- On TRUE reduce production list(invariant) ->
-- On RETURN reduce production list(invariant) ->
-- On REAL reduce production list(invariant) ->
-- On RANGE reduce production list(invariant) ->
-- On RAISE reduce production list(invariant) ->
-- On PURE reduce production list(invariant) ->
-- On POSITION reduce production list(invariant) ->
-- On OPPREF reduce production list(invariant) ->
-- On OP4 reduce production list(invariant) ->
-- On OP3 reduce production list(invariant) ->
-- On OP2 reduce production list(invariant) ->
-- On OP1 reduce production list(invariant) ->
-- On NOT reduce production list(invariant) ->
-- On MINUS reduce production list(invariant) ->
-- On MATCH reduce production list(invariant) ->
-- On LT reduce production list(invariant) ->
-- On LIDENT reduce production list(invariant) ->
-- On LET reduce production list(invariant) ->
-- On LEFTPAR reduce production list(invariant) ->
-- On LEFTBRC reduce production list(invariant) ->
-- On LABEL reduce production list(invariant) ->
-- On INTEGER reduce production list(invariant) ->
-- On IF reduce production list(invariant) ->
-- On GT reduce production list(invariant) ->
-- On GHOST reduce production list(invariant) ->
-- On FUN reduce production list(invariant) ->
-- On FOR reduce production list(invariant) ->
-- On FLOAT reduce production list(invariant) ->
-- On FALSE reduce production list(invariant) ->
-- On EXCEPTION reduce production list(invariant) ->
-- On DONE reduce production list(invariant) ->
-- On CORE_UIDENT reduce production list(invariant) ->
-- On CORE_LIDENT reduce production list(invariant) ->
-- On CONTINUE reduce production list(invariant) ->
-- On CHECK reduce production list(invariant) ->
-- On BREAK reduce production list(invariant) ->
-- On BEGIN reduce production list(invariant) ->
-- On ATTRIBUTE reduce production list(invariant) ->
-- On ASSUME reduce production list(invariant) ->
-- On ASSERT reduce production list(invariant) ->
-- On ANY reduce production list(invariant) ->
-- On ABSURD reduce production list(invariant) ->

State 854:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant)
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) . loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 855
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On loop_body shift to state 856
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:
-- On DONE reduce production loop_body ->

State 855:
## Known stack suffix:
## seq_expr
## LR(1) items:
loop_body -> seq_expr . [ DONE ]
## Transitions:
## Reductions:
-- On DONE reduce production loop_body -> seq_expr

State 856:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body . DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On DONE shift to state 857
## Reductions:

State 857:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On WITH reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On VARIANT reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On VAL reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On USE reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On TYPE reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On TO reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On THEN reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On SEMICOLON reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On SCOPE reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On RIGHTSQ reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On RIGHTPAR reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On RIGHTBRC reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On RETURNS reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On REQUIRES reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On READS reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On RAISES reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On PREDICATE reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On OP4 reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On OP3 reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On OP2 reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On OP1 reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On MINUS reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On META reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On LTGT reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On LT reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On LET reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On LEMMA reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On LARROW reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On INDUCTIVE reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On IN reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On IMPORT reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On GT reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On GOAL reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On FUNCTION reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On EXCEPTION reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On EQUAL reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On EOF reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On ENSURES reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On END reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On ELSE reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On DOWNTO reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On DOTDOT reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On DONE reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On DO reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On DIVERGES reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On CONSTANT reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On COMMA reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On COLON reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On COINDUCTIVE reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On CLONE reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On BARBAR reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On BAR reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On AXIOM reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On AMPAMP reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
-- On ALIAS reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE

State 858:
## Known stack suffix:
## invariant
## LR(1) items:
list(invariant) -> invariant . list(invariant) [ WITH WHILE VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On INVARIANT shift to state 663
-- On list(invariant) shift to state 859
-- On invariant shift to state 858
## Reductions:
-- On WITH reduce production list(invariant) ->
-- On WHILE reduce production list(invariant) ->
-- On VAL reduce production list(invariant) ->
-- On USE reduce production list(invariant) ->
-- On UIDENT reduce production list(invariant) ->
-- On TYPE reduce production list(invariant) ->
-- On TRY reduce production list(invariant) ->
-- On TRUE reduce production list(invariant) ->
-- On SCOPE reduce production list(invariant) ->
-- On RETURN reduce production list(invariant) ->
-- On REAL reduce production list(invariant) ->
-- On RANGE reduce production list(invariant) ->
-- On RAISE reduce production list(invariant) ->
-- On PURE reduce production list(invariant) ->
-- On PREDICATE reduce production list(invariant) ->
-- On POSITION reduce production list(invariant) ->
-- On OPPREF reduce production list(invariant) ->
-- On OP4 reduce production list(invariant) ->
-- On OP3 reduce production list(invariant) ->
-- On OP2 reduce production list(invariant) ->
-- On OP1 reduce production list(invariant) ->
-- On NOT reduce production list(invariant) ->
-- On MINUS reduce production list(invariant) ->
-- On META reduce production list(invariant) ->
-- On MATCH reduce production list(invariant) ->
-- On LT reduce production list(invariant) ->
-- On LIDENT reduce production list(invariant) ->
-- On LET reduce production list(invariant) ->
-- On LEMMA reduce production list(invariant) ->
-- On LEFTPAR reduce production list(invariant) ->
-- On LEFTBRC reduce production list(invariant) ->
-- On LABEL reduce production list(invariant) ->
-- On INTEGER reduce production list(invariant) ->
-- On INDUCTIVE reduce production list(invariant) ->
-- On IMPORT reduce production list(invariant) ->
-- On IF reduce production list(invariant) ->
-- On GT reduce production list(invariant) ->
-- On GOAL reduce production list(invariant) ->
-- On GHOST reduce production list(invariant) ->
-- On FUNCTION reduce production list(invariant) ->
-- On FUN reduce production list(invariant) ->
-- On FOR reduce production list(invariant) ->
-- On FLOAT reduce production list(invariant) ->
-- On FALSE reduce production list(invariant) ->
-- On EXCEPTION reduce production list(invariant) ->
-- On EOF reduce production list(invariant) ->
-- On END reduce production list(invariant) ->
-- On DONE reduce production list(invariant) ->
-- On CORE_UIDENT reduce production list(invariant) ->
-- On CORE_LIDENT reduce production list(invariant) ->
-- On CONTINUE reduce production list(invariant) ->
-- On CONSTANT reduce production list(invariant) ->
-- On COINDUCTIVE reduce production list(invariant) ->
-- On CLONE reduce production list(invariant) ->
-- On CHECK reduce production list(invariant) ->
-- On BY reduce production list(invariant) ->
-- On BREAK reduce production list(invariant) ->
-- On BEGIN reduce production list(invariant) ->
-- On AXIOM reduce production list(invariant) ->
-- On ATTRIBUTE reduce production list(invariant) ->
-- On ASSUME reduce production list(invariant) ->
-- On ASSERT reduce production list(invariant) ->
-- On ANY reduce production list(invariant) ->
-- On ABSURD reduce production list(invariant) ->

State 859:
## Known stack suffix:
## invariant list(invariant)
## LR(1) items:
list(invariant) -> invariant list(invariant) . [ WITH WHILE VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WITH reduce production list(invariant) -> invariant list(invariant)
-- On WHILE reduce production list(invariant) -> invariant list(invariant)
-- On VAL reduce production list(invariant) -> invariant list(invariant)
-- On USE reduce production list(invariant) -> invariant list(invariant)
-- On UIDENT reduce production list(invariant) -> invariant list(invariant)
-- On TYPE reduce production list(invariant) -> invariant list(invariant)
-- On TRY reduce production list(invariant) -> invariant list(invariant)
-- On TRUE reduce production list(invariant) -> invariant list(invariant)
-- On SCOPE reduce production list(invariant) -> invariant list(invariant)
-- On RETURN reduce production list(invariant) -> invariant list(invariant)
-- On REAL reduce production list(invariant) -> invariant list(invariant)
-- On RANGE reduce production list(invariant) -> invariant list(invariant)
-- On RAISE reduce production list(invariant) -> invariant list(invariant)
-- On PURE reduce production list(invariant) -> invariant list(invariant)
-- On PREDICATE reduce production list(invariant) -> invariant list(invariant)
-- On POSITION reduce production list(invariant) -> invariant list(invariant)
-- On OPPREF reduce production list(invariant) -> invariant list(invariant)
-- On OP4 reduce production list(invariant) -> invariant list(invariant)
-- On OP3 reduce production list(invariant) -> invariant list(invariant)
-- On OP2 reduce production list(invariant) -> invariant list(invariant)
-- On OP1 reduce production list(invariant) -> invariant list(invariant)
-- On NOT reduce production list(invariant) -> invariant list(invariant)
-- On MINUS reduce production list(invariant) -> invariant list(invariant)
-- On META reduce production list(invariant) -> invariant list(invariant)
-- On MATCH reduce production list(invariant) -> invariant list(invariant)
-- On LT reduce production list(invariant) -> invariant list(invariant)
-- On LIDENT reduce production list(invariant) -> invariant list(invariant)
-- On LET reduce production list(invariant) -> invariant list(invariant)
-- On LEMMA reduce production list(invariant) -> invariant list(invariant)
-- On LEFTPAR reduce production list(invariant) -> invariant list(invariant)
-- On LEFTBRC reduce production list(invariant) -> invariant list(invariant)
-- On LABEL reduce production list(invariant) -> invariant list(invariant)
-- On INTEGER reduce production list(invariant) -> invariant list(invariant)
-- On INDUCTIVE reduce production list(invariant) -> invariant list(invariant)
-- On IMPORT reduce production list(invariant) -> invariant list(invariant)
-- On IF reduce production list(invariant) -> invariant list(invariant)
-- On GT reduce production list(invariant) -> invariant list(invariant)
-- On GOAL reduce production list(invariant) -> invariant list(invariant)
-- On GHOST reduce production list(invariant) -> invariant list(invariant)
-- On FUNCTION reduce production list(invariant) -> invariant list(invariant)
-- On FUN reduce production list(invariant) -> invariant list(invariant)
-- On FOR reduce production list(invariant) -> invariant list(invariant)
-- On FLOAT reduce production list(invariant) -> invariant list(invariant)
-- On FALSE reduce production list(invariant) -> invariant list(invariant)
-- On EXCEPTION reduce production list(invariant) -> invariant list(invariant)
-- On EOF reduce production list(invariant) -> invariant list(invariant)
-- On END reduce production list(invariant) -> invariant list(invariant)
-- On DONE reduce production list(invariant) -> invariant list(invariant)
-- On CORE_UIDENT reduce production list(invariant) -> invariant list(invariant)
-- On CORE_LIDENT reduce production list(invariant) -> invariant list(invariant)
-- On CONTINUE reduce production list(invariant) -> invariant list(invariant)
-- On CONSTANT reduce production list(invariant) -> invariant list(invariant)
-- On COINDUCTIVE reduce production list(invariant) -> invariant list(invariant)
-- On CLONE reduce production list(invariant) -> invariant list(invariant)
-- On CHECK reduce production list(invariant) -> invariant list(invariant)
-- On BY reduce production list(invariant) -> invariant list(invariant)
-- On BREAK reduce production list(invariant) -> invariant list(invariant)
-- On BEGIN reduce production list(invariant) -> invariant list(invariant)
-- On AXIOM reduce production list(invariant) -> invariant list(invariant)
-- On ATTRIBUTE reduce production list(invariant) -> invariant list(invariant)
-- On ASSUME reduce production list(invariant) -> invariant list(invariant)
-- On ASSERT reduce production list(invariant) -> invariant list(invariant)
-- On ANY reduce production list(invariant) -> invariant list(invariant)
-- On ABSURD reduce production list(invariant) -> invariant list(invariant)

State 860:
## Known stack suffix:
## FUN binders spec ARROW spec seq_expr
## LR(1) items:
single_expr_ -> FUN binders spec ARROW spec seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On WITH reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On VARIANT reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On VAL reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On USE reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On TYPE reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On TO reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On THEN reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On SEMICOLON reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On SCOPE reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On RIGHTSQ reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On RIGHTPAR reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On RIGHTBRC reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On RETURNS reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On REQUIRES reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On READS reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On RAISES reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On PREDICATE reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On OP4 reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On OP3 reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On OP2 reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On OP1 reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On MINUS reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On META reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On LTGT reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On LT reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On LET reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On LEMMA reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On LARROW reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On INDUCTIVE reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On IN reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On IMPORT reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On GT reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On GOAL reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On FUNCTION reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On EXCEPTION reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On EQUAL reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On EOF reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On ENSURES reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On END reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On ELSE reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On DOWNTO reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On DOTDOT reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On DONE reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On DO reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On DIVERGES reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On CONSTANT reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On COMMA reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On COLON reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On COINDUCTIVE reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On CLONE reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On BARBAR reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On BAR reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On AXIOM reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On AMPAMP reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr
-- On ALIAS reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr

State 861:
## Known stack suffix:
## GHOST single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> GHOST single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On COLON shift to state 132
-- On BARBAR shift to state 815
-- On AMPAMP shift to state 817
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> GHOST single_expr
-- On WITH reduce production single_expr_ -> GHOST single_expr
-- On VARIANT reduce production single_expr_ -> GHOST single_expr
-- On VAL reduce production single_expr_ -> GHOST single_expr
-- On USE reduce production single_expr_ -> GHOST single_expr
-- On TYPE reduce production single_expr_ -> GHOST single_expr
-- On TO reduce production single_expr_ -> GHOST single_expr
-- On THEN reduce production single_expr_ -> GHOST single_expr
-- On SEMICOLON reduce production single_expr_ -> GHOST single_expr
-- On SCOPE reduce production single_expr_ -> GHOST single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> GHOST single_expr
-- On RIGHTSQ reduce production single_expr_ -> GHOST single_expr
-- On RIGHTPAR reduce production single_expr_ -> GHOST single_expr
-- On RIGHTBRC reduce production single_expr_ -> GHOST single_expr
-- On RETURNS reduce production single_expr_ -> GHOST single_expr
-- On REQUIRES reduce production single_expr_ -> GHOST single_expr
-- On READS reduce production single_expr_ -> GHOST single_expr
-- On RAISES reduce production single_expr_ -> GHOST single_expr
-- On PREDICATE reduce production single_expr_ -> GHOST single_expr
-- On META reduce production single_expr_ -> GHOST single_expr
-- On LET reduce production single_expr_ -> GHOST single_expr
-- On LEMMA reduce production single_expr_ -> GHOST single_expr
-- On LARROW reduce production single_expr_ -> GHOST single_expr
-- On INDUCTIVE reduce production single_expr_ -> GHOST single_expr
-- On IN reduce production single_expr_ -> GHOST single_expr
-- On IMPORT reduce production single_expr_ -> GHOST single_expr
-- On GOAL reduce production single_expr_ -> GHOST single_expr
-- On FUNCTION reduce production single_expr_ -> GHOST single_expr
-- On EXCEPTION reduce production single_expr_ -> GHOST single_expr
-- On EOF reduce production single_expr_ -> GHOST single_expr
-- On ENSURES reduce production single_expr_ -> GHOST single_expr
-- On END reduce production single_expr_ -> GHOST single_expr
-- On ELSE reduce production single_expr_ -> GHOST single_expr
-- On DOWNTO reduce production single_expr_ -> GHOST single_expr
-- On DOTDOT reduce production single_expr_ -> GHOST single_expr
-- On DONE reduce production single_expr_ -> GHOST single_expr
-- On DO reduce production single_expr_ -> GHOST single_expr
-- On DIVERGES reduce production single_expr_ -> GHOST single_expr
-- On CONSTANT reduce production single_expr_ -> GHOST single_expr
-- On COMMA reduce production single_expr_ -> GHOST single_expr
-- On COINDUCTIVE reduce production single_expr_ -> GHOST single_expr
-- On CLONE reduce production single_expr_ -> GHOST single_expr
-- On BAR reduce production single_expr_ -> GHOST single_expr
-- On AXIOM reduce production single_expr_ -> GHOST single_expr
-- On ALIAS reduce production single_expr_ -> GHOST single_expr

State 862:
## Known stack suffix:
## IF seq_expr
## LR(1) items:
single_expr_ -> IF seq_expr . THEN contract_expr ELSE contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> IF seq_expr . THEN contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On THEN shift to state 863
## Reductions:

State 863:
## Known stack suffix:
## IF seq_expr THEN
## LR(1) items:
single_expr_ -> IF seq_expr THEN . contract_expr ELSE contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> IF seq_expr THEN . contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 864
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 864:
## Known stack suffix:
## IF seq_expr THEN contract_expr
## LR(1) items:
single_expr_ -> IF seq_expr THEN contract_expr . ELSE contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> IF seq_expr THEN contract_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On ELSE shift to state 865
## Reductions:
-- On WRITES reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On WITH reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On VARIANT reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On VAL reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On USE reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On TYPE reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On TO reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On THEN reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On SEMICOLON reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On SCOPE reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On RIGHTSQ reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On RIGHTPAR reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On RIGHTBRC reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On RETURNS reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On REQUIRES reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On READS reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On RAISES reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On PREDICATE reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On OP4 reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On OP3 reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On OP2 reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On OP1 reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On MINUS reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On META reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On LTGT reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On LT reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On LET reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On LEMMA reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On LARROW reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On INDUCTIVE reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On IN reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On IMPORT reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On GT reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On GOAL reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On FUNCTION reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On EXCEPTION reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On EQUAL reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On EOF reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On ENSURES reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On END reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On DOWNTO reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On DOTDOT reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On DONE reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On DO reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On DIVERGES reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On CONSTANT reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On COMMA reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On COLON reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On COINDUCTIVE reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On CLONE reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On BARBAR reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On BAR reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On AXIOM reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On AMPAMP reduce production single_expr_ -> IF seq_expr THEN contract_expr
-- On ALIAS reduce production single_expr_ -> IF seq_expr THEN contract_expr

State 865:
## Known stack suffix:
## IF seq_expr THEN contract_expr ELSE
## LR(1) items:
single_expr_ -> IF seq_expr THEN contract_expr ELSE . contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 866
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 866:
## Known stack suffix:
## IF seq_expr THEN contract_expr ELSE contract_expr
## LR(1) items:
single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On WITH reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On VARIANT reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On VAL reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On USE reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On TYPE reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On TO reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On THEN reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On SEMICOLON reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On SCOPE reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On RIGHTSQ reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On RIGHTPAR reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On RIGHTBRC reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On RETURNS reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On REQUIRES reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On READS reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On RAISES reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On PREDICATE reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On OP4 reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On OP3 reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On OP2 reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On OP1 reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On MINUS reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On META reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On LTGT reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On LT reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On LET reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On LEMMA reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On LARROW reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On INDUCTIVE reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On IN reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On IMPORT reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On GT reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On GOAL reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On FUNCTION reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On EXCEPTION reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On EQUAL reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On EOF reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On ENSURES reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On END reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On ELSE reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On DOWNTO reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On DOTDOT reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On DONE reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On DO reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On DIVERGES reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On CONSTANT reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On COMMA reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On COLON reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On COINDUCTIVE reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On CLONE reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On BARBAR reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On BAR reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On AXIOM reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On AMPAMP reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr
-- On ALIAS reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr

State 867:
## Known stack suffix:
## LABEL attrs(uident) IN seq_expr
## LR(1) items:
single_expr_ -> LABEL attrs(uident) IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On WITH reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On VARIANT reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On VAL reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On USE reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On TYPE reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On TO reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On THEN reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On SEMICOLON reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On SCOPE reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On RIGHTSQ reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On RIGHTPAR reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On RIGHTBRC reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On RETURNS reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On REQUIRES reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On READS reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On RAISES reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On PREDICATE reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On OP4 reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On OP3 reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On OP2 reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On OP1 reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On MINUS reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On META reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On LTGT reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On LT reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On LET reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On LEMMA reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On LARROW reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On INDUCTIVE reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On IN reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On IMPORT reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On GT reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On GOAL reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On FUNCTION reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On EXCEPTION reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On EQUAL reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On EOF reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On ENSURES reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On END reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On ELSE reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On DOWNTO reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On DOTDOT reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On DONE reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On DO reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On DIVERGES reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On CONSTANT reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On COMMA reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On COLON reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On COINDUCTIVE reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On CLONE reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On BARBAR reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On BAR reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On AXIOM reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On AMPAMP reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr
-- On ALIAS reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr

State 868:
## Known stack suffix:
## LET REC with_list1(rec_defn) IN seq_expr
## LR(1) items:
single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On WITH reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On VARIANT reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On VAL reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On USE reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On TYPE reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On TO reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On THEN reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On SEMICOLON reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On SCOPE reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On RIGHTSQ reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On RIGHTPAR reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On RIGHTBRC reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On RETURNS reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On REQUIRES reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On READS reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On RAISES reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On PREDICATE reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On OP4 reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On OP3 reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On OP2 reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On OP1 reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On MINUS reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On META reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On LTGT reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On LT reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On LET reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On LEMMA reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On LARROW reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On INDUCTIVE reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On IN reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On IMPORT reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On GT reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On GOAL reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On FUNCTION reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On EXCEPTION reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On EQUAL reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On EOF reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On ENSURES reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On END reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On ELSE reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On DOWNTO reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On DOTDOT reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On DONE reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On DO reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On DIVERGES reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On CONSTANT reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On COMMA reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On COLON reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On COINDUCTIVE reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On CLONE reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On BARBAR reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On BAR reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On AXIOM reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On AMPAMP reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr
-- On ALIAS reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr

State 869:
## Known stack suffix:
## separated_nonempty_list(WITH,rec_defn)
## LR(1) items:
with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On USE reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On TYPE reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On SCOPE reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On PREDICATE reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On META reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On LET reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On LEMMA reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On INDUCTIVE reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On IN reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On IMPORT reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On GOAL reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On FUNCTION reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On EXCEPTION reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On EOF reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On END reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On CONSTANT reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On COINDUCTIVE reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On CLONE reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
-- On AXIOM reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)

State 870:
## Known stack suffix:
## rec_defn
## LR(1) items:
separated_nonempty_list(WITH,rec_defn) -> rec_defn . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(WITH,rec_defn) -> rec_defn . WITH separated_nonempty_list(WITH,rec_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 871
## Reductions:
-- On VAL reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On USE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On TYPE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On SCOPE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On PREDICATE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On META reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On LET reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On LEMMA reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On INDUCTIVE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On IN reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On IMPORT reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On GOAL reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On FUNCTION reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On EXCEPTION reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On EOF reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On END reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On CONSTANT reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On COINDUCTIVE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On CLONE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn
-- On AXIOM reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn

State 871:
## Known stack suffix:
## rec_defn WITH
## LR(1) items:
separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH . separated_nonempty_list(WITH,rec_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On GHOST shift to state 53
-- On separated_nonempty_list(WITH,rec_defn) shift to state 872
-- On rec_defn shift to state 870
-- On ghost shift to state 873
## Reductions:
-- On RANGE reduce production ghost ->
-- On PREDICATE reduce production ghost ->
-- On LIDENT reduce production ghost ->
-- On LEMMA reduce production ghost ->
-- On LEFTPAR reduce production ghost ->
-- On FUNCTION reduce production ghost ->
-- On FLOAT reduce production ghost ->
-- On CORE_LIDENT reduce production ghost ->
-- On CONSTANT reduce production ghost ->

State 872:
## Known stack suffix:
## rec_defn WITH separated_nonempty_list(WITH,rec_defn)
## LR(1) items:
separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On USE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On TYPE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On SCOPE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On PREDICATE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On META reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On LET reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On LEMMA reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On INDUCTIVE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On IN reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On IMPORT reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On GOAL reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On FUNCTION reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On EXCEPTION reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On EOF reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On END reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On CONSTANT reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On COINDUCTIVE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On CLONE reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)
-- On AXIOM reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)

State 873:
## Known stack suffix:
## ghost
## LR(1) items:
rec_defn -> ghost . kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On PREDICATE shift to state 55
-- On LEMMA shift to state 56
-- On FUNCTION shift to state 57
-- On CONSTANT shift to state 58
-- On kind shift to state 874
## Reductions:
-- On RANGE reduce production kind ->
-- On LIDENT reduce production kind ->
-- On LEFTPAR reduce production kind ->
-- On FLOAT reduce production kind ->
-- On CORE_LIDENT reduce production kind ->

State 874:
## Known stack suffix:
## ghost kind
## LR(1) items:
rec_defn -> ghost kind . attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On attrs(lident_rich) shift to state 875
## Reductions:

State 875:
## Known stack suffix:
## ghost kind attrs(lident_rich)
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) . binders return_opt spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On binders shift to state 876
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:

State 876:
## Known stack suffix:
## ghost kind attrs(lident_rich) binders
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) binders . return_opt spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 148
-- On return_opt shift to state 877
## Reductions:
-- On WRITES reduce production return_opt ->
-- On VARIANT reduce production return_opt ->
-- On RETURNS reduce production return_opt ->
-- On REQUIRES reduce production return_opt ->
-- On READS reduce production return_opt ->
-- On RAISES reduce production return_opt ->
-- On EQUAL reduce production return_opt ->
-- On ENSURES reduce production return_opt ->
-- On DIVERGES reduce production return_opt ->
-- On ALIAS reduce production return_opt ->

State 877:
## Known stack suffix:
## ghost kind attrs(lident_rich) binders return_opt
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) binders return_opt . spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 878
-- On single_spec shift to state 567
## Reductions:
-- On EQUAL reduce production spec ->

State 878:
## Known stack suffix:
## ghost kind attrs(lident_rich) binders return_opt spec
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec . EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 879
## Reductions:

State 879:
## Known stack suffix:
## ghost kind attrs(lident_rich) binders return_opt spec EQUAL
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL . spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 880
-- On single_spec shift to state 567
## Reductions:
-- On WHILE reduce production spec ->
-- On VAL reduce production spec ->
-- On UIDENT reduce production spec ->
-- On TRY reduce production spec ->
-- On TRUE reduce production spec ->
-- On RETURN reduce production spec ->
-- On REAL reduce production spec ->
-- On RANGE reduce production spec ->
-- On RAISE reduce production spec ->
-- On PURE reduce production spec ->
-- On POSITION reduce production spec ->
-- On OPPREF reduce production spec ->
-- On OP4 reduce production spec ->
-- On OP3 reduce production spec ->
-- On OP2 reduce production spec ->
-- On OP1 reduce production spec ->
-- On NOT reduce production spec ->
-- On MINUS reduce production spec ->
-- On MATCH reduce production spec ->
-- On LT reduce production spec ->
-- On LIDENT reduce production spec ->
-- On LET reduce production spec ->
-- On LEFTPAR reduce production spec ->
-- On LEFTBRC reduce production spec ->
-- On LABEL reduce production spec ->
-- On INTEGER reduce production spec ->
-- On IF reduce production spec ->
-- On GT reduce production spec ->
-- On GHOST reduce production spec ->
-- On FUN reduce production spec ->
-- On FOR reduce production spec ->
-- On FLOAT reduce production spec ->
-- On FALSE reduce production spec ->
-- On EXCEPTION reduce production spec ->
-- On CORE_UIDENT reduce production spec ->
-- On CORE_LIDENT reduce production spec ->
-- On CONTINUE reduce production spec ->
-- On CHECK reduce production spec ->
-- On BREAK reduce production spec ->
-- On BEGIN reduce production spec ->
-- On ATTRIBUTE reduce production spec ->
-- On ASSUME reduce production spec ->
-- On ASSERT reduce production spec ->
-- On ANY reduce production spec ->
-- On ABSURD reduce production spec ->

State 880:
## Known stack suffix:
## ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec . seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 881
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 881:
## Known stack suffix:
## ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On VAL reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On USE reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On TYPE reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On SCOPE reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On PREDICATE reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On META reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On LET reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On LEMMA reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On INDUCTIVE reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On IN reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On IMPORT reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On GOAL reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On FUNCTION reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On EXCEPTION reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On EOF reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On END reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On CONSTANT reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On COINDUCTIVE reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On CLONE reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
-- On AXIOM reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr

State 882:
## Known stack suffix:
## LET ghost
## LR(1) items:
single_expr_ -> LET ghost . kind let_pattern EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost . kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost . kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost . kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On PREDICATE shift to state 55
-- On LEMMA shift to state 56
-- On FUNCTION shift to state 57
-- On CONSTANT shift to state 58
-- On kind shift to state 883
## Reductions:
-- On UNDERSCORE reduce production kind ->
-- On UIDENT reduce production kind ->
-- On RANGE reduce production kind ->
-- On LIDENT reduce production kind ->
-- On LEFTPAR reduce production kind ->
-- On LEFTBRC reduce production kind ->
-- On FLOAT reduce production kind ->
-- On CORE_UIDENT reduce production kind ->
-- On CORE_LIDENT reduce production kind ->

State 883:
## Known stack suffix:
## LET ghost kind
## LR(1) items:
single_expr_ -> LET ghost kind . let_pattern EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost kind . attrs(lident_op_nq) EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost kind . attrs(lident_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost kind . attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 217
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 884
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 886
-- On mk_pat(let_pattern_) shift to state 887
-- On mk_pat(let_pat_uni_) shift to state 888
-- On mk_pat(let_pat_conj_) shift to state 895
-- On lident_op_nq shift to state 429
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On let_pattern_ shift to state 898
-- On let_pattern shift to state 899
-- On let_pat_uni_ shift to state 904
-- On let_pat_conj_ shift to state 905
-- On attrs(lident_op_nq) shift to state 906
-- On attrs(lident_nq) shift to state 921
## Reductions:

State 884:
## Known stack suffix:
## uqualid
## LR(1) items:
let_pat_uni_ -> uqualid . nonempty_list(pat_arg) [ EQUAL COMMA COLON BAR AS ]
pat_arg_ -> uqualid . [ EQUAL COMMA COLON BAR AS ]
pat_arg_ -> uqualid . DOT mk_pat(pat_block_) [ EQUAL COMMA COLON BAR AS ]
uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On DOT shift to state 228
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 231
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 233
-- On pat_arg shift to state 234
-- On nonempty_list(pat_arg) shift to state 885
-- On mk_pat(pat_arg_) shift to state 236
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:
-- On EQUAL reduce production pat_arg_ -> uqualid
-- On COMMA reduce production pat_arg_ -> uqualid
-- On COLON reduce production pat_arg_ -> uqualid
-- On BAR reduce production pat_arg_ -> uqualid
-- On AS reduce production pat_arg_ -> uqualid

State 885:
## Known stack suffix:
## uqualid nonempty_list(pat_arg)
## LR(1) items:
let_pat_uni_ -> uqualid nonempty_list(pat_arg) . [ EQUAL COMMA COLON BAR AS ]
## Transitions:
## Reductions:
-- On EQUAL reduce production let_pat_uni_ -> uqualid nonempty_list(pat_arg)
-- On COMMA reduce production let_pat_uni_ -> uqualid nonempty_list(pat_arg)
-- On COLON reduce production let_pat_uni_ -> uqualid nonempty_list(pat_arg)
-- On BAR reduce production let_pat_uni_ -> uqualid nonempty_list(pat_arg)
-- On AS reduce production let_pat_uni_ -> uqualid nonempty_list(pat_arg)

State 886:
## Known stack suffix:
## pat_arg_
## LR(1) items:
let_pat_uni_ -> pat_arg_ . [ EQUAL COMMA COLON BAR AS ]
## Transitions:
## Reductions:
-- On EQUAL reduce production let_pat_uni_ -> pat_arg_
-- On COMMA reduce production let_pat_uni_ -> pat_arg_
-- On COLON reduce production let_pat_uni_ -> pat_arg_
-- On BAR reduce production let_pat_uni_ -> pat_arg_
-- On AS reduce production let_pat_uni_ -> pat_arg_

State 887:
## Known stack suffix:
## mk_pat(let_pattern_)
## LR(1) items:
let_pattern -> mk_pat(let_pattern_) . [ EQUAL ]
## Transitions:
## Reductions:
-- On EQUAL reduce production let_pattern -> mk_pat(let_pattern_)

State 888:
## Known stack suffix:
## mk_pat(let_pat_uni_)
## LR(1) items:
let_pat_conj_ -> mk_pat(let_pat_uni_) . COMMA comma_list1(mk_pat(pat_uni_)) [ EQUAL BAR ]
let_pat_uni_ -> mk_pat(let_pat_uni_) . AS ghost attrs(lident_nq) [ EQUAL COMMA COLON BAR AS ]
let_pat_uni_ -> mk_pat(let_pat_uni_) . cast [ EQUAL COMMA COLON BAR AS ]
## Transitions:
-- On COMMA shift to state 889
-- On COLON shift to state 132
-- On AS shift to state 891
-- On cast shift to state 894
## Reductions:

State 889:
## Known stack suffix:
## mk_pat(let_pat_uni_) COMMA
## LR(1) items:
let_pat_conj_ -> mk_pat(let_pat_uni_) COMMA . comma_list1(mk_pat(pat_uni_)) [ EQUAL BAR ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,mk_pat(pat_uni_)) shift to state 252
-- On pat_uni_ shift to state 239
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pat_uni_) shift to state 253
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list1(mk_pat(pat_uni_)) shift to state 890
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 890:
## Known stack suffix:
## mk_pat(let_pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))
## LR(1) items:
let_pat_conj_ -> mk_pat(let_pat_uni_) COMMA comma_list1(mk_pat(pat_uni_)) . [ EQUAL BAR ]
## Transitions:
## Reductions:
-- On EQUAL reduce production let_pat_conj_ -> mk_pat(let_pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))
-- On BAR reduce production let_pat_conj_ -> mk_pat(let_pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))

State 891:
## Known stack suffix:
## mk_pat(let_pat_uni_) AS
## LR(1) items:
let_pat_uni_ -> mk_pat(let_pat_uni_) AS . ghost attrs(lident_nq) [ EQUAL COMMA COLON BAR AS ]
## Transitions:
-- On GHOST shift to state 53
-- On ghost shift to state 892
## Reductions:
-- On RANGE reduce production ghost ->
-- On LIDENT reduce production ghost ->
-- On FLOAT reduce production ghost ->
-- On CORE_LIDENT reduce production ghost ->

State 892:
## Known stack suffix:
## mk_pat(let_pat_uni_) AS ghost
## LR(1) items:
let_pat_uni_ -> mk_pat(let_pat_uni_) AS ghost . attrs(lident_nq) [ EQUAL COMMA COLON BAR AS ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 893
## Reductions:

State 893:
## Known stack suffix:
## mk_pat(let_pat_uni_) AS ghost attrs(lident_nq)
## LR(1) items:
let_pat_uni_ -> mk_pat(let_pat_uni_) AS ghost attrs(lident_nq) . [ EQUAL COMMA COLON BAR AS ]
## Transitions:
## Reductions:
-- On EQUAL reduce production let_pat_uni_ -> mk_pat(let_pat_uni_) AS ghost attrs(lident_nq)
-- On COMMA reduce production let_pat_uni_ -> mk_pat(let_pat_uni_) AS ghost attrs(lident_nq)
-- On COLON reduce production let_pat_uni_ -> mk_pat(let_pat_uni_) AS ghost attrs(lident_nq)
-- On BAR reduce production let_pat_uni_ -> mk_pat(let_pat_uni_) AS ghost attrs(lident_nq)
-- On AS reduce production let_pat_uni_ -> mk_pat(let_pat_uni_) AS ghost attrs(lident_nq)

State 894:
## Known stack suffix:
## mk_pat(let_pat_uni_) cast
## LR(1) items:
let_pat_uni_ -> mk_pat(let_pat_uni_) cast . [ EQUAL COMMA COLON BAR AS ]
## Transitions:
## Reductions:
-- On EQUAL reduce production let_pat_uni_ -> mk_pat(let_pat_uni_) cast
-- On COMMA reduce production let_pat_uni_ -> mk_pat(let_pat_uni_) cast
-- On COLON reduce production let_pat_uni_ -> mk_pat(let_pat_uni_) cast
-- On BAR reduce production let_pat_uni_ -> mk_pat(let_pat_uni_) cast
-- On AS reduce production let_pat_uni_ -> mk_pat(let_pat_uni_) cast

State 895:
## Known stack suffix:
## mk_pat(let_pat_conj_)
## LR(1) items:
let_pattern_ -> mk_pat(let_pat_conj_) . BAR pattern [ EQUAL ]
## Transitions:
-- On BAR shift to state 896
## Reductions:

State 896:
## Known stack suffix:
## mk_pat(let_pat_conj_) BAR
## LR(1) items:
let_pattern_ -> mk_pat(let_pat_conj_) BAR . pattern [ EQUAL ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 897
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 897:
## Known stack suffix:
## mk_pat(let_pat_conj_) BAR pattern
## LR(1) items:
let_pattern_ -> mk_pat(let_pat_conj_) BAR pattern . [ EQUAL ]
## Transitions:
## Reductions:
-- On EQUAL reduce production let_pattern_ -> mk_pat(let_pat_conj_) BAR pattern

State 898:
## Known stack suffix:
## let_pattern_
## LR(1) items:
mk_pat(let_pattern_) -> let_pattern_ . [ EQUAL ]
## Transitions:
## Reductions:
-- On EQUAL reduce production mk_pat(let_pattern_) -> let_pattern_

State 899:
## Known stack suffix:
## LET ghost kind let_pattern
## LR(1) items:
single_expr_ -> LET ghost kind let_pattern . EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On EQUAL shift to state 900
## Reductions:

State 900:
## Known stack suffix:
## LET ghost kind let_pattern EQUAL
## LR(1) items:
single_expr_ -> LET ghost kind let_pattern EQUAL . seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 901
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 901:
## Known stack suffix:
## LET ghost kind let_pattern EQUAL seq_expr
## LR(1) items:
single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 902
## Reductions:

State 902:
## Known stack suffix:
## LET ghost kind let_pattern EQUAL seq_expr IN
## LR(1) items:
single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 903
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 903:
## Known stack suffix:
## LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
## LR(1) items:
single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On WITH reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On VARIANT reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On VAL reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On USE reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On TYPE reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On TO reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On THEN reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On SEMICOLON reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On SCOPE reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On RIGHTSQ reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On RIGHTPAR reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On RIGHTBRC reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On RETURNS reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On REQUIRES reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On READS reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On RAISES reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On PREDICATE reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On OP4 reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On OP3 reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On OP2 reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On OP1 reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On MINUS reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On META reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On LTGT reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On LT reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On LET reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On LEMMA reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On LARROW reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On INDUCTIVE reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On IN reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On IMPORT reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On GT reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On GOAL reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On FUNCTION reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On EXCEPTION reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On EQUAL reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On EOF reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On ENSURES reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On END reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On ELSE reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On DOWNTO reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On DOTDOT reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On DONE reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On DO reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On DIVERGES reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On CONSTANT reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On COMMA reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On COLON reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On COINDUCTIVE reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On CLONE reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On BARBAR reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On BAR reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On AXIOM reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On AMPAMP reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
-- On ALIAS reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr

State 904:
## Known stack suffix:
## let_pat_uni_
## LR(1) items:
let_pat_conj_ -> let_pat_uni_ . [ EQUAL BAR ]
mk_pat(let_pat_uni_) -> let_pat_uni_ . [ COMMA COLON AS ]
## Transitions:
## Reductions:
-- On EQUAL reduce production let_pat_conj_ -> let_pat_uni_
-- On COMMA reduce production mk_pat(let_pat_uni_) -> let_pat_uni_
-- On COLON reduce production mk_pat(let_pat_uni_) -> let_pat_uni_
-- On BAR reduce production let_pat_conj_ -> let_pat_uni_
-- On AS reduce production mk_pat(let_pat_uni_) -> let_pat_uni_

State 905:
## Known stack suffix:
## let_pat_conj_
## LR(1) items:
let_pattern_ -> let_pat_conj_ . [ EQUAL ]
mk_pat(let_pat_conj_) -> let_pat_conj_ . [ BAR ]
## Transitions:
## Reductions:
-- On EQUAL reduce production let_pattern_ -> let_pat_conj_
-- On BAR reduce production mk_pat(let_pat_conj_) -> let_pat_conj_

State 906:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq)
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) . EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost kind attrs(lident_op_nq) . mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On EQUAL shift to state 907
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On mk_expr(fun_defn) shift to state 911
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On fun_defn shift to state 914
-- On binders shift to state 915
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:

State 907:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) EQUAL
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL . seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 908
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 908:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) EQUAL seq_expr
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 909
## Reductions:

State 909:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 910
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 910:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On WITH reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On VARIANT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On VAL reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On USE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On TYPE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On TO reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On THEN reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On SEMICOLON reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On SCOPE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On RIGHTSQ reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On RIGHTPAR reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On RIGHTBRC reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On RETURNS reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On REQUIRES reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On READS reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On RAISES reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On PREDICATE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On OP4 reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On OP3 reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On OP2 reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On OP1 reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On MINUS reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On META reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On LTGT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On LT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On LET reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On LEMMA reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On LARROW reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On INDUCTIVE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On IN reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On IMPORT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On GT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On GOAL reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On FUNCTION reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On EXCEPTION reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On EQUAL reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On EOF reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On ENSURES reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On END reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On ELSE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On DOWNTO reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On DOTDOT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On DONE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On DO reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On DIVERGES reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On CONSTANT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On COMMA reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On COLON reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On COINDUCTIVE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On CLONE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On BARBAR reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On BAR reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On AXIOM reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On AMPAMP reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
-- On ALIAS reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr

State 911:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn)
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 912
## Reductions:

State 912:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 913
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 913:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On WITH reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On VARIANT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On VAL reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On USE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On TYPE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On TO reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On THEN reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On SEMICOLON reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On SCOPE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On RIGHTSQ reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On RIGHTPAR reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On RIGHTBRC reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On RETURNS reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On REQUIRES reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On READS reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On RAISES reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On PREDICATE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On OP4 reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On OP3 reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On OP2 reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On OP1 reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On MINUS reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On META reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On LTGT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On LT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On LET reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On LEMMA reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On LARROW reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On INDUCTIVE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On IN reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On IMPORT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On GT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On GOAL reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On FUNCTION reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On EXCEPTION reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On EQUAL reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On EOF reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On ENSURES reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On END reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On ELSE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On DOWNTO reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On DOTDOT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On DONE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On DO reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On DIVERGES reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On CONSTANT reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On COMMA reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On COLON reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On COINDUCTIVE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On CLONE reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On BARBAR reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On BAR reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On AXIOM reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On AMPAMP reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
-- On ALIAS reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr

State 914:
## Known stack suffix:
## fun_defn
## LR(1) items:
mk_expr(fun_defn) -> fun_defn . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production mk_expr(fun_defn) -> fun_defn
-- On USE reduce production mk_expr(fun_defn) -> fun_defn
-- On TYPE reduce production mk_expr(fun_defn) -> fun_defn
-- On SCOPE reduce production mk_expr(fun_defn) -> fun_defn
-- On PREDICATE reduce production mk_expr(fun_defn) -> fun_defn
-- On META reduce production mk_expr(fun_defn) -> fun_defn
-- On LET reduce production mk_expr(fun_defn) -> fun_defn
-- On LEMMA reduce production mk_expr(fun_defn) -> fun_defn
-- On INDUCTIVE reduce production mk_expr(fun_defn) -> fun_defn
-- On IN reduce production mk_expr(fun_defn) -> fun_defn
-- On IMPORT reduce production mk_expr(fun_defn) -> fun_defn
-- On GOAL reduce production mk_expr(fun_defn) -> fun_defn
-- On FUNCTION reduce production mk_expr(fun_defn) -> fun_defn
-- On EXCEPTION reduce production mk_expr(fun_defn) -> fun_defn
-- On EOF reduce production mk_expr(fun_defn) -> fun_defn
-- On END reduce production mk_expr(fun_defn) -> fun_defn
-- On CONSTANT reduce production mk_expr(fun_defn) -> fun_defn
-- On COINDUCTIVE reduce production mk_expr(fun_defn) -> fun_defn
-- On CLONE reduce production mk_expr(fun_defn) -> fun_defn
-- On AXIOM reduce production mk_expr(fun_defn) -> fun_defn

State 915:
## Known stack suffix:
## binders
## LR(1) items:
fun_defn -> binders . return_opt spec EQUAL spec seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 148
-- On return_opt shift to state 916
## Reductions:
-- On WRITES reduce production return_opt ->
-- On VARIANT reduce production return_opt ->
-- On RETURNS reduce production return_opt ->
-- On REQUIRES reduce production return_opt ->
-- On READS reduce production return_opt ->
-- On RAISES reduce production return_opt ->
-- On EQUAL reduce production return_opt ->
-- On ENSURES reduce production return_opt ->
-- On DIVERGES reduce production return_opt ->
-- On ALIAS reduce production return_opt ->

State 916:
## Known stack suffix:
## binders return_opt
## LR(1) items:
fun_defn -> binders return_opt . spec EQUAL spec seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 917
-- On single_spec shift to state 567
## Reductions:
-- On EQUAL reduce production spec ->

State 917:
## Known stack suffix:
## binders return_opt spec
## LR(1) items:
fun_defn -> binders return_opt spec . EQUAL spec seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 918
## Reductions:

State 918:
## Known stack suffix:
## binders return_opt spec EQUAL
## LR(1) items:
fun_defn -> binders return_opt spec EQUAL . spec seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 919
-- On single_spec shift to state 567
## Reductions:
-- On WHILE reduce production spec ->
-- On VAL reduce production spec ->
-- On UIDENT reduce production spec ->
-- On TRY reduce production spec ->
-- On TRUE reduce production spec ->
-- On RETURN reduce production spec ->
-- On REAL reduce production spec ->
-- On RANGE reduce production spec ->
-- On RAISE reduce production spec ->
-- On PURE reduce production spec ->
-- On POSITION reduce production spec ->
-- On OPPREF reduce production spec ->
-- On OP4 reduce production spec ->
-- On OP3 reduce production spec ->
-- On OP2 reduce production spec ->
-- On OP1 reduce production spec ->
-- On NOT reduce production spec ->
-- On MINUS reduce production spec ->
-- On MATCH reduce production spec ->
-- On LT reduce production spec ->
-- On LIDENT reduce production spec ->
-- On LET reduce production spec ->
-- On LEFTPAR reduce production spec ->
-- On LEFTBRC reduce production spec ->
-- On LABEL reduce production spec ->
-- On INTEGER reduce production spec ->
-- On IF reduce production spec ->
-- On GT reduce production spec ->
-- On GHOST reduce production spec ->
-- On FUN reduce production spec ->
-- On FOR reduce production spec ->
-- On FLOAT reduce production spec ->
-- On FALSE reduce production spec ->
-- On EXCEPTION reduce production spec ->
-- On CORE_UIDENT reduce production spec ->
-- On CORE_LIDENT reduce production spec ->
-- On CONTINUE reduce production spec ->
-- On CHECK reduce production spec ->
-- On BREAK reduce production spec ->
-- On BEGIN reduce production spec ->
-- On ATTRIBUTE reduce production spec ->
-- On ASSUME reduce production spec ->
-- On ASSERT reduce production spec ->
-- On ANY reduce production spec ->
-- On ABSURD reduce production spec ->

State 919:
## Known stack suffix:
## binders return_opt spec EQUAL spec
## LR(1) items:
fun_defn -> binders return_opt spec EQUAL spec . seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 920
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 920:
## Known stack suffix:
## binders return_opt spec EQUAL spec seq_expr
## LR(1) items:
fun_defn -> binders return_opt spec EQUAL spec seq_expr . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On USE reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On TYPE reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On SCOPE reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On PREDICATE reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On META reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On LET reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On LEMMA reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On INDUCTIVE reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On IN reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On IMPORT reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On GOAL reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On FUNCTION reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On EXCEPTION reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On EOF reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On END reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On CONSTANT reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On COINDUCTIVE reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On CLONE reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr
-- On AXIOM reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr

State 921:
## Known stack suffix:
## LET ghost kind attrs(lident_nq)
## LR(1) items:
pat_arg_ -> attrs(lident_nq) . [ EQUAL COMMA COLON BAR AS ]
single_expr_ -> LET ghost kind attrs(lident_nq) . mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On mk_expr(fun_defn) shift to state 922
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On fun_defn shift to state 914
-- On binders shift to state 915
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:
-- On EQUAL reduce production pat_arg_ -> attrs(lident_nq)
-- On COMMA reduce production pat_arg_ -> attrs(lident_nq)
-- On COLON reduce production pat_arg_ -> attrs(lident_nq)
-- On BAR reduce production pat_arg_ -> attrs(lident_nq)
-- On AS reduce production pat_arg_ -> attrs(lident_nq)

State 922:
## Known stack suffix:
## LET ghost kind attrs(lident_nq) mk_expr(fun_defn)
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 923
## Reductions:

State 923:
## Known stack suffix:
## LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 924
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 924:
## Known stack suffix:
## LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On WITH reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On VARIANT reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On VAL reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On USE reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On TYPE reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On TO reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On THEN reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On SEMICOLON reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On SCOPE reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On RIGHTSQ reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On RIGHTPAR reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On RIGHTBRC reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On RETURNS reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On REQUIRES reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On READS reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On RAISES reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On PREDICATE reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On OP4 reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On OP3 reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On OP2 reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On OP1 reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On MINUS reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On META reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On LTGT reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On LT reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On LET reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On LEMMA reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On LARROW reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On INDUCTIVE reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On IN reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On IMPORT reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On GT reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On GOAL reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On FUNCTION reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On EXCEPTION reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On EQUAL reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On EOF reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On ENSURES reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On END reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On ELSE reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On DOWNTO reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On DOTDOT reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On DONE reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On DO reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On DIVERGES reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On CONSTANT reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On COMMA reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On COLON reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On COINDUCTIVE reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On CLONE reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On BARBAR reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On BAR reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On AXIOM reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On AMPAMP reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
-- On ALIAS reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr

State 925:
## Known stack suffix:
## MATCH seq_expr
## LR(1) items:
single_expr_ -> MATCH seq_expr . WITH ext_match_cases END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WITH shift to state 926
## Reductions:

State 926:
## Known stack suffix:
## MATCH seq_expr WITH
## LR(1) items:
single_expr_ -> MATCH seq_expr WITH . ext_match_cases END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On EXCEPTION shift to state 927
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On BAR shift to state 942
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 935
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_case(seq_expr) shift to state 938
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On ext_match_cases1 shift to state 944
-- On ext_match_cases shift to state 945
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 927:
## Known stack suffix:
## EXCEPTION
## LR(1) items:
ext_match_cases1 -> EXCEPTION . exn_handler ext_match_cases0 [ END ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 928
-- On uident shift to state 89
-- On exn_handler shift to state 933
## Reductions:

State 928:
## Known stack suffix:
## uqualid
## LR(1) items:
exn_handler -> uqualid . option(pat_arg) ARROW seq_expr [ END BAR ]
uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT DOT CORE_UIDENT CORE_LIDENT ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On DOT shift to state 526
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 231
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 233
-- On pat_arg shift to state 929
-- On option(pat_arg) shift to state 930
-- On mk_pat(pat_arg_) shift to state 236
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:
-- On ARROW reduce production option(pat_arg) ->

State 929:
## Known stack suffix:
## pat_arg
## LR(1) items:
option(pat_arg) -> pat_arg . [ ARROW ]
## Transitions:
## Reductions:
-- On ARROW reduce production option(pat_arg) -> pat_arg

State 930:
## Known stack suffix:
## uqualid option(pat_arg)
## LR(1) items:
exn_handler -> uqualid option(pat_arg) . ARROW seq_expr [ END BAR ]
## Transitions:
-- On ARROW shift to state 931
## Reductions:

State 931:
## Known stack suffix:
## uqualid option(pat_arg) ARROW
## LR(1) items:
exn_handler -> uqualid option(pat_arg) ARROW . seq_expr [ END BAR ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 932
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 932:
## Known stack suffix:
## uqualid option(pat_arg) ARROW seq_expr
## LR(1) items:
exn_handler -> uqualid option(pat_arg) ARROW seq_expr . [ END BAR ]
## Transitions:
## Reductions:
-- On END reduce production exn_handler -> uqualid option(pat_arg) ARROW seq_expr
-- On BAR reduce production exn_handler -> uqualid option(pat_arg) ARROW seq_expr

State 933:
## Known stack suffix:
## EXCEPTION exn_handler
## LR(1) items:
ext_match_cases1 -> EXCEPTION exn_handler . ext_match_cases0 [ END ]
## Transitions:
-- On BAR shift to state 934
-- On ext_match_cases0 shift to state 941
## Reductions:
-- On END reduce production ext_match_cases0 ->

State 934:
## Known stack suffix:
## BAR
## LR(1) items:
ext_match_cases0 -> BAR . ext_match_cases1 [ END ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On EXCEPTION shift to state 927
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 935
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_case(seq_expr) shift to state 938
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On ext_match_cases1 shift to state 940
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 935:
## Known stack suffix:
## pattern
## LR(1) items:
match_case(seq_expr) -> pattern . ARROW seq_expr [ END BAR ]
## Transitions:
-- On ARROW shift to state 936
## Reductions:

State 936:
## Known stack suffix:
## pattern ARROW
## LR(1) items:
match_case(seq_expr) -> pattern ARROW . seq_expr [ END BAR ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 937
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 937:
## Known stack suffix:
## pattern ARROW seq_expr
## LR(1) items:
match_case(seq_expr) -> pattern ARROW seq_expr . [ END BAR ]
## Transitions:
## Reductions:
-- On END reduce production match_case(seq_expr) -> pattern ARROW seq_expr
-- On BAR reduce production match_case(seq_expr) -> pattern ARROW seq_expr

State 938:
## Known stack suffix:
## match_case(seq_expr)
## LR(1) items:
ext_match_cases1 -> match_case(seq_expr) . ext_match_cases0 [ END ]
## Transitions:
-- On BAR shift to state 934
-- On ext_match_cases0 shift to state 939
## Reductions:
-- On END reduce production ext_match_cases0 ->

State 939:
## Known stack suffix:
## match_case(seq_expr) ext_match_cases0
## LR(1) items:
ext_match_cases1 -> match_case(seq_expr) ext_match_cases0 . [ END ]
## Transitions:
## Reductions:
-- On END reduce production ext_match_cases1 -> match_case(seq_expr) ext_match_cases0

State 940:
## Known stack suffix:
## BAR ext_match_cases1
## LR(1) items:
ext_match_cases0 -> BAR ext_match_cases1 . [ END ]
## Transitions:
## Reductions:
-- On END reduce production ext_match_cases0 -> BAR ext_match_cases1

State 941:
## Known stack suffix:
## EXCEPTION exn_handler ext_match_cases0
## LR(1) items:
ext_match_cases1 -> EXCEPTION exn_handler ext_match_cases0 . [ END ]
## Transitions:
## Reductions:
-- On END reduce production ext_match_cases1 -> EXCEPTION exn_handler ext_match_cases0

State 942:
## Known stack suffix:
## BAR
## LR(1) items:
ext_match_cases -> BAR . ext_match_cases1 [ END ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On EXCEPTION shift to state 927
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 935
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_case(seq_expr) shift to state 938
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On ext_match_cases1 shift to state 943
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 943:
## Known stack suffix:
## BAR ext_match_cases1
## LR(1) items:
ext_match_cases -> BAR ext_match_cases1 . [ END ]
## Transitions:
## Reductions:
-- On END reduce production ext_match_cases -> BAR ext_match_cases1

State 944:
## Known stack suffix:
## ext_match_cases1
## LR(1) items:
ext_match_cases -> ext_match_cases1 . [ END ]
## Transitions:
## Reductions:
-- On END reduce production ext_match_cases -> ext_match_cases1

State 945:
## Known stack suffix:
## MATCH seq_expr WITH ext_match_cases
## LR(1) items:
single_expr_ -> MATCH seq_expr WITH ext_match_cases . END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On END shift to state 946
## Reductions:

State 946:
## Known stack suffix:
## MATCH seq_expr WITH ext_match_cases END
## LR(1) items:
single_expr_ -> MATCH seq_expr WITH ext_match_cases END . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On WITH reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On VARIANT reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On VAL reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On USE reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On TYPE reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On TO reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On THEN reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On SEMICOLON reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On SCOPE reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On RIGHTSQ reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On RIGHTPAR reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On RIGHTBRC reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On RETURNS reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On REQUIRES reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On READS reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On RAISES reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On PREDICATE reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On OP4 reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On OP3 reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On OP2 reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On OP1 reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On MINUS reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On META reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On LTGT reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On LT reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On LET reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On LEMMA reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On LARROW reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On INDUCTIVE reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On IN reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On IMPORT reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On GT reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On GOAL reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On FUNCTION reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On EXCEPTION reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On EQUAL reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On EOF reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On ENSURES reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On END reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On ELSE reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On DOWNTO reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On DOTDOT reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On DONE reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On DO reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On DIVERGES reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On CONSTANT reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On COMMA reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On COLON reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On COINDUCTIVE reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On CLONE reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On BARBAR reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On BAR reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On AXIOM reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On AMPAMP reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END
-- On ALIAS reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END

State 947:
## Known stack suffix:
## NOT single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> NOT single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On cast shift to state 782
## Reductions:
-- On WRITES reduce production single_expr_ -> NOT single_expr
-- On WITH reduce production single_expr_ -> NOT single_expr
-- On VARIANT reduce production single_expr_ -> NOT single_expr
-- On VAL reduce production single_expr_ -> NOT single_expr
-- On USE reduce production single_expr_ -> NOT single_expr
-- On TYPE reduce production single_expr_ -> NOT single_expr
-- On TO reduce production single_expr_ -> NOT single_expr
-- On THEN reduce production single_expr_ -> NOT single_expr
-- On SEMICOLON reduce production single_expr_ -> NOT single_expr
-- On SCOPE reduce production single_expr_ -> NOT single_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> NOT single_expr
-- On RIGHTSQ reduce production single_expr_ -> NOT single_expr
-- On RIGHTPAR reduce production single_expr_ -> NOT single_expr
-- On RIGHTBRC reduce production single_expr_ -> NOT single_expr
-- On RETURNS reduce production single_expr_ -> NOT single_expr
-- On REQUIRES reduce production single_expr_ -> NOT single_expr
-- On READS reduce production single_expr_ -> NOT single_expr
-- On RAISES reduce production single_expr_ -> NOT single_expr
-- On PREDICATE reduce production single_expr_ -> NOT single_expr
-- On META reduce production single_expr_ -> NOT single_expr
-- On LET reduce production single_expr_ -> NOT single_expr
-- On LEMMA reduce production single_expr_ -> NOT single_expr
-- On LARROW reduce production single_expr_ -> NOT single_expr
-- On INDUCTIVE reduce production single_expr_ -> NOT single_expr
-- On IN reduce production single_expr_ -> NOT single_expr
-- On IMPORT reduce production single_expr_ -> NOT single_expr
-- On GOAL reduce production single_expr_ -> NOT single_expr
-- On FUNCTION reduce production single_expr_ -> NOT single_expr
-- On EXCEPTION reduce production single_expr_ -> NOT single_expr
-- On EOF reduce production single_expr_ -> NOT single_expr
-- On ENSURES reduce production single_expr_ -> NOT single_expr
-- On END reduce production single_expr_ -> NOT single_expr
-- On ELSE reduce production single_expr_ -> NOT single_expr
-- On DOWNTO reduce production single_expr_ -> NOT single_expr
-- On DOTDOT reduce production single_expr_ -> NOT single_expr
-- On DONE reduce production single_expr_ -> NOT single_expr
-- On DO reduce production single_expr_ -> NOT single_expr
-- On DIVERGES reduce production single_expr_ -> NOT single_expr
-- On CONSTANT reduce production single_expr_ -> NOT single_expr
-- On COMMA reduce production single_expr_ -> NOT single_expr
-- On COLON reduce production single_expr_ -> NOT single_expr
-- On COINDUCTIVE reduce production single_expr_ -> NOT single_expr
-- On CLONE reduce production single_expr_ -> NOT single_expr
-- On BARBAR reduce production single_expr_ -> NOT single_expr
-- On BAR reduce production single_expr_ -> NOT single_expr
-- On AXIOM reduce production single_expr_ -> NOT single_expr
-- On AMPAMP reduce production single_expr_ -> NOT single_expr
-- On ALIAS reduce production single_expr_ -> NOT single_expr

State 948:
## Known stack suffix:
## BEGIN END
## LR(1) items:
expr_block_ -> BEGIN END . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_block_ -> BEGIN END
-- On WITH reduce production expr_block_ -> BEGIN END
-- On VARIANT reduce production expr_block_ -> BEGIN END
-- On VAL reduce production expr_block_ -> BEGIN END
-- On USE reduce production expr_block_ -> BEGIN END
-- On UIDENT reduce production expr_block_ -> BEGIN END
-- On TYPE reduce production expr_block_ -> BEGIN END
-- On TRUE reduce production expr_block_ -> BEGIN END
-- On TO reduce production expr_block_ -> BEGIN END
-- On THEN reduce production expr_block_ -> BEGIN END
-- On SEMICOLON reduce production expr_block_ -> BEGIN END
-- On SCOPE reduce production expr_block_ -> BEGIN END
-- On RIGHTSQ_QUOTE reduce production expr_block_ -> BEGIN END
-- On RIGHTSQ reduce production expr_block_ -> BEGIN END
-- On RIGHTPAR reduce production expr_block_ -> BEGIN END
-- On RIGHTBRC reduce production expr_block_ -> BEGIN END
-- On RETURNS reduce production expr_block_ -> BEGIN END
-- On REQUIRES reduce production expr_block_ -> BEGIN END
-- On REAL reduce production expr_block_ -> BEGIN END
-- On READS reduce production expr_block_ -> BEGIN END
-- On RANGE reduce production expr_block_ -> BEGIN END
-- On RAISES reduce production expr_block_ -> BEGIN END
-- On PURE reduce production expr_block_ -> BEGIN END
-- On PREDICATE reduce production expr_block_ -> BEGIN END
-- On OPPREF reduce production expr_block_ -> BEGIN END
-- On OP4 reduce production expr_block_ -> BEGIN END
-- On OP3 reduce production expr_block_ -> BEGIN END
-- On OP2 reduce production expr_block_ -> BEGIN END
-- On OP1 reduce production expr_block_ -> BEGIN END
-- On MINUS reduce production expr_block_ -> BEGIN END
-- On META reduce production expr_block_ -> BEGIN END
-- On LTGT reduce production expr_block_ -> BEGIN END
-- On LT reduce production expr_block_ -> BEGIN END
-- On LIDENT reduce production expr_block_ -> BEGIN END
-- On LET reduce production expr_block_ -> BEGIN END
-- On LEMMA reduce production expr_block_ -> BEGIN END
-- On LEFTSQ reduce production expr_block_ -> BEGIN END
-- On LEFTPAR reduce production expr_block_ -> BEGIN END
-- On LEFTBRC reduce production expr_block_ -> BEGIN END
-- On LARROW reduce production expr_block_ -> BEGIN END
-- On INTEGER reduce production expr_block_ -> BEGIN END
-- On INDUCTIVE reduce production expr_block_ -> BEGIN END
-- On IN reduce production expr_block_ -> BEGIN END
-- On IMPORT reduce production expr_block_ -> BEGIN END
-- On GT reduce production expr_block_ -> BEGIN END
-- On GOAL reduce production expr_block_ -> BEGIN END
-- On FUNCTION reduce production expr_block_ -> BEGIN END
-- On FLOAT reduce production expr_block_ -> BEGIN END
-- On FALSE reduce production expr_block_ -> BEGIN END
-- On EXCEPTION reduce production expr_block_ -> BEGIN END
-- On EQUAL reduce production expr_block_ -> BEGIN END
-- On EOF reduce production expr_block_ -> BEGIN END
-- On ENSURES reduce production expr_block_ -> BEGIN END
-- On END reduce production expr_block_ -> BEGIN END
-- On ELSE reduce production expr_block_ -> BEGIN END
-- On DOWNTO reduce production expr_block_ -> BEGIN END
-- On DOTDOT reduce production expr_block_ -> BEGIN END
-- On DOT reduce production expr_block_ -> BEGIN END
-- On DONE reduce production expr_block_ -> BEGIN END
-- On DO reduce production expr_block_ -> BEGIN END
-- On DIVERGES reduce production expr_block_ -> BEGIN END
-- On CORE_UIDENT reduce production expr_block_ -> BEGIN END
-- On CORE_LIDENT reduce production expr_block_ -> BEGIN END
-- On CONSTANT reduce production expr_block_ -> BEGIN END
-- On COMMA reduce production expr_block_ -> BEGIN END
-- On COLON reduce production expr_block_ -> BEGIN END
-- On COINDUCTIVE reduce production expr_block_ -> BEGIN END
-- On CLONE reduce production expr_block_ -> BEGIN END
-- On BEGIN reduce production expr_block_ -> BEGIN END
-- On BARBAR reduce production expr_block_ -> BEGIN END
-- On BAR reduce production expr_block_ -> BEGIN END
-- On AXIOM reduce production expr_block_ -> BEGIN END
-- On AMPAMP reduce production expr_block_ -> BEGIN END
-- On ALIAS reduce production expr_block_ -> BEGIN END

State 949:
## Known stack suffix:
## BEGIN single_spec
## LR(1) items:
expr_block_ -> BEGIN single_spec . spec seq_expr END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> BEGIN single_spec . spec END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 950
-- On single_spec shift to state 567
## Reductions:
-- On WHILE reduce production spec ->
-- On VAL reduce production spec ->
-- On UIDENT reduce production spec ->
-- On TRY reduce production spec ->
-- On TRUE reduce production spec ->
-- On RETURN reduce production spec ->
-- On REAL reduce production spec ->
-- On RANGE reduce production spec ->
-- On RAISE reduce production spec ->
-- On PURE reduce production spec ->
-- On POSITION reduce production spec ->
-- On OPPREF reduce production spec ->
-- On OP4 reduce production spec ->
-- On OP3 reduce production spec ->
-- On OP2 reduce production spec ->
-- On OP1 reduce production spec ->
-- On NOT reduce production spec ->
-- On MINUS reduce production spec ->
-- On MATCH reduce production spec ->
-- On LT reduce production spec ->
-- On LIDENT reduce production spec ->
-- On LET reduce production spec ->
-- On LEFTPAR reduce production spec ->
-- On LEFTBRC reduce production spec ->
-- On LABEL reduce production spec ->
-- On INTEGER reduce production spec ->
-- On IF reduce production spec ->
-- On GT reduce production spec ->
-- On GHOST reduce production spec ->
-- On FUN reduce production spec ->
-- On FOR reduce production spec ->
-- On FLOAT reduce production spec ->
-- On FALSE reduce production spec ->
-- On EXCEPTION reduce production spec ->
-- On END reduce production spec ->
-- On CORE_UIDENT reduce production spec ->
-- On CORE_LIDENT reduce production spec ->
-- On CONTINUE reduce production spec ->
-- On CHECK reduce production spec ->
-- On BREAK reduce production spec ->
-- On BEGIN reduce production spec ->
-- On ATTRIBUTE reduce production spec ->
-- On ASSUME reduce production spec ->
-- On ASSERT reduce production spec ->
-- On ANY reduce production spec ->
-- On ABSURD reduce production spec ->

State 950:
## Known stack suffix:
## BEGIN single_spec spec
## LR(1) items:
expr_block_ -> BEGIN single_spec spec . seq_expr END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> BEGIN single_spec spec . END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On END shift to state 951
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 952
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 951:
## Known stack suffix:
## BEGIN single_spec spec END
## LR(1) items:
expr_block_ -> BEGIN single_spec spec END . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_block_ -> BEGIN single_spec spec END
-- On WITH reduce production expr_block_ -> BEGIN single_spec spec END
-- On VARIANT reduce production expr_block_ -> BEGIN single_spec spec END
-- On VAL reduce production expr_block_ -> BEGIN single_spec spec END
-- On USE reduce production expr_block_ -> BEGIN single_spec spec END
-- On UIDENT reduce production expr_block_ -> BEGIN single_spec spec END
-- On TYPE reduce production expr_block_ -> BEGIN single_spec spec END
-- On TRUE reduce production expr_block_ -> BEGIN single_spec spec END
-- On TO reduce production expr_block_ -> BEGIN single_spec spec END
-- On THEN reduce production expr_block_ -> BEGIN single_spec spec END
-- On SEMICOLON reduce production expr_block_ -> BEGIN single_spec spec END
-- On SCOPE reduce production expr_block_ -> BEGIN single_spec spec END
-- On RIGHTSQ_QUOTE reduce production expr_block_ -> BEGIN single_spec spec END
-- On RIGHTSQ reduce production expr_block_ -> BEGIN single_spec spec END
-- On RIGHTPAR reduce production expr_block_ -> BEGIN single_spec spec END
-- On RIGHTBRC reduce production expr_block_ -> BEGIN single_spec spec END
-- On RETURNS reduce production expr_block_ -> BEGIN single_spec spec END
-- On REQUIRES reduce production expr_block_ -> BEGIN single_spec spec END
-- On REAL reduce production expr_block_ -> BEGIN single_spec spec END
-- On READS reduce production expr_block_ -> BEGIN single_spec spec END
-- On RANGE reduce production expr_block_ -> BEGIN single_spec spec END
-- On RAISES reduce production expr_block_ -> BEGIN single_spec spec END
-- On PURE reduce production expr_block_ -> BEGIN single_spec spec END
-- On PREDICATE reduce production expr_block_ -> BEGIN single_spec spec END
-- On OPPREF reduce production expr_block_ -> BEGIN single_spec spec END
-- On OP4 reduce production expr_block_ -> BEGIN single_spec spec END
-- On OP3 reduce production expr_block_ -> BEGIN single_spec spec END
-- On OP2 reduce production expr_block_ -> BEGIN single_spec spec END
-- On OP1 reduce production expr_block_ -> BEGIN single_spec spec END
-- On MINUS reduce production expr_block_ -> BEGIN single_spec spec END
-- On META reduce production expr_block_ -> BEGIN single_spec spec END
-- On LTGT reduce production expr_block_ -> BEGIN single_spec spec END
-- On LT reduce production expr_block_ -> BEGIN single_spec spec END
-- On LIDENT reduce production expr_block_ -> BEGIN single_spec spec END
-- On LET reduce production expr_block_ -> BEGIN single_spec spec END
-- On LEMMA reduce production expr_block_ -> BEGIN single_spec spec END
-- On LEFTSQ reduce production expr_block_ -> BEGIN single_spec spec END
-- On LEFTPAR reduce production expr_block_ -> BEGIN single_spec spec END
-- On LEFTBRC reduce production expr_block_ -> BEGIN single_spec spec END
-- On LARROW reduce production expr_block_ -> BEGIN single_spec spec END
-- On INTEGER reduce production expr_block_ -> BEGIN single_spec spec END
-- On INDUCTIVE reduce production expr_block_ -> BEGIN single_spec spec END
-- On IN reduce production expr_block_ -> BEGIN single_spec spec END
-- On IMPORT reduce production expr_block_ -> BEGIN single_spec spec END
-- On GT reduce production expr_block_ -> BEGIN single_spec spec END
-- On GOAL reduce production expr_block_ -> BEGIN single_spec spec END
-- On FUNCTION reduce production expr_block_ -> BEGIN single_spec spec END
-- On FLOAT reduce production expr_block_ -> BEGIN single_spec spec END
-- On FALSE reduce production expr_block_ -> BEGIN single_spec spec END
-- On EXCEPTION reduce production expr_block_ -> BEGIN single_spec spec END
-- On EQUAL reduce production expr_block_ -> BEGIN single_spec spec END
-- On EOF reduce production expr_block_ -> BEGIN single_spec spec END
-- On ENSURES reduce production expr_block_ -> BEGIN single_spec spec END
-- On END reduce production expr_block_ -> BEGIN single_spec spec END
-- On ELSE reduce production expr_block_ -> BEGIN single_spec spec END
-- On DOWNTO reduce production expr_block_ -> BEGIN single_spec spec END
-- On DOTDOT reduce production expr_block_ -> BEGIN single_spec spec END
-- On DOT reduce production expr_block_ -> BEGIN single_spec spec END
-- On DONE reduce production expr_block_ -> BEGIN single_spec spec END
-- On DO reduce production expr_block_ -> BEGIN single_spec spec END
-- On DIVERGES reduce production expr_block_ -> BEGIN single_spec spec END
-- On CORE_UIDENT reduce production expr_block_ -> BEGIN single_spec spec END
-- On CORE_LIDENT reduce production expr_block_ -> BEGIN single_spec spec END
-- On CONSTANT reduce production expr_block_ -> BEGIN single_spec spec END
-- On COMMA reduce production expr_block_ -> BEGIN single_spec spec END
-- On COLON reduce production expr_block_ -> BEGIN single_spec spec END
-- On COINDUCTIVE reduce production expr_block_ -> BEGIN single_spec spec END
-- On CLONE reduce production expr_block_ -> BEGIN single_spec spec END
-- On BEGIN reduce production expr_block_ -> BEGIN single_spec spec END
-- On BARBAR reduce production expr_block_ -> BEGIN single_spec spec END
-- On BAR reduce production expr_block_ -> BEGIN single_spec spec END
-- On AXIOM reduce production expr_block_ -> BEGIN single_spec spec END
-- On AMPAMP reduce production expr_block_ -> BEGIN single_spec spec END
-- On ALIAS reduce production expr_block_ -> BEGIN single_spec spec END

State 952:
## Known stack suffix:
## BEGIN single_spec spec seq_expr
## LR(1) items:
expr_block_ -> BEGIN single_spec spec seq_expr . END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On END shift to state 953
## Reductions:

State 953:
## Known stack suffix:
## BEGIN single_spec spec seq_expr END
## LR(1) items:
expr_block_ -> BEGIN single_spec spec seq_expr END . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On WITH reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On VARIANT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On VAL reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On USE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On UIDENT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On TYPE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On TRUE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On TO reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On THEN reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On SEMICOLON reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On SCOPE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On RIGHTSQ_QUOTE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On RIGHTSQ reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On RIGHTPAR reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On RIGHTBRC reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On RETURNS reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On REQUIRES reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On REAL reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On READS reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On RANGE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On RAISES reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On PURE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On PREDICATE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On OPPREF reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On OP4 reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On OP3 reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On OP2 reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On OP1 reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On MINUS reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On META reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On LTGT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On LT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On LIDENT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On LET reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On LEMMA reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On LEFTSQ reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On LEFTPAR reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On LEFTBRC reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On LARROW reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On INTEGER reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On INDUCTIVE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On IN reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On IMPORT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On GT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On GOAL reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On FUNCTION reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On FLOAT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On FALSE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On EXCEPTION reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On EQUAL reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On EOF reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On ENSURES reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On END reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On ELSE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On DOWNTO reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On DOTDOT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On DOT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On DONE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On DO reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On DIVERGES reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On CORE_UIDENT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On CORE_LIDENT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On CONSTANT reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On COMMA reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On COLON reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On COINDUCTIVE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On CLONE reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On BEGIN reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On BARBAR reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On BAR reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On AXIOM reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On AMPAMP reduce production expr_block_ -> BEGIN single_spec spec seq_expr END
-- On ALIAS reduce production expr_block_ -> BEGIN single_spec spec seq_expr END

State 954:
## Known stack suffix:
## BEGIN seq_expr
## LR(1) items:
expr_block_ -> BEGIN seq_expr . END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On END shift to state 955
## Reductions:

State 955:
## Known stack suffix:
## BEGIN seq_expr END
## LR(1) items:
expr_block_ -> BEGIN seq_expr END . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_block_ -> BEGIN seq_expr END
-- On WITH reduce production expr_block_ -> BEGIN seq_expr END
-- On VARIANT reduce production expr_block_ -> BEGIN seq_expr END
-- On VAL reduce production expr_block_ -> BEGIN seq_expr END
-- On USE reduce production expr_block_ -> BEGIN seq_expr END
-- On UIDENT reduce production expr_block_ -> BEGIN seq_expr END
-- On TYPE reduce production expr_block_ -> BEGIN seq_expr END
-- On TRUE reduce production expr_block_ -> BEGIN seq_expr END
-- On TO reduce production expr_block_ -> BEGIN seq_expr END
-- On THEN reduce production expr_block_ -> BEGIN seq_expr END
-- On SEMICOLON reduce production expr_block_ -> BEGIN seq_expr END
-- On SCOPE reduce production expr_block_ -> BEGIN seq_expr END
-- On RIGHTSQ_QUOTE reduce production expr_block_ -> BEGIN seq_expr END
-- On RIGHTSQ reduce production expr_block_ -> BEGIN seq_expr END
-- On RIGHTPAR reduce production expr_block_ -> BEGIN seq_expr END
-- On RIGHTBRC reduce production expr_block_ -> BEGIN seq_expr END
-- On RETURNS reduce production expr_block_ -> BEGIN seq_expr END
-- On REQUIRES reduce production expr_block_ -> BEGIN seq_expr END
-- On REAL reduce production expr_block_ -> BEGIN seq_expr END
-- On READS reduce production expr_block_ -> BEGIN seq_expr END
-- On RANGE reduce production expr_block_ -> BEGIN seq_expr END
-- On RAISES reduce production expr_block_ -> BEGIN seq_expr END
-- On PURE reduce production expr_block_ -> BEGIN seq_expr END
-- On PREDICATE reduce production expr_block_ -> BEGIN seq_expr END
-- On OPPREF reduce production expr_block_ -> BEGIN seq_expr END
-- On OP4 reduce production expr_block_ -> BEGIN seq_expr END
-- On OP3 reduce production expr_block_ -> BEGIN seq_expr END
-- On OP2 reduce production expr_block_ -> BEGIN seq_expr END
-- On OP1 reduce production expr_block_ -> BEGIN seq_expr END
-- On MINUS reduce production expr_block_ -> BEGIN seq_expr END
-- On META reduce production expr_block_ -> BEGIN seq_expr END
-- On LTGT reduce production expr_block_ -> BEGIN seq_expr END
-- On LT reduce production expr_block_ -> BEGIN seq_expr END
-- On LIDENT reduce production expr_block_ -> BEGIN seq_expr END
-- On LET reduce production expr_block_ -> BEGIN seq_expr END
-- On LEMMA reduce production expr_block_ -> BEGIN seq_expr END
-- On LEFTSQ reduce production expr_block_ -> BEGIN seq_expr END
-- On LEFTPAR reduce production expr_block_ -> BEGIN seq_expr END
-- On LEFTBRC reduce production expr_block_ -> BEGIN seq_expr END
-- On LARROW reduce production expr_block_ -> BEGIN seq_expr END
-- On INTEGER reduce production expr_block_ -> BEGIN seq_expr END
-- On INDUCTIVE reduce production expr_block_ -> BEGIN seq_expr END
-- On IN reduce production expr_block_ -> BEGIN seq_expr END
-- On IMPORT reduce production expr_block_ -> BEGIN seq_expr END
-- On GT reduce production expr_block_ -> BEGIN seq_expr END
-- On GOAL reduce production expr_block_ -> BEGIN seq_expr END
-- On FUNCTION reduce production expr_block_ -> BEGIN seq_expr END
-- On FLOAT reduce production expr_block_ -> BEGIN seq_expr END
-- On FALSE reduce production expr_block_ -> BEGIN seq_expr END
-- On EXCEPTION reduce production expr_block_ -> BEGIN seq_expr END
-- On EQUAL reduce production expr_block_ -> BEGIN seq_expr END
-- On EOF reduce production expr_block_ -> BEGIN seq_expr END
-- On ENSURES reduce production expr_block_ -> BEGIN seq_expr END
-- On END reduce production expr_block_ -> BEGIN seq_expr END
-- On ELSE reduce production expr_block_ -> BEGIN seq_expr END
-- On DOWNTO reduce production expr_block_ -> BEGIN seq_expr END
-- On DOTDOT reduce production expr_block_ -> BEGIN seq_expr END
-- On DOT reduce production expr_block_ -> BEGIN seq_expr END
-- On DONE reduce production expr_block_ -> BEGIN seq_expr END
-- On DO reduce production expr_block_ -> BEGIN seq_expr END
-- On DIVERGES reduce production expr_block_ -> BEGIN seq_expr END
-- On CORE_UIDENT reduce production expr_block_ -> BEGIN seq_expr END
-- On CORE_LIDENT reduce production expr_block_ -> BEGIN seq_expr END
-- On CONSTANT reduce production expr_block_ -> BEGIN seq_expr END
-- On COMMA reduce production expr_block_ -> BEGIN seq_expr END
-- On COLON reduce production expr_block_ -> BEGIN seq_expr END
-- On COINDUCTIVE reduce production expr_block_ -> BEGIN seq_expr END
-- On CLONE reduce production expr_block_ -> BEGIN seq_expr END
-- On BEGIN reduce production expr_block_ -> BEGIN seq_expr END
-- On BARBAR reduce production expr_block_ -> BEGIN seq_expr END
-- On BAR reduce production expr_block_ -> BEGIN seq_expr END
-- On AXIOM reduce production expr_block_ -> BEGIN seq_expr END
-- On AMPAMP reduce production expr_block_ -> BEGIN seq_expr END
-- On ALIAS reduce production expr_block_ -> BEGIN seq_expr END

State 956:
## Known stack suffix:
## LEFTBRC qualid
## LR(1) items:
expr_arg_ -> qualid . [ WITH LEFTSQ ]
expr_pure_ -> LEFTBRC qualid . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 762
## Reductions:
-- On WITH reduce production expr_arg_ -> qualid
-- On LEFTSQ reduce production expr_arg_ -> qualid

State 957:
## Known stack suffix:
## OPPREF expr_dot
## LR(1) items:
expr_dot_ -> OPPREF expr_dot . [ DOT ]
expr_sub_ -> expr_dot . DOT mk_expr(expr_pure_) [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_dot . DOT lqualid_rich [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On DOT reduce production expr_dot_ -> OPPREF expr_dot

State 958:
## Known stack suffix:
## OPPREF expr_arg
## LR(1) items:
expr_arg_ -> OPPREF expr_arg . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr LARROW expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_arg_ -> OPPREF expr_arg
-- On WITH reduce production expr_arg_ -> OPPREF expr_arg
-- On VARIANT reduce production expr_arg_ -> OPPREF expr_arg
-- On VAL reduce production expr_arg_ -> OPPREF expr_arg
-- On USE reduce production expr_arg_ -> OPPREF expr_arg
-- On UIDENT reduce production expr_arg_ -> OPPREF expr_arg
-- On TYPE reduce production expr_arg_ -> OPPREF expr_arg
-- On TRUE reduce production expr_arg_ -> OPPREF expr_arg
-- On TO reduce production expr_arg_ -> OPPREF expr_arg
-- On THEN reduce production expr_arg_ -> OPPREF expr_arg
-- On SEMICOLON reduce production expr_arg_ -> OPPREF expr_arg
-- On SCOPE reduce production expr_arg_ -> OPPREF expr_arg
-- On RIGHTSQ_QUOTE reduce production expr_arg_ -> OPPREF expr_arg
-- On RIGHTSQ reduce production expr_arg_ -> OPPREF expr_arg
-- On RIGHTPAR reduce production expr_arg_ -> OPPREF expr_arg
-- On RIGHTBRC reduce production expr_arg_ -> OPPREF expr_arg
-- On RETURNS reduce production expr_arg_ -> OPPREF expr_arg
-- On REQUIRES reduce production expr_arg_ -> OPPREF expr_arg
-- On REAL reduce production expr_arg_ -> OPPREF expr_arg
-- On READS reduce production expr_arg_ -> OPPREF expr_arg
-- On RANGE reduce production expr_arg_ -> OPPREF expr_arg
-- On RAISES reduce production expr_arg_ -> OPPREF expr_arg
-- On PURE reduce production expr_arg_ -> OPPREF expr_arg
-- On PREDICATE reduce production expr_arg_ -> OPPREF expr_arg
-- On OPPREF reduce production expr_arg_ -> OPPREF expr_arg
-- On OP4 reduce production expr_arg_ -> OPPREF expr_arg
-- On OP3 reduce production expr_arg_ -> OPPREF expr_arg
-- On OP2 reduce production expr_arg_ -> OPPREF expr_arg
-- On OP1 reduce production expr_arg_ -> OPPREF expr_arg
-- On MINUS reduce production expr_arg_ -> OPPREF expr_arg
-- On META reduce production expr_arg_ -> OPPREF expr_arg
-- On LTGT reduce production expr_arg_ -> OPPREF expr_arg
-- On LT reduce production expr_arg_ -> OPPREF expr_arg
-- On LIDENT reduce production expr_arg_ -> OPPREF expr_arg
-- On LET reduce production expr_arg_ -> OPPREF expr_arg
-- On LEMMA reduce production expr_arg_ -> OPPREF expr_arg
-- On LEFTSQ reduce production expr_arg_ -> OPPREF expr_arg
-- On LEFTPAR reduce production expr_arg_ -> OPPREF expr_arg
-- On LEFTBRC reduce production expr_arg_ -> OPPREF expr_arg
-- On LARROW reduce production expr_arg_ -> OPPREF expr_arg
-- On INTEGER reduce production expr_arg_ -> OPPREF expr_arg
-- On INDUCTIVE reduce production expr_arg_ -> OPPREF expr_arg
-- On IN reduce production expr_arg_ -> OPPREF expr_arg
-- On IMPORT reduce production expr_arg_ -> OPPREF expr_arg
-- On GT reduce production expr_arg_ -> OPPREF expr_arg
-- On GOAL reduce production expr_arg_ -> OPPREF expr_arg
-- On FUNCTION reduce production expr_arg_ -> OPPREF expr_arg
-- On FLOAT reduce production expr_arg_ -> OPPREF expr_arg
-- On FALSE reduce production expr_arg_ -> OPPREF expr_arg
-- On EXCEPTION reduce production expr_arg_ -> OPPREF expr_arg
-- On EQUAL reduce production expr_arg_ -> OPPREF expr_arg
-- On EOF reduce production expr_arg_ -> OPPREF expr_arg
-- On ENSURES reduce production expr_arg_ -> OPPREF expr_arg
-- On END reduce production expr_arg_ -> OPPREF expr_arg
-- On ELSE reduce production expr_arg_ -> OPPREF expr_arg
-- On DOWNTO reduce production expr_arg_ -> OPPREF expr_arg
-- On DOTDOT reduce production expr_arg_ -> OPPREF expr_arg
-- On DONE reduce production expr_arg_ -> OPPREF expr_arg
-- On DO reduce production expr_arg_ -> OPPREF expr_arg
-- On DIVERGES reduce production expr_arg_ -> OPPREF expr_arg
-- On CORE_UIDENT reduce production expr_arg_ -> OPPREF expr_arg
-- On CORE_LIDENT reduce production expr_arg_ -> OPPREF expr_arg
-- On CONSTANT reduce production expr_arg_ -> OPPREF expr_arg
-- On COMMA reduce production expr_arg_ -> OPPREF expr_arg
-- On COLON reduce production expr_arg_ -> OPPREF expr_arg
-- On COINDUCTIVE reduce production expr_arg_ -> OPPREF expr_arg
-- On CLONE reduce production expr_arg_ -> OPPREF expr_arg
-- On BEGIN reduce production expr_arg_ -> OPPREF expr_arg
-- On BARBAR reduce production expr_arg_ -> OPPREF expr_arg
-- On BAR reduce production expr_arg_ -> OPPREF expr_arg
-- On AXIOM reduce production expr_arg_ -> OPPREF expr_arg
-- On AMPAMP reduce production expr_arg_ -> OPPREF expr_arg
-- On ALIAS reduce production expr_arg_ -> OPPREF expr_arg

State 959:
## Known stack suffix:
## MINUS
## LR(1) items:
lident_op_str -> MINUS . UNDERSCORE [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> MINUS . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
prefix_op -> MINUS . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
single_expr_ -> MINUS . INTEGER [ WRITES VARIANT SEMICOLON RIGHTPAR RETURNS REQUIRES READS RAISES OP4 OP3 OP2 OP1 MINUS LTGT LT LARROW GT EQUAL ENSURES DIVERGES COMMA COLON BARBAR AMPAMP ALIAS ]
single_expr_ -> MINUS . REAL [ WRITES VARIANT SEMICOLON RIGHTPAR RETURNS REQUIRES READS RAISES OP4 OP3 OP2 OP1 MINUS LTGT LT LARROW GT EQUAL ENSURES DIVERGES COMMA COLON BARBAR AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 13
-- On REAL shift to state 699
-- On INTEGER shift to state 700
## Reductions:
-- On WHILE reduce production prefix_op -> MINUS
-- On VAL reduce production prefix_op -> MINUS
-- On UIDENT reduce production prefix_op -> MINUS
-- On TRY reduce production prefix_op -> MINUS
-- On TRUE reduce production prefix_op -> MINUS
-- On RIGHTPAR_USCORE reduce production lident_op_str -> MINUS
-- On RIGHTPAR_QUOTE reduce production lident_op_str -> MINUS
-- On RIGHTPAR reduce production lident_op_str -> MINUS
-- On RETURN reduce production prefix_op -> MINUS
-- On RANGE reduce production prefix_op -> MINUS
-- On RAISE reduce production prefix_op -> MINUS
-- On PURE reduce production prefix_op -> MINUS
-- On POSITION reduce production prefix_op -> MINUS
-- On OPPREF reduce production prefix_op -> MINUS
-- On OP4 reduce production prefix_op -> MINUS
-- On OP3 reduce production prefix_op -> MINUS
-- On OP2 reduce production prefix_op -> MINUS
-- On OP1 reduce production prefix_op -> MINUS
-- On NOT reduce production prefix_op -> MINUS
-- On MINUS reduce production prefix_op -> MINUS
-- On MATCH reduce production prefix_op -> MINUS
-- On LT reduce production prefix_op -> MINUS
-- On LIDENT reduce production prefix_op -> MINUS
-- On LET reduce production prefix_op -> MINUS
-- On LEFTPAR reduce production prefix_op -> MINUS
-- On LEFTBRC reduce production prefix_op -> MINUS
-- On LABEL reduce production prefix_op -> MINUS
-- On IF reduce production prefix_op -> MINUS
-- On GT reduce production prefix_op -> MINUS
-- On GHOST reduce production prefix_op -> MINUS
-- On FUN reduce production prefix_op -> MINUS
-- On FOR reduce production prefix_op -> MINUS
-- On FLOAT reduce production prefix_op -> MINUS
-- On FALSE reduce production prefix_op -> MINUS
-- On EXCEPTION reduce production prefix_op -> MINUS
-- On CORE_UIDENT reduce production prefix_op -> MINUS
-- On CORE_LIDENT reduce production prefix_op -> MINUS
-- On CONTINUE reduce production prefix_op -> MINUS
-- On CHECK reduce production prefix_op -> MINUS
-- On BREAK reduce production prefix_op -> MINUS
-- On BEGIN reduce production prefix_op -> MINUS
-- On ATTRIBUTE reduce production prefix_op -> MINUS
-- On ASSUME reduce production prefix_op -> MINUS
-- On ASSERT reduce production prefix_op -> MINUS
-- On ANY reduce production prefix_op -> MINUS
-- On ABSURD reduce production prefix_op -> MINUS

State 960:
## Known stack suffix:
## LEFTPAR seq_expr
## LR(1) items:
expr_block_ -> LEFTPAR seq_expr . RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 961
## Reductions:

State 961:
## Known stack suffix:
## LEFTPAR seq_expr RIGHTPAR
## LR(1) items:
expr_block_ -> LEFTPAR seq_expr RIGHTPAR . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On WITH reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On VARIANT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On VAL reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On USE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On UIDENT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On TYPE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On TRUE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On TO reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On THEN reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On SEMICOLON reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On SCOPE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On RIGHTSQ reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On RIGHTPAR reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On RIGHTBRC reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On RETURNS reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On REQUIRES reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On REAL reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On READS reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On RANGE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On RAISES reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On PURE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On PREDICATE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On OPPREF reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On OP4 reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On OP3 reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On OP2 reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On OP1 reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On MINUS reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On META reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On LTGT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On LT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On LIDENT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On LET reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On LEMMA reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On LEFTSQ reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On LEFTPAR reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On LEFTBRC reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On LARROW reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On INTEGER reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On INDUCTIVE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On IN reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On IMPORT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On GT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On GOAL reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On FUNCTION reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On FLOAT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On FALSE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On EXCEPTION reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On EQUAL reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On EOF reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On ENSURES reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On END reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On ELSE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On DOWNTO reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On DOTDOT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On DOT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On DONE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On DO reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On DIVERGES reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On CORE_UIDENT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On CORE_LIDENT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On CONSTANT reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On COMMA reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On COLON reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On COINDUCTIVE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On CLONE reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On BEGIN reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On BARBAR reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On BAR reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On AXIOM reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On AMPAMP reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR
-- On ALIAS reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR

State 962:
## Known stack suffix:
## RAISE LEFTPAR uqualid option(expr_arg)
## LR(1) items:
single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 963
## Reductions:

State 963:
## Known stack suffix:
## RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
## LR(1) items:
single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On WITH reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On VARIANT reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On VAL reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On USE reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On TYPE reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On TO reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On THEN reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On SEMICOLON reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On SCOPE reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On RIGHTSQ reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On RIGHTPAR reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On RIGHTBRC reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On RETURNS reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On REQUIRES reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On READS reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On RAISES reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On PREDICATE reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On OP4 reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On OP3 reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On OP2 reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On OP1 reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On MINUS reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On META reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On LTGT reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On LT reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On LET reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On LEMMA reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On LARROW reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On INDUCTIVE reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On IN reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On IMPORT reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On GT reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On GOAL reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On FUNCTION reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On EXCEPTION reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On EQUAL reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On EOF reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On ENSURES reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On END reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On ELSE reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On DOWNTO reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On DOTDOT reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On DONE reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On DO reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On DIVERGES reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On CONSTANT reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On COMMA reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On COLON reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On COINDUCTIVE reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On CLONE reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On BARBAR reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On BAR reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On AXIOM reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On AMPAMP reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
-- On ALIAS reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR

State 964:
## Known stack suffix:
## expr_arg
## LR(1) items:
expr_sub_ -> expr_arg . LEFTSQ expr rightsq [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr LARROW expr rightsq [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT rightsq [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
option(expr_arg) -> expr_arg . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On LEFTSQ shift to state 776
## Reductions:
-- On WRITES reduce production option(expr_arg) -> expr_arg
-- On WITH reduce production option(expr_arg) -> expr_arg
-- On VARIANT reduce production option(expr_arg) -> expr_arg
-- On VAL reduce production option(expr_arg) -> expr_arg
-- On USE reduce production option(expr_arg) -> expr_arg
-- On TYPE reduce production option(expr_arg) -> expr_arg
-- On TO reduce production option(expr_arg) -> expr_arg
-- On THEN reduce production option(expr_arg) -> expr_arg
-- On SEMICOLON reduce production option(expr_arg) -> expr_arg
-- On SCOPE reduce production option(expr_arg) -> expr_arg
-- On RIGHTSQ_QUOTE reduce production option(expr_arg) -> expr_arg
-- On RIGHTSQ reduce production option(expr_arg) -> expr_arg
-- On RIGHTPAR reduce production option(expr_arg) -> expr_arg
-- On RIGHTBRC reduce production option(expr_arg) -> expr_arg
-- On RETURNS reduce production option(expr_arg) -> expr_arg
-- On REQUIRES reduce production option(expr_arg) -> expr_arg
-- On READS reduce production option(expr_arg) -> expr_arg
-- On RAISES reduce production option(expr_arg) -> expr_arg
-- On PREDICATE reduce production option(expr_arg) -> expr_arg
-- On OP4 reduce production option(expr_arg) -> expr_arg
-- On OP3 reduce production option(expr_arg) -> expr_arg
-- On OP2 reduce production option(expr_arg) -> expr_arg
-- On OP1 reduce production option(expr_arg) -> expr_arg
-- On MINUS reduce production option(expr_arg) -> expr_arg
-- On META reduce production option(expr_arg) -> expr_arg
-- On LTGT reduce production option(expr_arg) -> expr_arg
-- On LT reduce production option(expr_arg) -> expr_arg
-- On LET reduce production option(expr_arg) -> expr_arg
-- On LEMMA reduce production option(expr_arg) -> expr_arg
-- On LARROW reduce production option(expr_arg) -> expr_arg
-- On INDUCTIVE reduce production option(expr_arg) -> expr_arg
-- On IN reduce production option(expr_arg) -> expr_arg
-- On IMPORT reduce production option(expr_arg) -> expr_arg
-- On GT reduce production option(expr_arg) -> expr_arg
-- On GOAL reduce production option(expr_arg) -> expr_arg
-- On FUNCTION reduce production option(expr_arg) -> expr_arg
-- On EXCEPTION reduce production option(expr_arg) -> expr_arg
-- On EQUAL reduce production option(expr_arg) -> expr_arg
-- On EOF reduce production option(expr_arg) -> expr_arg
-- On ENSURES reduce production option(expr_arg) -> expr_arg
-- On END reduce production option(expr_arg) -> expr_arg
-- On ELSE reduce production option(expr_arg) -> expr_arg
-- On DOWNTO reduce production option(expr_arg) -> expr_arg
-- On DOTDOT reduce production option(expr_arg) -> expr_arg
-- On DONE reduce production option(expr_arg) -> expr_arg
-- On DO reduce production option(expr_arg) -> expr_arg
-- On DIVERGES reduce production option(expr_arg) -> expr_arg
-- On CONSTANT reduce production option(expr_arg) -> expr_arg
-- On COMMA reduce production option(expr_arg) -> expr_arg
-- On COLON reduce production option(expr_arg) -> expr_arg
-- On COINDUCTIVE reduce production option(expr_arg) -> expr_arg
-- On CLONE reduce production option(expr_arg) -> expr_arg
-- On BARBAR reduce production option(expr_arg) -> expr_arg
-- On BAR reduce production option(expr_arg) -> expr_arg
-- On AXIOM reduce production option(expr_arg) -> expr_arg
-- On AMPAMP reduce production option(expr_arg) -> expr_arg
-- On ALIAS reduce production option(expr_arg) -> expr_arg

State 965:
## Known stack suffix:
## RAISE uqualid
## LR(1) items:
single_expr_ -> RAISE uqualid . option(expr_arg) [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
uqualid -> uqualid . DOT uident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On DOT shift to state 526
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On qualid shift to state 744
-- On option(expr_arg) shift to state 966
-- On numeral shift to state 745
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 964
## Reductions:
-- On WRITES reduce production option(expr_arg) ->
-- On WITH reduce production option(expr_arg) ->
-- On VARIANT reduce production option(expr_arg) ->
-- On VAL reduce production option(expr_arg) ->
-- On USE reduce production option(expr_arg) ->
-- On TYPE reduce production option(expr_arg) ->
-- On TO reduce production option(expr_arg) ->
-- On THEN reduce production option(expr_arg) ->
-- On SEMICOLON reduce production option(expr_arg) ->
-- On SCOPE reduce production option(expr_arg) ->
-- On RIGHTSQ_QUOTE reduce production option(expr_arg) ->
-- On RIGHTSQ reduce production option(expr_arg) ->
-- On RIGHTPAR reduce production option(expr_arg) ->
-- On RIGHTBRC reduce production option(expr_arg) ->
-- On RETURNS reduce production option(expr_arg) ->
-- On REQUIRES reduce production option(expr_arg) ->
-- On READS reduce production option(expr_arg) ->
-- On RAISES reduce production option(expr_arg) ->
-- On PREDICATE reduce production option(expr_arg) ->
-- On OP4 reduce production option(expr_arg) ->
-- On OP3 reduce production option(expr_arg) ->
-- On OP2 reduce production option(expr_arg) ->
-- On OP1 reduce production option(expr_arg) ->
-- On MINUS reduce production option(expr_arg) ->
-- On META reduce production option(expr_arg) ->
-- On LTGT reduce production option(expr_arg) ->
-- On LT reduce production option(expr_arg) ->
-- On LET reduce production option(expr_arg) ->
-- On LEMMA reduce production option(expr_arg) ->
-- On LARROW reduce production option(expr_arg) ->
-- On INDUCTIVE reduce production option(expr_arg) ->
-- On IN reduce production option(expr_arg) ->
-- On IMPORT reduce production option(expr_arg) ->
-- On GT reduce production option(expr_arg) ->
-- On GOAL reduce production option(expr_arg) ->
-- On FUNCTION reduce production option(expr_arg) ->
-- On EXCEPTION reduce production option(expr_arg) ->
-- On EQUAL reduce production option(expr_arg) ->
-- On EOF reduce production option(expr_arg) ->
-- On ENSURES reduce production option(expr_arg) ->
-- On END reduce production option(expr_arg) ->
-- On ELSE reduce production option(expr_arg) ->
-- On DOWNTO reduce production option(expr_arg) ->
-- On DOTDOT reduce production option(expr_arg) ->
-- On DONE reduce production option(expr_arg) ->
-- On DO reduce production option(expr_arg) ->
-- On DIVERGES reduce production option(expr_arg) ->
-- On CONSTANT reduce production option(expr_arg) ->
-- On COMMA reduce production option(expr_arg) ->
-- On COLON reduce production option(expr_arg) ->
-- On COINDUCTIVE reduce production option(expr_arg) ->
-- On CLONE reduce production option(expr_arg) ->
-- On BARBAR reduce production option(expr_arg) ->
-- On BAR reduce production option(expr_arg) ->
-- On AXIOM reduce production option(expr_arg) ->
-- On AMPAMP reduce production option(expr_arg) ->
-- On ALIAS reduce production option(expr_arg) ->

State 966:
## Known stack suffix:
## RAISE uqualid option(expr_arg)
## LR(1) items:
single_expr_ -> RAISE uqualid option(expr_arg) . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On WITH reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On VARIANT reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On VAL reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On USE reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On TYPE reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On TO reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On THEN reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On SEMICOLON reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On SCOPE reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On RIGHTSQ reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On RIGHTPAR reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On RIGHTBRC reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On RETURNS reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On REQUIRES reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On READS reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On RAISES reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On PREDICATE reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On OP4 reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On OP3 reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On OP2 reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On OP1 reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On MINUS reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On META reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On LTGT reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On LT reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On LET reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On LEMMA reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On LARROW reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On INDUCTIVE reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On IN reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On IMPORT reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On GT reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On GOAL reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On FUNCTION reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On EXCEPTION reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On EQUAL reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On EOF reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On ENSURES reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On END reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On ELSE reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On DOWNTO reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On DOTDOT reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On DONE reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On DO reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On DIVERGES reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On CONSTANT reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On COMMA reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On COLON reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On COINDUCTIVE reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On CLONE reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On BARBAR reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On BAR reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On AXIOM reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On AMPAMP reduce production single_expr_ -> RAISE uqualid option(expr_arg)
-- On ALIAS reduce production single_expr_ -> RAISE uqualid option(expr_arg)

State 967:
## Known stack suffix:
## RETURN contract_expr
## LR(1) items:
single_expr_ -> RETURN contract_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> RETURN contract_expr
-- On WITH reduce production single_expr_ -> RETURN contract_expr
-- On VARIANT reduce production single_expr_ -> RETURN contract_expr
-- On VAL reduce production single_expr_ -> RETURN contract_expr
-- On USE reduce production single_expr_ -> RETURN contract_expr
-- On TYPE reduce production single_expr_ -> RETURN contract_expr
-- On TO reduce production single_expr_ -> RETURN contract_expr
-- On THEN reduce production single_expr_ -> RETURN contract_expr
-- On SEMICOLON reduce production single_expr_ -> RETURN contract_expr
-- On SCOPE reduce production single_expr_ -> RETURN contract_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> RETURN contract_expr
-- On RIGHTSQ reduce production single_expr_ -> RETURN contract_expr
-- On RIGHTPAR reduce production single_expr_ -> RETURN contract_expr
-- On RIGHTBRC reduce production single_expr_ -> RETURN contract_expr
-- On RETURNS reduce production single_expr_ -> RETURN contract_expr
-- On REQUIRES reduce production single_expr_ -> RETURN contract_expr
-- On READS reduce production single_expr_ -> RETURN contract_expr
-- On RAISES reduce production single_expr_ -> RETURN contract_expr
-- On PREDICATE reduce production single_expr_ -> RETURN contract_expr
-- On OP4 reduce production single_expr_ -> RETURN contract_expr
-- On OP3 reduce production single_expr_ -> RETURN contract_expr
-- On OP2 reduce production single_expr_ -> RETURN contract_expr
-- On OP1 reduce production single_expr_ -> RETURN contract_expr
-- On MINUS reduce production single_expr_ -> RETURN contract_expr
-- On META reduce production single_expr_ -> RETURN contract_expr
-- On LTGT reduce production single_expr_ -> RETURN contract_expr
-- On LT reduce production single_expr_ -> RETURN contract_expr
-- On LET reduce production single_expr_ -> RETURN contract_expr
-- On LEMMA reduce production single_expr_ -> RETURN contract_expr
-- On LARROW reduce production single_expr_ -> RETURN contract_expr
-- On INDUCTIVE reduce production single_expr_ -> RETURN contract_expr
-- On IN reduce production single_expr_ -> RETURN contract_expr
-- On IMPORT reduce production single_expr_ -> RETURN contract_expr
-- On GT reduce production single_expr_ -> RETURN contract_expr
-- On GOAL reduce production single_expr_ -> RETURN contract_expr
-- On FUNCTION reduce production single_expr_ -> RETURN contract_expr
-- On EXCEPTION reduce production single_expr_ -> RETURN contract_expr
-- On EQUAL reduce production single_expr_ -> RETURN contract_expr
-- On EOF reduce production single_expr_ -> RETURN contract_expr
-- On ENSURES reduce production single_expr_ -> RETURN contract_expr
-- On END reduce production single_expr_ -> RETURN contract_expr
-- On ELSE reduce production single_expr_ -> RETURN contract_expr
-- On DOWNTO reduce production single_expr_ -> RETURN contract_expr
-- On DOTDOT reduce production single_expr_ -> RETURN contract_expr
-- On DONE reduce production single_expr_ -> RETURN contract_expr
-- On DO reduce production single_expr_ -> RETURN contract_expr
-- On DIVERGES reduce production single_expr_ -> RETURN contract_expr
-- On CONSTANT reduce production single_expr_ -> RETURN contract_expr
-- On COMMA reduce production single_expr_ -> RETURN contract_expr
-- On COLON reduce production single_expr_ -> RETURN contract_expr
-- On COINDUCTIVE reduce production single_expr_ -> RETURN contract_expr
-- On CLONE reduce production single_expr_ -> RETURN contract_expr
-- On BARBAR reduce production single_expr_ -> RETURN contract_expr
-- On BAR reduce production single_expr_ -> RETURN contract_expr
-- On AXIOM reduce production single_expr_ -> RETURN contract_expr
-- On AMPAMP reduce production single_expr_ -> RETURN contract_expr
-- On ALIAS reduce production single_expr_ -> RETURN contract_expr

State 968:
## Known stack suffix:
## TRY seq_expr
## LR(1) items:
single_expr_ -> TRY seq_expr . WITH bar_list1(exn_handler) END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WITH shift to state 969
## Reductions:

State 969:
## Known stack suffix:
## TRY seq_expr WITH
## LR(1) items:
single_expr_ -> TRY seq_expr WITH . bar_list1(exn_handler) END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On BAR shift to state 970
-- On uqualid shift to state 928
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,exn_handler) shift to state 975
-- On exn_handler shift to state 972
-- On bar_list1(exn_handler) shift to state 976
## Reductions:

State 970:
## Known stack suffix:
## BAR
## LR(1) items:
bar_list1(exn_handler) -> BAR . separated_nonempty_list(BAR,exn_handler) [ END ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 928
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,exn_handler) shift to state 971
-- On exn_handler shift to state 972
## Reductions:

State 971:
## Known stack suffix:
## BAR separated_nonempty_list(BAR,exn_handler)
## LR(1) items:
bar_list1(exn_handler) -> BAR separated_nonempty_list(BAR,exn_handler) . [ END ]
## Transitions:
## Reductions:
-- On END reduce production bar_list1(exn_handler) -> BAR separated_nonempty_list(BAR,exn_handler)

State 972:
## Known stack suffix:
## exn_handler
## LR(1) items:
separated_nonempty_list(BAR,exn_handler) -> exn_handler . [ END ]
separated_nonempty_list(BAR,exn_handler) -> exn_handler . BAR separated_nonempty_list(BAR,exn_handler) [ END ]
## Transitions:
-- On BAR shift to state 973
## Reductions:
-- On END reduce production separated_nonempty_list(BAR,exn_handler) -> exn_handler

State 973:
## Known stack suffix:
## exn_handler BAR
## LR(1) items:
separated_nonempty_list(BAR,exn_handler) -> exn_handler BAR . separated_nonempty_list(BAR,exn_handler) [ END ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 928
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,exn_handler) shift to state 974
-- On exn_handler shift to state 972
## Reductions:

State 974:
## Known stack suffix:
## exn_handler BAR separated_nonempty_list(BAR,exn_handler)
## LR(1) items:
separated_nonempty_list(BAR,exn_handler) -> exn_handler BAR separated_nonempty_list(BAR,exn_handler) . [ END ]
## Transitions:
## Reductions:
-- On END reduce production separated_nonempty_list(BAR,exn_handler) -> exn_handler BAR separated_nonempty_list(BAR,exn_handler)

State 975:
## Known stack suffix:
## separated_nonempty_list(BAR,exn_handler)
## LR(1) items:
bar_list1(exn_handler) -> separated_nonempty_list(BAR,exn_handler) . [ END ]
## Transitions:
## Reductions:
-- On END reduce production bar_list1(exn_handler) -> separated_nonempty_list(BAR,exn_handler)

State 976:
## Known stack suffix:
## TRY seq_expr WITH bar_list1(exn_handler)
## LR(1) items:
single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) . END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On END shift to state 977
## Reductions:

State 977:
## Known stack suffix:
## TRY seq_expr WITH bar_list1(exn_handler) END
## LR(1) items:
single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On WITH reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On VARIANT reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On VAL reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On USE reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On TYPE reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On TO reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On THEN reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On SEMICOLON reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On SCOPE reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On RIGHTSQ reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On RIGHTPAR reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On RIGHTBRC reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On RETURNS reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On REQUIRES reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On READS reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On RAISES reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On PREDICATE reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On OP4 reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On OP3 reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On OP2 reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On OP1 reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On MINUS reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On META reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On LTGT reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On LT reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On LET reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On LEMMA reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On LARROW reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On INDUCTIVE reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On IN reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On IMPORT reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On GT reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On GOAL reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On FUNCTION reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On EXCEPTION reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On EQUAL reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On EOF reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On ENSURES reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On END reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On ELSE reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On DOWNTO reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On DOTDOT reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On DONE reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On DO reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On DIVERGES reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On CONSTANT reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On COMMA reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On COLON reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On COINDUCTIVE reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On CLONE reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On BARBAR reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On BAR reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On AXIOM reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On AMPAMP reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END
-- On ALIAS reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END

State 978:
## Known stack suffix:
## VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
## LR(1) items:
single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On WITH reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On VARIANT reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On VAL reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On USE reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On TYPE reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On TO reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On THEN reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On SEMICOLON reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On SCOPE reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On RIGHTSQ reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On RIGHTPAR reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On RIGHTBRC reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On RETURNS reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On REQUIRES reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On READS reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On RAISES reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On PREDICATE reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On OP4 reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On OP3 reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On OP2 reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On OP1 reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On MINUS reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On META reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On LTGT reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On LT reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On LET reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On LEMMA reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On LARROW reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On INDUCTIVE reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On IN reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On IMPORT reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On GT reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On GOAL reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On FUNCTION reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On EXCEPTION reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On EQUAL reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On EOF reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On ENSURES reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On END reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On ELSE reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On DOWNTO reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On DOTDOT reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On DONE reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On DO reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On DIVERGES reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On CONSTANT reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On COMMA reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On COLON reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On COINDUCTIVE reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On CLONE reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On BARBAR reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On BAR reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On AXIOM reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On AMPAMP reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
-- On ALIAS reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr

State 979:
## Known stack suffix:
## WHILE seq_expr
## LR(1) items:
single_expr_ -> WHILE seq_expr . DO loop_annotation loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On DO shift to state 980
## Reductions:

State 980:
## Known stack suffix:
## WHILE seq_expr DO
## LR(1) items:
single_expr_ -> WHILE seq_expr DO . loop_annotation loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On VARIANT shift to state 493
-- On INVARIANT shift to state 663
-- On variant shift to state 981
-- On loop_annotation shift to state 985
-- On invariant shift to state 983
## Reductions:
-- On WHILE reduce production loop_annotation ->
-- On VAL reduce production loop_annotation ->
-- On UIDENT reduce production loop_annotation ->
-- On TRY reduce production loop_annotation ->
-- On TRUE reduce production loop_annotation ->
-- On RETURN reduce production loop_annotation ->
-- On REAL reduce production loop_annotation ->
-- On RANGE reduce production loop_annotation ->
-- On RAISE reduce production loop_annotation ->
-- On PURE reduce production loop_annotation ->
-- On POSITION reduce production loop_annotation ->
-- On OPPREF reduce production loop_annotation ->
-- On OP4 reduce production loop_annotation ->
-- On OP3 reduce production loop_annotation ->
-- On OP2 reduce production loop_annotation ->
-- On OP1 reduce production loop_annotation ->
-- On NOT reduce production loop_annotation ->
-- On MINUS reduce production loop_annotation ->
-- On MATCH reduce production loop_annotation ->
-- On LT reduce production loop_annotation ->
-- On LIDENT reduce production loop_annotation ->
-- On LET reduce production loop_annotation ->
-- On LEFTPAR reduce production loop_annotation ->
-- On LEFTBRC reduce production loop_annotation ->
-- On LABEL reduce production loop_annotation ->
-- On INTEGER reduce production loop_annotation ->
-- On IF reduce production loop_annotation ->
-- On GT reduce production loop_annotation ->
-- On GHOST reduce production loop_annotation ->
-- On FUN reduce production loop_annotation ->
-- On FOR reduce production loop_annotation ->
-- On FLOAT reduce production loop_annotation ->
-- On FALSE reduce production loop_annotation ->
-- On EXCEPTION reduce production loop_annotation ->
-- On DONE reduce production loop_annotation ->
-- On CORE_UIDENT reduce production loop_annotation ->
-- On CORE_LIDENT reduce production loop_annotation ->
-- On CONTINUE reduce production loop_annotation ->
-- On CHECK reduce production loop_annotation ->
-- On BREAK reduce production loop_annotation ->
-- On BEGIN reduce production loop_annotation ->
-- On ATTRIBUTE reduce production loop_annotation ->
-- On ASSUME reduce production loop_annotation ->
-- On ASSERT reduce production loop_annotation ->
-- On ANY reduce production loop_annotation ->
-- On ABSURD reduce production loop_annotation ->

State 981:
## Known stack suffix:
## variant
## LR(1) items:
loop_annotation -> variant . loop_annotation [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On VARIANT shift to state 493
-- On INVARIANT shift to state 663
-- On variant shift to state 981
-- On loop_annotation shift to state 982
-- On invariant shift to state 983
## Reductions:
-- On WHILE reduce production loop_annotation ->
-- On VAL reduce production loop_annotation ->
-- On UIDENT reduce production loop_annotation ->
-- On TRY reduce production loop_annotation ->
-- On TRUE reduce production loop_annotation ->
-- On RETURN reduce production loop_annotation ->
-- On REAL reduce production loop_annotation ->
-- On RANGE reduce production loop_annotation ->
-- On RAISE reduce production loop_annotation ->
-- On PURE reduce production loop_annotation ->
-- On POSITION reduce production loop_annotation ->
-- On OPPREF reduce production loop_annotation ->
-- On OP4 reduce production loop_annotation ->
-- On OP3 reduce production loop_annotation ->
-- On OP2 reduce production loop_annotation ->
-- On OP1 reduce production loop_annotation ->
-- On NOT reduce production loop_annotation ->
-- On MINUS reduce production loop_annotation ->
-- On MATCH reduce production loop_annotation ->
-- On LT reduce production loop_annotation ->
-- On LIDENT reduce production loop_annotation ->
-- On LET reduce production loop_annotation ->
-- On LEFTPAR reduce production loop_annotation ->
-- On LEFTBRC reduce production loop_annotation ->
-- On LABEL reduce production loop_annotation ->
-- On INTEGER reduce production loop_annotation ->
-- On IF reduce production loop_annotation ->
-- On GT reduce production loop_annotation ->
-- On GHOST reduce production loop_annotation ->
-- On FUN reduce production loop_annotation ->
-- On FOR reduce production loop_annotation ->
-- On FLOAT reduce production loop_annotation ->
-- On FALSE reduce production loop_annotation ->
-- On EXCEPTION reduce production loop_annotation ->
-- On DONE reduce production loop_annotation ->
-- On CORE_UIDENT reduce production loop_annotation ->
-- On CORE_LIDENT reduce production loop_annotation ->
-- On CONTINUE reduce production loop_annotation ->
-- On CHECK reduce production loop_annotation ->
-- On BREAK reduce production loop_annotation ->
-- On BEGIN reduce production loop_annotation ->
-- On ATTRIBUTE reduce production loop_annotation ->
-- On ASSUME reduce production loop_annotation ->
-- On ASSERT reduce production loop_annotation ->
-- On ANY reduce production loop_annotation ->
-- On ABSURD reduce production loop_annotation ->

State 982:
## Known stack suffix:
## variant loop_annotation
## LR(1) items:
loop_annotation -> variant loop_annotation . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE reduce production loop_annotation -> variant loop_annotation
-- On VAL reduce production loop_annotation -> variant loop_annotation
-- On UIDENT reduce production loop_annotation -> variant loop_annotation
-- On TRY reduce production loop_annotation -> variant loop_annotation
-- On TRUE reduce production loop_annotation -> variant loop_annotation
-- On RETURN reduce production loop_annotation -> variant loop_annotation
-- On REAL reduce production loop_annotation -> variant loop_annotation
-- On RANGE reduce production loop_annotation -> variant loop_annotation
-- On RAISE reduce production loop_annotation -> variant loop_annotation
-- On PURE reduce production loop_annotation -> variant loop_annotation
-- On POSITION reduce production loop_annotation -> variant loop_annotation
-- On OPPREF reduce production loop_annotation -> variant loop_annotation
-- On OP4 reduce production loop_annotation -> variant loop_annotation
-- On OP3 reduce production loop_annotation -> variant loop_annotation
-- On OP2 reduce production loop_annotation -> variant loop_annotation
-- On OP1 reduce production loop_annotation -> variant loop_annotation
-- On NOT reduce production loop_annotation -> variant loop_annotation
-- On MINUS reduce production loop_annotation -> variant loop_annotation
-- On MATCH reduce production loop_annotation -> variant loop_annotation
-- On LT reduce production loop_annotation -> variant loop_annotation
-- On LIDENT reduce production loop_annotation -> variant loop_annotation
-- On LET reduce production loop_annotation -> variant loop_annotation
-- On LEFTPAR reduce production loop_annotation -> variant loop_annotation
-- On LEFTBRC reduce production loop_annotation -> variant loop_annotation
-- On LABEL reduce production loop_annotation -> variant loop_annotation
-- On INTEGER reduce production loop_annotation -> variant loop_annotation
-- On IF reduce production loop_annotation -> variant loop_annotation
-- On GT reduce production loop_annotation -> variant loop_annotation
-- On GHOST reduce production loop_annotation -> variant loop_annotation
-- On FUN reduce production loop_annotation -> variant loop_annotation
-- On FOR reduce production loop_annotation -> variant loop_annotation
-- On FLOAT reduce production loop_annotation -> variant loop_annotation
-- On FALSE reduce production loop_annotation -> variant loop_annotation
-- On EXCEPTION reduce production loop_annotation -> variant loop_annotation
-- On DONE reduce production loop_annotation -> variant loop_annotation
-- On CORE_UIDENT reduce production loop_annotation -> variant loop_annotation
-- On CORE_LIDENT reduce production loop_annotation -> variant loop_annotation
-- On CONTINUE reduce production loop_annotation -> variant loop_annotation
-- On CHECK reduce production loop_annotation -> variant loop_annotation
-- On BREAK reduce production loop_annotation -> variant loop_annotation
-- On BEGIN reduce production loop_annotation -> variant loop_annotation
-- On ATTRIBUTE reduce production loop_annotation -> variant loop_annotation
-- On ASSUME reduce production loop_annotation -> variant loop_annotation
-- On ASSERT reduce production loop_annotation -> variant loop_annotation
-- On ANY reduce production loop_annotation -> variant loop_annotation
-- On ABSURD reduce production loop_annotation -> variant loop_annotation

State 983:
## Known stack suffix:
## invariant
## LR(1) items:
loop_annotation -> invariant . loop_annotation [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On VARIANT shift to state 493
-- On INVARIANT shift to state 663
-- On variant shift to state 981
-- On loop_annotation shift to state 984
-- On invariant shift to state 983
## Reductions:
-- On WHILE reduce production loop_annotation ->
-- On VAL reduce production loop_annotation ->
-- On UIDENT reduce production loop_annotation ->
-- On TRY reduce production loop_annotation ->
-- On TRUE reduce production loop_annotation ->
-- On RETURN reduce production loop_annotation ->
-- On REAL reduce production loop_annotation ->
-- On RANGE reduce production loop_annotation ->
-- On RAISE reduce production loop_annotation ->
-- On PURE reduce production loop_annotation ->
-- On POSITION reduce production loop_annotation ->
-- On OPPREF reduce production loop_annotation ->
-- On OP4 reduce production loop_annotation ->
-- On OP3 reduce production loop_annotation ->
-- On OP2 reduce production loop_annotation ->
-- On OP1 reduce production loop_annotation ->
-- On NOT reduce production loop_annotation ->
-- On MINUS reduce production loop_annotation ->
-- On MATCH reduce production loop_annotation ->
-- On LT reduce production loop_annotation ->
-- On LIDENT reduce production loop_annotation ->
-- On LET reduce production loop_annotation ->
-- On LEFTPAR reduce production loop_annotation ->
-- On LEFTBRC reduce production loop_annotation ->
-- On LABEL reduce production loop_annotation ->
-- On INTEGER reduce production loop_annotation ->
-- On IF reduce production loop_annotation ->
-- On GT reduce production loop_annotation ->
-- On GHOST reduce production loop_annotation ->
-- On FUN reduce production loop_annotation ->
-- On FOR reduce production loop_annotation ->
-- On FLOAT reduce production loop_annotation ->
-- On FALSE reduce production loop_annotation ->
-- On EXCEPTION reduce production loop_annotation ->
-- On DONE reduce production loop_annotation ->
-- On CORE_UIDENT reduce production loop_annotation ->
-- On CORE_LIDENT reduce production loop_annotation ->
-- On CONTINUE reduce production loop_annotation ->
-- On CHECK reduce production loop_annotation ->
-- On BREAK reduce production loop_annotation ->
-- On BEGIN reduce production loop_annotation ->
-- On ATTRIBUTE reduce production loop_annotation ->
-- On ASSUME reduce production loop_annotation ->
-- On ASSERT reduce production loop_annotation ->
-- On ANY reduce production loop_annotation ->
-- On ABSURD reduce production loop_annotation ->

State 984:
## Known stack suffix:
## invariant loop_annotation
## LR(1) items:
loop_annotation -> invariant loop_annotation . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE reduce production loop_annotation -> invariant loop_annotation
-- On VAL reduce production loop_annotation -> invariant loop_annotation
-- On UIDENT reduce production loop_annotation -> invariant loop_annotation
-- On TRY reduce production loop_annotation -> invariant loop_annotation
-- On TRUE reduce production loop_annotation -> invariant loop_annotation
-- On RETURN reduce production loop_annotation -> invariant loop_annotation
-- On REAL reduce production loop_annotation -> invariant loop_annotation
-- On RANGE reduce production loop_annotation -> invariant loop_annotation
-- On RAISE reduce production loop_annotation -> invariant loop_annotation
-- On PURE reduce production loop_annotation -> invariant loop_annotation
-- On POSITION reduce production loop_annotation -> invariant loop_annotation
-- On OPPREF reduce production loop_annotation -> invariant loop_annotation
-- On OP4 reduce production loop_annotation -> invariant loop_annotation
-- On OP3 reduce production loop_annotation -> invariant loop_annotation
-- On OP2 reduce production loop_annotation -> invariant loop_annotation
-- On OP1 reduce production loop_annotation -> invariant loop_annotation
-- On NOT reduce production loop_annotation -> invariant loop_annotation
-- On MINUS reduce production loop_annotation -> invariant loop_annotation
-- On MATCH reduce production loop_annotation -> invariant loop_annotation
-- On LT reduce production loop_annotation -> invariant loop_annotation
-- On LIDENT reduce production loop_annotation -> invariant loop_annotation
-- On LET reduce production loop_annotation -> invariant loop_annotation
-- On LEFTPAR reduce production loop_annotation -> invariant loop_annotation
-- On LEFTBRC reduce production loop_annotation -> invariant loop_annotation
-- On LABEL reduce production loop_annotation -> invariant loop_annotation
-- On INTEGER reduce production loop_annotation -> invariant loop_annotation
-- On IF reduce production loop_annotation -> invariant loop_annotation
-- On GT reduce production loop_annotation -> invariant loop_annotation
-- On GHOST reduce production loop_annotation -> invariant loop_annotation
-- On FUN reduce production loop_annotation -> invariant loop_annotation
-- On FOR reduce production loop_annotation -> invariant loop_annotation
-- On FLOAT reduce production loop_annotation -> invariant loop_annotation
-- On FALSE reduce production loop_annotation -> invariant loop_annotation
-- On EXCEPTION reduce production loop_annotation -> invariant loop_annotation
-- On DONE reduce production loop_annotation -> invariant loop_annotation
-- On CORE_UIDENT reduce production loop_annotation -> invariant loop_annotation
-- On CORE_LIDENT reduce production loop_annotation -> invariant loop_annotation
-- On CONTINUE reduce production loop_annotation -> invariant loop_annotation
-- On CHECK reduce production loop_annotation -> invariant loop_annotation
-- On BREAK reduce production loop_annotation -> invariant loop_annotation
-- On BEGIN reduce production loop_annotation -> invariant loop_annotation
-- On ATTRIBUTE reduce production loop_annotation -> invariant loop_annotation
-- On ASSUME reduce production loop_annotation -> invariant loop_annotation
-- On ASSERT reduce production loop_annotation -> invariant loop_annotation
-- On ANY reduce production loop_annotation -> invariant loop_annotation
-- On ABSURD reduce production loop_annotation -> invariant loop_annotation

State 985:
## Known stack suffix:
## WHILE seq_expr DO loop_annotation
## LR(1) items:
single_expr_ -> WHILE seq_expr DO loop_annotation . loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 855
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On loop_body shift to state 986
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:
-- On DONE reduce production loop_body ->

State 986:
## Known stack suffix:
## WHILE seq_expr DO loop_annotation loop_body
## LR(1) items:
single_expr_ -> WHILE seq_expr DO loop_annotation loop_body . DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On DONE shift to state 987
## Reductions:

State 987:
## Known stack suffix:
## WHILE seq_expr DO loop_annotation loop_body DONE
## LR(1) items:
single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On WITH reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On VARIANT reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On VAL reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On USE reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On TYPE reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On TO reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On THEN reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On SEMICOLON reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On SCOPE reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On RIGHTSQ_QUOTE reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On RIGHTSQ reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On RIGHTPAR reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On RIGHTBRC reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On RETURNS reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On REQUIRES reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On READS reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On RAISES reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On PREDICATE reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On OP4 reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On OP3 reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On OP2 reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On OP1 reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On MINUS reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On META reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On LTGT reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On LT reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On LET reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On LEMMA reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On LARROW reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On INDUCTIVE reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On IN reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On IMPORT reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On GT reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On GOAL reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On FUNCTION reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On EXCEPTION reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On EQUAL reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On EOF reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On ENSURES reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On END reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On ELSE reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On DOWNTO reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On DOTDOT reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On DONE reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On DO reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On DIVERGES reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On CONSTANT reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On COMMA reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On COLON reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On COINDUCTIVE reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On CLONE reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On BARBAR reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On BAR reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On AXIOM reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On AMPAMP reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE
-- On ALIAS reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE

State 988:
## Known stack suffix:
## lqualid EQUAL expr
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr . [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr . SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr . SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
## Transitions:
-- On SEMICOLON shift to state 989
## Reductions:
-- On RIGHTBRC reduce production semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr

State 989:
## Known stack suffix:
## lqualid EQUAL expr SEMICOLON
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON . [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON . semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,expr)) shift to state 990
-- On lqualid shift to state 671
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:
-- On RIGHTBRC reduce production semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON

State 990:
## Known stack suffix:
## lqualid EQUAL expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr))
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC reduce production semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr))

State 991:
## Known stack suffix:
## BY LEFTBRC field_list1(expr)
## LR(1) items:
type_witness -> BY LEFTBRC field_list1(expr) . RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RIGHTBRC shift to state 992
## Reductions:

State 992:
## Known stack suffix:
## BY LEFTBRC field_list1(expr) RIGHTBRC
## LR(1) items:
type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On VAL reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On USE reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On TYPE reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On SCOPE reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On PREDICATE reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On META reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On LET reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On LEMMA reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On INDUCTIVE reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On IMPORT reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On GOAL reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On FUNCTION reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On EXCEPTION reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On EOF reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On END reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On CONSTANT reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On COINDUCTIVE reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On CLONE reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC
-- On AXIOM reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC

State 993:
## Known stack suffix:
## attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
## LR(1) items:
type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On VAL reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On USE reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On TYPE reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On SCOPE reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On PREDICATE reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On META reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On LET reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On LEMMA reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On INDUCTIVE reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On IMPORT reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On GOAL reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On FUNCTION reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On EXCEPTION reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On EOF reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On END reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On CONSTANT reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On COINDUCTIVE reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On CLONE reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
-- On AXIOM reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness

State 994:
## Known stack suffix:
## separated_nonempty_list(WITH,type_decl)
## LR(1) items:
with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On USE reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On TYPE reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On SCOPE reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On PREDICATE reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On META reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On LET reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On LEMMA reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On INDUCTIVE reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On IMPORT reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On GOAL reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On FUNCTION reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On EXCEPTION reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On EOF reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On END reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On CONSTANT reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On COINDUCTIVE reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On CLONE reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)
-- On AXIOM reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)

State 995:
## Known stack suffix:
## THEORY
## LR(1) items:
module_head -> THEORY . attrs(uident_nq) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On CORE_UIDENT shift to state 648
-- On uident_nq shift to state 649
-- On attrs(uident_nq) shift to state 996
## Reductions:

State 996:
## Known stack suffix:
## THEORY attrs(uident_nq)
## LR(1) items:
module_head -> THEORY attrs(uident_nq) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production module_head -> THEORY attrs(uident_nq)
-- On USE reduce production module_head -> THEORY attrs(uident_nq)
-- On TYPE reduce production module_head -> THEORY attrs(uident_nq)
-- On SCOPE reduce production module_head -> THEORY attrs(uident_nq)
-- On PREDICATE reduce production module_head -> THEORY attrs(uident_nq)
-- On META reduce production module_head -> THEORY attrs(uident_nq)
-- On LET reduce production module_head -> THEORY attrs(uident_nq)
-- On LEMMA reduce production module_head -> THEORY attrs(uident_nq)
-- On INDUCTIVE reduce production module_head -> THEORY attrs(uident_nq)
-- On IMPORT reduce production module_head -> THEORY attrs(uident_nq)
-- On GOAL reduce production module_head -> THEORY attrs(uident_nq)
-- On FUNCTION reduce production module_head -> THEORY attrs(uident_nq)
-- On EXCEPTION reduce production module_head -> THEORY attrs(uident_nq)
-- On END reduce production module_head -> THEORY attrs(uident_nq)
-- On CONSTANT reduce production module_head -> THEORY attrs(uident_nq)
-- On COINDUCTIVE reduce production module_head -> THEORY attrs(uident_nq)
-- On CLONE reduce production module_head -> THEORY attrs(uident_nq)
-- On AXIOM reduce production module_head -> THEORY attrs(uident_nq)

State 997:
## Known stack suffix:
## SCOPE
## LR(1) items:
scope_head -> SCOPE . boption(IMPORT) uident [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On IMPORT shift to state 577
-- On boption(IMPORT) shift to state 998
## Reductions:
-- On UIDENT reduce production boption(IMPORT) ->
-- On CORE_UIDENT reduce production boption(IMPORT) ->

State 998:
## Known stack suffix:
## SCOPE boption(IMPORT)
## LR(1) items:
scope_head -> SCOPE boption(IMPORT) . uident [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 999
## Reductions:

State 999:
## Known stack suffix:
## SCOPE boption(IMPORT) uident
## LR(1) items:
scope_head -> SCOPE boption(IMPORT) uident . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On USE reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On TYPE reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On SCOPE reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On PREDICATE reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On META reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On LET reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On LEMMA reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On INDUCTIVE reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On IMPORT reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On GOAL reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On FUNCTION reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On EXCEPTION reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On END reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On CONSTANT reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On COINDUCTIVE reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On CLONE reduce production scope_head -> SCOPE boption(IMPORT) uident
-- On AXIOM reduce production scope_head -> SCOPE boption(IMPORT) uident

State 1000:
## Known stack suffix:
## PREDICATE
## LR(1) items:
pure_decl -> PREDICATE . predicate_decl list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On predicate_decl shift to state 1001
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On attrs(lident_rich) shift to state 1012
## Reductions:

State 1001:
## Known stack suffix:
## PREDICATE predicate_decl
## LR(1) items:
pure_decl -> PREDICATE predicate_decl . list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 1002
-- On with_logic_decl shift to state 1009
-- On list(with_logic_decl) shift to state 1011
## Reductions:
-- On VAL reduce production list(with_logic_decl) ->
-- On USE reduce production list(with_logic_decl) ->
-- On TYPE reduce production list(with_logic_decl) ->
-- On SCOPE reduce production list(with_logic_decl) ->
-- On PREDICATE reduce production list(with_logic_decl) ->
-- On META reduce production list(with_logic_decl) ->
-- On LET reduce production list(with_logic_decl) ->
-- On LEMMA reduce production list(with_logic_decl) ->
-- On INDUCTIVE reduce production list(with_logic_decl) ->
-- On IMPORT reduce production list(with_logic_decl) ->
-- On GOAL reduce production list(with_logic_decl) ->
-- On FUNCTION reduce production list(with_logic_decl) ->
-- On EXCEPTION reduce production list(with_logic_decl) ->
-- On EOF reduce production list(with_logic_decl) ->
-- On END reduce production list(with_logic_decl) ->
-- On CONSTANT reduce production list(with_logic_decl) ->
-- On COINDUCTIVE reduce production list(with_logic_decl) ->
-- On CLONE reduce production list(with_logic_decl) ->
-- On AXIOM reduce production list(with_logic_decl) ->

State 1002:
## Known stack suffix:
## WITH
## LR(1) items:
with_logic_decl -> WITH . attrs(lident_rich) params option(cast) option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On attrs(lident_rich) shift to state 1003
## Reductions:

State 1003:
## Known stack suffix:
## WITH attrs(lident_rich)
## LR(1) items:
with_logic_decl -> WITH attrs(lident_rich) . params option(cast) option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 1004
-- On param shift to state 569
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WITH reduce production list(param) ->
-- On VAL reduce production list(param) ->
-- On USE reduce production list(param) ->
-- On TYPE reduce production list(param) ->
-- On SCOPE reduce production list(param) ->
-- On PREDICATE reduce production list(param) ->
-- On META reduce production list(param) ->
-- On LET reduce production list(param) ->
-- On LEMMA reduce production list(param) ->
-- On INDUCTIVE reduce production list(param) ->
-- On IMPORT reduce production list(param) ->
-- On GOAL reduce production list(param) ->
-- On FUNCTION reduce production list(param) ->
-- On EXCEPTION reduce production list(param) ->
-- On EQUAL reduce production list(param) ->
-- On EOF reduce production list(param) ->
-- On END reduce production list(param) ->
-- On CONSTANT reduce production list(param) ->
-- On COLON reduce production list(param) ->
-- On COINDUCTIVE reduce production list(param) ->
-- On CLONE reduce production list(param) ->
-- On AXIOM reduce production list(param) ->

State 1004:
## Known stack suffix:
## WITH attrs(lident_rich) params
## LR(1) items:
with_logic_decl -> WITH attrs(lident_rich) params . option(cast) option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 132
-- On option(cast) shift to state 1005
-- On cast shift to state 337
## Reductions:
-- On WITH reduce production option(cast) ->
-- On VAL reduce production option(cast) ->
-- On USE reduce production option(cast) ->
-- On TYPE reduce production option(cast) ->
-- On SCOPE reduce production option(cast) ->
-- On PREDICATE reduce production option(cast) ->
-- On META reduce production option(cast) ->
-- On LET reduce production option(cast) ->
-- On LEMMA reduce production option(cast) ->
-- On INDUCTIVE reduce production option(cast) ->
-- On IMPORT reduce production option(cast) ->
-- On GOAL reduce production option(cast) ->
-- On FUNCTION reduce production option(cast) ->
-- On EXCEPTION reduce production option(cast) ->
-- On EQUAL reduce production option(cast) ->
-- On EOF reduce production option(cast) ->
-- On END reduce production option(cast) ->
-- On CONSTANT reduce production option(cast) ->
-- On COINDUCTIVE reduce production option(cast) ->
-- On CLONE reduce production option(cast) ->
-- On AXIOM reduce production option(cast) ->

State 1005:
## Known stack suffix:
## WITH attrs(lident_rich) params option(cast)
## LR(1) items:
with_logic_decl -> WITH attrs(lident_rich) params option(cast) . option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1006
-- On option(preceded(EQUAL,term)) shift to state 1008
## Reductions:
-- On WITH reduce production option(preceded(EQUAL,term)) ->
-- On VAL reduce production option(preceded(EQUAL,term)) ->
-- On USE reduce production option(preceded(EQUAL,term)) ->
-- On TYPE reduce production option(preceded(EQUAL,term)) ->
-- On SCOPE reduce production option(preceded(EQUAL,term)) ->
-- On PREDICATE reduce production option(preceded(EQUAL,term)) ->
-- On META reduce production option(preceded(EQUAL,term)) ->
-- On LET reduce production option(preceded(EQUAL,term)) ->
-- On LEMMA reduce production option(preceded(EQUAL,term)) ->
-- On INDUCTIVE reduce production option(preceded(EQUAL,term)) ->
-- On IMPORT reduce production option(preceded(EQUAL,term)) ->
-- On GOAL reduce production option(preceded(EQUAL,term)) ->
-- On FUNCTION reduce production option(preceded(EQUAL,term)) ->
-- On EXCEPTION reduce production option(preceded(EQUAL,term)) ->
-- On EOF reduce production option(preceded(EQUAL,term)) ->
-- On END reduce production option(preceded(EQUAL,term)) ->
-- On CONSTANT reduce production option(preceded(EQUAL,term)) ->
-- On COINDUCTIVE reduce production option(preceded(EQUAL,term)) ->
-- On CLONE reduce production option(preceded(EQUAL,term)) ->
-- On AXIOM reduce production option(preceded(EQUAL,term)) ->

State 1006:
## Known stack suffix:
## EQUAL
## LR(1) items:
option(preceded(EQUAL,term)) -> EQUAL . term [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 1007
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 1007:
## Known stack suffix:
## EQUAL term
## LR(1) items:
option(preceded(EQUAL,term)) -> EQUAL term . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On VAL reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On USE reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On TYPE reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On SCOPE reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On PREDICATE reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On META reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On LET reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On LEMMA reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On INDUCTIVE reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On IMPORT reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On GOAL reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On FUNCTION reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On EXCEPTION reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On EOF reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On END reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On CONSTANT reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On COINDUCTIVE reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On CLONE reduce production option(preceded(EQUAL,term)) -> EQUAL term
-- On AXIOM reduce production option(preceded(EQUAL,term)) -> EQUAL term

State 1008:
## Known stack suffix:
## WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
## LR(1) items:
with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term)) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On VAL reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On USE reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On TYPE reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On SCOPE reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On PREDICATE reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On META reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On LET reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On LEMMA reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On INDUCTIVE reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On IMPORT reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On GOAL reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On FUNCTION reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On EXCEPTION reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On EOF reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On END reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On CONSTANT reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On COINDUCTIVE reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On CLONE reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
-- On AXIOM reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))

State 1009:
## Known stack suffix:
## with_logic_decl
## LR(1) items:
list(with_logic_decl) -> with_logic_decl . list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 1002
-- On with_logic_decl shift to state 1009
-- On list(with_logic_decl) shift to state 1010
## Reductions:
-- On VAL reduce production list(with_logic_decl) ->
-- On USE reduce production list(with_logic_decl) ->
-- On TYPE reduce production list(with_logic_decl) ->
-- On SCOPE reduce production list(with_logic_decl) ->
-- On PREDICATE reduce production list(with_logic_decl) ->
-- On META reduce production list(with_logic_decl) ->
-- On LET reduce production list(with_logic_decl) ->
-- On LEMMA reduce production list(with_logic_decl) ->
-- On INDUCTIVE reduce production list(with_logic_decl) ->
-- On IMPORT reduce production list(with_logic_decl) ->
-- On GOAL reduce production list(with_logic_decl) ->
-- On FUNCTION reduce production list(with_logic_decl) ->
-- On EXCEPTION reduce production list(with_logic_decl) ->
-- On EOF reduce production list(with_logic_decl) ->
-- On END reduce production list(with_logic_decl) ->
-- On CONSTANT reduce production list(with_logic_decl) ->
-- On COINDUCTIVE reduce production list(with_logic_decl) ->
-- On CLONE reduce production list(with_logic_decl) ->
-- On AXIOM reduce production list(with_logic_decl) ->

State 1010:
## Known stack suffix:
## with_logic_decl list(with_logic_decl)
## LR(1) items:
list(with_logic_decl) -> with_logic_decl list(with_logic_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On USE reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On TYPE reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On SCOPE reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On PREDICATE reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On META reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On LET reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On LEMMA reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On INDUCTIVE reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On IMPORT reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On GOAL reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On FUNCTION reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On EXCEPTION reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On EOF reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On END reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On CONSTANT reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On COINDUCTIVE reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On CLONE reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)
-- On AXIOM reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)

State 1011:
## Known stack suffix:
## PREDICATE predicate_decl list(with_logic_decl)
## LR(1) items:
pure_decl -> PREDICATE predicate_decl list(with_logic_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On USE reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On TYPE reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On SCOPE reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On PREDICATE reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On META reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On LET reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On LEMMA reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On INDUCTIVE reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On IMPORT reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On GOAL reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On FUNCTION reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On EXCEPTION reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On EOF reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On END reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On CONSTANT reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On COINDUCTIVE reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On CLONE reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)
-- On AXIOM reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)

State 1012:
## Known stack suffix:
## attrs(lident_rich)
## LR(1) items:
predicate_decl -> attrs(lident_rich) . params option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 1013
-- On param shift to state 569
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WITH reduce production list(param) ->
-- On VAL reduce production list(param) ->
-- On USE reduce production list(param) ->
-- On TYPE reduce production list(param) ->
-- On SCOPE reduce production list(param) ->
-- On PREDICATE reduce production list(param) ->
-- On META reduce production list(param) ->
-- On LET reduce production list(param) ->
-- On LEMMA reduce production list(param) ->
-- On INDUCTIVE reduce production list(param) ->
-- On IMPORT reduce production list(param) ->
-- On GOAL reduce production list(param) ->
-- On FUNCTION reduce production list(param) ->
-- On EXCEPTION reduce production list(param) ->
-- On EQUAL reduce production list(param) ->
-- On EOF reduce production list(param) ->
-- On END reduce production list(param) ->
-- On CONSTANT reduce production list(param) ->
-- On COINDUCTIVE reduce production list(param) ->
-- On CLONE reduce production list(param) ->
-- On AXIOM reduce production list(param) ->

State 1013:
## Known stack suffix:
## attrs(lident_rich) params
## LR(1) items:
predicate_decl -> attrs(lident_rich) params . option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1006
-- On option(preceded(EQUAL,term)) shift to state 1014
## Reductions:
-- On WITH reduce production option(preceded(EQUAL,term)) ->
-- On VAL reduce production option(preceded(EQUAL,term)) ->
-- On USE reduce production option(preceded(EQUAL,term)) ->
-- On TYPE reduce production option(preceded(EQUAL,term)) ->
-- On SCOPE reduce production option(preceded(EQUAL,term)) ->
-- On PREDICATE reduce production option(preceded(EQUAL,term)) ->
-- On META reduce production option(preceded(EQUAL,term)) ->
-- On LET reduce production option(preceded(EQUAL,term)) ->
-- On LEMMA reduce production option(preceded(EQUAL,term)) ->
-- On INDUCTIVE reduce production option(preceded(EQUAL,term)) ->
-- On IMPORT reduce production option(preceded(EQUAL,term)) ->
-- On GOAL reduce production option(preceded(EQUAL,term)) ->
-- On FUNCTION reduce production option(preceded(EQUAL,term)) ->
-- On EXCEPTION reduce production option(preceded(EQUAL,term)) ->
-- On EOF reduce production option(preceded(EQUAL,term)) ->
-- On END reduce production option(preceded(EQUAL,term)) ->
-- On CONSTANT reduce production option(preceded(EQUAL,term)) ->
-- On COINDUCTIVE reduce production option(preceded(EQUAL,term)) ->
-- On CLONE reduce production option(preceded(EQUAL,term)) ->
-- On AXIOM reduce production option(preceded(EQUAL,term)) ->

State 1014:
## Known stack suffix:
## attrs(lident_rich) params option(preceded(EQUAL,term))
## LR(1) items:
predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term)) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On VAL reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On USE reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On TYPE reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On SCOPE reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On PREDICATE reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On META reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On LET reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On LEMMA reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On INDUCTIVE reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On IMPORT reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On GOAL reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On FUNCTION reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On EXCEPTION reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On EOF reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On END reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On CONSTANT reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On COINDUCTIVE reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On CLONE reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))
-- On AXIOM reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))

State 1015:
## Known stack suffix:
## MODULE
## LR(1) items:
module_head -> MODULE . attrs(uident_nq) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On CORE_UIDENT shift to state 648
-- On uident_nq shift to state 649
-- On attrs(uident_nq) shift to state 1016
## Reductions:

State 1016:
## Known stack suffix:
## MODULE attrs(uident_nq)
## LR(1) items:
module_head -> MODULE attrs(uident_nq) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production module_head -> MODULE attrs(uident_nq)
-- On USE reduce production module_head -> MODULE attrs(uident_nq)
-- On TYPE reduce production module_head -> MODULE attrs(uident_nq)
-- On SCOPE reduce production module_head -> MODULE attrs(uident_nq)
-- On PREDICATE reduce production module_head -> MODULE attrs(uident_nq)
-- On META reduce production module_head -> MODULE attrs(uident_nq)
-- On LET reduce production module_head -> MODULE attrs(uident_nq)
-- On LEMMA reduce production module_head -> MODULE attrs(uident_nq)
-- On INDUCTIVE reduce production module_head -> MODULE attrs(uident_nq)
-- On IMPORT reduce production module_head -> MODULE attrs(uident_nq)
-- On GOAL reduce production module_head -> MODULE attrs(uident_nq)
-- On FUNCTION reduce production module_head -> MODULE attrs(uident_nq)
-- On EXCEPTION reduce production module_head -> MODULE attrs(uident_nq)
-- On END reduce production module_head -> MODULE attrs(uident_nq)
-- On CONSTANT reduce production module_head -> MODULE attrs(uident_nq)
-- On COINDUCTIVE reduce production module_head -> MODULE attrs(uident_nq)
-- On CLONE reduce production module_head -> MODULE attrs(uident_nq)
-- On AXIOM reduce production module_head -> MODULE attrs(uident_nq)

State 1017:
## Known stack suffix:
## META
## LR(1) items:
meta_decl -> META . sident comma_list1(meta_arg) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 1018
-- On sident shift to state 1019
-- On lident_keyword shift to state 43
-- On lident shift to state 586
## Reductions:

State 1018:
## Known stack suffix:
## uident
## LR(1) items:
sident -> uident . [ TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION CONSTANT AXIOM ]
## Transitions:
## Reductions:
-- On TYPE reduce production sident -> uident
-- On STRING reduce production sident -> uident
-- On PREDICATE reduce production sident -> uident
-- On LEMMA reduce production sident -> uident
-- On INTEGER reduce production sident -> uident
-- On GOAL reduce production sident -> uident
-- On FUNCTION reduce production sident -> uident
-- On CONSTANT reduce production sident -> uident
-- On AXIOM reduce production sident -> uident

State 1019:
## Known stack suffix:
## META sident
## LR(1) items:
meta_decl -> META sident . comma_list1(meta_arg) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On TYPE shift to state 1020
-- On STRING shift to state 1022
-- On PREDICATE shift to state 1023
-- On LEMMA shift to state 1025
-- On INTEGER shift to state 1027
-- On GOAL shift to state 1028
-- On FUNCTION shift to state 1030
-- On CONSTANT shift to state 1032
-- On AXIOM shift to state 1034
-- On separated_nonempty_list(COMMA,meta_arg) shift to state 1036
-- On meta_arg shift to state 1037
-- On comma_list1(meta_arg) shift to state 1040
## Reductions:

State 1020:
## Known stack suffix:
## TYPE
## LR(1) items:
meta_arg -> TYPE . ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 1021
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 1021:
## Known stack suffix:
## TYPE ty
## LR(1) items:
meta_arg -> TYPE ty . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
ty -> ty . ARROW ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ARROW ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On VAL reduce production meta_arg -> TYPE ty
-- On USE reduce production meta_arg -> TYPE ty
-- On TYPE reduce production meta_arg -> TYPE ty
-- On SCOPE reduce production meta_arg -> TYPE ty
-- On PREDICATE reduce production meta_arg -> TYPE ty
-- On META reduce production meta_arg -> TYPE ty
-- On LET reduce production meta_arg -> TYPE ty
-- On LEMMA reduce production meta_arg -> TYPE ty
-- On INDUCTIVE reduce production meta_arg -> TYPE ty
-- On IMPORT reduce production meta_arg -> TYPE ty
-- On GOAL reduce production meta_arg -> TYPE ty
-- On FUNCTION reduce production meta_arg -> TYPE ty
-- On EXCEPTION reduce production meta_arg -> TYPE ty
-- On EOF reduce production meta_arg -> TYPE ty
-- On END reduce production meta_arg -> TYPE ty
-- On CONSTANT reduce production meta_arg -> TYPE ty
-- On COMMA reduce production meta_arg -> TYPE ty
-- On COINDUCTIVE reduce production meta_arg -> TYPE ty
-- On CLONE reduce production meta_arg -> TYPE ty
-- On AXIOM reduce production meta_arg -> TYPE ty

State 1022:
## Known stack suffix:
## STRING
## LR(1) items:
meta_arg -> STRING . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production meta_arg -> STRING
-- On USE reduce production meta_arg -> STRING
-- On TYPE reduce production meta_arg -> STRING
-- On SCOPE reduce production meta_arg -> STRING
-- On PREDICATE reduce production meta_arg -> STRING
-- On META reduce production meta_arg -> STRING
-- On LET reduce production meta_arg -> STRING
-- On LEMMA reduce production meta_arg -> STRING
-- On INDUCTIVE reduce production meta_arg -> STRING
-- On IMPORT reduce production meta_arg -> STRING
-- On GOAL reduce production meta_arg -> STRING
-- On FUNCTION reduce production meta_arg -> STRING
-- On EXCEPTION reduce production meta_arg -> STRING
-- On EOF reduce production meta_arg -> STRING
-- On END reduce production meta_arg -> STRING
-- On CONSTANT reduce production meta_arg -> STRING
-- On COMMA reduce production meta_arg -> STRING
-- On COINDUCTIVE reduce production meta_arg -> STRING
-- On CLONE reduce production meta_arg -> STRING
-- On AXIOM reduce production meta_arg -> STRING

State 1023:
## Known stack suffix:
## PREDICATE
## LR(1) items:
meta_arg -> PREDICATE . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1024
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1024:
## Known stack suffix:
## PREDICATE qualid
## LR(1) items:
meta_arg -> PREDICATE qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production meta_arg -> PREDICATE qualid
-- On USE reduce production meta_arg -> PREDICATE qualid
-- On TYPE reduce production meta_arg -> PREDICATE qualid
-- On SCOPE reduce production meta_arg -> PREDICATE qualid
-- On PREDICATE reduce production meta_arg -> PREDICATE qualid
-- On META reduce production meta_arg -> PREDICATE qualid
-- On LET reduce production meta_arg -> PREDICATE qualid
-- On LEMMA reduce production meta_arg -> PREDICATE qualid
-- On INDUCTIVE reduce production meta_arg -> PREDICATE qualid
-- On IMPORT reduce production meta_arg -> PREDICATE qualid
-- On GOAL reduce production meta_arg -> PREDICATE qualid
-- On FUNCTION reduce production meta_arg -> PREDICATE qualid
-- On EXCEPTION reduce production meta_arg -> PREDICATE qualid
-- On EOF reduce production meta_arg -> PREDICATE qualid
-- On END reduce production meta_arg -> PREDICATE qualid
-- On CONSTANT reduce production meta_arg -> PREDICATE qualid
-- On COMMA reduce production meta_arg -> PREDICATE qualid
-- On COINDUCTIVE reduce production meta_arg -> PREDICATE qualid
-- On CLONE reduce production meta_arg -> PREDICATE qualid
-- On AXIOM reduce production meta_arg -> PREDICATE qualid

State 1025:
## Known stack suffix:
## LEMMA
## LR(1) items:
meta_arg -> LEMMA . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1026
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1026:
## Known stack suffix:
## LEMMA qualid
## LR(1) items:
meta_arg -> LEMMA qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production meta_arg -> LEMMA qualid
-- On USE reduce production meta_arg -> LEMMA qualid
-- On TYPE reduce production meta_arg -> LEMMA qualid
-- On SCOPE reduce production meta_arg -> LEMMA qualid
-- On PREDICATE reduce production meta_arg -> LEMMA qualid
-- On META reduce production meta_arg -> LEMMA qualid
-- On LET reduce production meta_arg -> LEMMA qualid
-- On LEMMA reduce production meta_arg -> LEMMA qualid
-- On INDUCTIVE reduce production meta_arg -> LEMMA qualid
-- On IMPORT reduce production meta_arg -> LEMMA qualid
-- On GOAL reduce production meta_arg -> LEMMA qualid
-- On FUNCTION reduce production meta_arg -> LEMMA qualid
-- On EXCEPTION reduce production meta_arg -> LEMMA qualid
-- On EOF reduce production meta_arg -> LEMMA qualid
-- On END reduce production meta_arg -> LEMMA qualid
-- On CONSTANT reduce production meta_arg -> LEMMA qualid
-- On COMMA reduce production meta_arg -> LEMMA qualid
-- On COINDUCTIVE reduce production meta_arg -> LEMMA qualid
-- On CLONE reduce production meta_arg -> LEMMA qualid
-- On AXIOM reduce production meta_arg -> LEMMA qualid

State 1027:
## Known stack suffix:
## INTEGER
## LR(1) items:
meta_arg -> INTEGER . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production meta_arg -> INTEGER
-- On USE reduce production meta_arg -> INTEGER
-- On TYPE reduce production meta_arg -> INTEGER
-- On SCOPE reduce production meta_arg -> INTEGER
-- On PREDICATE reduce production meta_arg -> INTEGER
-- On META reduce production meta_arg -> INTEGER
-- On LET reduce production meta_arg -> INTEGER
-- On LEMMA reduce production meta_arg -> INTEGER
-- On INDUCTIVE reduce production meta_arg -> INTEGER
-- On IMPORT reduce production meta_arg -> INTEGER
-- On GOAL reduce production meta_arg -> INTEGER
-- On FUNCTION reduce production meta_arg -> INTEGER
-- On EXCEPTION reduce production meta_arg -> INTEGER
-- On EOF reduce production meta_arg -> INTEGER
-- On END reduce production meta_arg -> INTEGER
-- On CONSTANT reduce production meta_arg -> INTEGER
-- On COMMA reduce production meta_arg -> INTEGER
-- On COINDUCTIVE reduce production meta_arg -> INTEGER
-- On CLONE reduce production meta_arg -> INTEGER
-- On AXIOM reduce production meta_arg -> INTEGER

State 1028:
## Known stack suffix:
## GOAL
## LR(1) items:
meta_arg -> GOAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1029
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1029:
## Known stack suffix:
## GOAL qualid
## LR(1) items:
meta_arg -> GOAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production meta_arg -> GOAL qualid
-- On USE reduce production meta_arg -> GOAL qualid
-- On TYPE reduce production meta_arg -> GOAL qualid
-- On SCOPE reduce production meta_arg -> GOAL qualid
-- On PREDICATE reduce production meta_arg -> GOAL qualid
-- On META reduce production meta_arg -> GOAL qualid
-- On LET reduce production meta_arg -> GOAL qualid
-- On LEMMA reduce production meta_arg -> GOAL qualid
-- On INDUCTIVE reduce production meta_arg -> GOAL qualid
-- On IMPORT reduce production meta_arg -> GOAL qualid
-- On GOAL reduce production meta_arg -> GOAL qualid
-- On FUNCTION reduce production meta_arg -> GOAL qualid
-- On EXCEPTION reduce production meta_arg -> GOAL qualid
-- On EOF reduce production meta_arg -> GOAL qualid
-- On END reduce production meta_arg -> GOAL qualid
-- On CONSTANT reduce production meta_arg -> GOAL qualid
-- On COMMA reduce production meta_arg -> GOAL qualid
-- On COINDUCTIVE reduce production meta_arg -> GOAL qualid
-- On CLONE reduce production meta_arg -> GOAL qualid
-- On AXIOM reduce production meta_arg -> GOAL qualid

State 1030:
## Known stack suffix:
## FUNCTION
## LR(1) items:
meta_arg -> FUNCTION . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1031
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1031:
## Known stack suffix:
## FUNCTION qualid
## LR(1) items:
meta_arg -> FUNCTION qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production meta_arg -> FUNCTION qualid
-- On USE reduce production meta_arg -> FUNCTION qualid
-- On TYPE reduce production meta_arg -> FUNCTION qualid
-- On SCOPE reduce production meta_arg -> FUNCTION qualid
-- On PREDICATE reduce production meta_arg -> FUNCTION qualid
-- On META reduce production meta_arg -> FUNCTION qualid
-- On LET reduce production meta_arg -> FUNCTION qualid
-- On LEMMA reduce production meta_arg -> FUNCTION qualid
-- On INDUCTIVE reduce production meta_arg -> FUNCTION qualid
-- On IMPORT reduce production meta_arg -> FUNCTION qualid
-- On GOAL reduce production meta_arg -> FUNCTION qualid
-- On FUNCTION reduce production meta_arg -> FUNCTION qualid
-- On EXCEPTION reduce production meta_arg -> FUNCTION qualid
-- On EOF reduce production meta_arg -> FUNCTION qualid
-- On END reduce production meta_arg -> FUNCTION qualid
-- On CONSTANT reduce production meta_arg -> FUNCTION qualid
-- On COMMA reduce production meta_arg -> FUNCTION qualid
-- On COINDUCTIVE reduce production meta_arg -> FUNCTION qualid
-- On CLONE reduce production meta_arg -> FUNCTION qualid
-- On AXIOM reduce production meta_arg -> FUNCTION qualid

State 1032:
## Known stack suffix:
## CONSTANT
## LR(1) items:
meta_arg -> CONSTANT . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1033
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1033:
## Known stack suffix:
## CONSTANT qualid
## LR(1) items:
meta_arg -> CONSTANT qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production meta_arg -> CONSTANT qualid
-- On USE reduce production meta_arg -> CONSTANT qualid
-- On TYPE reduce production meta_arg -> CONSTANT qualid
-- On SCOPE reduce production meta_arg -> CONSTANT qualid
-- On PREDICATE reduce production meta_arg -> CONSTANT qualid
-- On META reduce production meta_arg -> CONSTANT qualid
-- On LET reduce production meta_arg -> CONSTANT qualid
-- On LEMMA reduce production meta_arg -> CONSTANT qualid
-- On INDUCTIVE reduce production meta_arg -> CONSTANT qualid
-- On IMPORT reduce production meta_arg -> CONSTANT qualid
-- On GOAL reduce production meta_arg -> CONSTANT qualid
-- On FUNCTION reduce production meta_arg -> CONSTANT qualid
-- On EXCEPTION reduce production meta_arg -> CONSTANT qualid
-- On EOF reduce production meta_arg -> CONSTANT qualid
-- On END reduce production meta_arg -> CONSTANT qualid
-- On CONSTANT reduce production meta_arg -> CONSTANT qualid
-- On COMMA reduce production meta_arg -> CONSTANT qualid
-- On COINDUCTIVE reduce production meta_arg -> CONSTANT qualid
-- On CLONE reduce production meta_arg -> CONSTANT qualid
-- On AXIOM reduce production meta_arg -> CONSTANT qualid

State 1034:
## Known stack suffix:
## AXIOM
## LR(1) items:
meta_arg -> AXIOM . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1035
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1035:
## Known stack suffix:
## AXIOM qualid
## LR(1) items:
meta_arg -> AXIOM qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production meta_arg -> AXIOM qualid
-- On USE reduce production meta_arg -> AXIOM qualid
-- On TYPE reduce production meta_arg -> AXIOM qualid
-- On SCOPE reduce production meta_arg -> AXIOM qualid
-- On PREDICATE reduce production meta_arg -> AXIOM qualid
-- On META reduce production meta_arg -> AXIOM qualid
-- On LET reduce production meta_arg -> AXIOM qualid
-- On LEMMA reduce production meta_arg -> AXIOM qualid
-- On INDUCTIVE reduce production meta_arg -> AXIOM qualid
-- On IMPORT reduce production meta_arg -> AXIOM qualid
-- On GOAL reduce production meta_arg -> AXIOM qualid
-- On FUNCTION reduce production meta_arg -> AXIOM qualid
-- On EXCEPTION reduce production meta_arg -> AXIOM qualid
-- On EOF reduce production meta_arg -> AXIOM qualid
-- On END reduce production meta_arg -> AXIOM qualid
-- On CONSTANT reduce production meta_arg -> AXIOM qualid
-- On COMMA reduce production meta_arg -> AXIOM qualid
-- On COINDUCTIVE reduce production meta_arg -> AXIOM qualid
-- On CLONE reduce production meta_arg -> AXIOM qualid
-- On AXIOM reduce production meta_arg -> AXIOM qualid

State 1036:
## Known stack suffix:
## separated_nonempty_list(COMMA,meta_arg)
## LR(1) items:
comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On USE reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On TYPE reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On SCOPE reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On PREDICATE reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On META reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On LET reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On LEMMA reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On INDUCTIVE reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On IMPORT reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On GOAL reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On FUNCTION reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On EXCEPTION reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On EOF reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On END reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On CONSTANT reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On COINDUCTIVE reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On CLONE reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)
-- On AXIOM reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)

State 1037:
## Known stack suffix:
## meta_arg
## LR(1) items:
separated_nonempty_list(COMMA,meta_arg) -> meta_arg . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(COMMA,meta_arg) -> meta_arg . COMMA separated_nonempty_list(COMMA,meta_arg) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COMMA shift to state 1038
## Reductions:
-- On VAL reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On USE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On TYPE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On SCOPE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On PREDICATE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On META reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On LET reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On LEMMA reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On INDUCTIVE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On IMPORT reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On GOAL reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On FUNCTION reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On EXCEPTION reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On EOF reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On END reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On CONSTANT reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On COINDUCTIVE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On CLONE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg
-- On AXIOM reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg

State 1038:
## Known stack suffix:
## meta_arg COMMA
## LR(1) items:
separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA . separated_nonempty_list(COMMA,meta_arg) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On TYPE shift to state 1020
-- On STRING shift to state 1022
-- On PREDICATE shift to state 1023
-- On LEMMA shift to state 1025
-- On INTEGER shift to state 1027
-- On GOAL shift to state 1028
-- On FUNCTION shift to state 1030
-- On CONSTANT shift to state 1032
-- On AXIOM shift to state 1034
-- On separated_nonempty_list(COMMA,meta_arg) shift to state 1039
-- On meta_arg shift to state 1037
## Reductions:

State 1039:
## Known stack suffix:
## meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
## LR(1) items:
separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On USE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On TYPE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On SCOPE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On PREDICATE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On META reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On LET reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On LEMMA reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On INDUCTIVE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On IMPORT reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On GOAL reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On FUNCTION reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On EXCEPTION reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On EOF reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On END reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On CONSTANT reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On COINDUCTIVE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On CLONE reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
-- On AXIOM reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)

State 1040:
## Known stack suffix:
## META sident comma_list1(meta_arg)
## LR(1) items:
meta_decl -> META sident comma_list1(meta_arg) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On USE reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On TYPE reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On SCOPE reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On PREDICATE reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On META reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On LET reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On LEMMA reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On INDUCTIVE reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On IMPORT reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On GOAL reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On FUNCTION reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On EXCEPTION reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On EOF reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On END reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On CONSTANT reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On COINDUCTIVE reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On CLONE reduce production meta_decl -> META sident comma_list1(meta_arg)
-- On AXIOM reduce production meta_decl -> META sident comma_list1(meta_arg)

State 1041:
## Known stack suffix:
## LET
## LR(1) items:
prog_decl -> LET . ghost kind attrs(lident_rich) mk_expr(fun_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> LET . ghost kind attrs(lident_rich) const_defn [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> LET . REC with_list1(rec_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On REC shift to state 1042
-- On GHOST shift to state 53
-- On ghost shift to state 1044
## Reductions:
-- On RANGE reduce production ghost ->
-- On PREDICATE reduce production ghost ->
-- On LIDENT reduce production ghost ->
-- On LEMMA reduce production ghost ->
-- On LEFTPAR reduce production ghost ->
-- On FUNCTION reduce production ghost ->
-- On FLOAT reduce production ghost ->
-- On CORE_LIDENT reduce production ghost ->
-- On CONSTANT reduce production ghost ->

State 1042:
## Known stack suffix:
## LET REC
## LR(1) items:
prog_decl -> LET REC . with_list1(rec_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On GHOST shift to state 53
-- On with_list1(rec_defn) shift to state 1043
-- On separated_nonempty_list(WITH,rec_defn) shift to state 869
-- On rec_defn shift to state 870
-- On ghost shift to state 873
## Reductions:
-- On RANGE reduce production ghost ->
-- On PREDICATE reduce production ghost ->
-- On LIDENT reduce production ghost ->
-- On LEMMA reduce production ghost ->
-- On LEFTPAR reduce production ghost ->
-- On FUNCTION reduce production ghost ->
-- On FLOAT reduce production ghost ->
-- On CORE_LIDENT reduce production ghost ->
-- On CONSTANT reduce production ghost ->

State 1043:
## Known stack suffix:
## LET REC with_list1(rec_defn)
## LR(1) items:
prog_decl -> LET REC with_list1(rec_defn) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On USE reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On TYPE reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On SCOPE reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On PREDICATE reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On META reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On LET reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On LEMMA reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On INDUCTIVE reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On IMPORT reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On GOAL reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On FUNCTION reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On EXCEPTION reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On EOF reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On END reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On CONSTANT reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On COINDUCTIVE reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On CLONE reduce production prog_decl -> LET REC with_list1(rec_defn)
-- On AXIOM reduce production prog_decl -> LET REC with_list1(rec_defn)

State 1044:
## Known stack suffix:
## LET ghost
## LR(1) items:
prog_decl -> LET ghost . kind attrs(lident_rich) mk_expr(fun_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> LET ghost . kind attrs(lident_rich) const_defn [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On PREDICATE shift to state 55
-- On LEMMA shift to state 56
-- On FUNCTION shift to state 57
-- On CONSTANT shift to state 58
-- On kind shift to state 1045
## Reductions:
-- On RANGE reduce production kind ->
-- On LIDENT reduce production kind ->
-- On LEFTPAR reduce production kind ->
-- On FLOAT reduce production kind ->
-- On CORE_LIDENT reduce production kind ->

State 1045:
## Known stack suffix:
## LET ghost kind
## LR(1) items:
prog_decl -> LET ghost kind . attrs(lident_rich) mk_expr(fun_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> LET ghost kind . attrs(lident_rich) const_defn [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On attrs(lident_rich) shift to state 1046
## Reductions:

State 1046:
## Known stack suffix:
## LET ghost kind attrs(lident_rich)
## LR(1) items:
prog_decl -> LET ghost kind attrs(lident_rich) . mk_expr(fun_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> LET ghost kind attrs(lident_rich) . const_defn [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On EQUAL shift to state 1047
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On COLON shift to state 132
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On mk_expr(fun_defn) shift to state 1049
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On fun_defn shift to state 914
-- On const_defn shift to state 1050
-- On cast shift to state 1051
-- On binders shift to state 915
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:

State 1047:
## Known stack suffix:
## EQUAL
## LR(1) items:
const_defn -> EQUAL . seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 1048
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 1048:
## Known stack suffix:
## EQUAL seq_expr
## LR(1) items:
const_defn -> EQUAL seq_expr . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production const_defn -> EQUAL seq_expr
-- On USE reduce production const_defn -> EQUAL seq_expr
-- On TYPE reduce production const_defn -> EQUAL seq_expr
-- On SCOPE reduce production const_defn -> EQUAL seq_expr
-- On PREDICATE reduce production const_defn -> EQUAL seq_expr
-- On META reduce production const_defn -> EQUAL seq_expr
-- On LET reduce production const_defn -> EQUAL seq_expr
-- On LEMMA reduce production const_defn -> EQUAL seq_expr
-- On INDUCTIVE reduce production const_defn -> EQUAL seq_expr
-- On IMPORT reduce production const_defn -> EQUAL seq_expr
-- On GOAL reduce production const_defn -> EQUAL seq_expr
-- On FUNCTION reduce production const_defn -> EQUAL seq_expr
-- On EXCEPTION reduce production const_defn -> EQUAL seq_expr
-- On EOF reduce production const_defn -> EQUAL seq_expr
-- On END reduce production const_defn -> EQUAL seq_expr
-- On CONSTANT reduce production const_defn -> EQUAL seq_expr
-- On COINDUCTIVE reduce production const_defn -> EQUAL seq_expr
-- On CLONE reduce production const_defn -> EQUAL seq_expr
-- On AXIOM reduce production const_defn -> EQUAL seq_expr

State 1049:
## Known stack suffix:
## LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
## LR(1) items:
prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On USE reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On TYPE reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On SCOPE reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On PREDICATE reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On META reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On LET reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On LEMMA reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On INDUCTIVE reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On IMPORT reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On GOAL reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On FUNCTION reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On EXCEPTION reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On EOF reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On END reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On CONSTANT reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On COINDUCTIVE reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On CLONE reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
-- On AXIOM reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)

State 1050:
## Known stack suffix:
## LET ghost kind attrs(lident_rich) const_defn
## LR(1) items:
prog_decl -> LET ghost kind attrs(lident_rich) const_defn . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On USE reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On TYPE reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On SCOPE reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On PREDICATE reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On META reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On LET reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On LEMMA reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On INDUCTIVE reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On IMPORT reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On GOAL reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On FUNCTION reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On EXCEPTION reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On EOF reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On END reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On CONSTANT reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On COINDUCTIVE reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On CLONE reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn
-- On AXIOM reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn

State 1051:
## Known stack suffix:
## cast
## LR(1) items:
const_defn -> cast . EQUAL seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1052
## Reductions:

State 1052:
## Known stack suffix:
## cast EQUAL
## LR(1) items:
const_defn -> cast EQUAL . seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 1053
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 1053:
## Known stack suffix:
## cast EQUAL seq_expr
## LR(1) items:
const_defn -> cast EQUAL seq_expr . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production const_defn -> cast EQUAL seq_expr
-- On USE reduce production const_defn -> cast EQUAL seq_expr
-- On TYPE reduce production const_defn -> cast EQUAL seq_expr
-- On SCOPE reduce production const_defn -> cast EQUAL seq_expr
-- On PREDICATE reduce production const_defn -> cast EQUAL seq_expr
-- On META reduce production const_defn -> cast EQUAL seq_expr
-- On LET reduce production const_defn -> cast EQUAL seq_expr
-- On LEMMA reduce production const_defn -> cast EQUAL seq_expr
-- On INDUCTIVE reduce production const_defn -> cast EQUAL seq_expr
-- On IMPORT reduce production const_defn -> cast EQUAL seq_expr
-- On GOAL reduce production const_defn -> cast EQUAL seq_expr
-- On FUNCTION reduce production const_defn -> cast EQUAL seq_expr
-- On EXCEPTION reduce production const_defn -> cast EQUAL seq_expr
-- On EOF reduce production const_defn -> cast EQUAL seq_expr
-- On END reduce production const_defn -> cast EQUAL seq_expr
-- On CONSTANT reduce production const_defn -> cast EQUAL seq_expr
-- On COINDUCTIVE reduce production const_defn -> cast EQUAL seq_expr
-- On CLONE reduce production const_defn -> cast EQUAL seq_expr
-- On AXIOM reduce production const_defn -> cast EQUAL seq_expr

State 1054:
## Known stack suffix:
## LEMMA
## LR(1) items:
pure_decl -> LEMMA . attrs(ident_nq) COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 648
-- On CORE_LIDENT shift to state 66
-- On uident_nq shift to state 1055
-- On lident_op_nq shift to state 1056
-- On lident_nq shift to state 1057
-- On lident_keyword shift to state 75
-- On ident_nq shift to state 1058
-- On attrs(ident_nq) shift to state 1060
## Reductions:

State 1055:
## Known stack suffix:
## uident_nq
## LR(1) items:
ident_nq -> uident_nq . [ POSITION COLON ATTRIBUTE ]
## Transitions:
## Reductions:
-- On POSITION reduce production ident_nq -> uident_nq
-- On COLON reduce production ident_nq -> uident_nq
-- On ATTRIBUTE reduce production ident_nq -> uident_nq

State 1056:
## Known stack suffix:
## lident_op_nq
## LR(1) items:
ident_nq -> lident_op_nq . [ POSITION COLON ATTRIBUTE ]
## Transitions:
## Reductions:
-- On POSITION reduce production ident_nq -> lident_op_nq
-- On COLON reduce production ident_nq -> lident_op_nq
-- On ATTRIBUTE reduce production ident_nq -> lident_op_nq

State 1057:
## Known stack suffix:
## lident_nq
## LR(1) items:
ident_nq -> lident_nq . [ POSITION COLON ATTRIBUTE ]
## Transitions:
## Reductions:
-- On POSITION reduce production ident_nq -> lident_nq
-- On COLON reduce production ident_nq -> lident_nq
-- On ATTRIBUTE reduce production ident_nq -> lident_nq

State 1058:
## Known stack suffix:
## ident_nq
## LR(1) items:
attrs(ident_nq) -> ident_nq . list(attr) [ COLON ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 1059
-- On attr shift to state 71
## Reductions:
-- On COLON reduce production list(attr) ->

State 1059:
## Known stack suffix:
## ident_nq list(attr)
## LR(1) items:
attrs(ident_nq) -> ident_nq list(attr) . [ COLON ]
## Transitions:
## Reductions:
-- On COLON reduce production attrs(ident_nq) -> ident_nq list(attr)

State 1060:
## Known stack suffix:
## LEMMA attrs(ident_nq)
## LR(1) items:
pure_decl -> LEMMA attrs(ident_nq) . COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 1061
## Reductions:

State 1061:
## Known stack suffix:
## LEMMA attrs(ident_nq) COLON
## LR(1) items:
pure_decl -> LEMMA attrs(ident_nq) COLON . term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 1062
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 1062:
## Known stack suffix:
## LEMMA attrs(ident_nq) COLON term
## LR(1) items:
pure_decl -> LEMMA attrs(ident_nq) COLON term . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On USE reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On TYPE reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On SCOPE reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On PREDICATE reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On META reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On LET reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On LEMMA reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On INDUCTIVE reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On IMPORT reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On GOAL reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On FUNCTION reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On EXCEPTION reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On EOF reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On END reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On CONSTANT reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On COINDUCTIVE reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On CLONE reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term
-- On AXIOM reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term

State 1063:
## Known stack suffix:
## INDUCTIVE
## LR(1) items:
pure_decl -> INDUCTIVE . with_list1(inductive_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On with_list1(inductive_decl) shift to state 1064
-- On separated_nonempty_list(WITH,inductive_decl) shift to state 1065
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On inductive_decl shift to state 1066
-- On attrs(lident_rich) shift to state 1069
## Reductions:

State 1064:
## Known stack suffix:
## INDUCTIVE with_list1(inductive_decl)
## LR(1) items:
pure_decl -> INDUCTIVE with_list1(inductive_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On USE reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On TYPE reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On SCOPE reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On PREDICATE reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On META reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On LET reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On LEMMA reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On INDUCTIVE reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On IMPORT reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On GOAL reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On FUNCTION reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On EXCEPTION reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On EOF reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On END reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On CONSTANT reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On COINDUCTIVE reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On CLONE reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)
-- On AXIOM reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)

State 1065:
## Known stack suffix:
## separated_nonempty_list(WITH,inductive_decl)
## LR(1) items:
with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On USE reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On TYPE reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On SCOPE reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On PREDICATE reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On META reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On LET reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On LEMMA reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On INDUCTIVE reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On IMPORT reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On GOAL reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On FUNCTION reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On EXCEPTION reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On EOF reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On END reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On CONSTANT reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On COINDUCTIVE reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On CLONE reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)
-- On AXIOM reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)

State 1066:
## Known stack suffix:
## inductive_decl
## LR(1) items:
separated_nonempty_list(WITH,inductive_decl) -> inductive_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(WITH,inductive_decl) -> inductive_decl . WITH separated_nonempty_list(WITH,inductive_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 1067
## Reductions:
-- On VAL reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On USE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On TYPE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On SCOPE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On PREDICATE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On META reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On LET reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On LEMMA reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On INDUCTIVE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On IMPORT reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On GOAL reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On FUNCTION reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On EXCEPTION reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On EOF reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On END reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On CONSTANT reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On COINDUCTIVE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On CLONE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl
-- On AXIOM reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl

State 1067:
## Known stack suffix:
## inductive_decl WITH
## LR(1) items:
separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH . separated_nonempty_list(WITH,inductive_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On separated_nonempty_list(WITH,inductive_decl) shift to state 1068
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On inductive_decl shift to state 1066
-- On attrs(lident_rich) shift to state 1069
## Reductions:

State 1068:
## Known stack suffix:
## inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
## LR(1) items:
separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On USE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On TYPE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On SCOPE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On PREDICATE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On META reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On LET reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On LEMMA reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On INDUCTIVE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On IMPORT reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On GOAL reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On FUNCTION reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On EXCEPTION reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On EOF reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On END reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On CONSTANT reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On COINDUCTIVE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On CLONE reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
-- On AXIOM reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)

State 1069:
## Known stack suffix:
## attrs(lident_rich)
## LR(1) items:
inductive_decl -> attrs(lident_rich) . params ind_defn [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 1070
-- On param shift to state 569
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WITH reduce production list(param) ->
-- On VAL reduce production list(param) ->
-- On USE reduce production list(param) ->
-- On TYPE reduce production list(param) ->
-- On SCOPE reduce production list(param) ->
-- On PREDICATE reduce production list(param) ->
-- On META reduce production list(param) ->
-- On LET reduce production list(param) ->
-- On LEMMA reduce production list(param) ->
-- On INDUCTIVE reduce production list(param) ->
-- On IMPORT reduce production list(param) ->
-- On GOAL reduce production list(param) ->
-- On FUNCTION reduce production list(param) ->
-- On EXCEPTION reduce production list(param) ->
-- On EQUAL reduce production list(param) ->
-- On EOF reduce production list(param) ->
-- On END reduce production list(param) ->
-- On CONSTANT reduce production list(param) ->
-- On COINDUCTIVE reduce production list(param) ->
-- On CLONE reduce production list(param) ->
-- On AXIOM reduce production list(param) ->

State 1070:
## Known stack suffix:
## attrs(lident_rich) params
## LR(1) items:
inductive_decl -> attrs(lident_rich) params . ind_defn [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1071
-- On ind_defn shift to state 1082
## Reductions:
-- On WITH reduce production ind_defn ->
-- On VAL reduce production ind_defn ->
-- On USE reduce production ind_defn ->
-- On TYPE reduce production ind_defn ->
-- On SCOPE reduce production ind_defn ->
-- On PREDICATE reduce production ind_defn ->
-- On META reduce production ind_defn ->
-- On LET reduce production ind_defn ->
-- On LEMMA reduce production ind_defn ->
-- On INDUCTIVE reduce production ind_defn ->
-- On IMPORT reduce production ind_defn ->
-- On GOAL reduce production ind_defn ->
-- On FUNCTION reduce production ind_defn ->
-- On EXCEPTION reduce production ind_defn ->
-- On EOF reduce production ind_defn ->
-- On END reduce production ind_defn ->
-- On CONSTANT reduce production ind_defn ->
-- On COINDUCTIVE reduce production ind_defn ->
-- On CLONE reduce production ind_defn ->
-- On AXIOM reduce production ind_defn ->

State 1071:
## Known stack suffix:
## EQUAL
## LR(1) items:
ind_defn -> EQUAL . bar_list1(ind_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 648
-- On CORE_LIDENT shift to state 66
-- On BAR shift to state 1072
-- On uident_nq shift to state 1055
-- On separated_nonempty_list(BAR,ind_case) shift to state 1080
-- On lident_op_nq shift to state 1056
-- On lident_nq shift to state 1057
-- On lident_keyword shift to state 75
-- On ind_case shift to state 1074
-- On ident_nq shift to state 1058
-- On bar_list1(ind_case) shift to state 1081
-- On attrs(ident_nq) shift to state 1077
## Reductions:

State 1072:
## Known stack suffix:
## BAR
## LR(1) items:
bar_list1(ind_case) -> BAR . separated_nonempty_list(BAR,ind_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 648
-- On CORE_LIDENT shift to state 66
-- On uident_nq shift to state 1055
-- On separated_nonempty_list(BAR,ind_case) shift to state 1073
-- On lident_op_nq shift to state 1056
-- On lident_nq shift to state 1057
-- On lident_keyword shift to state 75
-- On ind_case shift to state 1074
-- On ident_nq shift to state 1058
-- On attrs(ident_nq) shift to state 1077
## Reductions:

State 1073:
## Known stack suffix:
## BAR separated_nonempty_list(BAR,ind_case)
## LR(1) items:
bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On VAL reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On USE reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On TYPE reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On SCOPE reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On PREDICATE reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On META reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On LET reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On LEMMA reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On INDUCTIVE reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On IMPORT reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On GOAL reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On FUNCTION reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On EXCEPTION reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On EOF reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On END reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On CONSTANT reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On COINDUCTIVE reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On CLONE reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)
-- On AXIOM reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)

State 1074:
## Known stack suffix:
## ind_case
## LR(1) items:
separated_nonempty_list(BAR,ind_case) -> ind_case . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(BAR,ind_case) -> ind_case . BAR separated_nonempty_list(BAR,ind_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On BAR shift to state 1075
## Reductions:
-- On WITH reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On VAL reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On USE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On TYPE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On SCOPE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On PREDICATE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On META reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On LET reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On LEMMA reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On INDUCTIVE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On IMPORT reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On GOAL reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On FUNCTION reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On EXCEPTION reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On EOF reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On END reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On CONSTANT reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On COINDUCTIVE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On CLONE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case
-- On AXIOM reduce production separated_nonempty_list(BAR,ind_case) -> ind_case

State 1075:
## Known stack suffix:
## ind_case BAR
## LR(1) items:
separated_nonempty_list(BAR,ind_case) -> ind_case BAR . separated_nonempty_list(BAR,ind_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 648
-- On CORE_LIDENT shift to state 66
-- On uident_nq shift to state 1055
-- On separated_nonempty_list(BAR,ind_case) shift to state 1076
-- On lident_op_nq shift to state 1056
-- On lident_nq shift to state 1057
-- On lident_keyword shift to state 75
-- On ind_case shift to state 1074
-- On ident_nq shift to state 1058
-- On attrs(ident_nq) shift to state 1077
## Reductions:

State 1076:
## Known stack suffix:
## ind_case BAR separated_nonempty_list(BAR,ind_case)
## LR(1) items:
separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On VAL reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On USE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On TYPE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On SCOPE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On PREDICATE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On META reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On LET reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On LEMMA reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On INDUCTIVE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On IMPORT reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On GOAL reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On FUNCTION reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On EXCEPTION reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On EOF reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On END reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On CONSTANT reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On COINDUCTIVE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On CLONE reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)
-- On AXIOM reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)

State 1077:
## Known stack suffix:
## attrs(ident_nq)
## LR(1) items:
ind_case -> attrs(ident_nq) . COLON term [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
## Transitions:
-- On COLON shift to state 1078
## Reductions:

State 1078:
## Known stack suffix:
## attrs(ident_nq) COLON
## LR(1) items:
ind_case -> attrs(ident_nq) COLON . term [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 1079
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 1079:
## Known stack suffix:
## attrs(ident_nq) COLON term
## LR(1) items:
ind_case -> attrs(ident_nq) COLON term . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production ind_case -> attrs(ident_nq) COLON term
-- On VAL reduce production ind_case -> attrs(ident_nq) COLON term
-- On USE reduce production ind_case -> attrs(ident_nq) COLON term
-- On TYPE reduce production ind_case -> attrs(ident_nq) COLON term
-- On SCOPE reduce production ind_case -> attrs(ident_nq) COLON term
-- On PREDICATE reduce production ind_case -> attrs(ident_nq) COLON term
-- On META reduce production ind_case -> attrs(ident_nq) COLON term
-- On LET reduce production ind_case -> attrs(ident_nq) COLON term
-- On LEMMA reduce production ind_case -> attrs(ident_nq) COLON term
-- On INDUCTIVE reduce production ind_case -> attrs(ident_nq) COLON term
-- On IMPORT reduce production ind_case -> attrs(ident_nq) COLON term
-- On GOAL reduce production ind_case -> attrs(ident_nq) COLON term
-- On FUNCTION reduce production ind_case -> attrs(ident_nq) COLON term
-- On EXCEPTION reduce production ind_case -> attrs(ident_nq) COLON term
-- On EOF reduce production ind_case -> attrs(ident_nq) COLON term
-- On END reduce production ind_case -> attrs(ident_nq) COLON term
-- On CONSTANT reduce production ind_case -> attrs(ident_nq) COLON term
-- On COINDUCTIVE reduce production ind_case -> attrs(ident_nq) COLON term
-- On CLONE reduce production ind_case -> attrs(ident_nq) COLON term
-- On BAR reduce production ind_case -> attrs(ident_nq) COLON term
-- On AXIOM reduce production ind_case -> attrs(ident_nq) COLON term

State 1080:
## Known stack suffix:
## separated_nonempty_list(BAR,ind_case)
## LR(1) items:
bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On VAL reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On USE reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On TYPE reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On SCOPE reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On PREDICATE reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On META reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On LET reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On LEMMA reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On INDUCTIVE reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On IMPORT reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On GOAL reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On FUNCTION reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On EXCEPTION reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On EOF reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On END reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On CONSTANT reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On COINDUCTIVE reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On CLONE reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)
-- On AXIOM reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)

State 1081:
## Known stack suffix:
## EQUAL bar_list1(ind_case)
## LR(1) items:
ind_defn -> EQUAL bar_list1(ind_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On VAL reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On USE reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On TYPE reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On SCOPE reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On PREDICATE reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On META reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On LET reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On LEMMA reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On INDUCTIVE reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On IMPORT reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On GOAL reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On FUNCTION reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On EXCEPTION reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On EOF reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On END reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On CONSTANT reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On COINDUCTIVE reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On CLONE reduce production ind_defn -> EQUAL bar_list1(ind_case)
-- On AXIOM reduce production ind_defn -> EQUAL bar_list1(ind_case)

State 1082:
## Known stack suffix:
## attrs(lident_rich) params ind_defn
## LR(1) items:
inductive_decl -> attrs(lident_rich) params ind_defn . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On VAL reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On USE reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On TYPE reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On SCOPE reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On PREDICATE reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On META reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On LET reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On LEMMA reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On INDUCTIVE reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On IMPORT reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On GOAL reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On FUNCTION reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On EXCEPTION reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On EOF reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On END reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On CONSTANT reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On COINDUCTIVE reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On CLONE reduce production inductive_decl -> attrs(lident_rich) params ind_defn
-- On AXIOM reduce production inductive_decl -> attrs(lident_rich) params ind_defn

State 1083:
## Known stack suffix:
## IMPORT
## LR(1) items:
module_decl -> IMPORT . uqualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 1084
-- On uident shift to state 89
## Reductions:

State 1084:
## Known stack suffix:
## IMPORT uqualid
## LR(1) items:
module_decl -> IMPORT uqualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
uqualid -> uqualid . DOT uident [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END DOT CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On DOT shift to state 526
## Reductions:
-- On VAL reduce production module_decl -> IMPORT uqualid
-- On USE reduce production module_decl -> IMPORT uqualid
-- On TYPE reduce production module_decl -> IMPORT uqualid
-- On SCOPE reduce production module_decl -> IMPORT uqualid
-- On PREDICATE reduce production module_decl -> IMPORT uqualid
-- On META reduce production module_decl -> IMPORT uqualid
-- On LET reduce production module_decl -> IMPORT uqualid
-- On LEMMA reduce production module_decl -> IMPORT uqualid
-- On INDUCTIVE reduce production module_decl -> IMPORT uqualid
-- On IMPORT reduce production module_decl -> IMPORT uqualid
-- On GOAL reduce production module_decl -> IMPORT uqualid
-- On FUNCTION reduce production module_decl -> IMPORT uqualid
-- On EXCEPTION reduce production module_decl -> IMPORT uqualid
-- On EOF reduce production module_decl -> IMPORT uqualid
-- On END reduce production module_decl -> IMPORT uqualid
-- On CONSTANT reduce production module_decl -> IMPORT uqualid
-- On COINDUCTIVE reduce production module_decl -> IMPORT uqualid
-- On CLONE reduce production module_decl -> IMPORT uqualid
-- On AXIOM reduce production module_decl -> IMPORT uqualid

State 1085:
## Known stack suffix:
## GOAL
## LR(1) items:
pure_decl -> GOAL . attrs(ident_nq) COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 648
-- On CORE_LIDENT shift to state 66
-- On uident_nq shift to state 1055
-- On lident_op_nq shift to state 1056
-- On lident_nq shift to state 1057
-- On lident_keyword shift to state 75
-- On ident_nq shift to state 1058
-- On attrs(ident_nq) shift to state 1086
## Reductions:

State 1086:
## Known stack suffix:
## GOAL attrs(ident_nq)
## LR(1) items:
pure_decl -> GOAL attrs(ident_nq) . COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 1087
## Reductions:

State 1087:
## Known stack suffix:
## GOAL attrs(ident_nq) COLON
## LR(1) items:
pure_decl -> GOAL attrs(ident_nq) COLON . term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 1088
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 1088:
## Known stack suffix:
## GOAL attrs(ident_nq) COLON term
## LR(1) items:
pure_decl -> GOAL attrs(ident_nq) COLON term . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On USE reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On TYPE reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On SCOPE reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On PREDICATE reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On META reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On LET reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On LEMMA reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On INDUCTIVE reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On IMPORT reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On GOAL reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On FUNCTION reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On EXCEPTION reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On EOF reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On END reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On CONSTANT reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On COINDUCTIVE reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On CLONE reduce production pure_decl -> GOAL attrs(ident_nq) COLON term
-- On AXIOM reduce production pure_decl -> GOAL attrs(ident_nq) COLON term

State 1089:
## Known stack suffix:
## FUNCTION
## LR(1) items:
pure_decl -> FUNCTION . function_decl list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On function_decl shift to state 1090
-- On attrs(lident_rich) shift to state 1092
## Reductions:

State 1090:
## Known stack suffix:
## FUNCTION function_decl
## LR(1) items:
pure_decl -> FUNCTION function_decl . list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 1002
-- On with_logic_decl shift to state 1009
-- On list(with_logic_decl) shift to state 1091
## Reductions:
-- On VAL reduce production list(with_logic_decl) ->
-- On USE reduce production list(with_logic_decl) ->
-- On TYPE reduce production list(with_logic_decl) ->
-- On SCOPE reduce production list(with_logic_decl) ->
-- On PREDICATE reduce production list(with_logic_decl) ->
-- On META reduce production list(with_logic_decl) ->
-- On LET reduce production list(with_logic_decl) ->
-- On LEMMA reduce production list(with_logic_decl) ->
-- On INDUCTIVE reduce production list(with_logic_decl) ->
-- On IMPORT reduce production list(with_logic_decl) ->
-- On GOAL reduce production list(with_logic_decl) ->
-- On FUNCTION reduce production list(with_logic_decl) ->
-- On EXCEPTION reduce production list(with_logic_decl) ->
-- On EOF reduce production list(with_logic_decl) ->
-- On END reduce production list(with_logic_decl) ->
-- On CONSTANT reduce production list(with_logic_decl) ->
-- On COINDUCTIVE reduce production list(with_logic_decl) ->
-- On CLONE reduce production list(with_logic_decl) ->
-- On AXIOM reduce production list(with_logic_decl) ->

State 1091:
## Known stack suffix:
## FUNCTION function_decl list(with_logic_decl)
## LR(1) items:
pure_decl -> FUNCTION function_decl list(with_logic_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On USE reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On TYPE reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On SCOPE reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On PREDICATE reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On META reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On LET reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On LEMMA reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On INDUCTIVE reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On IMPORT reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On GOAL reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On FUNCTION reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On EXCEPTION reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On EOF reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On END reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On CONSTANT reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On COINDUCTIVE reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On CLONE reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)
-- On AXIOM reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)

State 1092:
## Known stack suffix:
## attrs(lident_rich)
## LR(1) items:
function_decl -> attrs(lident_rich) . params cast option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 1093
-- On param shift to state 569
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On COLON reduce production list(param) ->

State 1093:
## Known stack suffix:
## attrs(lident_rich) params
## LR(1) items:
function_decl -> attrs(lident_rich) params . cast option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 1094
## Reductions:

State 1094:
## Known stack suffix:
## attrs(lident_rich) params cast
## LR(1) items:
function_decl -> attrs(lident_rich) params cast . option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1006
-- On option(preceded(EQUAL,term)) shift to state 1095
## Reductions:
-- On WITH reduce production option(preceded(EQUAL,term)) ->
-- On VAL reduce production option(preceded(EQUAL,term)) ->
-- On USE reduce production option(preceded(EQUAL,term)) ->
-- On TYPE reduce production option(preceded(EQUAL,term)) ->
-- On SCOPE reduce production option(preceded(EQUAL,term)) ->
-- On PREDICATE reduce production option(preceded(EQUAL,term)) ->
-- On META reduce production option(preceded(EQUAL,term)) ->
-- On LET reduce production option(preceded(EQUAL,term)) ->
-- On LEMMA reduce production option(preceded(EQUAL,term)) ->
-- On INDUCTIVE reduce production option(preceded(EQUAL,term)) ->
-- On IMPORT reduce production option(preceded(EQUAL,term)) ->
-- On GOAL reduce production option(preceded(EQUAL,term)) ->
-- On FUNCTION reduce production option(preceded(EQUAL,term)) ->
-- On EXCEPTION reduce production option(preceded(EQUAL,term)) ->
-- On EOF reduce production option(preceded(EQUAL,term)) ->
-- On END reduce production option(preceded(EQUAL,term)) ->
-- On CONSTANT reduce production option(preceded(EQUAL,term)) ->
-- On COINDUCTIVE reduce production option(preceded(EQUAL,term)) ->
-- On CLONE reduce production option(preceded(EQUAL,term)) ->
-- On AXIOM reduce production option(preceded(EQUAL,term)) ->

State 1095:
## Known stack suffix:
## attrs(lident_rich) params cast option(preceded(EQUAL,term))
## LR(1) items:
function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term)) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On VAL reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On USE reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On TYPE reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On SCOPE reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On PREDICATE reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On META reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On LET reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On LEMMA reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On INDUCTIVE reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On IMPORT reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On GOAL reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On FUNCTION reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On EXCEPTION reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On EOF reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On END reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On CONSTANT reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On COINDUCTIVE reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On CLONE reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))
-- On AXIOM reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))

State 1096:
## Known stack suffix:
## EXCEPTION
## LR(1) items:
prog_decl -> EXCEPTION . attrs(uident_nq) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> EXCEPTION . attrs(uident_nq) return [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On CORE_UIDENT shift to state 648
-- On uident_nq shift to state 649
-- On attrs(uident_nq) shift to state 1097
## Reductions:

State 1097:
## Known stack suffix:
## EXCEPTION attrs(uident_nq)
## LR(1) items:
prog_decl -> EXCEPTION attrs(uident_nq) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> EXCEPTION attrs(uident_nq) . return [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 723
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 191
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 193
-- On return shift to state 1098
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:
-- On VAL reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On USE reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On TYPE reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On SCOPE reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On PREDICATE reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On META reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On LET reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On LEMMA reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On INDUCTIVE reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On IMPORT reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On GOAL reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On FUNCTION reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On EXCEPTION reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On EOF reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On END reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On CONSTANT reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On COINDUCTIVE reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On CLONE reduce production prog_decl -> EXCEPTION attrs(uident_nq)
-- On AXIOM reduce production prog_decl -> EXCEPTION attrs(uident_nq)

State 1098:
## Known stack suffix:
## EXCEPTION attrs(uident_nq) return
## LR(1) items:
prog_decl -> EXCEPTION attrs(uident_nq) return . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On USE reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On TYPE reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On SCOPE reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On PREDICATE reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On META reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On LET reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On LEMMA reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On INDUCTIVE reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On IMPORT reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On GOAL reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On FUNCTION reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On EXCEPTION reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On EOF reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On END reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On CONSTANT reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On COINDUCTIVE reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On CLONE reduce production prog_decl -> EXCEPTION attrs(uident_nq) return
-- On AXIOM reduce production prog_decl -> EXCEPTION attrs(uident_nq) return

State 1099:
## Known stack suffix:
## CONSTANT
## LR(1) items:
pure_decl -> CONSTANT . constant_decl [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On constant_decl shift to state 1100
-- On attrs(lident_rich) shift to state 1101
## Reductions:

State 1100:
## Known stack suffix:
## CONSTANT constant_decl
## LR(1) items:
pure_decl -> CONSTANT constant_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production pure_decl -> CONSTANT constant_decl
-- On USE reduce production pure_decl -> CONSTANT constant_decl
-- On TYPE reduce production pure_decl -> CONSTANT constant_decl
-- On SCOPE reduce production pure_decl -> CONSTANT constant_decl
-- On PREDICATE reduce production pure_decl -> CONSTANT constant_decl
-- On META reduce production pure_decl -> CONSTANT constant_decl
-- On LET reduce production pure_decl -> CONSTANT constant_decl
-- On LEMMA reduce production pure_decl -> CONSTANT constant_decl
-- On INDUCTIVE reduce production pure_decl -> CONSTANT constant_decl
-- On IMPORT reduce production pure_decl -> CONSTANT constant_decl
-- On GOAL reduce production pure_decl -> CONSTANT constant_decl
-- On FUNCTION reduce production pure_decl -> CONSTANT constant_decl
-- On EXCEPTION reduce production pure_decl -> CONSTANT constant_decl
-- On EOF reduce production pure_decl -> CONSTANT constant_decl
-- On END reduce production pure_decl -> CONSTANT constant_decl
-- On CONSTANT reduce production pure_decl -> CONSTANT constant_decl
-- On COINDUCTIVE reduce production pure_decl -> CONSTANT constant_decl
-- On CLONE reduce production pure_decl -> CONSTANT constant_decl
-- On AXIOM reduce production pure_decl -> CONSTANT constant_decl

State 1101:
## Known stack suffix:
## attrs(lident_rich)
## LR(1) items:
constant_decl -> attrs(lident_rich) . cast option(preceded(EQUAL,term)) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 1102
## Reductions:

State 1102:
## Known stack suffix:
## attrs(lident_rich) cast
## LR(1) items:
constant_decl -> attrs(lident_rich) cast . option(preceded(EQUAL,term)) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1006
-- On option(preceded(EQUAL,term)) shift to state 1103
## Reductions:
-- On VAL reduce production option(preceded(EQUAL,term)) ->
-- On USE reduce production option(preceded(EQUAL,term)) ->
-- On TYPE reduce production option(preceded(EQUAL,term)) ->
-- On SCOPE reduce production option(preceded(EQUAL,term)) ->
-- On PREDICATE reduce production option(preceded(EQUAL,term)) ->
-- On META reduce production option(preceded(EQUAL,term)) ->
-- On LET reduce production option(preceded(EQUAL,term)) ->
-- On LEMMA reduce production option(preceded(EQUAL,term)) ->
-- On INDUCTIVE reduce production option(preceded(EQUAL,term)) ->
-- On IMPORT reduce production option(preceded(EQUAL,term)) ->
-- On GOAL reduce production option(preceded(EQUAL,term)) ->
-- On FUNCTION reduce production option(preceded(EQUAL,term)) ->
-- On EXCEPTION reduce production option(preceded(EQUAL,term)) ->
-- On EOF reduce production option(preceded(EQUAL,term)) ->
-- On END reduce production option(preceded(EQUAL,term)) ->
-- On CONSTANT reduce production option(preceded(EQUAL,term)) ->
-- On COINDUCTIVE reduce production option(preceded(EQUAL,term)) ->
-- On CLONE reduce production option(preceded(EQUAL,term)) ->
-- On AXIOM reduce production option(preceded(EQUAL,term)) ->

State 1103:
## Known stack suffix:
## attrs(lident_rich) cast option(preceded(EQUAL,term))
## LR(1) items:
constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term)) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On USE reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On TYPE reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On SCOPE reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On PREDICATE reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On META reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On LET reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On LEMMA reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On INDUCTIVE reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On IMPORT reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On GOAL reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On FUNCTION reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On EXCEPTION reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On EOF reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On END reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On CONSTANT reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On COINDUCTIVE reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On CLONE reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))
-- On AXIOM reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))

State 1104:
## Known stack suffix:
## COINDUCTIVE
## LR(1) items:
pure_decl -> COINDUCTIVE . with_list1(inductive_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On with_list1(inductive_decl) shift to state 1105
-- On separated_nonempty_list(WITH,inductive_decl) shift to state 1065
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On inductive_decl shift to state 1066
-- On attrs(lident_rich) shift to state 1069
## Reductions:

State 1105:
## Known stack suffix:
## COINDUCTIVE with_list1(inductive_decl)
## LR(1) items:
pure_decl -> COINDUCTIVE with_list1(inductive_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On USE reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On TYPE reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On SCOPE reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On PREDICATE reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On META reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On LET reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On LEMMA reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On INDUCTIVE reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On IMPORT reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On GOAL reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On FUNCTION reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On EXCEPTION reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On EOF reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On END reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On CONSTANT reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On COINDUCTIVE reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On CLONE reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)
-- On AXIOM reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)

State 1106:
## Known stack suffix:
## CLONE
## LR(1) items:
use_clone -> CLONE . EXPORT tqualid clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
use_clone -> CLONE . boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On IMPORT shift to state 577
-- On EXPORT shift to state 1107
-- On boption(IMPORT) shift to state 1150
## Reductions:
-- On UIDENT reduce production boption(IMPORT) ->
-- On STRING reduce production boption(IMPORT) ->
-- On RANGE reduce production boption(IMPORT) ->
-- On LIDENT reduce production boption(IMPORT) ->
-- On FLOAT reduce production boption(IMPORT) ->
-- On CORE_UIDENT reduce production boption(IMPORT) ->
-- On CORE_LIDENT reduce production boption(IMPORT) ->

State 1107:
## Known stack suffix:
## CLONE EXPORT
## LR(1) items:
use_clone -> CLONE EXPORT . tqualid clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 580
-- On tqualid shift to state 1108
-- On squalid shift to state 582
-- On sident shift to state 587
-- On lident_keyword shift to state 43
-- On lident shift to state 586
## Reductions:

State 1108:
## Known stack suffix:
## CLONE EXPORT tqualid
## LR(1) items:
use_clone -> CLONE EXPORT tqualid . clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 1109
-- On clone_subst shift to state 1149
## Reductions:
-- On VAL reduce production clone_subst ->
-- On USE reduce production clone_subst ->
-- On TYPE reduce production clone_subst ->
-- On SCOPE reduce production clone_subst ->
-- On PREDICATE reduce production clone_subst ->
-- On META reduce production clone_subst ->
-- On LET reduce production clone_subst ->
-- On LEMMA reduce production clone_subst ->
-- On INDUCTIVE reduce production clone_subst ->
-- On IMPORT reduce production clone_subst ->
-- On GOAL reduce production clone_subst ->
-- On FUNCTION reduce production clone_subst ->
-- On EXCEPTION reduce production clone_subst ->
-- On EOF reduce production clone_subst ->
-- On END reduce production clone_subst ->
-- On CONSTANT reduce production clone_subst ->
-- On COINDUCTIVE reduce production clone_subst ->
-- On CLONE reduce production clone_subst ->
-- On AXIOM reduce production clone_subst ->

State 1109:
## Known stack suffix:
## WITH
## LR(1) items:
clone_subst -> WITH . comma_list1(single_clone_subst) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On VAL shift to state 1110
-- On TYPE shift to state 1114
-- On PREDICATE shift to state 1119
-- On LEMMA shift to state 1123
-- On GOAL shift to state 1126
-- On FUNCTION shift to state 1129
-- On EXCEPTION shift to state 1133
-- On CONSTANT shift to state 1137
-- On AXIOM shift to state 1141
-- On single_clone_subst shift to state 1144
-- On separated_nonempty_list(COMMA,single_clone_subst) shift to state 1147
-- On comma_list1(single_clone_subst) shift to state 1148
## Reductions:

State 1110:
## Known stack suffix:
## VAL
## LR(1) items:
single_clone_subst -> VAL . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> VAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1111
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1111:
## Known stack suffix:
## VAL qualid
## LR(1) items:
single_clone_subst -> VAL qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> VAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1112
## Reductions:
-- On VAL reduce production single_clone_subst -> VAL qualid
-- On USE reduce production single_clone_subst -> VAL qualid
-- On TYPE reduce production single_clone_subst -> VAL qualid
-- On SCOPE reduce production single_clone_subst -> VAL qualid
-- On PREDICATE reduce production single_clone_subst -> VAL qualid
-- On META reduce production single_clone_subst -> VAL qualid
-- On LET reduce production single_clone_subst -> VAL qualid
-- On LEMMA reduce production single_clone_subst -> VAL qualid
-- On INDUCTIVE reduce production single_clone_subst -> VAL qualid
-- On IMPORT reduce production single_clone_subst -> VAL qualid
-- On GOAL reduce production single_clone_subst -> VAL qualid
-- On FUNCTION reduce production single_clone_subst -> VAL qualid
-- On EXCEPTION reduce production single_clone_subst -> VAL qualid
-- On EOF reduce production single_clone_subst -> VAL qualid
-- On END reduce production single_clone_subst -> VAL qualid
-- On CONSTANT reduce production single_clone_subst -> VAL qualid
-- On COMMA reduce production single_clone_subst -> VAL qualid
-- On COINDUCTIVE reduce production single_clone_subst -> VAL qualid
-- On CLONE reduce production single_clone_subst -> VAL qualid
-- On AXIOM reduce production single_clone_subst -> VAL qualid

State 1112:
## Known stack suffix:
## VAL qualid EQUAL
## LR(1) items:
single_clone_subst -> VAL qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1113
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1113:
## Known stack suffix:
## VAL qualid EQUAL qualid
## LR(1) items:
single_clone_subst -> VAL qualid EQUAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On USE reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On TYPE reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On SCOPE reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On PREDICATE reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On META reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On LET reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On LEMMA reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On INDUCTIVE reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On IMPORT reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On GOAL reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On FUNCTION reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On EXCEPTION reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On EOF reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On END reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On CONSTANT reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On COMMA reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On COINDUCTIVE reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On CLONE reduce production single_clone_subst -> VAL qualid EQUAL qualid
-- On AXIOM reduce production single_clone_subst -> VAL qualid EQUAL qualid

State 1114:
## Known stack suffix:
## TYPE
## LR(1) items:
single_clone_subst -> TYPE . qualid list(ty_var) EQUAL ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> TYPE . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1115
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1115:
## Known stack suffix:
## TYPE qualid
## LR(1) items:
single_clone_subst -> TYPE qualid . list(ty_var) EQUAL ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> TYPE qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On QUOTE_LIDENT shift to state 78
-- On ty_var shift to state 604
-- On quote_lident shift to state 605
-- On list(ty_var) shift to state 1116
-- On attrs(quote_lident) shift to state 608
## Reductions:
-- On VAL reduce production single_clone_subst -> TYPE qualid
-- On USE reduce production single_clone_subst -> TYPE qualid
-- On TYPE reduce production single_clone_subst -> TYPE qualid
-- On SCOPE reduce production single_clone_subst -> TYPE qualid
-- On PREDICATE reduce production single_clone_subst -> TYPE qualid
-- On META reduce production single_clone_subst -> TYPE qualid
-- On LET reduce production single_clone_subst -> TYPE qualid
-- On LEMMA reduce production single_clone_subst -> TYPE qualid
-- On INDUCTIVE reduce production single_clone_subst -> TYPE qualid
-- On IMPORT reduce production single_clone_subst -> TYPE qualid
-- On GOAL reduce production single_clone_subst -> TYPE qualid
-- On FUNCTION reduce production single_clone_subst -> TYPE qualid
-- On EXCEPTION reduce production single_clone_subst -> TYPE qualid
-- On EQUAL reduce production list(ty_var) ->
-- On EOF reduce production single_clone_subst -> TYPE qualid
-- On END reduce production single_clone_subst -> TYPE qualid
-- On CONSTANT reduce production single_clone_subst -> TYPE qualid
-- On COMMA reduce production single_clone_subst -> TYPE qualid
-- On COINDUCTIVE reduce production single_clone_subst -> TYPE qualid
-- On CLONE reduce production single_clone_subst -> TYPE qualid
-- On AXIOM reduce production single_clone_subst -> TYPE qualid

State 1116:
## Known stack suffix:
## TYPE qualid list(ty_var)
## LR(1) items:
single_clone_subst -> TYPE qualid list(ty_var) . EQUAL ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1117
## Reductions:

State 1117:
## Known stack suffix:
## TYPE qualid list(ty_var) EQUAL
## LR(1) items:
single_clone_subst -> TYPE qualid list(ty_var) EQUAL . ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 1118
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 1118:
## Known stack suffix:
## TYPE qualid list(ty_var) EQUAL ty
## LR(1) items:
single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
ty -> ty . ARROW ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ARROW ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On VAL reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On USE reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On TYPE reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On SCOPE reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On PREDICATE reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On META reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On LET reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On LEMMA reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On INDUCTIVE reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On IMPORT reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On GOAL reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On FUNCTION reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On EXCEPTION reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On EOF reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On END reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On CONSTANT reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On COMMA reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On COINDUCTIVE reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On CLONE reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty
-- On AXIOM reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty

State 1119:
## Known stack suffix:
## PREDICATE
## LR(1) items:
single_clone_subst -> PREDICATE . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> PREDICATE . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1120
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1120:
## Known stack suffix:
## PREDICATE qualid
## LR(1) items:
single_clone_subst -> PREDICATE qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> PREDICATE qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1121
## Reductions:
-- On VAL reduce production single_clone_subst -> PREDICATE qualid
-- On USE reduce production single_clone_subst -> PREDICATE qualid
-- On TYPE reduce production single_clone_subst -> PREDICATE qualid
-- On SCOPE reduce production single_clone_subst -> PREDICATE qualid
-- On PREDICATE reduce production single_clone_subst -> PREDICATE qualid
-- On META reduce production single_clone_subst -> PREDICATE qualid
-- On LET reduce production single_clone_subst -> PREDICATE qualid
-- On LEMMA reduce production single_clone_subst -> PREDICATE qualid
-- On INDUCTIVE reduce production single_clone_subst -> PREDICATE qualid
-- On IMPORT reduce production single_clone_subst -> PREDICATE qualid
-- On GOAL reduce production single_clone_subst -> PREDICATE qualid
-- On FUNCTION reduce production single_clone_subst -> PREDICATE qualid
-- On EXCEPTION reduce production single_clone_subst -> PREDICATE qualid
-- On EOF reduce production single_clone_subst -> PREDICATE qualid
-- On END reduce production single_clone_subst -> PREDICATE qualid
-- On CONSTANT reduce production single_clone_subst -> PREDICATE qualid
-- On COMMA reduce production single_clone_subst -> PREDICATE qualid
-- On COINDUCTIVE reduce production single_clone_subst -> PREDICATE qualid
-- On CLONE reduce production single_clone_subst -> PREDICATE qualid
-- On AXIOM reduce production single_clone_subst -> PREDICATE qualid

State 1121:
## Known stack suffix:
## PREDICATE qualid EQUAL
## LR(1) items:
single_clone_subst -> PREDICATE qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1122
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1122:
## Known stack suffix:
## PREDICATE qualid EQUAL qualid
## LR(1) items:
single_clone_subst -> PREDICATE qualid EQUAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On USE reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On TYPE reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On SCOPE reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On PREDICATE reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On META reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On LET reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On LEMMA reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On INDUCTIVE reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On IMPORT reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On GOAL reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On FUNCTION reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On EXCEPTION reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On EOF reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On END reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On CONSTANT reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On COMMA reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On COINDUCTIVE reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On CLONE reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid
-- On AXIOM reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid

State 1123:
## Known stack suffix:
## LEMMA
## LR(1) items:
single_clone_subst -> LEMMA . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> LEMMA . DOT [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On DOT shift to state 1124
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1125
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1124:
## Known stack suffix:
## LEMMA DOT
## LR(1) items:
single_clone_subst -> LEMMA DOT . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production single_clone_subst -> LEMMA DOT
-- On USE reduce production single_clone_subst -> LEMMA DOT
-- On TYPE reduce production single_clone_subst -> LEMMA DOT
-- On SCOPE reduce production single_clone_subst -> LEMMA DOT
-- On PREDICATE reduce production single_clone_subst -> LEMMA DOT
-- On META reduce production single_clone_subst -> LEMMA DOT
-- On LET reduce production single_clone_subst -> LEMMA DOT
-- On LEMMA reduce production single_clone_subst -> LEMMA DOT
-- On INDUCTIVE reduce production single_clone_subst -> LEMMA DOT
-- On IMPORT reduce production single_clone_subst -> LEMMA DOT
-- On GOAL reduce production single_clone_subst -> LEMMA DOT
-- On FUNCTION reduce production single_clone_subst -> LEMMA DOT
-- On EXCEPTION reduce production single_clone_subst -> LEMMA DOT
-- On EOF reduce production single_clone_subst -> LEMMA DOT
-- On END reduce production single_clone_subst -> LEMMA DOT
-- On CONSTANT reduce production single_clone_subst -> LEMMA DOT
-- On COMMA reduce production single_clone_subst -> LEMMA DOT
-- On COINDUCTIVE reduce production single_clone_subst -> LEMMA DOT
-- On CLONE reduce production single_clone_subst -> LEMMA DOT
-- On AXIOM reduce production single_clone_subst -> LEMMA DOT

State 1125:
## Known stack suffix:
## LEMMA qualid
## LR(1) items:
single_clone_subst -> LEMMA qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production single_clone_subst -> LEMMA qualid
-- On USE reduce production single_clone_subst -> LEMMA qualid
-- On TYPE reduce production single_clone_subst -> LEMMA qualid
-- On SCOPE reduce production single_clone_subst -> LEMMA qualid
-- On PREDICATE reduce production single_clone_subst -> LEMMA qualid
-- On META reduce production single_clone_subst -> LEMMA qualid
-- On LET reduce production single_clone_subst -> LEMMA qualid
-- On LEMMA reduce production single_clone_subst -> LEMMA qualid
-- On INDUCTIVE reduce production single_clone_subst -> LEMMA qualid
-- On IMPORT reduce production single_clone_subst -> LEMMA qualid
-- On GOAL reduce production single_clone_subst -> LEMMA qualid
-- On FUNCTION reduce production single_clone_subst -> LEMMA qualid
-- On EXCEPTION reduce production single_clone_subst -> LEMMA qualid
-- On EOF reduce production single_clone_subst -> LEMMA qualid
-- On END reduce production single_clone_subst -> LEMMA qualid
-- On CONSTANT reduce production single_clone_subst -> LEMMA qualid
-- On COMMA reduce production single_clone_subst -> LEMMA qualid
-- On COINDUCTIVE reduce production single_clone_subst -> LEMMA qualid
-- On CLONE reduce production single_clone_subst -> LEMMA qualid
-- On AXIOM reduce production single_clone_subst -> LEMMA qualid

State 1126:
## Known stack suffix:
## GOAL
## LR(1) items:
single_clone_subst -> GOAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> GOAL . DOT [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On DOT shift to state 1127
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1128
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1127:
## Known stack suffix:
## GOAL DOT
## LR(1) items:
single_clone_subst -> GOAL DOT . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production single_clone_subst -> GOAL DOT
-- On USE reduce production single_clone_subst -> GOAL DOT
-- On TYPE reduce production single_clone_subst -> GOAL DOT
-- On SCOPE reduce production single_clone_subst -> GOAL DOT
-- On PREDICATE reduce production single_clone_subst -> GOAL DOT
-- On META reduce production single_clone_subst -> GOAL DOT
-- On LET reduce production single_clone_subst -> GOAL DOT
-- On LEMMA reduce production single_clone_subst -> GOAL DOT
-- On INDUCTIVE reduce production single_clone_subst -> GOAL DOT
-- On IMPORT reduce production single_clone_subst -> GOAL DOT
-- On GOAL reduce production single_clone_subst -> GOAL DOT
-- On FUNCTION reduce production single_clone_subst -> GOAL DOT
-- On EXCEPTION reduce production single_clone_subst -> GOAL DOT
-- On EOF reduce production single_clone_subst -> GOAL DOT
-- On END reduce production single_clone_subst -> GOAL DOT
-- On CONSTANT reduce production single_clone_subst -> GOAL DOT
-- On COMMA reduce production single_clone_subst -> GOAL DOT
-- On COINDUCTIVE reduce production single_clone_subst -> GOAL DOT
-- On CLONE reduce production single_clone_subst -> GOAL DOT
-- On AXIOM reduce production single_clone_subst -> GOAL DOT

State 1128:
## Known stack suffix:
## GOAL qualid
## LR(1) items:
single_clone_subst -> GOAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production single_clone_subst -> GOAL qualid
-- On USE reduce production single_clone_subst -> GOAL qualid
-- On TYPE reduce production single_clone_subst -> GOAL qualid
-- On SCOPE reduce production single_clone_subst -> GOAL qualid
-- On PREDICATE reduce production single_clone_subst -> GOAL qualid
-- On META reduce production single_clone_subst -> GOAL qualid
-- On LET reduce production single_clone_subst -> GOAL qualid
-- On LEMMA reduce production single_clone_subst -> GOAL qualid
-- On INDUCTIVE reduce production single_clone_subst -> GOAL qualid
-- On IMPORT reduce production single_clone_subst -> GOAL qualid
-- On GOAL reduce production single_clone_subst -> GOAL qualid
-- On FUNCTION reduce production single_clone_subst -> GOAL qualid
-- On EXCEPTION reduce production single_clone_subst -> GOAL qualid
-- On EOF reduce production single_clone_subst -> GOAL qualid
-- On END reduce production single_clone_subst -> GOAL qualid
-- On CONSTANT reduce production single_clone_subst -> GOAL qualid
-- On COMMA reduce production single_clone_subst -> GOAL qualid
-- On COINDUCTIVE reduce production single_clone_subst -> GOAL qualid
-- On CLONE reduce production single_clone_subst -> GOAL qualid
-- On AXIOM reduce production single_clone_subst -> GOAL qualid

State 1129:
## Known stack suffix:
## FUNCTION
## LR(1) items:
single_clone_subst -> FUNCTION . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> FUNCTION . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1130
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1130:
## Known stack suffix:
## FUNCTION qualid
## LR(1) items:
single_clone_subst -> FUNCTION qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> FUNCTION qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1131
## Reductions:
-- On VAL reduce production single_clone_subst -> FUNCTION qualid
-- On USE reduce production single_clone_subst -> FUNCTION qualid
-- On TYPE reduce production single_clone_subst -> FUNCTION qualid
-- On SCOPE reduce production single_clone_subst -> FUNCTION qualid
-- On PREDICATE reduce production single_clone_subst -> FUNCTION qualid
-- On META reduce production single_clone_subst -> FUNCTION qualid
-- On LET reduce production single_clone_subst -> FUNCTION qualid
-- On LEMMA reduce production single_clone_subst -> FUNCTION qualid
-- On INDUCTIVE reduce production single_clone_subst -> FUNCTION qualid
-- On IMPORT reduce production single_clone_subst -> FUNCTION qualid
-- On GOAL reduce production single_clone_subst -> FUNCTION qualid
-- On FUNCTION reduce production single_clone_subst -> FUNCTION qualid
-- On EXCEPTION reduce production single_clone_subst -> FUNCTION qualid
-- On EOF reduce production single_clone_subst -> FUNCTION qualid
-- On END reduce production single_clone_subst -> FUNCTION qualid
-- On CONSTANT reduce production single_clone_subst -> FUNCTION qualid
-- On COMMA reduce production single_clone_subst -> FUNCTION qualid
-- On COINDUCTIVE reduce production single_clone_subst -> FUNCTION qualid
-- On CLONE reduce production single_clone_subst -> FUNCTION qualid
-- On AXIOM reduce production single_clone_subst -> FUNCTION qualid

State 1131:
## Known stack suffix:
## FUNCTION qualid EQUAL
## LR(1) items:
single_clone_subst -> FUNCTION qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1132
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1132:
## Known stack suffix:
## FUNCTION qualid EQUAL qualid
## LR(1) items:
single_clone_subst -> FUNCTION qualid EQUAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On USE reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On TYPE reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On SCOPE reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On PREDICATE reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On META reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On LET reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On LEMMA reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On INDUCTIVE reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On IMPORT reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On GOAL reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On FUNCTION reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On EXCEPTION reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On EOF reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On END reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On CONSTANT reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On COMMA reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On COINDUCTIVE reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On CLONE reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid
-- On AXIOM reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid

State 1133:
## Known stack suffix:
## EXCEPTION
## LR(1) items:
single_clone_subst -> EXCEPTION . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> EXCEPTION . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1134
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1134:
## Known stack suffix:
## EXCEPTION qualid
## LR(1) items:
single_clone_subst -> EXCEPTION qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> EXCEPTION qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1135
## Reductions:
-- On VAL reduce production single_clone_subst -> EXCEPTION qualid
-- On USE reduce production single_clone_subst -> EXCEPTION qualid
-- On TYPE reduce production single_clone_subst -> EXCEPTION qualid
-- On SCOPE reduce production single_clone_subst -> EXCEPTION qualid
-- On PREDICATE reduce production single_clone_subst -> EXCEPTION qualid
-- On META reduce production single_clone_subst -> EXCEPTION qualid
-- On LET reduce production single_clone_subst -> EXCEPTION qualid
-- On LEMMA reduce production single_clone_subst -> EXCEPTION qualid
-- On INDUCTIVE reduce production single_clone_subst -> EXCEPTION qualid
-- On IMPORT reduce production single_clone_subst -> EXCEPTION qualid
-- On GOAL reduce production single_clone_subst -> EXCEPTION qualid
-- On FUNCTION reduce production single_clone_subst -> EXCEPTION qualid
-- On EXCEPTION reduce production single_clone_subst -> EXCEPTION qualid
-- On EOF reduce production single_clone_subst -> EXCEPTION qualid
-- On END reduce production single_clone_subst -> EXCEPTION qualid
-- On CONSTANT reduce production single_clone_subst -> EXCEPTION qualid
-- On COMMA reduce production single_clone_subst -> EXCEPTION qualid
-- On COINDUCTIVE reduce production single_clone_subst -> EXCEPTION qualid
-- On CLONE reduce production single_clone_subst -> EXCEPTION qualid
-- On AXIOM reduce production single_clone_subst -> EXCEPTION qualid

State 1135:
## Known stack suffix:
## EXCEPTION qualid EQUAL
## LR(1) items:
single_clone_subst -> EXCEPTION qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1136
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1136:
## Known stack suffix:
## EXCEPTION qualid EQUAL qualid
## LR(1) items:
single_clone_subst -> EXCEPTION qualid EQUAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On USE reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On TYPE reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On SCOPE reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On PREDICATE reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On META reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On LET reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On LEMMA reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On INDUCTIVE reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On IMPORT reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On GOAL reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On FUNCTION reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On EXCEPTION reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On EOF reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On END reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On CONSTANT reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On COMMA reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On COINDUCTIVE reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On CLONE reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid
-- On AXIOM reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid

State 1137:
## Known stack suffix:
## CONSTANT
## LR(1) items:
single_clone_subst -> CONSTANT . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> CONSTANT . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1138
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1138:
## Known stack suffix:
## CONSTANT qualid
## LR(1) items:
single_clone_subst -> CONSTANT qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> CONSTANT qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1139
## Reductions:
-- On VAL reduce production single_clone_subst -> CONSTANT qualid
-- On USE reduce production single_clone_subst -> CONSTANT qualid
-- On TYPE reduce production single_clone_subst -> CONSTANT qualid
-- On SCOPE reduce production single_clone_subst -> CONSTANT qualid
-- On PREDICATE reduce production single_clone_subst -> CONSTANT qualid
-- On META reduce production single_clone_subst -> CONSTANT qualid
-- On LET reduce production single_clone_subst -> CONSTANT qualid
-- On LEMMA reduce production single_clone_subst -> CONSTANT qualid
-- On INDUCTIVE reduce production single_clone_subst -> CONSTANT qualid
-- On IMPORT reduce production single_clone_subst -> CONSTANT qualid
-- On GOAL reduce production single_clone_subst -> CONSTANT qualid
-- On FUNCTION reduce production single_clone_subst -> CONSTANT qualid
-- On EXCEPTION reduce production single_clone_subst -> CONSTANT qualid
-- On EOF reduce production single_clone_subst -> CONSTANT qualid
-- On END reduce production single_clone_subst -> CONSTANT qualid
-- On CONSTANT reduce production single_clone_subst -> CONSTANT qualid
-- On COMMA reduce production single_clone_subst -> CONSTANT qualid
-- On COINDUCTIVE reduce production single_clone_subst -> CONSTANT qualid
-- On CLONE reduce production single_clone_subst -> CONSTANT qualid
-- On AXIOM reduce production single_clone_subst -> CONSTANT qualid

State 1139:
## Known stack suffix:
## CONSTANT qualid EQUAL
## LR(1) items:
single_clone_subst -> CONSTANT qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1140
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1140:
## Known stack suffix:
## CONSTANT qualid EQUAL qualid
## LR(1) items:
single_clone_subst -> CONSTANT qualid EQUAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On USE reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On TYPE reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On SCOPE reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On PREDICATE reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On META reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On LET reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On LEMMA reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On INDUCTIVE reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On IMPORT reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On GOAL reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On FUNCTION reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On EXCEPTION reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On EOF reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On END reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On CONSTANT reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On COMMA reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On COINDUCTIVE reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On CLONE reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid
-- On AXIOM reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid

State 1141:
## Known stack suffix:
## AXIOM
## LR(1) items:
single_clone_subst -> AXIOM . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> AXIOM . DOT [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On DOT shift to state 1142
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1143
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1142:
## Known stack suffix:
## AXIOM DOT
## LR(1) items:
single_clone_subst -> AXIOM DOT . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production single_clone_subst -> AXIOM DOT
-- On USE reduce production single_clone_subst -> AXIOM DOT
-- On TYPE reduce production single_clone_subst -> AXIOM DOT
-- On SCOPE reduce production single_clone_subst -> AXIOM DOT
-- On PREDICATE reduce production single_clone_subst -> AXIOM DOT
-- On META reduce production single_clone_subst -> AXIOM DOT
-- On LET reduce production single_clone_subst -> AXIOM DOT
-- On LEMMA reduce production single_clone_subst -> AXIOM DOT
-- On INDUCTIVE reduce production single_clone_subst -> AXIOM DOT
-- On IMPORT reduce production single_clone_subst -> AXIOM DOT
-- On GOAL reduce production single_clone_subst -> AXIOM DOT
-- On FUNCTION reduce production single_clone_subst -> AXIOM DOT
-- On EXCEPTION reduce production single_clone_subst -> AXIOM DOT
-- On EOF reduce production single_clone_subst -> AXIOM DOT
-- On END reduce production single_clone_subst -> AXIOM DOT
-- On CONSTANT reduce production single_clone_subst -> AXIOM DOT
-- On COMMA reduce production single_clone_subst -> AXIOM DOT
-- On COINDUCTIVE reduce production single_clone_subst -> AXIOM DOT
-- On CLONE reduce production single_clone_subst -> AXIOM DOT
-- On AXIOM reduce production single_clone_subst -> AXIOM DOT

State 1143:
## Known stack suffix:
## AXIOM qualid
## LR(1) items:
single_clone_subst -> AXIOM qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production single_clone_subst -> AXIOM qualid
-- On USE reduce production single_clone_subst -> AXIOM qualid
-- On TYPE reduce production single_clone_subst -> AXIOM qualid
-- On SCOPE reduce production single_clone_subst -> AXIOM qualid
-- On PREDICATE reduce production single_clone_subst -> AXIOM qualid
-- On META reduce production single_clone_subst -> AXIOM qualid
-- On LET reduce production single_clone_subst -> AXIOM qualid
-- On LEMMA reduce production single_clone_subst -> AXIOM qualid
-- On INDUCTIVE reduce production single_clone_subst -> AXIOM qualid
-- On IMPORT reduce production single_clone_subst -> AXIOM qualid
-- On GOAL reduce production single_clone_subst -> AXIOM qualid
-- On FUNCTION reduce production single_clone_subst -> AXIOM qualid
-- On EXCEPTION reduce production single_clone_subst -> AXIOM qualid
-- On EOF reduce production single_clone_subst -> AXIOM qualid
-- On END reduce production single_clone_subst -> AXIOM qualid
-- On CONSTANT reduce production single_clone_subst -> AXIOM qualid
-- On COMMA reduce production single_clone_subst -> AXIOM qualid
-- On COINDUCTIVE reduce production single_clone_subst -> AXIOM qualid
-- On CLONE reduce production single_clone_subst -> AXIOM qualid
-- On AXIOM reduce production single_clone_subst -> AXIOM qualid

State 1144:
## Known stack suffix:
## single_clone_subst
## LR(1) items:
separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst . COMMA separated_nonempty_list(COMMA,single_clone_subst) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COMMA shift to state 1145
## Reductions:
-- On VAL reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On USE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On TYPE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On SCOPE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On PREDICATE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On META reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On LET reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On LEMMA reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On INDUCTIVE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On IMPORT reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On GOAL reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On FUNCTION reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On EXCEPTION reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On EOF reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On END reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On CONSTANT reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On COINDUCTIVE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On CLONE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst
-- On AXIOM reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst

State 1145:
## Known stack suffix:
## single_clone_subst COMMA
## LR(1) items:
separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA . separated_nonempty_list(COMMA,single_clone_subst) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On VAL shift to state 1110
-- On TYPE shift to state 1114
-- On PREDICATE shift to state 1119
-- On LEMMA shift to state 1123
-- On GOAL shift to state 1126
-- On FUNCTION shift to state 1129
-- On EXCEPTION shift to state 1133
-- On CONSTANT shift to state 1137
-- On AXIOM shift to state 1141
-- On single_clone_subst shift to state 1144
-- On separated_nonempty_list(COMMA,single_clone_subst) shift to state 1146
## Reductions:

State 1146:
## Known stack suffix:
## single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
## LR(1) items:
separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On USE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On TYPE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On SCOPE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On PREDICATE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On META reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On LET reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On LEMMA reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On INDUCTIVE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On IMPORT reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On GOAL reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On FUNCTION reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On EXCEPTION reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On EOF reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On END reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On CONSTANT reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On COINDUCTIVE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On CLONE reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
-- On AXIOM reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)

State 1147:
## Known stack suffix:
## separated_nonempty_list(COMMA,single_clone_subst)
## LR(1) items:
comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On USE reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On TYPE reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On SCOPE reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On PREDICATE reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On META reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On LET reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On LEMMA reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On INDUCTIVE reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On IMPORT reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On GOAL reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On FUNCTION reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On EXCEPTION reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On EOF reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On END reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On CONSTANT reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On COINDUCTIVE reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On CLONE reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)
-- On AXIOM reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)

State 1148:
## Known stack suffix:
## WITH comma_list1(single_clone_subst)
## LR(1) items:
clone_subst -> WITH comma_list1(single_clone_subst) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On USE reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On TYPE reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On SCOPE reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On PREDICATE reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On META reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On LET reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On LEMMA reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On INDUCTIVE reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On IMPORT reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On GOAL reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On FUNCTION reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On EXCEPTION reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On EOF reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On END reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On CONSTANT reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On COINDUCTIVE reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On CLONE reduce production clone_subst -> WITH comma_list1(single_clone_subst)
-- On AXIOM reduce production clone_subst -> WITH comma_list1(single_clone_subst)

State 1149:
## Known stack suffix:
## CLONE EXPORT tqualid clone_subst
## LR(1) items:
use_clone -> CLONE EXPORT tqualid clone_subst . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On USE reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On TYPE reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On SCOPE reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On PREDICATE reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On META reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On LET reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On LEMMA reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On INDUCTIVE reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On IMPORT reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On GOAL reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On FUNCTION reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On EXCEPTION reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On EOF reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On END reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On CONSTANT reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On COINDUCTIVE reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On CLONE reduce production use_clone -> CLONE EXPORT tqualid clone_subst
-- On AXIOM reduce production use_clone -> CLONE EXPORT tqualid clone_subst

State 1150:
## Known stack suffix:
## CLONE boption(IMPORT)
## LR(1) items:
use_clone -> CLONE boption(IMPORT) . tqualid option(preceded(AS,uident)) clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 580
-- On tqualid shift to state 1151
-- On squalid shift to state 582
-- On sident shift to state 587
-- On lident_keyword shift to state 43
-- On lident shift to state 586
## Reductions:

State 1151:
## Known stack suffix:
## CLONE boption(IMPORT) tqualid
## LR(1) items:
use_clone -> CLONE boption(IMPORT) tqualid . option(preceded(AS,uident)) clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On AS shift to state 592
-- On option(preceded(AS,uident)) shift to state 1152
## Reductions:
-- On WITH reduce production option(preceded(AS,uident)) ->
-- On VAL reduce production option(preceded(AS,uident)) ->
-- On USE reduce production option(preceded(AS,uident)) ->
-- On TYPE reduce production option(preceded(AS,uident)) ->
-- On SCOPE reduce production option(preceded(AS,uident)) ->
-- On PREDICATE reduce production option(preceded(AS,uident)) ->
-- On META reduce production option(preceded(AS,uident)) ->
-- On LET reduce production option(preceded(AS,uident)) ->
-- On LEMMA reduce production option(preceded(AS,uident)) ->
-- On INDUCTIVE reduce production option(preceded(AS,uident)) ->
-- On IMPORT reduce production option(preceded(AS,uident)) ->
-- On GOAL reduce production option(preceded(AS,uident)) ->
-- On FUNCTION reduce production option(preceded(AS,uident)) ->
-- On EXCEPTION reduce production option(preceded(AS,uident)) ->
-- On EOF reduce production option(preceded(AS,uident)) ->
-- On END reduce production option(preceded(AS,uident)) ->
-- On CONSTANT reduce production option(preceded(AS,uident)) ->
-- On COINDUCTIVE reduce production option(preceded(AS,uident)) ->
-- On CLONE reduce production option(preceded(AS,uident)) ->
-- On AXIOM reduce production option(preceded(AS,uident)) ->

State 1152:
## Known stack suffix:
## CLONE boption(IMPORT) tqualid option(preceded(AS,uident))
## LR(1) items:
use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) . clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 1109
-- On clone_subst shift to state 1153
## Reductions:
-- On VAL reduce production clone_subst ->
-- On USE reduce production clone_subst ->
-- On TYPE reduce production clone_subst ->
-- On SCOPE reduce production clone_subst ->
-- On PREDICATE reduce production clone_subst ->
-- On META reduce production clone_subst ->
-- On LET reduce production clone_subst ->
-- On LEMMA reduce production clone_subst ->
-- On INDUCTIVE reduce production clone_subst ->
-- On IMPORT reduce production clone_subst ->
-- On GOAL reduce production clone_subst ->
-- On FUNCTION reduce production clone_subst ->
-- On EXCEPTION reduce production clone_subst ->
-- On EOF reduce production clone_subst ->
-- On END reduce production clone_subst ->
-- On CONSTANT reduce production clone_subst ->
-- On COINDUCTIVE reduce production clone_subst ->
-- On CLONE reduce production clone_subst ->
-- On AXIOM reduce production clone_subst ->

State 1153:
## Known stack suffix:
## CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
## LR(1) items:
use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On USE reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On TYPE reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On SCOPE reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On PREDICATE reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On META reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On LET reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On LEMMA reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On INDUCTIVE reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On IMPORT reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On GOAL reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On FUNCTION reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On EXCEPTION reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On EOF reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On END reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On CONSTANT reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On COINDUCTIVE reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On CLONE reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
-- On AXIOM reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst

State 1154:
## Known stack suffix:
## AXIOM
## LR(1) items:
pure_decl -> AXIOM . attrs(ident_nq) COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 648
-- On CORE_LIDENT shift to state 66
-- On uident_nq shift to state 1055
-- On lident_op_nq shift to state 1056
-- On lident_nq shift to state 1057
-- On lident_keyword shift to state 75
-- On ident_nq shift to state 1058
-- On attrs(ident_nq) shift to state 1155
## Reductions:

State 1155:
## Known stack suffix:
## AXIOM attrs(ident_nq)
## LR(1) items:
pure_decl -> AXIOM attrs(ident_nq) . COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 1156
## Reductions:

State 1156:
## Known stack suffix:
## AXIOM attrs(ident_nq) COLON
## LR(1) items:
pure_decl -> AXIOM attrs(ident_nq) COLON . term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 1157
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 1157:
## Known stack suffix:
## AXIOM attrs(ident_nq) COLON term
## LR(1) items:
pure_decl -> AXIOM attrs(ident_nq) COLON term . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On USE reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On TYPE reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On SCOPE reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On PREDICATE reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On META reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On LET reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On LEMMA reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On INDUCTIVE reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On IMPORT reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On GOAL reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On FUNCTION reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On EXCEPTION reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On EOF reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On END reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On CONSTANT reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On COINDUCTIVE reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On CLONE reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term
-- On AXIOM reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term

State 1158:
## Known stack suffix:
## use_clone
## LR(1) items:
module_decl -> use_clone . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production module_decl -> use_clone
-- On USE reduce production module_decl -> use_clone
-- On TYPE reduce production module_decl -> use_clone
-- On SCOPE reduce production module_decl -> use_clone
-- On PREDICATE reduce production module_decl -> use_clone
-- On META reduce production module_decl -> use_clone
-- On LET reduce production module_decl -> use_clone
-- On LEMMA reduce production module_decl -> use_clone
-- On INDUCTIVE reduce production module_decl -> use_clone
-- On IMPORT reduce production module_decl -> use_clone
-- On GOAL reduce production module_decl -> use_clone
-- On FUNCTION reduce production module_decl -> use_clone
-- On EXCEPTION reduce production module_decl -> use_clone
-- On EOF reduce production module_decl -> use_clone
-- On END reduce production module_decl -> use_clone
-- On CONSTANT reduce production module_decl -> use_clone
-- On COINDUCTIVE reduce production module_decl -> use_clone
-- On CLONE reduce production module_decl -> use_clone
-- On AXIOM reduce production module_decl -> use_clone

State 1159:
## Known stack suffix:
## scope_head
## LR(1) items:
module_decl -> scope_head . list(module_decl) END [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On VAL shift to state 52
-- On USE shift to state 576
-- On TYPE shift to state 598
-- On SCOPE shift to state 997
-- On PREDICATE shift to state 1000
-- On META shift to state 1017
-- On LET shift to state 1041
-- On LEMMA shift to state 1054
-- On INDUCTIVE shift to state 1063
-- On IMPORT shift to state 1083
-- On GOAL shift to state 1085
-- On FUNCTION shift to state 1089
-- On EXCEPTION shift to state 1096
-- On CONSTANT shift to state 1099
-- On COINDUCTIVE shift to state 1104
-- On CLONE shift to state 1106
-- On AXIOM shift to state 1154
-- On use_clone shift to state 1158
-- On scope_head shift to state 1159
-- On pure_decl shift to state 1160
-- On prog_decl shift to state 1161
-- On module_decl shift to state 1162
-- On meta_decl shift to state 1163
-- On list(module_decl) shift to state 1165
## Reductions:
-- On END reduce production list(module_decl) ->

State 1160:
## Known stack suffix:
## pure_decl
## LR(1) items:
module_decl -> pure_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production module_decl -> pure_decl
-- On USE reduce production module_decl -> pure_decl
-- On TYPE reduce production module_decl -> pure_decl
-- On SCOPE reduce production module_decl -> pure_decl
-- On PREDICATE reduce production module_decl -> pure_decl
-- On META reduce production module_decl -> pure_decl
-- On LET reduce production module_decl -> pure_decl
-- On LEMMA reduce production module_decl -> pure_decl
-- On INDUCTIVE reduce production module_decl -> pure_decl
-- On IMPORT reduce production module_decl -> pure_decl
-- On GOAL reduce production module_decl -> pure_decl
-- On FUNCTION reduce production module_decl -> pure_decl
-- On EXCEPTION reduce production module_decl -> pure_decl
-- On EOF reduce production module_decl -> pure_decl
-- On END reduce production module_decl -> pure_decl
-- On CONSTANT reduce production module_decl -> pure_decl
-- On COINDUCTIVE reduce production module_decl -> pure_decl
-- On CLONE reduce production module_decl -> pure_decl
-- On AXIOM reduce production module_decl -> pure_decl

State 1161:
## Known stack suffix:
## prog_decl
## LR(1) items:
module_decl -> prog_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production module_decl -> prog_decl
-- On USE reduce production module_decl -> prog_decl
-- On TYPE reduce production module_decl -> prog_decl
-- On SCOPE reduce production module_decl -> prog_decl
-- On PREDICATE reduce production module_decl -> prog_decl
-- On META reduce production module_decl -> prog_decl
-- On LET reduce production module_decl -> prog_decl
-- On LEMMA reduce production module_decl -> prog_decl
-- On INDUCTIVE reduce production module_decl -> prog_decl
-- On IMPORT reduce production module_decl -> prog_decl
-- On GOAL reduce production module_decl -> prog_decl
-- On FUNCTION reduce production module_decl -> prog_decl
-- On EXCEPTION reduce production module_decl -> prog_decl
-- On EOF reduce production module_decl -> prog_decl
-- On END reduce production module_decl -> prog_decl
-- On CONSTANT reduce production module_decl -> prog_decl
-- On COINDUCTIVE reduce production module_decl -> prog_decl
-- On CLONE reduce production module_decl -> prog_decl
-- On AXIOM reduce production module_decl -> prog_decl

State 1162:
## Known stack suffix:
## module_decl
## LR(1) items:
list(module_decl) -> module_decl . list(module_decl) [ END ]
## Transitions:
-- On VAL shift to state 52
-- On USE shift to state 576
-- On TYPE shift to state 598
-- On SCOPE shift to state 997
-- On PREDICATE shift to state 1000
-- On META shift to state 1017
-- On LET shift to state 1041
-- On LEMMA shift to state 1054
-- On INDUCTIVE shift to state 1063
-- On IMPORT shift to state 1083
-- On GOAL shift to state 1085
-- On FUNCTION shift to state 1089
-- On EXCEPTION shift to state 1096
-- On CONSTANT shift to state 1099
-- On COINDUCTIVE shift to state 1104
-- On CLONE shift to state 1106
-- On AXIOM shift to state 1154
-- On use_clone shift to state 1158
-- On scope_head shift to state 1159
-- On pure_decl shift to state 1160
-- On prog_decl shift to state 1161
-- On module_decl shift to state 1162
-- On meta_decl shift to state 1163
-- On list(module_decl) shift to state 1164
## Reductions:
-- On END reduce production list(module_decl) ->

State 1163:
## Known stack suffix:
## meta_decl
## LR(1) items:
module_decl -> meta_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production module_decl -> meta_decl
-- On USE reduce production module_decl -> meta_decl
-- On TYPE reduce production module_decl -> meta_decl
-- On SCOPE reduce production module_decl -> meta_decl
-- On PREDICATE reduce production module_decl -> meta_decl
-- On META reduce production module_decl -> meta_decl
-- On LET reduce production module_decl -> meta_decl
-- On LEMMA reduce production module_decl -> meta_decl
-- On INDUCTIVE reduce production module_decl -> meta_decl
-- On IMPORT reduce production module_decl -> meta_decl
-- On GOAL reduce production module_decl -> meta_decl
-- On FUNCTION reduce production module_decl -> meta_decl
-- On EXCEPTION reduce production module_decl -> meta_decl
-- On EOF reduce production module_decl -> meta_decl
-- On END reduce production module_decl -> meta_decl
-- On CONSTANT reduce production module_decl -> meta_decl
-- On COINDUCTIVE reduce production module_decl -> meta_decl
-- On CLONE reduce production module_decl -> meta_decl
-- On AXIOM reduce production module_decl -> meta_decl

State 1164:
## Known stack suffix:
## module_decl list(module_decl)
## LR(1) items:
list(module_decl) -> module_decl list(module_decl) . [ END ]
## Transitions:
## Reductions:
-- On END reduce production list(module_decl) -> module_decl list(module_decl)

State 1165:
## Known stack suffix:
## scope_head list(module_decl)
## LR(1) items:
module_decl -> scope_head list(module_decl) . END [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On END shift to state 1166
## Reductions:

State 1166:
## Known stack suffix:
## scope_head list(module_decl) END
## LR(1) items:
module_decl -> scope_head list(module_decl) END . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL reduce production module_decl -> scope_head list(module_decl) END
-- On USE reduce production module_decl -> scope_head list(module_decl) END
-- On TYPE reduce production module_decl -> scope_head list(module_decl) END
-- On SCOPE reduce production module_decl -> scope_head list(module_decl) END
-- On PREDICATE reduce production module_decl -> scope_head list(module_decl) END
-- On META reduce production module_decl -> scope_head list(module_decl) END
-- On LET reduce production module_decl -> scope_head list(module_decl) END
-- On LEMMA reduce production module_decl -> scope_head list(module_decl) END
-- On INDUCTIVE reduce production module_decl -> scope_head list(module_decl) END
-- On IMPORT reduce production module_decl -> scope_head list(module_decl) END
-- On GOAL reduce production module_decl -> scope_head list(module_decl) END
-- On FUNCTION reduce production module_decl -> scope_head list(module_decl) END
-- On EXCEPTION reduce production module_decl -> scope_head list(module_decl) END
-- On EOF reduce production module_decl -> scope_head list(module_decl) END
-- On END reduce production module_decl -> scope_head list(module_decl) END
-- On CONSTANT reduce production module_decl -> scope_head list(module_decl) END
-- On COINDUCTIVE reduce production module_decl -> scope_head list(module_decl) END
-- On CLONE reduce production module_decl -> scope_head list(module_decl) END
-- On AXIOM reduce production module_decl -> scope_head list(module_decl) END

State 1167:
## Known stack suffix:
## nonempty_list(module_decl)
## LR(1) items:
mlw_file -> nonempty_list(module_decl) . EOF [ # ]
## Transitions:
-- On EOF shift to state 1168
## Reductions:

State 1168:
## Known stack suffix:
## nonempty_list(module_decl) EOF
## LR(1) items:
mlw_file -> nonempty_list(module_decl) EOF . [ # ]
## Transitions:
## Reductions:
-- On # reduce production mlw_file -> nonempty_list(module_decl) EOF

State 1169:
## Known stack suffix:
## module_head
## LR(1) items:
mlw_module -> module_head . list(module_decl) END [ THEORY MODULE EOF ]
## Transitions:
-- On VAL shift to state 52
-- On USE shift to state 576
-- On TYPE shift to state 598
-- On SCOPE shift to state 997
-- On PREDICATE shift to state 1000
-- On META shift to state 1017
-- On LET shift to state 1041
-- On LEMMA shift to state 1054
-- On INDUCTIVE shift to state 1063
-- On IMPORT shift to state 1083
-- On GOAL shift to state 1085
-- On FUNCTION shift to state 1089
-- On EXCEPTION shift to state 1096
-- On CONSTANT shift to state 1099
-- On COINDUCTIVE shift to state 1104
-- On CLONE shift to state 1106
-- On AXIOM shift to state 1154
-- On use_clone shift to state 1158
-- On scope_head shift to state 1159
-- On pure_decl shift to state 1160
-- On prog_decl shift to state 1161
-- On module_decl shift to state 1162
-- On meta_decl shift to state 1163
-- On list(module_decl) shift to state 1170
## Reductions:
-- On END reduce production list(module_decl) ->

State 1170:
## Known stack suffix:
## module_head list(module_decl)
## LR(1) items:
mlw_module -> module_head list(module_decl) . END [ THEORY MODULE EOF ]
## Transitions:
-- On END shift to state 1171
## Reductions:

State 1171:
## Known stack suffix:
## module_head list(module_decl) END
## LR(1) items:
mlw_module -> module_head list(module_decl) END . [ THEORY MODULE EOF ]
## Transitions:
## Reductions:
-- On THEORY reduce production mlw_module -> module_head list(module_decl) END
-- On MODULE reduce production mlw_module -> module_head list(module_decl) END
-- On EOF reduce production mlw_module -> module_head list(module_decl) END

State 1172:
## Known stack suffix:
## module_decl
## LR(1) items:
nonempty_list(module_decl) -> module_decl . [ EOF ]
nonempty_list(module_decl) -> module_decl . nonempty_list(module_decl) [ EOF ]
## Transitions:
-- On VAL shift to state 52
-- On USE shift to state 576
-- On TYPE shift to state 598
-- On SCOPE shift to state 997
-- On PREDICATE shift to state 1000
-- On META shift to state 1017
-- On LET shift to state 1041
-- On LEMMA shift to state 1054
-- On INDUCTIVE shift to state 1063
-- On IMPORT shift to state 1083
-- On GOAL shift to state 1085
-- On FUNCTION shift to state 1089
-- On EXCEPTION shift to state 1096
-- On CONSTANT shift to state 1099
-- On COINDUCTIVE shift to state 1104
-- On CLONE shift to state 1106
-- On AXIOM shift to state 1154
-- On use_clone shift to state 1158
-- On scope_head shift to state 1159
-- On pure_decl shift to state 1160
-- On prog_decl shift to state 1161
-- On nonempty_list(module_decl) shift to state 1173
-- On module_decl shift to state 1172
-- On meta_decl shift to state 1163
## Reductions:
-- On EOF reduce production nonempty_list(module_decl) -> module_decl

State 1173:
## Known stack suffix:
## module_decl nonempty_list(module_decl)
## LR(1) items:
nonempty_list(module_decl) -> module_decl nonempty_list(module_decl) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF reduce production nonempty_list(module_decl) -> module_decl nonempty_list(module_decl)

State 1174:
## Known stack suffix:
## mlw_module
## LR(1) items:
list(mlw_module) -> mlw_module . list(mlw_module) [ EOF ]
## Transitions:
-- On THEORY shift to state 995
-- On MODULE shift to state 1015
-- On module_head shift to state 1169
-- On mlw_module shift to state 1174
-- On list(mlw_module) shift to state 1175
## Reductions:
-- On EOF reduce production list(mlw_module) ->

State 1175:
## Known stack suffix:
## mlw_module list(mlw_module)
## LR(1) items:
list(mlw_module) -> mlw_module list(mlw_module) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF reduce production list(mlw_module) -> mlw_module list(mlw_module)

State 1176:
## Known stack suffix:
## mlw_file
## LR(1) items:
mlw_file' -> mlw_file . [ # ]
## Transitions:
## Reductions:
-- On # accept mlw_file

State 1177:
## Known stack suffix:
## list(mlw_module)
## LR(1) items:
mlw_file -> list(mlw_module) . EOF [ # ]
## Transitions:
-- On EOF shift to state 1178
## Reductions:

State 1178:
## Known stack suffix:
## list(mlw_module) EOF
## LR(1) items:
mlw_file -> list(mlw_module) EOF . [ # ]
## Transitions:
## Reductions:
-- On # reduce production mlw_file -> list(mlw_module) EOF

State 1179:
## Known stack suffix:
##
## LR(1) items:
qualid_comma_list_eof' -> . qualid_comma_list_eof [ # ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On separated_nonempty_list(COMMA,qualid) shift to state 1180
-- On qualid_comma_list_eof shift to state 1181
-- On qualid shift to state 1182
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
-- On comma_list1(qualid) shift to state 1185
## Reductions:

State 1180:
## Known stack suffix:
## separated_nonempty_list(COMMA,qualid)
## LR(1) items:
comma_list1(qualid) -> separated_nonempty_list(COMMA,qualid) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF reduce production comma_list1(qualid) -> separated_nonempty_list(COMMA,qualid)

State 1181:
## Known stack suffix:
## qualid_comma_list_eof
## LR(1) items:
qualid_comma_list_eof' -> qualid_comma_list_eof . [ # ]
## Transitions:
## Reductions:
-- On # accept qualid_comma_list_eof

State 1182:
## Known stack suffix:
## qualid
## LR(1) items:
separated_nonempty_list(COMMA,qualid) -> qualid . [ EOF ]
separated_nonempty_list(COMMA,qualid) -> qualid . COMMA separated_nonempty_list(COMMA,qualid) [ EOF ]
## Transitions:
-- On COMMA shift to state 1183
## Reductions:
-- On EOF reduce production separated_nonempty_list(COMMA,qualid) -> qualid

State 1183:
## Known stack suffix:
## qualid COMMA
## LR(1) items:
separated_nonempty_list(COMMA,qualid) -> qualid COMMA . separated_nonempty_list(COMMA,qualid) [ EOF ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On separated_nonempty_list(COMMA,qualid) shift to state 1184
-- On qualid shift to state 1182
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1184:
## Known stack suffix:
## qualid COMMA separated_nonempty_list(COMMA,qualid)
## LR(1) items:
separated_nonempty_list(COMMA,qualid) -> qualid COMMA separated_nonempty_list(COMMA,qualid) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF reduce production separated_nonempty_list(COMMA,qualid) -> qualid COMMA separated_nonempty_list(COMMA,qualid)

State 1185:
## Known stack suffix:
## comma_list1(qualid)
## LR(1) items:
qualid_comma_list_eof -> comma_list1(qualid) . EOF [ # ]
## Transitions:
-- On EOF shift to state 1186
## Reductions:

State 1186:
## Known stack suffix:
## comma_list1(qualid) EOF
## LR(1) items:
qualid_comma_list_eof -> comma_list1(qualid) EOF . [ # ]
## Transitions:
## Reductions:
-- On # reduce production qualid_comma_list_eof -> comma_list1(qualid) EOF

State 1187:
## Known stack suffix:
##
## LR(1) items:
qualid_eof' -> . qualid_eof [ # ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid_eof shift to state 1188
-- On qualid shift to state 1189
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1188:
## Known stack suffix:
## qualid_eof
## LR(1) items:
qualid_eof' -> qualid_eof . [ # ]
## Transitions:
## Reductions:
-- On # accept qualid_eof

State 1189:
## Known stack suffix:
## qualid
## LR(1) items:
qualid_eof -> qualid . EOF [ # ]
## Transitions:
-- On EOF shift to state 1190
## Reductions:

State 1190:
## Known stack suffix:
## qualid EOF
## LR(1) items:
qualid_eof -> qualid EOF . [ # ]
## Transitions:
## Reductions:
-- On # reduce production qualid_eof -> qualid EOF

State 1191:
## Known stack suffix:
##
## LR(1) items:
term_comma_list_eof' -> . term_comma_list_eof [ # ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_comma_list_eof shift to state 1192
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 342
-- On separated_nonempty_list(COMMA,single_term) shift to state 388
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On comma_list1(single_term) shift to state 1193
-- On attr shift to state 356
## Reductions:

State 1192:
## Known stack suffix:
## term_comma_list_eof
## LR(1) items:
term_comma_list_eof' -> term_comma_list_eof . [ # ]
## Transitions:
## Reductions:
-- On # accept term_comma_list_eof

State 1193:
## Known stack suffix:
## comma_list1(single_term)
## LR(1) items:
term_comma_list_eof -> comma_list1(single_term) . EOF [ # ]
## Transitions:
-- On EOF shift to state 1194
## Reductions:

State 1194:
## Known stack suffix:
## comma_list1(single_term) EOF
## LR(1) items:
term_comma_list_eof -> comma_list1(single_term) EOF . [ # ]
## Transitions:
## Reductions:
-- On # reduce production term_comma_list_eof -> comma_list1(single_term) EOF

State 1195:
## Known stack suffix:
##
## LR(1) items:
term_eof' -> . term_eof [ # ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_eof shift to state 1196
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 1197
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 1196:
## Known stack suffix:
## term_eof
## LR(1) items:
term_eof' -> term_eof . [ # ]
## Transitions:
## Reductions:
-- On # accept term_eof

State 1197:
## Known stack suffix:
## term
## LR(1) items:
term_eof -> term . EOF [ # ]
## Transitions:
-- On EOF shift to state 1198
## Reductions:

State 1198:
## Known stack suffix:
## term EOF
## LR(1) items:
term_eof -> term EOF . [ # ]
## Transitions:
## Reductions:
-- On # reduce production term_eof -> term EOF

