%{
  open Ptree

  let qualid_last = function Qident x | Qdot (_, x) -> x

  let use_as q = function Some x -> x | None -> qualid_last q

  let floc s e = Loc.extract (s,e)

  let debug_auto_model = Debug.register_flag
    ~desc:"When set, model attributes are not added during parsing"
    "no_auto_model"

  let add_attr id l = { id with id_ats = l }

  let add_model_trace_attr id =
    if Debug.test_flag debug_auto_model then id else
    let is_model_trace_attr l =
      match l with
      | ATpos _ -> false
      | ATstr attr -> Ident.is_model_trace_attr attr
    in
    if List.exists is_model_trace_attr id.id_ats then id else
      let l =
        (ATstr (Ident.create_model_trace_attr id.id_str))
        :: id.id_ats in
      { id with id_ats = l }

  let add_model_attrs (b : binder) =
    match b with
    | (loc, Some id, ghost, ty) ->
      (loc, Some (add_model_trace_attr id), ghost, ty)
    | _ -> b

  let id_anonymous loc = { id_str = "_"; id_ats = []; id_loc = loc }

  let mk_int_const neg lit =
    Number.{ ic_negative = neg ; ic_abs = lit}

  let mk_real_const neg lit =
    Number.{ rc_negative = neg ; rc_abs = lit}

  let mk_id id s e = { id_str = id; id_ats = []; id_loc = floc s e }

  let get_op  q s e = Qident (mk_id (Ident.op_get q) s e)
  let upd_op  q s e = Qident (mk_id (Ident.op_update q) s e)
  let cut_op  q s e = Qident (mk_id (Ident.op_cut q) s e)
  let rcut_op q s e = Qident (mk_id (Ident.op_rcut q) s e)
  let lcut_op q s e = Qident (mk_id (Ident.op_lcut q) s e)

  let mk_pat  d s e = { pat_desc  = d; pat_loc  = floc s e }
  let mk_term d s e = { term_desc = d; term_loc = floc s e }
  let mk_expr d s e = { expr_desc = d; expr_loc = floc s e }

  let variant_union v1 v2 = match v1, v2 with
    | _, [] -> v1
    | [], _ -> v2
    | _, ({term_loc = loc},_)::_ -> Loc.errorm ~loc
        "multiple `variant' clauses are not allowed"

  let empty_spec = {
    sp_pre     = [];
    sp_post    = [];
    sp_xpost   = [];
    sp_reads   = [];
    sp_writes  = [];
    sp_alias   = [];
    sp_variant = [];
    sp_checkrw = false;
    sp_diverge = false;
  }

  let spec_union s1 s2 = {
    sp_pre     = s1.sp_pre @ s2.sp_pre;
    sp_post    = s1.sp_post @ s2.sp_post;
    sp_xpost   = s1.sp_xpost @ s2.sp_xpost;
    sp_reads   = s1.sp_reads @ s2.sp_reads;
    sp_writes  = s1.sp_writes @ s2.sp_writes;
    sp_alias   = s1.sp_alias @ s2.sp_alias;
    sp_variant = variant_union s1.sp_variant s2.sp_variant;
    sp_checkrw = s1.sp_checkrw || s2.sp_checkrw;
    sp_diverge = s1.sp_diverge || s2.sp_diverge;
  }

  let break_id    = "'Break"
  let continue_id = "'Continue"
  let return_id   = "'Return"

  let apply_return pat sp =
    let apply = function
      | loc, [{pat_desc = Pvar {id_str = "result"; id_loc = l}}, f]
        when Loc.equal loc l -> loc, [pat, f]
      | post -> post in
    match pat.pat_desc with
    | Pwild -> sp
    | _ -> { sp with sp_post = List.map apply sp.sp_post }

  let we_attr = Ident.create_attribute "expl:witness existence"

  let pre_of_any any_loc ty ql =
    if ql = [] then [] else
    let ri loc = { id_str = "result"; id_loc = loc; id_ats = [] } in
    let rt loc = { term_desc = Tident (Qident (ri loc)); term_loc = loc } in
    let cast t ty = { t with term_desc = Tcast (t,ty) } in
    let case (loc, pfl) =
      let mk_t d = { term_desc = d; term_loc = loc } in
      match pfl with
      | [pat, f] ->
          let rec unfold d p = match p.pat_desc with
            | Pparen p | Pscope (_,p) -> unfold d p
            | Pcast (p,ty) -> unfold (cast d ty) p
            | Ptuple [] -> unfold (cast d (PTtuple []))
                                  { p with pat_desc = Pwild }
            | Pvar { id_str = "result" } | Pwild ->
              begin match d.term_desc with
                | Tident (Qident _) -> f (* no type casts on d *)
                | _ -> mk_t (Tlet (id_anonymous p.pat_loc, d, f))
              end
            | Pvar id -> mk_t (Tlet (id, d, f))
            | _ -> mk_t (Tcase (d, pfl)) in
          unfold (rt loc) pat
      | _ -> mk_t (Tcase (rt loc, pfl)) in
    let mk_t desc = { term_desc = desc; term_loc = any_loc } in
    let rec join ql = match ql with
      | [] -> assert false (* never *)
      | [q] -> case q
      | q::ql -> mk_t (Tbinop (case q, Dterm.DTand_asym, join ql)) in
    let id = add_attr (ri any_loc) [ATstr Ity.break_attr] in
    let bl = [any_loc, Some id, false, Some ty] in
    let p = mk_t (Tquant (Dterm.DTexists, bl, [], join ql)) in
    [mk_t (Tattr (ATstr we_attr, p))]

  let error_param loc =
    Loc.errorm ~loc "cannot determine the type of the parameter"

  let error_loc loc = Loc.error ~loc Error

  let () = Exn_printer.register (fun fmt exn -> match exn with
    | Error -> Format.fprintf fmt "syntax error %s" (Parser_messages.message 1)
    | _ -> raise exn)
%}
%start ident_comma_list_eof
%start mlw_file
%start qualid_comma_list_eof
%start qualid_eof
%start term_comma_list_eof
%start term_eof
%token ABSTRACT
%token ABSURD
%token ALIAS
%token AMPAMP
%token AND
%token ANY
%token ARROW
%token AS
%token ASSERT
%token ASSUME
%token AT
%token <string> ATTRIBUTE
%token AXIOM
%token BAR
%token BARBAR
%token BEGIN
%token BREAK
%token BY
%token CHECK
%token CLONE
%token COINDUCTIVE
%token COLON
%token COMMA
%token CONSTANT
%token CONTINUE
%token <string> CORE_LIDENT
%token <string> CORE_UIDENT
%token DIVERGES
%token DO
%token DONE
%token DOT
%token DOTDOT
%token DOWNTO
%token ELSE
%token END
%token ENSURES
%token EOF
%token EPSILON
%token EQUAL
%token EXCEPTION
%token EXISTS
%token EXPORT
%token FALSE
%token FLOAT
%token FOR
%token FORALL
%token FUN
%token FUNCTION
%token GHOST
%token GOAL
%token GT
%token IF
%token IMPORT
%token IN
%token INDUCTIVE
%token <Number.integer_literal> INTEGER
%token INVARIANT
%token LABEL
%token LARROW
%token LEFTBRC
%token LEFTPAR
%token LEFTSQ
%token LEMMA
%token LET
%token <string> LIDENT
%token LRARROW
%token LT
%token LTGT
%token MATCH
%token META
%token MINUS
%token MODULE
%token MUTABLE
%token NOT
%token OLD
%token <string> OP1
%token <string> OP2
%token <string> OP3
%token <string> OP4
%token <string> OPPREF
%token OR
%token <Loc.position> POSITION
%token PREDICATE
%token PRIVATE
%token PURE
%token <string> QUOTE_LIDENT
%token RAISE
%token RAISES
%token RANGE
%token READS
%token <Number.real_literal> REAL
%token REC
%token REQUIRES
%token RETURN
%token RETURNS
%token RIGHTBRC
%token RIGHTPAR
%token <string> RIGHTPAR_QUOTE
%token <string> RIGHTPAR_USCORE
%token RIGHTSQ
%token <string> RIGHTSQ_QUOTE
%token SCOPE
%token SEMICOLON
%token SO
%token <string> STRING
%token THEN
%token THEORY
%token TO
%token TRUE
%token TRY
%token TYPE
%token <string> UIDENT
%token UNDERSCORE
%token USE
%token VAL
%token VARIANT
%token WHILE
%token WITH
%token WRITES
%nonassoc below_SEMI
%nonassoc SEMICOLON
%nonassoc EXCEPTION LET VAL
%nonassoc prec_no_else
%nonassoc DOT ELSE RETURN
%nonassoc prec_no_spec
%nonassoc ALIAS DIVERGES ENSURES RAISES READS REQUIRES RETURNS VARIANT WRITES
%nonassoc below_LARROW
%nonassoc LARROW
%nonassoc below_COMMA
%nonassoc COMMA
%nonassoc AS
%nonassoc GHOST
%nonassoc prec_attr
%nonassoc COLON
%right ARROW BY LRARROW SO
%right BARBAR OR
%right AMPAMP AND
%nonassoc NOT
%right EQUAL GT LT LTGT OP1
%nonassoc AT OLD
%left MINUS OP2
%left OP3
%left OP4
%nonassoc prec_prefix_op
%nonassoc INTEGER REAL
%nonassoc LEFTSQ
%nonassoc OPPREF
%type <Ptree.ident list> ident_comma_list_eof
%type <Pmodule.pmodule Wstdlib.Mstr.t> mlw_file
%type <Ptree.qualid list> qualid_comma_list_eof
%type <Ptree.qualid> qualid_eof
%type <Ptree.term list> term_comma_list_eof
%type <Ptree.term> term_eof
%%

option_UNDERSCORE_:
  
    {    ( None )} [@name none_UNDERSCORE]
| x = UNDERSCORE
    {    ( Some x )} [@name some_UNDERSCORE]

option_cast_:
  
    {    ( None )} [@name none_cast]
| x = cast
    {    ( Some x )} [@name some_cast]

option_expr_arg_:
  
    {    ( None )} [@name none_expr_arg]
| x = expr_arg
    {    ( Some x )} [@name some_expr_arg]

option_pat_arg_:
  
    {    ( None )} [@name none_pat_arg]
| x = pat_arg
    {    ( Some x )} [@name some_pat_arg]

option_preceded_AS_uident__:
  
    {    ( None )} [@name none_preceded_AS_uident_]
| _1 = AS x = uident
    {let x =     ( x ) in
    ( Some x )} [@name some_preceded_AS_uident_]

option_preceded_EQUAL_term__:
  
    {    ( None )} [@name none_preceded_EQUAL_term_]
| _1 = EQUAL x = term
    {let x =     ( x ) in
    ( Some x )} [@name some_preceded_EQUAL_term_]

option_preceded_WITH_lqualid__:
  
    {    ( None )} [@name none_preceded_WITH_lqualid_]
| _1 = WITH x = lqualid
    {let x =     ( x ) in
    ( Some x )} [@name some_preceded_WITH_lqualid_]

boption_IMPORT_:
  
    {    ( false )} [@name none_IMPORT]
| _1 = IMPORT
    {    ( true )} [@name some_IMPORT]

loption_semicolon_list1_type_field__:
  
    {    ( [] )} [@name none_semicolon_list1_type_field_]
| x = semicolon_list1_type_field_
    {    ( x )} [@name some_semicolon_list1_type_field_]

loption_separated_nonempty_list_COMMA_alias__:
  
    {    ( [] )} [@name none_separated_nonempty_list_COMMA_alias_]
| x = separated_nonempty_list_COMMA_alias_
    {    ( x )} [@name some_separated_nonempty_list_COMMA_alias_]

loption_separated_nonempty_list_COMMA_lqualid__:
  
    {    ( [] )} [@name none_separated_nonempty_list_COMMA_lqualid_]
| x = separated_nonempty_list_COMMA_lqualid_
    {    ( x )} [@name some_separated_nonempty_list_COMMA_lqualid_]

loption_separated_nonempty_list_COMMA_single_term__:
  
    {    ( [] )} [@name none_separated_nonempty_list_COMMA_single_term_]
| x = separated_nonempty_list_COMMA_single_term_
    {    ( x )} [@name some_separated_nonempty_list_COMMA_single_term_]

list_attr_:
  
    {    ( [] )} [@name nil_attr]
| x = attr xs = list_attr_
    {    ( x :: xs )} [@name cons_attr]

list_binder_var_:
  
    {    ( [] )} [@name nil_binder_var]
| x = binder_var xs = list_binder_var_
    {    ( x :: xs )} [@name cons_binder_var]

list_invariant_:
  
    {    ( [] )} [@name nil_invariant]
| x = invariant xs = list_invariant_
    {    ( x :: xs )} [@name cons_invariant]

list_mlw_module_:
  
    {    ( [] )} [@name nil_mlw_module]
| x = mlw_module xs = list_mlw_module_
    {    ( x :: xs )} [@name cons_mlw_module]

list_module_decl_:
  
    {    ( [] )} [@name nil_module_decl]
| x = module_decl xs = list_module_decl_
    {    ( x :: xs )} [@name cons_module_decl]

list_param_:
  
    {    ( [] )} [@name nil_param]
| x = param xs = list_param_
    {    ( x :: xs )} [@name cons_param]

list_ty_var_:
  
    {    ( [] )} [@name nil_ty_var]
| x = ty_var xs = list_ty_var_
    {    ( x :: xs )} [@name cons_ty_var]

list_with_logic_decl_:
  
    {    ( [] )} [@name nil_with_logic_decl]
| x = with_logic_decl xs = list_with_logic_decl_
    {    ( x :: xs )} [@name cons_with_logic_decl]

nonempty_list_attr_:
  x = attr
    {    ( [ x ] )} [@name one_attr]
| x = attr xs = nonempty_list_attr_
    {    ( x :: xs )} [@name more_attr]

nonempty_list_binder_:
  x = binder
    {    ( [ x ] )} [@name one_binder]
| x = binder xs = nonempty_list_binder_
    {    ( x :: xs )} [@name more_binder]

nonempty_list_binder_var_:
  x = binder_var
    {    ( [ x ] )} [@name one_binder_var]
| x = binder_var xs = nonempty_list_binder_var_
    {    ( x :: xs )} [@name more_binder_var]

nonempty_list_located_expr_arg__:
  x = located_expr_arg_
    {    ( [ x ] )} [@name one_located_expr_arg_]
| x = located_expr_arg_ xs = nonempty_list_located_expr_arg__
    {    ( x :: xs )} [@name more_located_expr_arg_]

nonempty_list_located_term_arg__:
  x = located_term_arg_
    {    ( [ x ] )} [@name one_located_term_arg_]
| x = located_term_arg_ xs = nonempty_list_located_term_arg__
    {    ( x :: xs )} [@name more_located_term_arg_]

nonempty_list_module_decl_:
  x = module_decl
    {    ( [ x ] )} [@name one_module_decl]
| x = module_decl xs = nonempty_list_module_decl_
    {    ( x :: xs )} [@name more_module_decl]

nonempty_list_pat_arg_:
  x = pat_arg
    {    ( [ x ] )} [@name one_pat_arg]
| x = pat_arg xs = nonempty_list_pat_arg_
    {    ( x :: xs )} [@name more_pat_arg]

nonempty_list_ty_arg_:
  x = ty_arg
    {    ( [ x ] )} [@name one_ty_arg]
| x = ty_arg xs = nonempty_list_ty_arg_
    {    ( x :: xs )} [@name more_ty_arg]

separated_nonempty_list_BAR_comma_list1_single_term__:
  x = comma_list1_single_term_
    {    ( [ x ] )} [@name one_BAR_comma_list1_single_term_]
| x = comma_list1_single_term_ _2 = BAR xs = separated_nonempty_list_BAR_comma_list1_single_term__
    {    ( x :: xs )} [@name more_BAR_comma_list1_single_term_]

separated_nonempty_list_BAR_exn_handler_:
  x = exn_handler
    {    ( [ x ] )} [@name one_BAR_exn_handler]
| x = exn_handler _2 = BAR xs = separated_nonempty_list_BAR_exn_handler_
    {    ( x :: xs )} [@name more_BAR_exn_handler]

separated_nonempty_list_BAR_ind_case_:
  x = ind_case
    {    ( [ x ] )} [@name one_BAR_ind_case]
| x = ind_case _2 = BAR xs = separated_nonempty_list_BAR_ind_case_
    {    ( x :: xs )} [@name more_BAR_ind_case]

separated_nonempty_list_BAR_match_case_term__:
  x = match_case_term_
    {    ( [ x ] )} [@name one_BAR_match_case_term_]
| x = match_case_term_ _2 = BAR xs = separated_nonempty_list_BAR_match_case_term__
    {    ( x :: xs )} [@name more_BAR_match_case_term_]

separated_nonempty_list_BAR_raises_:
  x = raises
    {    ( [ x ] )} [@name one_BAR_raises]
| x = raises _2 = BAR xs = separated_nonempty_list_BAR_raises_
    {    ( x :: xs )} [@name more_BAR_raises]

separated_nonempty_list_BAR_type_case_:
  x = type_case
    {    ( [ x ] )} [@name one_BAR_type_case]
| x = type_case _2 = BAR xs = separated_nonempty_list_BAR_type_case_
    {    ( x :: xs )} [@name more_BAR_type_case]

separated_nonempty_list_COMMA_alias_:
  x = alias
    {    ( [ x ] )} [@name one_COMMA_alias]
| x = alias _2 = COMMA xs = separated_nonempty_list_COMMA_alias_
    {    ( x :: xs )} [@name more_COMMA_alias]

separated_nonempty_list_COMMA_ident_:
  x = ident
    {    ( [ x ] )} [@name one_COMMA_ident]
| x = ident _2 = COMMA xs = separated_nonempty_list_COMMA_ident_
    {    ( x :: xs )} [@name more_COMMA_ident]

separated_nonempty_list_COMMA_lqualid_:
  x = lqualid
    {    ( [ x ] )} [@name one_COMMA_lqualid]
| x = lqualid _2 = COMMA xs = separated_nonempty_list_COMMA_lqualid_
    {    ( x :: xs )} [@name more_COMMA_lqualid]

separated_nonempty_list_COMMA_meta_arg_:
  x = meta_arg
    {    ( [ x ] )} [@name one_COMMA_meta_arg]
| x = meta_arg _2 = COMMA xs = separated_nonempty_list_COMMA_meta_arg_
    {    ( x :: xs )} [@name more_COMMA_meta_arg]

separated_nonempty_list_COMMA_mk_pat_pat_uni___:
  x = mk_pat_pat_uni__
    {    ( [ x ] )} [@name one_COMMA_mk_pat_pat_uni__]
| x = mk_pat_pat_uni__ _2 = COMMA xs = separated_nonempty_list_COMMA_mk_pat_pat_uni___
    {    ( x :: xs )} [@name more_COMMA_mk_pat_pat_uni__]

separated_nonempty_list_COMMA_qualid_:
  x = qualid
    {    ( [ x ] )} [@name one_COMMA_qualid]
| x = qualid _2 = COMMA xs = separated_nonempty_list_COMMA_qualid_
    {    ( x :: xs )} [@name more_COMMA_qualid]

separated_nonempty_list_COMMA_quant_vars_:
  x = quant_vars
    {    ( [ x ] )} [@name one_COMMA_quant_vars]
| x = quant_vars _2 = COMMA xs = separated_nonempty_list_COMMA_quant_vars_
    {    ( x :: xs )} [@name more_COMMA_quant_vars]

separated_nonempty_list_COMMA_ret_cast_:
  x = ret_cast
    {    ( [ x ] )} [@name one_COMMA_ret_cast]
| x = ret_cast _2 = COMMA xs = separated_nonempty_list_COMMA_ret_cast_
    {    ( x :: xs )} [@name more_COMMA_ret_cast]

separated_nonempty_list_COMMA_single_clone_subst_:
  x = single_clone_subst
    {    ( [ x ] )} [@name one_COMMA_single_clone_subst]
| x = single_clone_subst _2 = COMMA xs = separated_nonempty_list_COMMA_single_clone_subst_
    {    ( x :: xs )} [@name more_COMMA_single_clone_subst]

separated_nonempty_list_COMMA_single_term_:
  x = single_term
    {    ( [ x ] )} [@name one_COMMA_single_term]
| x = single_term _2 = COMMA xs = separated_nonempty_list_COMMA_single_term_
    {    ( x :: xs )} [@name more_COMMA_single_term]

separated_nonempty_list_COMMA_single_variant_:
  x = single_variant
    {    ( [ x ] )} [@name one_COMMA_single_variant]
| x = single_variant _2 = COMMA xs = separated_nonempty_list_COMMA_single_variant_
    {    ( x :: xs )} [@name more_COMMA_single_variant]

separated_nonempty_list_COMMA_ty_:
  x = ty
    {    ( [ x ] )} [@name one_COMMA_ty]
| x = ty _2 = COMMA xs = separated_nonempty_list_COMMA_ty_
    {    ( x :: xs )} [@name more_COMMA_ty]

separated_nonempty_list_COMMA_use_as_:
  x = use_as
    {    ( [ x ] )} [@name one_COMMA_use_as]
| x = use_as _2 = COMMA xs = separated_nonempty_list_COMMA_use_as_
    {    ( x :: xs )} [@name more_COMMA_use_as]

separated_nonempty_list_COMMA_xsymbol_:
  x = xsymbol
    {    ( [ x ] )} [@name one_COMMA_xsymbol]
| x = xsymbol _2 = COMMA xs = separated_nonempty_list_COMMA_xsymbol_
    {    ( x :: xs )} [@name more_COMMA_xsymbol]

separated_nonempty_list_WITH_inductive_decl_:
  x = inductive_decl
    {    ( [ x ] )} [@name one_WITH_inductive_decl]
| x = inductive_decl _2 = WITH xs = separated_nonempty_list_WITH_inductive_decl_
    {    ( x :: xs )} [@name more_WITH_inductive_decl]

separated_nonempty_list_WITH_rec_defn_:
  x = rec_defn
    {    ( [ x ] )} [@name one_WITH_rec_defn]
| x = rec_defn _2 = WITH xs = separated_nonempty_list_WITH_rec_defn_
    {    ( x :: xs )} [@name more_WITH_rec_defn]

separated_nonempty_list_WITH_type_decl_:
  x = type_decl
    {    ( [ x ] )} [@name one_WITH_type_decl]
| x = type_decl _2 = WITH xs = separated_nonempty_list_WITH_type_decl_
    {    ( x :: xs )} [@name more_WITH_type_decl]

term_eof:
  _1 = term _2 = EOF
    {           ( _1 )}

mlw_file:
  _1 = list_mlw_module_ _2 = EOF
    {    ( Typing.close_file () )}
| _1 = nonempty_list_module_decl_ _2 = EOF
    {    ( let loc = floc _startpos__2_ _endpos__2_ in
      Typing.close_module loc; Typing.close_file () )}

mlw_module:
  _1 = module_head _2 = list_module_decl_ _3 = END
    {    ( Typing.close_module (floc _startpos__3_ _endpos__3_) )}

module_head:
  _1 = THEORY _2 = attrs_uident_nq_
    {                           ( Typing.open_module _2 )}
| _1 = MODULE _2 = attrs_uident_nq_
    {                           ( Typing.open_module _2 )}

scope_head:
  _1 = SCOPE _2 = boption_IMPORT_ _3 = uident
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( Typing.open_scope (floc _startpos _endpos) _3; _2 )}

module_decl:
  _1 = scope_head _2 = list_module_decl_ _3 = END
    {    ( Typing.close_scope (floc _startpos__1_ _endpos__1_) ~import:_1 )}
| _1 = IMPORT _2 = uqualid
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
    ( Typing.import_scope (floc _startpos _endpos) _2 )}
| d = pure_decl
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
    ( Typing.add_decl (floc _startpos _endpos) d )}
| d = prog_decl
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
    ( Typing.add_decl (floc _startpos _endpos) d )}
| d = meta_decl
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
    ( Typing.add_decl (floc _startpos _endpos) d )}
| _1 = use_clone
    {            ( () )}

use_clone:
  _1 = USE _2 = EXPORT _3 = tqualid
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( Typing.add_decl (floc _startpos _endpos) (Duse _3) )}
| _1 = CLONE _2 = EXPORT _3 = tqualid _4 = clone_subst
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( Typing.add_decl (floc _startpos _endpos) (Dclone (_3, _4)) )}
| _1 = USE _2 = boption_IMPORT_ m_as_list = comma_list1_use_as_
    {let _endpos = _endpos_m_as_list_ in
let _startpos = _startpos__1_ in
    ( let loc = floc _startpos _endpos in
      let exists_as = List.exists (fun (_, q) -> q <> None) m_as_list in
      if _2 && not exists_as then Warning.emit ~loc
        "the keyword `import' is redundant here and can be omitted";
      let add_import (m, q) = let import = _2 || q = None in
        Typing.open_scope loc (use_as m q);
        Typing.add_decl loc (Duse m);
        Typing.close_scope loc ~import  in
      List.iter add_import m_as_list )}
| _1 = CLONE _2 = boption_IMPORT_ _3 = tqualid _4 = option_preceded_AS_uident__ _5 = clone_subst
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
    ( let loc = floc _startpos _endpos in
      if _2 && _4 = None then Warning.emit ~loc
        "the keyword `import' is redundant here and can be omitted";
      let import = _2 || _4 = None in
      Typing.open_scope loc (use_as _3 _4);
      Typing.add_decl loc (Dclone (_3, _5));
      Typing.close_scope loc ~import )}

use_as:
  n = tqualid q = option_preceded_AS_uident__
    {                                               ( (n, q) )}

clone_subst:
  
    {                                        ( [] )}
| _1 = WITH _2 = comma_list1_single_clone_subst_
    {                                        ( _2 )}

single_clone_subst:
  _1 = TYPE _2 = qualid _3 = list_ty_var_ _4 = EQUAL _5 = ty
    {                                ( CStsym  (_2,_3,_5) )}
| _1 = TYPE _2 = qualid
    {                                ( CStsym  (_2, [], PTtyapp (_2, [])) )}
| _1 = CONSTANT _2 = qualid _3 = EQUAL _4 = qualid
    {                                ( CSfsym  (_2,_4) )}
| _1 = CONSTANT _2 = qualid
    {                                ( CSfsym  (_2,_2) )}
| _1 = FUNCTION _2 = qualid _3 = EQUAL _4 = qualid
    {                                ( CSfsym  (_2,_4) )}
| _1 = FUNCTION _2 = qualid
    {                                ( CSfsym  (_2,_2) )}
| _1 = PREDICATE _2 = qualid _3 = EQUAL _4 = qualid
    {                                ( CSpsym  (_2,_4) )}
| _1 = PREDICATE _2 = qualid
    {                                ( CSpsym  (_2,_2) )}
| _1 = VAL _2 = qualid _3 = EQUAL _4 = qualid
    {                                ( CSvsym  (_2,_4) )}
| _1 = VAL _2 = qualid
    {                                ( CSvsym  (_2,_2) )}
| _1 = EXCEPTION _2 = qualid _3 = EQUAL _4 = qualid
    {                                ( CSxsym  (_2,_4) )}
| _1 = EXCEPTION _2 = qualid
    {                                ( CSxsym  (_2,_2) )}
| _1 = AXIOM _2 = qualid
    {                                ( CSaxiom (_2) )}
| _1 = LEMMA _2 = qualid
    {                                ( CSlemma (_2) )}
| _1 = GOAL _2 = qualid
    {                                ( CSgoal  (_2) )}
| _1 = AXIOM _2 = DOT
    {                                ( CSprop  (Decl.Paxiom) )}
| _1 = LEMMA _2 = DOT
    {                                ( CSprop  (Decl.Plemma) )}
| _1 = GOAL _2 = DOT
    {                                ( CSprop  (Decl.Pgoal) )}

meta_decl:
  _1 = META _2 = sident _3 = comma_list1_meta_arg_
    {                                     ( Dmeta (_2, _3) )}

meta_arg:
  _1 = TYPE _2 = ty
    {                    ( Mty _2 )}
| _1 = CONSTANT _2 = qualid
    {                    ( Mfs _2 )}
| _1 = FUNCTION _2 = qualid
    {                    ( Mfs _2 )}
| _1 = PREDICATE _2 = qualid
    {                    ( Mps _2 )}
| _1 = AXIOM _2 = qualid
    {                    ( Max _2 )}
| _1 = LEMMA _2 = qualid
    {                    ( Mlm _2 )}
| _1 = GOAL _2 = qualid
    {                    ( Mgl _2 )}
| _1 = STRING
    {                    ( Mstr _1 )}
| _1 = INTEGER
    {                    ( Mint (Number.to_small_integer _1) )}

pure_decl:
  _1 = TYPE _2 = with_list1_type_decl_
    {                                            ( Dtype _2 )}
| _1 = CONSTANT _2 = constant_decl
    {                                            ( Dlogic [_2] )}
| _1 = FUNCTION _2 = function_decl _3 = list_with_logic_decl_
    {                                            ( Dlogic (_2::_3) )}
| _1 = PREDICATE _2 = predicate_decl _3 = list_with_logic_decl_
    {                                            ( Dlogic (_2::_3) )}
| _1 = INDUCTIVE _2 = with_list1_inductive_decl_
    {                                            ( Dind (Decl.Ind, _2) )}
| _1 = COINDUCTIVE _2 = with_list1_inductive_decl_
    {                                            ( Dind (Decl.Coind, _2) )}
| _1 = AXIOM _2 = attrs_ident_nq_ _3 = COLON _4 = term
    {                                            ( Dprop (Decl.Paxiom, _2, _4) )}
| _1 = LEMMA _2 = attrs_ident_nq_ _3 = COLON _4 = term
    {                                            ( Dprop (Decl.Plemma, _2, _4) )}
| _1 = GOAL _2 = attrs_ident_nq_ _3 = COLON _4 = term
    {                                            ( Dprop (Decl.Pgoal, _2, _4) )}

type_decl:
  _1 = attrs_lident_nq_ _2 = list_ty_var_ _3 = typedefn _4 = list_invariant_ _5 = type_witness
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
  ( let (vis, mut), def = _3 in
    { td_ident = _1; td_params = _2;
      td_vis = vis; td_mut = mut;
      td_inv = _4; td_wit = _5; td_def = def;
      td_loc = floc _startpos _endpos } )}

type_witness:
  
    {                                          ( [] )}
| _1 = BY _2 = LEFTBRC _3 = field_list1_expr_ _4 = RIGHTBRC
    {                                          ( _3 )}

ty_var:
  _1 = attrs_quote_lident_
    {                      ( _1 )}

typedefn:
  
    {    ( (Abstract, false), TDrecord [] )}
| _1 = EQUAL _2 = vis_mut _3 = bar_list1_type_case_
    {    ( _2, TDalgebraic _3 )}
| _1 = EQUAL _2 = vis_mut _3 = LEFTBRC _4 = loption_semicolon_list1_type_field__ _5 = RIGHTBRC
    {    ( _2, TDrecord _4 )}
| _1 = EQUAL _2 = vis_mut _3 = ty
    {    ( _2, TDalias _3 )}
| _1 = EQUAL _2 = LT _3 = RANGE _4 = int_constant _5 = int_constant _6 = GT
    {    ( (Public, false), TDrange (_4, _5) )}
| _1 = EQUAL _2 = LT _3 = FLOAT _4 = INTEGER _5 = INTEGER _6 = GT
    {    ( (Public, false),
      TDfloat (Number.to_small_integer _4, Number.to_small_integer _5) )}

int_constant:
  _1 = INTEGER
    {                ( Number.compute_int_literal _1 )}
| _1 = MINUS _2 = INTEGER
    {                ( BigInt.minus (Number.compute_int_literal _2) )}

vis_mut:
  
    {                    ( Public, false )}
| _1 = MUTABLE
    {                    ( Public, true  )}
| _1 = abstract
    {                    ( _1, false )}
| _1 = abstract _2 = MUTABLE
    {                    ( _1, true )}
| _1 = MUTABLE _2 = abstract
    {                    ( _2, true )}

abstract:
  _1 = PRIVATE
    {                    ( Private )}
| _1 = ABSTRACT
    {                    ( Abstract )}

type_field:
  _1 = attrs_lident_nq_ _2 = cast
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
  ( { f_ident = _1; f_mutable = false; f_ghost = false;
      f_pty = _2; f_loc = floc _startpos _endpos } )}
| _1 = field_modifiers _2 = attrs_lident_nq_ _3 = cast
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( { f_ident = _2; f_mutable = fst _1; f_ghost = snd _1;
      f_pty = _3; f_loc = floc _startpos _endpos } )}

field_modifiers:
  _1 = MUTABLE
    {                ( true,  false )}
| _1 = GHOST
    {                ( false, true  )}
| _1 = GHOST _2 = MUTABLE
    {                ( true,  true  )}
| _1 = MUTABLE _2 = GHOST
    {                ( true,  true  )}

type_case:
  _1 = attrs_uident_nq_ _2 = params
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
                          ( floc _startpos _endpos, _1, _2 )}

constant_decl:
  _1 = attrs_lident_rich_ _2 = cast _3 = option_preceded_EQUAL_term__
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( { ld_ident = add_model_trace_attr _1;
      ld_params = []; ld_type = Some _2;
      ld_def = _3; ld_loc = floc _startpos _endpos } )}

function_decl:
  _1 = attrs_lident_rich_ _2 = params _3 = cast _4 = option_preceded_EQUAL_term__
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
  ( { ld_ident = _1; ld_params = _2; ld_type = Some _3;
      ld_def = _4; ld_loc = floc _startpos _endpos } )}

predicate_decl:
  _1 = attrs_lident_rich_ _2 = params _3 = option_preceded_EQUAL_term__
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( { ld_ident = _1; ld_params = _2; ld_type = None;
      ld_def = _3; ld_loc = floc _startpos _endpos } )}

with_logic_decl:
  _1 = WITH _2 = attrs_lident_rich_ _3 = params _4 = option_cast_ _5 = option_preceded_EQUAL_term__
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
  ( { ld_ident = _2; ld_params = _3; ld_type = _4;
      ld_def = _5; ld_loc = floc _startpos _endpos } )}

inductive_decl:
  _1 = attrs_lident_rich_ _2 = params _3 = ind_defn
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( { in_ident = _1; in_params = _2;
      in_def = _3; in_loc = floc _startpos _endpos } )}

ind_defn:
  
    {                            ( [] )}
| _1 = EQUAL _2 = bar_list1_ind_case_
    {                            ( _2 )}

ind_case:
  _1 = attrs_ident_nq_ _2 = COLON _3 = term
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
                              ( floc _startpos _endpos, _1, _3 )}

ty:
  _1 = ty_arg
    {                  ( _1 )}
| _1 = lqualid _2 = nonempty_list_ty_arg_
    {                  ( PTtyapp (_1, _2) )}
| _1 = ty _2 = ARROW _3 = ty
    {                  ( PTarrow (_1, _3) )}

ty_arg:
  _1 = lqualid
    {                                    ( PTtyapp (_1, []) )}
| _1 = quote_lident
    {                                    ( PTtyvar _1 )}
| _1 = uqualid _2 = DOT _3 = ty_block
    {                                    ( PTscope (_1, _3) )}
| _1 = ty_block
    {                                    ( _1 )}

ty_block:
  _1 = LEFTPAR _2 = comma_list2_ty_ _3 = RIGHTPAR
    {                                    ( PTtuple _2 )}
| _1 = LEFTPAR _2 = RIGHTPAR
    {                                    ( PTtuple [] )}
| _1 = LEFTPAR _2 = ty _3 = RIGHTPAR
    {                                    ( PTparen _2 )}
| _1 = LEFTBRC _2 = ty _3 = RIGHTBRC
    {                                    ( PTpure _2 )}

cast:
  _1 = COLON _2 = ty
    {            ( _2 )}

params:
  _1 = list_param_
    {                 ( List.concat _1 )}

binders:
  _1 = nonempty_list_binder_
    {                 ( List.concat _1 )}

param:
  _1 = anon_binder
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
    ( error_param (floc _startpos _endpos) )}
| _1 = lident_nq _2 = nonempty_list_attr_
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
    ( error_param (floc _startpos _endpos) )}
| _1 = ty_arg
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
    ( [floc _startpos _endpos, None, false, _1] )}
| _1 = LEFTPAR _2 = GHOST _3 = ty _4 = RIGHTPAR
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( [floc _startpos _endpos, None, true, _3] )}
| _1 = LEFTPAR _2 = binder_vars_rest _3 = RIGHTPAR
    {    ( match _2 with [l,_] -> error_param l
      | _ -> error_loc (floc _startpos__3_ _endpos__3_) )}
| _1 = LEFTPAR _2 = GHOST _3 = binder_vars_rest _4 = RIGHTPAR
    {    ( match _3 with [l,_] -> error_param l
      | _ -> error_loc (floc _startpos__4_ _endpos__4_) )}
| _1 = LEFTPAR _2 = binder_vars _3 = cast _4 = RIGHTPAR
    {    ( List.map (fun (l,i) -> l, i, false, _3) _2 )}
| _1 = LEFTPAR _2 = GHOST _3 = binder_vars _4 = cast _5 = RIGHTPAR
    {    ( List.map (fun (l,i) -> l, i, true, _4) _3 )}

binder:
  _1 = anon_binder
    {    ( let l,i = _1 in [l, i, false, None] )}
| _1 = lident_nq _2 = nonempty_list_attr_
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
    ( [floc _startpos _endpos, Some (add_attr _1 _2), false, None] )}
| _1 = ty_arg
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
    ( match _1 with
      | PTtyapp (Qident id, [])
      | PTparen (PTtyapp (Qident id, [])) ->
          [floc _startpos _endpos, Some id, false, None]
      | _ -> [floc _startpos _endpos, None, false, Some _1] )}
| _1 = LEFTPAR _2 = GHOST _3 = ty _4 = RIGHTPAR
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( match _3 with
      | PTtyapp (Qident id, []) ->
             [floc _startpos _endpos, Some id, true, None]
      | _ -> [floc _startpos _endpos, None, true, Some _3] )}
| _1 = LEFTPAR _2 = binder_vars_rest _3 = RIGHTPAR
    {    ( match _2 with [l,i] -> [l, i, false, None]
      | _ -> error_loc (floc _startpos__3_ _endpos__3_) )}
| _1 = LEFTPAR _2 = GHOST _3 = binder_vars_rest _4 = RIGHTPAR
    {    ( match _3 with [l,i] -> [l, i, true, None]
      | _ -> error_loc (floc _startpos__4_ _endpos__4_) )}
| _1 = LEFTPAR _2 = binder_vars _3 = cast _4 = RIGHTPAR
    {    ( List.map (fun (l,i) -> l, i, false, Some _3) _2 )}
| _1 = LEFTPAR _2 = GHOST _3 = binder_vars _4 = cast _5 = RIGHTPAR
    {    ( List.map (fun (l,i) -> l, i, true, Some _4) _3 )}

binder_vars:
  _1 = binder_vars_head
    {                    ( List.rev _1 )}
| _1 = binder_vars_rest
    {                    ( _1 )}

binder_vars_rest:
  _1 = binder_vars_head _2 = nonempty_list_attr_ _3 = list_binder_var_
    {    ( List.rev_append (match _1 with
        | (l, Some id) :: bl ->
            let l2 = floc _startpos__2_ _endpos__2_ in
            (Loc.join l l2, Some (add_attr id _2)) :: bl
        | _ -> assert false) _3 )}
| _1 = binder_vars_head _2 = anon_binder _3 = list_binder_var_
    {    ( List.rev_append _1 (_2 :: _3) )}
| _1 = anon_binder _2 = list_binder_var_
    {    ( _1 :: _2 )}

binder_vars_head:
  _1 = ty
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
     (
    let of_id id = id.id_loc, Some id in
    let push acc = function
      | PTtyapp (Qident id, []) -> of_id id :: acc
      | _ -> Loc.error ~loc:(floc _startpos _endpos) Error in
    match _1 with
      | PTtyapp (Qident id, l) -> List.fold_left push [of_id id] l
      | _ -> Loc.error ~loc:(floc _startpos _endpos) Error )}

binder_var:
  _1 = attrs_lident_nq_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                    ( floc _startpos _endpos, Some _1 )}
| _1 = anon_binder
    {                    ( _1 )}

anon_binder:
  _1 = UNDERSCORE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                    ( floc _startpos _endpos, None )}

mk_term_lam_defn_:
  d = lam_defn
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mk_term d _startpos _endpos )}

mk_term_single_term__:
  d = single_term_
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mk_term d _startpos _endpos )}

mk_term_term_arg__:
  d = term_arg_
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mk_term d _startpos _endpos )}

mk_term_term_block__:
  d = term_block_
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mk_term d _startpos _endpos )}

mk_term_term_dot__:
  d = term_dot_
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mk_term d _startpos _endpos )}

term:
  _1 = single_term %prec below_COMMA
    {                                  ( _1 )}
| _1 = single_term _2 = COMMA _3 = term_
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mk_term (Ttuple (_1::_3)) _startpos _endpos )}

term_:
  _1 = single_term %prec below_COMMA
    {                                  ( [_1] )}
| _1 = single_term _2 = COMMA _3 = term_
    {                                  ( _1::_3 )}

single_term:
  t = mk_term_single_term__
    {                                       ( t )}

single_term_:
  _1 = term_arg_
    {    ( match _1 with (* break the infix relation chain *)
      | Tinfix (l,o,r) -> Tinnfix (l,o,r)
      | Tbinop (l,o,r) -> Tbinnop (l,o,r)
      | d -> d )}
| _1 = NOT _2 = single_term
    {    ( Tnot _2 )}
| _1 = OLD _2 = single_term
    {    ( Tat (_2, mk_id Dexpr.old_label _startpos__1_ _endpos__1_) )}
| _1 = single_term _2 = AT _3 = uident
    {    ( Tat (_1, _3) )}
| _1 = prefix_op _2 = single_term %prec prec_prefix_op
    {    ( Tidapp (Qident _1, [_2]) )}
| _1 = MINUS _2 = INTEGER
    {    ( Tconst (Number.ConstInt (mk_int_const true _2)) )}
| _1 = MINUS _2 = REAL
    {    ( Tconst (Number.ConstReal (mk_real_const true _2)) )}
| l = single_term _1 = ARROW r = single_term
    {let o =           ( Dterm.DTimplies ) in
    ( Tbinop (l, o, r) )}
| l = single_term _1 = LRARROW r = single_term
    {let o =           ( Dterm.DTiff ) in
    ( Tbinop (l, o, r) )}
| l = single_term _1 = OR r = single_term
    {let o =           ( Dterm.DTor ) in
    ( Tbinop (l, o, r) )}
| l = single_term _1 = BARBAR r = single_term
    {let o =           ( Dterm.DTor_asym ) in
    ( Tbinop (l, o, r) )}
| l = single_term _1 = AND r = single_term
    {let o =           ( Dterm.DTand ) in
    ( Tbinop (l, o, r) )}
| l = single_term _1 = AMPAMP r = single_term
    {let o =           ( Dterm.DTand_asym ) in
    ( Tbinop (l, o, r) )}
| l = single_term _1 = BY r = single_term
    {let o =           ( Dterm.DTby ) in
    ( Tbinop (l, o, r) )}
| l = single_term _1 = SO r = single_term
    {let o =           ( Dterm.DTso ) in
    ( Tbinop (l, o, r) )}
| l = single_term o = OP1 r = single_term
    {let o =
  let _endpos = _endpos_o_ in
  let _startpos = _startpos_o_ in
              ( mk_id (Ident.op_infix o)    _startpos _endpos )
in
    ( Tinfix (l, o, r) )}
| l = single_term _1 = EQUAL r = single_term
    {let o =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mk_id (Ident.op_infix "=")  _startpos _endpos )
in
    ( Tinfix (l, o, r) )}
| l = single_term _1 = LTGT r = single_term
    {let o =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mk_id (Ident.op_infix "<>") _startpos _endpos )
in
    ( Tinfix (l, o, r) )}
| l = single_term _1 = LT r = single_term
    {let o =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mk_id (Ident.op_infix "<")  _startpos _endpos )
in
    ( Tinfix (l, o, r) )}
| l = single_term _1 = GT r = single_term
    {let o =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mk_id (Ident.op_infix ">")  _startpos _endpos )
in
    ( Tinfix (l, o, r) )}
| l = single_term o = OP2 r = single_term
    {let o =
  let _endpos = _endpos_o_ in
  let _startpos = _startpos_o_ in
              ( mk_id (Ident.op_infix o)    _startpos _endpos )
in
    ( Tidapp (Qident o, [l; r]) )}
| l = single_term o = OP3 r = single_term
    {let o =
  let _endpos = _endpos_o_ in
  let _startpos = _startpos_o_ in
              ( mk_id (Ident.op_infix o)    _startpos _endpos )
in
    ( Tidapp (Qident o, [l; r]) )}
| l = single_term o = OP4 r = single_term
    {let o =
  let _endpos = _endpos_o_ in
  let _startpos = _startpos_o_ in
              ( mk_id (Ident.op_infix o)    _startpos _endpos )
in
    ( Tidapp (Qident o, [l; r]) )}
| l = single_term _1 = MINUS r = single_term
    {let o =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mk_id (Ident.op_infix "-")  _startpos _endpos )
in
    ( Tidapp (Qident o, [l; r]) )}
| _1 = term_arg _2 = nonempty_list_located_term_arg__
    {let _startpos = _startpos__1_ in
    ( let join f (a,_,e) = mk_term (Tapply (f,a)) _startpos e in
      (List.fold_left join _1 _2).term_desc )}
| _1 = IF _2 = term _3 = THEN _4 = term _5 = ELSE _6 = term
    {    ( Tif (_2, _4, _6) )}
| _1 = LET _2 = pattern _3 = EQUAL _4 = term _5 = IN _6 = term
    {    ( let re_pat pat d = { pat with pat_desc = d } in
      let cast t ty = { t with term_desc = Tcast (t,ty) } in
      let rec unfold d p = match p.pat_desc with
        | Pparen p | Pscope (_,p) -> unfold d p
        | Pcast (p,ty) -> unfold (cast d ty) p
        | Ptuple [] -> unfold (cast d (PTtuple [])) (re_pat p Pwild)
        | Pvar id -> Tlet (id, d, _6)
        | Pwild -> Tlet (id_anonymous p.pat_loc, d, _6)
        | _ -> Tcase (d, [_2, _6]) in
      unfold _4 _2 )}
| _1 = LET _2 = attrs_lident_op_nq_ _3 = EQUAL _4 = term _5 = IN _6 = term
    {    ( Tlet (_2, _4, _6) )}
| _1 = LET _2 = attrs_lident_nq_ _3 = mk_term_lam_defn_ _4 = IN _5 = term
    {    ( Tlet (_2, _3, _5) )}
| _1 = LET _2 = attrs_lident_op_nq_ _3 = mk_term_lam_defn_ _4 = IN _5 = term
    {    ( Tlet (_2, _3, _5) )}
| _1 = MATCH _2 = term _3 = WITH _4 = match_cases_term_ _5 = END
    {    ( Tcase (_2, _4) )}
| _1 = quant _2 = comma_list1_quant_vars_ _3 = triggers _4 = DOT _5 = term
    {    ( let l = List.map add_model_attrs (List.concat _2) in
      Tquant (_1, l, _3, _5) )}
| _1 = FUN _2 = binders _3 = ARROW _4 = term
    {    ( Tquant (Dterm.DTlambda, _2, [], _4) )}
| _1 = EPSILON
    {    ( Loc.errorm "Epsilon terms are currently not supported in WhyML" )}
| _1 = attr _2 = single_term %prec prec_attr
    {    ( Tattr (_1, _2) )}
| _1 = single_term _2 = cast
    {    ( Tcast (_1, _2) )}

lam_defn:
  _1 = binders _2 = EQUAL _3 = term
    {                      ( Tquant (Dterm.DTlambda, _1, [], _3) )}

term_arg:
  _1 = mk_term_term_arg__
    {                             ( _1 )}

term_dot:
  _1 = mk_term_term_dot__
    {                             ( _1 )}

term_arg_:
  _1 = qualid
    {                            ( Tident _1 )}
| _1 = numeral
    {                            ( Tconst _1 )}
| _1 = TRUE
    {                            ( Ttrue )}
| _1 = FALSE
    {                            ( Tfalse )}
| o = OPPREF a = term_arg
    {let o =
  let _endpos = _endpos_o_ in
  let _startpos = _startpos_o_ in
               ( mk_id (Ident.op_prefix o)  _startpos _endpos )
in
                            ( Tidapp (Qident o, [a]) )}
| _1 = term_sub_
    {                            ( _1 )}

term_dot_:
  _1 = lqualid
    {                            ( Tident _1 )}
| o = OPPREF a = term_dot
    {let o =
  let _endpos = _endpos_o_ in
  let _startpos = _startpos_o_ in
               ( mk_id (Ident.op_prefix o)  _startpos _endpos )
in
                            ( Tidapp (Qident o, [a]) )}
| _1 = term_sub_
    {                            ( _1 )}

term_block_:
  _1 = BEGIN _2 = term _3 = END
    {                                                    ( _2.term_desc )}
| _1 = LEFTPAR _2 = term _3 = RIGHTPAR
    {                                                    ( _2.term_desc )}
| _1 = BEGIN _2 = END
    {                                                    ( Ttuple [] )}
| _1 = LEFTPAR _2 = RIGHTPAR
    {                                                    ( Ttuple [] )}
| _1 = LEFTBRC _2 = field_list1_term_ _3 = RIGHTBRC
    {                                                    ( Trecord _2 )}
| _1 = LEFTBRC _2 = term_arg _3 = WITH _4 = field_list1_term_ _5 = RIGHTBRC
    {                                                    ( Tupdate (_2,_4) )}

term_sub_:
  _1 = term_block_
    {                                                    ( _1 )}
| _1 = uqualid _2 = DOT _3 = mk_term_term_block__
    {                                                    ( Tscope (_1, _3) )}
| _1 = term_dot _2 = DOT _3 = lqualid_rich
    {                                                    ( Tidapp (_3,[_1]) )}
| _1 = term_arg _2 = LEFTSQ _3 = term _4 = rightsq
    {    ( Tidapp (get_op _4 _startpos__2_ _endpos__2_, [_1;_3]) )}
| _1 = term_arg _2 = LEFTSQ _3 = term _4 = LARROW _5 = term _6 = rightsq
    {    ( Tidapp (upd_op _6 _startpos__2_ _endpos__2_, [_1;_3;_5]) )}
| _1 = term_arg _2 = LEFTSQ _3 = term _4 = DOTDOT _5 = term _6 = rightsq
    {    ( Tidapp (cut_op _6 _startpos__2_ _endpos__2_, [_1;_3;_5]) )}
| _1 = term_arg _2 = LEFTSQ _3 = term _4 = DOTDOT _5 = rightsq
    {    ( Tidapp (rcut_op _5 _startpos__2_ _endpos__2_, [_1;_3]) )}
| _1 = term_arg _2 = LEFTSQ _3 = DOTDOT _4 = term _5 = rightsq
    {    ( Tidapp (lcut_op _5 _startpos__2_ _endpos__2_, [_1;_4]) )}

field_list1_expr_:
  fl = semicolon_list1_separated_pair_lqualid_EQUAL_expr__
    {                                                          ( fl )}

field_list1_pattern_:
  fl = semicolon_list1_separated_pair_lqualid_EQUAL_pattern__
    {                                                          ( fl )}

field_list1_term_:
  fl = semicolon_list1_separated_pair_lqualid_EQUAL_term__
    {                                                          ( fl )}

match_cases_term_:
  cl = bar_list1_match_case_term__
    {                                ( cl )}

match_case_seq_expr_:
  x = pattern _2 = ARROW y = seq_expr
    {let mc =     ( (x, y) ) in
                                         ( mc )}

match_case_term_:
  x = pattern _2 = ARROW y = term
    {let mc =     ( (x, y) ) in
                                         ( mc )}

quant_vars:
  _1 = nonempty_list_binder_var_ _2 = option_cast_
    {                    ( List.map (fun (l,i) -> l, i, false, _2) _1 )}

triggers:
  
    {                                                                        ( [] )}
| _1 = LEFTSQ _2 = separated_nonempty_list_BAR_comma_list1_single_term__ _3 = RIGHTSQ
    {                                                                        ( _2 )}

quant:
  _1 = FORALL
    {          ( Dterm.DTforall )}
| _1 = EXISTS
    {          ( Dterm.DTexists )}

numeral:
  _1 = INTEGER
    {          ( Number.ConstInt (mk_int_const false _1) )}
| _1 = REAL
    {          ( Number.ConstReal (mk_real_const false _1) )}

prog_decl:
  _1 = VAL _2 = ghost _3 = kind _4 = attrs_lident_rich_ _5 = mk_expr_val_defn_
    {                                                      ( Dlet (add_model_trace_attr _4, _2, _3, _5) )}
| _1 = LET _2 = ghost _3 = kind _4 = attrs_lident_rich_ _5 = mk_expr_fun_defn_
    {                                                      ( Dlet (_4, _2, _3, _5) )}
| _1 = LET _2 = ghost _3 = kind _4 = attrs_lident_rich_ _5 = const_defn
    {                                                      ( Dlet (_4, _2, _3, _5) )}
| _1 = LET _2 = REC _3 = with_list1_rec_defn_
    {                                                      ( Drec _3 )}
| _1 = EXCEPTION _2 = attrs_uident_nq_
    {                                    ( Dexn (_2, PTtuple [], Ity.MaskVisible) )}
| _1 = EXCEPTION _2 = attrs_uident_nq_ _3 = return
    {                                    ( Dexn (_2, fst _3, snd _3) )}

ghost:
  
    {                ( false )}
| _1 = GHOST
    {                ( true )}

kind:
  
    {                ( Expr.RKnone )}
| _1 = FUNCTION
    {                ( Expr.RKfunc )}
| _1 = CONSTANT
    {                ( Expr.RKfunc )}
| _1 = PREDICATE
    {                ( Expr.RKpred )}
| _1 = LEMMA
    {                ( Expr.RKlemma )}

rec_defn:
  _1 = ghost _2 = kind _3 = attrs_lident_rich_ _4 = binders _5 = return_opt _6 = spec _7 = EQUAL _8 = spec _9 = seq_expr
    {    ( let pat, ty, mask = _5 in
      let spec = apply_return pat (spec_union _6 _8) in
      let id = mk_id return_id _startpos__7_ _endpos__7_ in
      let e = { _9 with expr_desc = Eoptexn (id, mask, _9) } in
      _3, _1, _2, _4, ty, mask, spec, e )}

fun_defn:
  _1 = binders _2 = return_opt _3 = spec _4 = EQUAL _5 = spec _6 = seq_expr
    {    ( let pat, ty, mask = _2 in
      let spec = apply_return pat (spec_union _3 _5) in
      let id = mk_id return_id _startpos__4_ _endpos__4_ in
      let e = { _6 with expr_desc = Eoptexn (id, mask, _6) } in
      Efun (List.map add_model_attrs _1, ty, mask, spec, e) )}

val_defn:
  _1 = params _2 = return_opt _3 = spec
    {    ( let pat, ty, mask = _2 in
      Eany (_1, Expr.RKnone, ty, mask, apply_return pat _3) )}

const_defn:
  _1 = cast _2 = EQUAL _3 = seq_expr
    {                        ( { _3 with expr_desc = Ecast (_3, _1) } )}
| _1 = EQUAL _2 = seq_expr
    {                        ( _2 )}

mk_expr_expr_arg__:
  d = expr_arg_
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mk_expr d _startpos _endpos )}

mk_expr_expr_block__:
  d = expr_block_
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mk_expr d _startpos _endpos )}

mk_expr_expr_dot__:
  d = expr_dot_
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mk_expr d _startpos _endpos )}

mk_expr_expr_pure__:
  d = expr_pure_
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mk_expr d _startpos _endpos )}

mk_expr_fun_defn_:
  d = fun_defn
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mk_expr d _startpos _endpos )}

mk_expr_single_expr__:
  d = single_expr_
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mk_expr d _startpos _endpos )}

mk_expr_val_defn_:
  d = val_defn
    {let _endpos = _endpos_d_ in
let _startpos = _startpos_d_ in
                  ( mk_expr d _startpos _endpos )}

seq_expr:
  _1 = contract_expr %prec below_SEMI
    {                                  ( _1 )}
| _1 = contract_expr _2 = SEMICOLON
    {                                  ( _1 )}
| _1 = contract_expr _2 = SEMICOLON _3 = seq_expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mk_expr (Esequence (_1, _3)) _startpos _endpos )}

contract_expr:
  _1 = assign_expr %prec prec_no_spec
    {                                  ( _1 )}
| _1 = assign_expr _2 = single_spec _3 = spec
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( let d = Efun ([], None, Ity.MaskVisible, spec_union _2 _3, _1) in
      let d = Eattr (ATstr Vc.wb_attr, mk_expr d _startpos _endpos) in
      mk_expr d _startpos _endpos )}

assign_expr:
  _1 = expr %prec below_LARROW
    {                                  ( _1 )}
| _1 = expr _2 = LARROW _3 = expr
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( let loc = floc _startpos _endpos in
      let rec down ll rl = match ll, rl with
        | {expr_desc = Eidapp (q, [e1])}::ll, e2::rl -> (e1,q,e2) :: down ll rl
        | {expr_desc = Eidapp (Qident id, [_;_]); expr_loc = loc}::_, _::_ ->
            begin match Ident.sn_decode id.id_str with
              | Ident.SNget _ -> Loc.errorm ~loc
                  "Parallel array assignments are not allowed"
              | _ -> Loc.errorm ~loc
                  "Invalid left expression in an assignment"
            end
        | {expr_loc = loc}::_, _::_ -> Loc.errorm ~loc
            "Invalid left expression in an assignment"
        | [], [] -> []
        | _ -> Loc.errorm ~loc "Invalid parallel assignment" in
      let d = match _1.expr_desc, _3.expr_desc with
        | Eidapp (Qident id, [e1;e2]), _ ->
            begin match Ident.sn_decode id.id_str with
              | Ident.SNget q ->
                  Eidapp (Qident {id with id_str = Ident.op_set q}, [e1;e2;_3])
              | _ -> Loc.errorm ~loc:_1.expr_loc
                  "Invalid left expression in an assignment"
            end
        | Etuple ll, Etuple rl -> Eassign (down ll rl)
        | Etuple _, _ -> Loc.errorm ~loc "Invalid parallel assignment"
        | _, _ -> Eassign (down [_1] [_3]) in
      { expr_desc = d; expr_loc = loc } )}

expr:
  _1 = single_expr %prec below_COMMA
    {                                  ( _1 )}
| _1 = single_expr _2 = COMMA _3 = expr_list1
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mk_expr (Etuple (_1::_3)) _startpos _endpos )}

expr_list1:
  _1 = single_expr %prec below_COMMA
    {                                  ( [_1] )}
| _1 = single_expr _2 = COMMA _3 = expr_list1
    {                                  ( _1::_3 )}

single_expr:
  e = mk_expr_single_expr__
    {                                        ( e )}

single_expr_:
  _1 = expr_arg_
    {    ( match _1 with (* break the infix relation chain *)
      | Einfix (l,o,r) -> Einnfix (l,o,r) | d -> d )}
| _1 = single_expr _2 = AMPAMP _3 = single_expr
    {    ( Eand (_1, _3) )}
| _1 = single_expr _2 = BARBAR _3 = single_expr
    {    ( Eor (_1, _3) )}
| _1 = NOT _2 = single_expr
    {    ( Enot _2 )}
| _1 = prefix_op _2 = single_expr %prec prec_prefix_op
    {    ( Eidapp (Qident _1, [_2]) )}
| _1 = MINUS _2 = INTEGER
    {    ( Econst (Number.ConstInt (mk_int_const true _2)) )}
| _1 = MINUS _2 = REAL
    {    ( Econst (Number.ConstReal (mk_real_const true _2)) )}
| l = single_expr o = OP1 r = single_expr
    {let o =
  let _endpos = _endpos_o_ in
  let _startpos = _startpos_o_ in
              ( mk_id (Ident.op_infix o)    _startpos _endpos )
in
    ( Einfix (l,o,r) )}
| l = single_expr _1 = EQUAL r = single_expr
    {let o =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mk_id (Ident.op_infix "=")  _startpos _endpos )
in
    ( Einfix (l,o,r) )}
| l = single_expr _1 = LTGT r = single_expr
    {let o =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mk_id (Ident.op_infix "<>") _startpos _endpos )
in
    ( Einfix (l,o,r) )}
| l = single_expr _1 = LT r = single_expr
    {let o =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mk_id (Ident.op_infix "<")  _startpos _endpos )
in
    ( Einfix (l,o,r) )}
| l = single_expr _1 = GT r = single_expr
    {let o =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mk_id (Ident.op_infix ">")  _startpos _endpos )
in
    ( Einfix (l,o,r) )}
| l = single_expr o = OP2 r = single_expr
    {let o =
  let _endpos = _endpos_o_ in
  let _startpos = _startpos_o_ in
              ( mk_id (Ident.op_infix o)    _startpos _endpos )
in
    ( Eidapp (Qident o, [l;r]) )}
| l = single_expr o = OP3 r = single_expr
    {let o =
  let _endpos = _endpos_o_ in
  let _startpos = _startpos_o_ in
              ( mk_id (Ident.op_infix o)    _startpos _endpos )
in
    ( Eidapp (Qident o, [l;r]) )}
| l = single_expr o = OP4 r = single_expr
    {let o =
  let _endpos = _endpos_o_ in
  let _startpos = _startpos_o_ in
              ( mk_id (Ident.op_infix o)    _startpos _endpos )
in
    ( Eidapp (Qident o, [l;r]) )}
| l = single_expr _1 = MINUS r = single_expr
    {let o =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
              ( mk_id (Ident.op_infix "-")  _startpos _endpos )
in
    ( Eidapp (Qident o, [l;r]) )}
| _1 = expr_arg _2 = nonempty_list_located_expr_arg__
    {let _startpos = _startpos__1_ in
    ( let join f (a,_,e) = mk_expr (Eapply (f,a)) _startpos e in
      (List.fold_left join _1 _2).expr_desc )}
| _1 = IF _2 = seq_expr _3 = THEN _4 = contract_expr _5 = ELSE _6 = contract_expr
    {    ( Eif (_2, _4, _6) )}
| _1 = IF _2 = seq_expr _3 = THEN _4 = contract_expr %prec prec_no_else
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( Eif (_2, _4, mk_expr (Etuple []) _startpos _endpos) )}
| _1 = LET _2 = ghost _3 = kind _4 = let_pattern _5 = EQUAL _6 = seq_expr _7 = IN _8 = seq_expr
    {    ( let re_pat pat d = { pat with pat_desc = d } in
      let cast e ty = { e with expr_desc = Ecast (e,ty) } in
      let rec push pat = re_pat pat (match pat.pat_desc with
        | Ptuple (p::pl) -> Ptuple (push p :: pl)
        | Pcast (p,ty) -> Pcast (push p, ty)
        | Pas (p,v,g) -> Pas (push p, v, g)
        | Por (p,q) -> Por (push p, q)
        | _ -> Pghost pat) in
      let pat = if _2 then push _4 else _4 in
      let rec unfold gh d p = match p.pat_desc with
        | Pparen p | Pscope (_,p) -> unfold gh d p
        | Pghost p -> unfold true d p
        | Pcast (p,ty) -> unfold gh (cast d ty) p
        | Ptuple [] -> unfold gh (cast d (PTtuple [])) (re_pat p Pwild)
        | Pvar id -> Elet (add_model_trace_attr id, gh, _3, d, _8)
        | Pwild -> Elet (id_anonymous p.pat_loc, gh, _3, d, _8)
        | _ when _3 = Expr.RKnone -> Ematch (d, [pat, _8], [])
        | _ -> Loc.errorm ~loc:(floc _startpos__3_ _endpos__3_)
            "illegal kind qualifier" in
      unfold false _6 pat )}
| _1 = LET _2 = ghost _3 = kind _4 = attrs_lident_op_nq_ _5 = EQUAL _6 = seq_expr _7 = IN _8 = seq_expr
    {    ( Elet (_4, _2, _3, _6, _8) )}
| _1 = LET _2 = ghost _3 = kind _4 = attrs_lident_nq_ _5 = mk_expr_fun_defn_ _6 = IN _7 = seq_expr
    {    ( Elet (_4, _2, _3, _5, _7) )}
| _1 = LET _2 = ghost _3 = kind _4 = attrs_lident_op_nq_ _5 = mk_expr_fun_defn_ _6 = IN _7 = seq_expr
    {    ( Elet (_4, _2, _3, _5, _7) )}
| _1 = LET _2 = REC _3 = with_list1_rec_defn_ _4 = IN _5 = seq_expr
    {    ( Erec (_3, _5) )}
| _1 = FUN _2 = binders _3 = spec _4 = ARROW _5 = spec _6 = seq_expr
    {    ( let id = mk_id return_id _startpos__4_ _endpos__4_ in
      let e = { _6 with expr_desc = Eoptexn (id, Ity.MaskVisible, _6) } in
      Efun (_2, None, Ity.MaskVisible, spec_union _3 _5, e) )}
| _1 = ANY _2 = return_named _3 = spec
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( let pat, ty, mask = _2 in
      let loc = floc _startpos _endpos in
      let spec = apply_return pat _3 in
      if spec.sp_writes <> [] then Loc.errorm ~loc
        "this expression should not produce side effects";
      if spec.sp_xpost <> [] then Loc.errorm ~loc
        "this expression should not raise exceptions";
      if spec.sp_alias <> [] then Loc.errorm ~loc
        "this expression cannot have alias restrictions";
      if spec.sp_diverge then Loc.errorm ~loc
        "this expression must terminate";
      let pre = pre_of_any loc ty spec.sp_post in
      let spec = { spec with sp_pre = spec.sp_pre @ pre } in
      Eany ([], Expr.RKnone, Some ty, mask, spec) )}
| _1 = VAL _2 = ghost _3 = kind _4 = attrs_lident_rich_ _5 = mk_expr_val_defn_ _6 = IN _7 = seq_expr
    {    ( Elet (_4, _2, _3, _5, _7) )}
| _1 = MATCH _2 = seq_expr _3 = WITH _4 = ext_match_cases _5 = END
    {    ( let bl, xl = _4 in Ematch (_2, bl, xl) )}
| _1 = EXCEPTION _2 = attrs_uident_ _3 = IN _4 = seq_expr
    {    ( Eexn (_2, PTtuple [], Ity.MaskVisible, _4) )}
| _1 = EXCEPTION _2 = attrs_uident_ _3 = return _4 = IN _5 = seq_expr
    {    ( Eexn (_2, fst _3, snd _3, _5) )}
| _1 = LABEL id = attrs_uident_ _3 = IN e = seq_expr
    {    ( let cont e =
        let id = { id with id_str = id.id_str ^ continue_id } in
        { e with expr_desc = Eoptexn (id, Ity.MaskVisible, e) } in
      let rec over_loop e = { e with expr_desc = over_loop_desc e }
      and over_loop_desc e = match e.expr_desc with
        | Escope (q, e1) -> Escope (q, over_loop e1)
        | Eattr (l, e1) -> Eattr (l, over_loop e1)
        | Ecast (e1, t) -> Ecast (over_loop e1, t)
        | Eghost e1 -> Eghost (over_loop e1)
        | Esequence (e1, e2) -> Esequence (over_loop e1, e2)
        | Eoptexn (id, mask, e1) -> Eoptexn (id, mask, over_loop e1)
        | Ewhile (e1, inv, var, e2) ->
            let e = { e with expr_desc = Ewhile (e1, inv, var, cont e2) } in
            let id = { id with id_str = id.id_str ^ break_id } in
            Eoptexn (id, Ity.MaskVisible, e)
        | Efor (id, ef, dir, et, inv, e1) ->
            let e = { e with expr_desc = Efor (id,ef,dir,et,inv,cont e1) } in
            let id = { id with id_str = id.id_str ^ break_id } in
            Eoptexn (id, Ity.MaskVisible, e)
        | d -> d in
      Elabel (id, over_loop e) )}
| _1 = WHILE _2 = seq_expr _3 = DO _4 = loop_annotation _5 = loop_body _6 = DONE
    {let _endpos = _endpos__6_ in
let _startpos = _startpos__1_ in
    ( let id_b = mk_id break_id _startpos__3_ _endpos__3_ in
      let id_c = mk_id continue_id _startpos__3_ _endpos__3_ in
      let e = { _5 with expr_desc = Eoptexn (id_c, Ity.MaskVisible, _5) } in
      let e = mk_expr (Ewhile (_2, fst _4, snd _4, e)) _startpos _endpos in
      Eoptexn (id_b, Ity.MaskVisible, e) )}
| _1 = FOR _2 = lident_nq _3 = EQUAL _4 = seq_expr _5 = for_direction _6 = seq_expr _7 = DO _8 = list_invariant_ _9 = loop_body _10 = DONE
    {let _endpos = _endpos__10_ in
let _startpos = _startpos__1_ in
    ( let id_b = mk_id break_id _startpos__7_ _endpos__7_ in
      let id_c = mk_id continue_id _startpos__7_ _endpos__7_ in
      let e = { _9 with expr_desc = Eoptexn (id_c, Ity.MaskVisible, _9) } in
      let id = add_model_trace_attr _2 in
      let e = mk_expr (Efor (id, _4, _5, _6, _8, e)) _startpos _endpos in
      Eoptexn (id_b, Ity.MaskVisible, e) )}
| _1 = ABSURD
    {    ( Eabsurd )}
| _1 = RAISE _2 = uqualid _3 = option_expr_arg_
    {    ( Eraise (_2, _3) )}
| _1 = RAISE _2 = LEFTPAR _3 = uqualid _4 = option_expr_arg_ _5 = RIGHTPAR
    {    ( Eraise (_3, _4) )}
| _1 = RETURN
    {let _2 =     ( None ) in
    ( let id = mk_id return_id _startpos__1_ _endpos__1_ in
      Eraise (Qident id, _2) )} [@name none_contract_expr]
| _1 = RETURN x = contract_expr
    {let _2 =     ( Some x ) in
    ( let id = mk_id return_id _startpos__1_ _endpos__1_ in
      Eraise (Qident id, _2) )} [@name some_contract_expr]
| _1 = BREAK
    {let _2 =     ( None ) in
    ( let id = match _2 with
        | Some id -> { id with id_str = id.id_str ^ break_id }
        | None -> mk_id break_id _startpos__1_ _endpos__1_ in
      Eraise (Qident id, None) )} [@name none_uident]
| _1 = BREAK x = uident
    {let _2 =     ( Some x ) in
    ( let id = match _2 with
        | Some id -> { id with id_str = id.id_str ^ break_id }
        | None -> mk_id break_id _startpos__1_ _endpos__1_ in
      Eraise (Qident id, None) )} [@name some_uident]
| _1 = CONTINUE
    {let _2 =     ( None ) in
    ( let id = match _2 with
        | Some id -> { id with id_str = id.id_str ^ continue_id }
        | None -> mk_id continue_id _startpos__1_ _endpos__1_ in
      Eraise (Qident id, None) )} [@name none_uident]
| _1 = CONTINUE x = uident
    {let _2 =     ( Some x ) in
    ( let id = match _2 with
        | Some id -> { id with id_str = id.id_str ^ continue_id }
        | None -> mk_id continue_id _startpos__1_ _endpos__1_ in
      Eraise (Qident id, None) )} [@name some_uident]
| _1 = TRY _2 = seq_expr _3 = WITH _4 = bar_list1_exn_handler_ _5 = END
    {    ( Ematch (_2, [], _4) )}
| _1 = GHOST _2 = single_expr
    {    ( Eghost _2 )}
| _1 = assertion_kind _2 = LEFTBRC _3 = term _4 = RIGHTBRC
    {    ( Eassert (_1, _3) )}
| _1 = attr _2 = single_expr %prec prec_attr
    {    ( Eattr (_1, _2) )}
| _1 = single_expr _2 = cast
    {    ( Ecast (_1, _2) )}

expr_arg:
  e = mk_expr_expr_arg__
    {                                 ( e )}

expr_dot:
  e = mk_expr_expr_dot__
    {                                 ( e )}

expr_arg_:
  _1 = qualid
    {                            ( Eident _1 )}
| _1 = numeral
    {                            ( Econst _1 )}
| _1 = TRUE
    {                            ( Etrue )}
| _1 = FALSE
    {                            ( Efalse )}
| o = OPPREF a = expr_arg
    {let o =
  let _endpos = _endpos_o_ in
  let _startpos = _startpos_o_ in
               ( mk_id (Ident.op_prefix o)  _startpos _endpos )
in
                            ( Eidapp (Qident o, [a]) )}
| _1 = expr_sub_
    {                            ( _1 )}

expr_dot_:
  _1 = lqualid
    {                            ( Eident _1 )}
| o = OPPREF a = expr_dot
    {let o =
  let _endpos = _endpos_o_ in
  let _startpos = _startpos_o_ in
               ( mk_id (Ident.op_prefix o)  _startpos _endpos )
in
                            ( Eidapp (Qident o, [a]) )}
| _1 = expr_sub_
    {                            ( _1 )}

expr_block_:
  _1 = BEGIN _2 = single_spec _3 = spec _4 = seq_expr _5 = END
    {    ( Efun ([], None, Ity.MaskVisible, spec_union _2 _3, _4) )}
| _1 = BEGIN _2 = single_spec _3 = spec _4 = END
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( let e = mk_expr (Etuple []) _startpos _endpos in
      Efun ([], None, Ity.MaskVisible, spec_union _2 _3, e) )}
| _1 = BEGIN _2 = seq_expr _3 = END
    {                                                    ( _2.expr_desc )}
| _1 = LEFTPAR _2 = seq_expr _3 = RIGHTPAR
    {                                                    ( _2.expr_desc )}
| _1 = BEGIN _2 = END
    {                                                    ( Etuple [] )}
| _1 = LEFTPAR _2 = RIGHTPAR
    {                                                    ( Etuple [] )}
| _1 = LEFTBRC _2 = field_list1_expr_ _3 = RIGHTBRC
    {                                                    ( Erecord _2 )}
| _1 = LEFTBRC _2 = expr_arg _3 = WITH _4 = field_list1_expr_ _5 = RIGHTBRC
    {                                                    ( Eupdate (_2, _4) )}

expr_pure_:
  _1 = LEFTBRC _2 = qualid _3 = RIGHTBRC
    {                                                    ( Eidpur _2 )}
| _1 = uqualid _2 = DOT _3 = LEFTBRC _4 = ident _5 = RIGHTBRC
    {                                                    ( Eidpur (Qdot (_1, _4)) )}

expr_sub_:
  _1 = expr_block_
    {                                                    ( _1 )}
| _1 = expr_pure_
    {                                                    ( _1 )}
| _1 = uqualid _2 = DOT _3 = mk_expr_expr_block__
    {                                                    ( Escope (_1, _3) )}
| _1 = expr_dot _2 = DOT _3 = mk_expr_expr_pure__
    {                                                    ( Eapply (_3, _1) )}
| _1 = expr_dot _2 = DOT _3 = lqualid_rich
    {                                                    ( Eidapp (_3, [_1]) )}
| _1 = PURE _2 = LEFTBRC _3 = term _4 = RIGHTBRC
    {                                                    ( Epure _3 )}
| _1 = expr_arg _2 = LEFTSQ _3 = expr _4 = rightsq
    {    ( Eidapp (get_op _4 _startpos__2_ _endpos__2_, [_1;_3]) )}
| _1 = expr_arg _2 = LEFTSQ _3 = expr _4 = LARROW _5 = expr _6 = rightsq
    {    ( Eidapp (upd_op _6 _startpos__2_ _endpos__2_, [_1;_3;_5]) )}
| _1 = expr_arg _2 = LEFTSQ _3 = expr _4 = DOTDOT _5 = expr _6 = rightsq
    {    ( Eidapp (cut_op _6 _startpos__2_ _endpos__2_, [_1;_3;_5]) )}
| _1 = expr_arg _2 = LEFTSQ _3 = expr _4 = DOTDOT _5 = rightsq
    {    ( Eidapp (rcut_op _5 _startpos__2_ _endpos__2_, [_1;_3]) )}
| _1 = expr_arg _2 = LEFTSQ _3 = DOTDOT _4 = expr _5 = rightsq
    {    ( Eidapp (lcut_op _5 _startpos__2_ _endpos__2_, [_1;_4]) )}

loop_body:
  
    {let _endpos = _endpos__0_ in
let _startpos = _endpos__0_ in
                  ( mk_expr (Etuple []) _startpos _endpos )}
| _1 = seq_expr
    {                  ( _1 )}

loop_annotation:
  
    {    ( [], [] )}
| _1 = invariant _2 = loop_annotation
    {    ( let inv, var = _2 in _1 :: inv, var )}
| _1 = variant _2 = loop_annotation
    {    ( let inv, var = _2 in inv, variant_union _1 var )}

ext_match_cases:
  _2 = ext_match_cases1
    {let _1 =     ( None ) in
                                 ( _2 )} [@name none_BAR]
| x = BAR _2 = ext_match_cases1
    {let _1 =     ( Some x ) in
                                 ( _2 )} [@name some_BAR]

ext_match_cases1:
  _1 = match_case_seq_expr_ _2 = ext_match_cases0
    {                                          ( let bl,xl = _2 in _1::bl, xl )}
| _1 = EXCEPTION _2 = exn_handler _3 = ext_match_cases0
    {                                          ( let bl,xl = _3 in bl, _2::xl )}

ext_match_cases0:
  
    {                        ( [], [] )}
| _1 = BAR _2 = ext_match_cases1
    {                        ( _2 )}

exn_handler:
  _1 = uqualid _2 = option_pat_arg_ _3 = ARROW _4 = seq_expr
    {                                  ( _1, _2, _4 )}

assertion_kind:
  _1 = ASSERT
    {          ( Expr.Assert )}
| _1 = ASSUME
    {          ( Expr.Assume )}
| _1 = CHECK
    {          ( Expr.Check )}

for_direction:
  _1 = TO
    {          ( Expr.To )}
| _1 = DOWNTO
    {          ( Expr.DownTo )}

spec:
   %prec prec_no_spec
    {                                    ( empty_spec )}
| _1 = single_spec _2 = spec
    {                                    ( spec_union _1 _2 )}

single_spec:
  _1 = REQUIRES _2 = LEFTBRC _3 = term _4 = RIGHTBRC
    {    ( { empty_spec with sp_pre = [_3] } )}
| _1 = ENSURES _2 = LEFTBRC _3 = ensures _4 = RIGHTBRC
    {    ( { empty_spec with sp_post = [floc _startpos__3_ _endpos__3_, _3] } )}
| _1 = RETURNS _2 = LEFTBRC _3 = match_cases_term_ _4 = RIGHTBRC
    {    ( { empty_spec with sp_post = [floc _startpos__3_ _endpos__3_, _3] } )}
| _1 = RAISES _2 = LEFTBRC _3 = bar_list1_raises_ _4 = RIGHTBRC
    {    ( { empty_spec with sp_xpost = [floc _startpos__3_ _endpos__3_, _3] } )}
| _1 = READS _2 = LEFTBRC _3 = comma_list0_lqualid_ _4 = RIGHTBRC
    {    ( { empty_spec with sp_reads = _3; sp_checkrw = true } )}
| _1 = WRITES _2 = LEFTBRC _3 = comma_list0_single_term_ _4 = RIGHTBRC
    {    ( { empty_spec with sp_writes = _3; sp_checkrw = true } )}
| _1 = ALIAS _2 = LEFTBRC _3 = comma_list0_alias_ _4 = RIGHTBRC
    {    ( { empty_spec with sp_alias = _3; sp_checkrw = true } )}
| _1 = RAISES _2 = LEFTBRC _3 = comma_list1_xsymbol_ _4 = RIGHTBRC
    {    ( { empty_spec with sp_xpost = [floc _startpos__3_ _endpos__3_, _3] } )}
| _1 = DIVERGES
    {    ( { empty_spec with sp_diverge = true } )}
| _1 = variant
    {    ( { empty_spec with sp_variant = _1 } )}

alias:
  _1 = term _2 = WITH _3 = term
    {                  ( _1, _3 )}

ensures:
  _1 = term
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
    ( let id = mk_id "result" _startpos _endpos in
      [mk_pat (Pvar id) _startpos _endpos, _1] )}

raises:
  _1 = uqualid _2 = ARROW _3 = term
    {    ( _1, Some (mk_pat (Ptuple []) _startpos__1_ _endpos__1_, _3) )}
| _1 = uqualid _2 = pat_arg _3 = ARROW _4 = term
    {    ( _1, Some (_2, _4) )}

xsymbol:
  _1 = uqualid
    {          ( _1, None )}

invariant:
  _1 = INVARIANT _2 = LEFTBRC _3 = term _4 = RIGHTBRC
    {                                  ( _3 )}

variant:
  _1 = VARIANT _2 = LEFTBRC _3 = comma_list1_single_variant_ _4 = RIGHTBRC
    {                                                       ( _3 )}

single_variant:
  _1 = single_term _2 = option_preceded_WITH_lqualid__
    {                                       ( _1, _2 )}

return_opt:
  
    {let _endpos = _endpos__0_ in
let _startpos = _endpos__0_ in
                      ( mk_pat Pwild _startpos _endpos, None, Ity.MaskVisible )}
| _1 = COLON _2 = return_named
    {                      ( let pat, ty, mask = _2 in pat, Some ty, mask )}

return_named:
  _1 = LEFTPAR _2 = ret_cast _3 = RIGHTPAR
    {    ( _2 )}
| _1 = LEFTPAR _2 = comma_list2_ret_cast_ _3 = RIGHTPAR
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mk_pat (Ptuple (List.map (fun (pat,_,_) -> pat) _2)) _startpos _endpos,
      PTtuple (List.map (fun (_,ty,_) -> ty) _2),
      Ity.MaskTuple (List.map (fun (_,_,mask) -> mask) _2) )}
| _1 = return
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
    ( let ty, mask = _1 in mk_pat Pwild _startpos _endpos, ty, mask )}

ret_cast:
  _1 = ret_ident _2 = cast
    {                        ( _1, _2, Ity.MaskVisible )}
| _1 = GHOST _2 = ret_ident _3 = cast
    {                        ( _2, _3, Ity.MaskGhost )}

ret_ident:
  id = attrs_lident_nq_
    {let _endpos = _endpos_id_ in
let _startpos = _startpos_id_ in
    ( let ats = ATstr Dterm.attr_w_unused_var_no :: id.id_ats in
      mk_pat (Pvar {id with id_ats = ats}) _startpos _endpos )}
| _1 = UNDERSCORE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
    ( mk_pat Pwild _startpos _endpos )}

return:
  _1 = ty
    {                              ( _1, Ity.MaskVisible )}
| _1 = GHOST _2 = ty
    {                              ( _2, Ity.MaskGhost )}
| _1 = LEFTPAR _2 = GHOST _3 = ty _4 = RIGHTPAR
    {                              ( _3, Ity.MaskGhost )}
| _1 = LEFTPAR _2 = ret_ghost _3 = RIGHTPAR
    {                              ( PTtuple (fst _2), Ity.MaskTuple (snd _2) )}

ret_ghost:
  _1 = ty _2 = COMMA _3 = GHOST _4 = ty
    {                              ( [_1; _4], [Ity.MaskVisible; Ity.MaskGhost] )}
| _1 = ty _2 = COMMA _3 = ret_ghost
    {                              ( _1::fst _3, Ity.MaskVisible::snd _3 )}
| _1 = GHOST _2 = ty _3 = COMMA _4 = ret_rest
    {                              ( _2::fst _4, Ity.MaskGhost::snd _4 )}

ret_rest:
  _1 = ty _2 = COMMA _3 = ret_rest
    {                              ( _1::fst _3, Ity.MaskVisible::snd _3 )}
| _1 = GHOST _2 = ty _3 = COMMA _4 = ret_rest
    {                              ( _2::fst _4, Ity.MaskGhost::snd _4 )}
| _1 = ty
    {                              ( [_1], [Ity.MaskVisible] )}
| _1 = GHOST _2 = ty
    {                              ( [_2], [Ity.MaskGhost] )}

mk_pat_let_pat_conj__:
  _1 = let_pat_conj_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mk_pat _1 _startpos _endpos )}

mk_pat_let_pat_uni__:
  _1 = let_pat_uni_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mk_pat _1 _startpos _endpos )}

mk_pat_let_pattern__:
  _1 = let_pattern_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mk_pat _1 _startpos _endpos )}

mk_pat_pat_arg__:
  _1 = pat_arg_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mk_pat _1 _startpos _endpos )}

mk_pat_pat_block__:
  _1 = pat_block_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mk_pat _1 _startpos _endpos )}

mk_pat_pat_conj__:
  _1 = pat_conj_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mk_pat _1 _startpos _endpos )}

mk_pat_pat_uni__:
  _1 = pat_uni_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mk_pat _1 _startpos _endpos )}

mk_pat_pattern__:
  _1 = pattern_
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
             ( mk_pat _1 _startpos _endpos )}

pattern:
  _1 = mk_pat_pattern__
    {                          ( _1 )}

pat_arg:
  _1 = mk_pat_pat_arg__
    {                          ( _1 )}

pattern_:
  _1 = pat_conj_
    {                                        ( _1 )}
| _1 = mk_pat_pat_conj__ _2 = BAR _3 = pattern
    {                                        ( Por (_1,_3) )}

pat_conj_:
  _1 = pat_uni_
    {                                        ( _1 )}
| _1 = comma_list2_mk_pat_pat_uni___
    {                                        ( Ptuple _1 )}

pat_uni_:
  _1 = pat_arg_
    {                                        ( _1 )}
| _1 = uqualid _2 = nonempty_list_pat_arg_
    {                                        ( Papp (_1,_2) )}
| _1 = GHOST _2 = mk_pat_pat_uni__
    {                                        ( Pghost _2 )}
| _1 = mk_pat_pat_uni__ _2 = AS _3 = ghost _4 = attrs_lident_nq_
    {                                        ( Pas (_1,add_model_trace_attr _4,_3) )}
| _1 = mk_pat_pat_uni__ _2 = cast
    {                                        ( Pcast (_1,_2) )}

pat_arg_:
  _1 = UNDERSCORE
    {                                        ( Pwild )}
| _1 = attrs_lident_nq_
    {                                        ( Pvar (add_model_trace_attr _1) )}
| _1 = uqualid
    {                                        ( Papp (_1,[]) )}
| _1 = uqualid _2 = DOT _3 = mk_pat_pat_block__
    {                                        ( Pscope (_1,_3) )}
| _1 = pat_block_
    {                                        ( _1 )}

pat_block_:
  _1 = LEFTPAR _2 = RIGHTPAR
    {                                        ( Ptuple [] )}
| _1 = LEFTPAR _2 = pattern _3 = RIGHTPAR
    {                                        ( Pparen _2 )}
| _1 = LEFTBRC _2 = field_list1_pattern_ _3 = RIGHTBRC
    {                                        ( Prec _2 )}

let_pattern:
  _1 = mk_pat_let_pattern__
    {                                  ( _1 )}

let_pattern_:
  _1 = let_pat_conj_
    {                                        ( _1 )}
| _1 = mk_pat_let_pat_conj__ _2 = BAR _3 = pattern
    {                                        ( Por (_1,_3) )}

let_pat_conj_:
  _1 = let_pat_uni_
    {                                        ( _1 )}
| _1 = mk_pat_let_pat_uni__ _2 = COMMA _3 = comma_list1_mk_pat_pat_uni___
    {                                        ( Ptuple (_1::_3) )}

let_pat_uni_:
  _1 = pat_arg_
    {                                        ( _1 )}
| _1 = uqualid _2 = nonempty_list_pat_arg_
    {                                        ( Papp (_1,_2) )}
| _1 = mk_pat_let_pat_uni__ _2 = AS _3 = ghost _4 = attrs_lident_nq_
    {                                        ( Pas (_1,add_model_trace_attr _4,_3) )}
| _1 = mk_pat_let_pat_uni__ _2 = cast
    {                                        ( Pcast (_1,_2) )}

qualid:
  _1 = ident
    {                          ( Qident _1 )}
| _1 = uqualid _2 = DOT _3 = ident
    {                          ( Qdot (_1, _3) )}

uqualid:
  _1 = uident
    {                          ( Qident _1 )}
| _1 = uqualid _2 = DOT _3 = uident
    {                          ( Qdot (_1, _3) )}

lqualid:
  _1 = lident
    {                          ( Qident _1 )}
| _1 = uqualid _2 = DOT _3 = lident
    {                          ( Qdot (_1, _3) )}

lqualid_rich:
  _1 = lident
    {                          ( Qident _1 )}
| _1 = lident_op
    {                          ( Qident _1 )}
| _1 = uqualid _2 = DOT _3 = lident
    {                          ( Qdot (_1, _3) )}
| _1 = uqualid _2 = DOT _3 = lident_op
    {                          ( Qdot (_1, _3) )}

tqualid:
  _1 = uident
    {                          ( Qident _1 )}
| _1 = squalid _2 = DOT _3 = uident
    {                          ( Qdot (_1, _3) )}

squalid:
  _1 = sident
    {                          ( Qident _1 )}
| _1 = squalid _2 = DOT _3 = sident
    {                          ( Qdot (_1, _3) )}

ident:
  _1 = uident
    {                  ( _1 )}
| _1 = lident
    {                  ( _1 )}
| _1 = lident_op
    {                  ( _1 )}

ident_nq:
  _1 = uident_nq
    {                  ( _1 )}
| _1 = lident_nq
    {                  ( _1 )}
| _1 = lident_op_nq
    {                  ( _1 )}

lident_rich:
  _1 = lident_nq
    {                  ( _1 )}
| _1 = lident_op_nq
    {                  ( _1 )}

uident:
  _1 = UIDENT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                  ( mk_id _1 _startpos _endpos )}
| _1 = CORE_UIDENT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                  ( mk_id _1 _startpos _endpos )}

uident_nq:
  _1 = UIDENT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                  ( mk_id _1 _startpos _endpos )}
| _1 = CORE_UIDENT
    {                  ( let loc = floc _startpos__1_ _endpos__1_ in
                    Loc.errorm ~loc "Symbol %s cannot be user-defined" _1 )}

lident:
  _1 = LIDENT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                  ( mk_id _1 _startpos _endpos )}
| _1 = lident_keyword
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                  ( mk_id _1 _startpos _endpos )}
| _1 = CORE_LIDENT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                  ( mk_id _1 _startpos _endpos )}

lident_nq:
  _1 = LIDENT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                  ( mk_id _1 _startpos _endpos )}
| _1 = lident_keyword
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                  ( mk_id _1 _startpos _endpos )}
| _1 = CORE_LIDENT
    {                  ( let loc = floc _startpos__1_ _endpos__1_ in
                    Loc.errorm ~loc "Symbol %s cannot be user-defined" _1 )}

lident_keyword:
  _1 = RANGE
    {                  ( "range" )}
| _1 = FLOAT
    {                  ( "float" )}

sident:
  _1 = lident
    {                  ( _1 )}
| _1 = uident
    {                  ( _1 )}
| _1 = STRING
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                  ( mk_id _1 _startpos _endpos )}

quote_lident:
  _1 = QUOTE_LIDENT
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
                  ( mk_id _1 _startpos _endpos )}

lident_op:
  _1 = LEFTPAR _2 = lident_op_str _3 = RIGHTPAR
    {    ( mk_id _2 _startpos__2_ _endpos__2_ )}
| _1 = LEFTPAR _2 = lident_op_str _3 = RIGHTPAR_USCORE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mk_id (_2^_3) _startpos _endpos )}
| _1 = LEFTPAR _2 = lident_op_str _3 = RIGHTPAR_QUOTE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mk_id (_2^_3) _startpos _endpos )}

lident_op_nq:
  _1 = LEFTPAR _2 = lident_op_str _3 = RIGHTPAR
    {    ( mk_id _2 _startpos__2_ _endpos__2_ )}
| _1 = LEFTPAR _2 = lident_op_str _3 = RIGHTPAR_USCORE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mk_id (_2^_3) _startpos _endpos )}
| _1 = LEFTPAR _2 = lident_op_str _3 = RIGHTPAR_QUOTE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( let loc = floc _startpos _endpos in
      Loc.errorm ~loc "Symbol (%s)%s cannot be user-defined" _2 _3 )}

lident_op_str:
  _1 = op_symbol
    {                                    ( Ident.op_infix _1 )}
| _1 = op_symbol _2 = UNDERSCORE
    {                                    ( Ident.op_prefix _1 )}
| _1 = MINUS _2 = UNDERSCORE
    {                                    ( Ident.op_prefix "-" )}
| _1 = EQUAL
    {                                    ( Ident.op_infix "=" )}
| _1 = MINUS
    {                                    ( Ident.op_infix "-" )}
| _1 = OPPREF _2 = option_UNDERSCORE_
    {                                    ( Ident.op_prefix _1 )}
| _1 = LEFTSQ _2 = rightsq
    {                                    ( Ident.op_get _2 )}
| _1 = LEFTSQ _2 = rightsq _3 = LARROW
    {                                    ( Ident.op_set _2 )}
| _1 = LEFTSQ _2 = LARROW _3 = rightsq
    {                                    ( Ident.op_update _3 )}
| _1 = LEFTSQ _2 = DOTDOT _3 = rightsq
    {                                    ( Ident.op_cut _3 )}
| _1 = LEFTSQ _2 = UNDERSCORE _3 = DOTDOT _4 = rightsq
    {                                    ( Ident.op_rcut _4 )}
| _1 = LEFTSQ _2 = DOTDOT _3 = UNDERSCORE _4 = rightsq
    {                                    ( Ident.op_lcut _4 )}

rightsq:
  _1 = RIGHTSQ
    {                  ( "" )}
| _1 = RIGHTSQ_QUOTE
    {                  ( _1 )}

op_symbol:
  _1 = OP1
    {      ( _1 )}
| _1 = OP2
    {      ( _1 )}
| _1 = OP3
    {      ( _1 )}
| _1 = OP4
    {      ( _1 )}
| _1 = LT
    {      ( "<" )}
| _1 = GT
    {      ( ">" )}

prefix_op:
  _1 = op_symbol
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mk_id (Ident.op_prefix _1)  _startpos _endpos )}
| _1 = MINUS
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
            ( mk_id (Ident.op_prefix "-") _startpos _endpos )}

attrs_ident_nq_:
  _1 = ident_nq _2 = list_attr_
    {                  ( add_attr _1 _2 )}

attrs_lident_nq_:
  _1 = lident_nq _2 = list_attr_
    {                  ( add_attr _1 _2 )}

attrs_lident_op_nq_:
  _1 = lident_op_nq _2 = list_attr_
    {                  ( add_attr _1 _2 )}

attrs_lident_rich_:
  _1 = lident_rich _2 = list_attr_
    {                  ( add_attr _1 _2 )}

attrs_quote_lident_:
  _1 = quote_lident _2 = list_attr_
    {                  ( add_attr _1 _2 )}

attrs_uident_:
  _1 = uident _2 = list_attr_
    {                  ( add_attr _1 _2 )}

attrs_uident_nq_:
  _1 = uident_nq _2 = list_attr_
    {                  ( add_attr _1 _2 )}

attr:
  _1 = ATTRIBUTE
    {            ( ATstr (Ident.create_attribute _1) )}
| _1 = POSITION
    {            ( ATpos _1 )}

bar_list1_exn_handler_:
  xl = separated_nonempty_list_BAR_exn_handler_
    {let _1 =     ( None ) in
                                                      ( xl )} [@name none_BAR]
| x = BAR xl = separated_nonempty_list_BAR_exn_handler_
    {let _1 =     ( Some x ) in
                                                      ( xl )} [@name some_BAR]

bar_list1_ind_case_:
  xl = separated_nonempty_list_BAR_ind_case_
    {let _1 =     ( None ) in
                                                      ( xl )} [@name none_BAR]
| x = BAR xl = separated_nonempty_list_BAR_ind_case_
    {let _1 =     ( Some x ) in
                                                      ( xl )} [@name some_BAR]

bar_list1_match_case_term__:
  xl = separated_nonempty_list_BAR_match_case_term__
    {let _1 =     ( None ) in
                                                      ( xl )} [@name none_BAR]
| x = BAR xl = separated_nonempty_list_BAR_match_case_term__
    {let _1 =     ( Some x ) in
                                                      ( xl )} [@name some_BAR]

bar_list1_raises_:
  xl = separated_nonempty_list_BAR_raises_
    {let _1 =     ( None ) in
                                                      ( xl )} [@name none_BAR]
| x = BAR xl = separated_nonempty_list_BAR_raises_
    {let _1 =     ( Some x ) in
                                                      ( xl )} [@name some_BAR]

bar_list1_type_case_:
  xl = separated_nonempty_list_BAR_type_case_
    {let _1 =     ( None ) in
                                                      ( xl )} [@name none_BAR]
| x = BAR xl = separated_nonempty_list_BAR_type_case_
    {let _1 =     ( Some x ) in
                                                      ( xl )} [@name some_BAR]

with_list1_inductive_decl_:
  _1 = separated_nonempty_list_WITH_inductive_decl_
    {                                    ( _1 )}

with_list1_rec_defn_:
  _1 = separated_nonempty_list_WITH_rec_defn_
    {                                    ( _1 )}

with_list1_type_decl_:
  _1 = separated_nonempty_list_WITH_type_decl_
    {                                    ( _1 )}

comma_list2_mk_pat_pat_uni___:
  _1 = mk_pat_pat_uni__ _2 = COMMA _3 = comma_list1_mk_pat_pat_uni___
    {                         ( _1 :: _3 )}

comma_list2_ret_cast_:
  _1 = ret_cast _2 = COMMA _3 = comma_list1_ret_cast_
    {                         ( _1 :: _3 )}

comma_list2_ty_:
  _1 = ty _2 = COMMA _3 = comma_list1_ty_
    {                         ( _1 :: _3 )}

comma_list1_ident_:
  _1 = separated_nonempty_list_COMMA_ident_
    {                                    ( _1 )}

comma_list1_meta_arg_:
  _1 = separated_nonempty_list_COMMA_meta_arg_
    {                                    ( _1 )}

comma_list1_mk_pat_pat_uni___:
  _1 = separated_nonempty_list_COMMA_mk_pat_pat_uni___
    {                                    ( _1 )}

comma_list1_qualid_:
  _1 = separated_nonempty_list_COMMA_qualid_
    {                                    ( _1 )}

comma_list1_quant_vars_:
  _1 = separated_nonempty_list_COMMA_quant_vars_
    {                                    ( _1 )}

comma_list1_ret_cast_:
  _1 = separated_nonempty_list_COMMA_ret_cast_
    {                                    ( _1 )}

comma_list1_single_clone_subst_:
  _1 = separated_nonempty_list_COMMA_single_clone_subst_
    {                                    ( _1 )}

comma_list1_single_term_:
  _1 = separated_nonempty_list_COMMA_single_term_
    {                                    ( _1 )}

comma_list1_single_variant_:
  _1 = separated_nonempty_list_COMMA_single_variant_
    {                                    ( _1 )}

comma_list1_ty_:
  _1 = separated_nonempty_list_COMMA_ty_
    {                                    ( _1 )}

comma_list1_use_as_:
  _1 = separated_nonempty_list_COMMA_use_as_
    {                                    ( _1 )}

comma_list1_xsymbol_:
  _1 = separated_nonempty_list_COMMA_xsymbol_
    {                                    ( _1 )}

comma_list0_alias_:
  xs = loption_separated_nonempty_list_COMMA_alias__
    {let xl =     ( xs ) in
                                ( xl )}

comma_list0_lqualid_:
  xs = loption_separated_nonempty_list_COMMA_lqualid__
    {let xl =     ( xs ) in
                                ( xl )}

comma_list0_single_term_:
  xs = loption_separated_nonempty_list_COMMA_single_term__
    {let xl =     ( xs ) in
                                ( xl )}

semicolon_list1_separated_pair_lqualid_EQUAL_expr__:
  x = lqualid _2_inlined1 = EQUAL y = expr
    {let _2 =     ( None ) in
let x =     ( (x, y) ) in
                                              ( [x] )} [@name none_SEMICOLON]
| x = lqualid _2_inlined1 = EQUAL y = expr x_inlined1 = SEMICOLON
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
let x =     ( (x, y) ) in
                                              ( [x] )} [@name some_SEMICOLON]
| x = lqualid _2_inlined1 = EQUAL y = expr _2 = SEMICOLON xl = semicolon_list1_separated_pair_lqualid_EQUAL_expr__
    {let x =     ( (x, y) ) in
                                              ( x :: xl )}

semicolon_list1_separated_pair_lqualid_EQUAL_pattern__:
  x = lqualid _2_inlined1 = EQUAL y = pattern
    {let _2 =     ( None ) in
let x =     ( (x, y) ) in
                                              ( [x] )} [@name none_SEMICOLON]
| x = lqualid _2_inlined1 = EQUAL y = pattern x_inlined1 = SEMICOLON
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
let x =     ( (x, y) ) in
                                              ( [x] )} [@name some_SEMICOLON]
| x = lqualid _2_inlined1 = EQUAL y = pattern _2 = SEMICOLON xl = semicolon_list1_separated_pair_lqualid_EQUAL_pattern__
    {let x =     ( (x, y) ) in
                                              ( x :: xl )}

semicolon_list1_separated_pair_lqualid_EQUAL_term__:
  x = lqualid _2_inlined1 = EQUAL y = term
    {let _2 =     ( None ) in
let x =     ( (x, y) ) in
                                              ( [x] )} [@name none_SEMICOLON]
| x = lqualid _2_inlined1 = EQUAL y = term x_inlined1 = SEMICOLON
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
let x =     ( (x, y) ) in
                                              ( [x] )} [@name some_SEMICOLON]
| x = lqualid _2_inlined1 = EQUAL y = term _2 = SEMICOLON xl = semicolon_list1_separated_pair_lqualid_EQUAL_term__
    {let x =     ( (x, y) ) in
                                              ( x :: xl )}

semicolon_list1_type_field_:
  x = type_field
    {let _2 =     ( None ) in
                                              ( [x] )} [@name none_SEMICOLON]
| x = type_field x_inlined1 = SEMICOLON
    {let _2 =
  let x = x_inlined1 in
      ( Some x )
in
                                              ( [x] )} [@name some_SEMICOLON]
| x = type_field _2 = SEMICOLON xl = semicolon_list1_type_field_
    {                                              ( x :: xl )}

located_expr_arg_:
  _1 = expr_arg
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
              ( _1, _startpos, _endpos )}

located_term_arg_:
  _1 = term_arg
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
              ( _1, _startpos, _endpos )}

qualid_eof:
  _1 = qualid _2 = EOF
    {             ( _1 )}

qualid_comma_list_eof:
  _1 = comma_list1_qualid_ _2 = EOF
    {                          ( _1 )}

ident_comma_list_eof:
  _1 = comma_list1_ident_ _2 = EOF
    {                         ( _1 )}

term_comma_list_eof:
  _1 = comma_list1_single_term_ _2 = EOF
    {                               ( _1 )}

%%
