State 0:
## Known stack suffix:
##
## LR(1) items:
expr' -> . expr [ # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On relational_expr shift to state 42
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On or_expr shift to state 91
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On expr shift to state 92
-- On equality_expr shift to state 66
-- On axis_specifier shift to state 26
-- On and_expr shift to state 77
-- On additive_expr shift to state 69
-- On absolute_location_path shift to state 48
## Reductions:

State 1:
## Known stack suffix:
## VAR
## LR(1) items:
primary_expr -> VAR . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production primary_expr -> VAR
-- On RPAREN reduce production primary_expr -> VAR
-- On RBRACKET reduce production primary_expr -> VAR
-- On PLUS reduce production primary_expr -> VAR
-- On PIPE reduce production primary_expr -> VAR
-- On OR reduce production primary_expr -> VAR
-- On NOTEQUAL reduce production primary_expr -> VAR
-- On MUL reduce production primary_expr -> VAR
-- On MOD reduce production primary_expr -> VAR
-- On MINUS reduce production primary_expr -> VAR
-- On LTE reduce production primary_expr -> VAR
-- On LT reduce production primary_expr -> VAR
-- On LBRACKET reduce production primary_expr -> VAR
-- On GTE reduce production primary_expr -> VAR
-- On GT reduce production primary_expr -> VAR
-- On EQUAL reduce production primary_expr -> VAR
-- On DOUBLESLASH reduce production primary_expr -> VAR
-- On DIV reduce production primary_expr -> VAR
-- On COMMA reduce production primary_expr -> VAR
-- On AND reduce production primary_expr -> VAR
-- On # reduce production primary_expr -> VAR
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production primary_expr -> VAR
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 2:
## Known stack suffix:
## SLASH
## LR(1) items:
absolute_location_path -> SLASH . [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
absolute_location_path -> SLASH . relative_location_path [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 90
-- On node_test shift to state 25
-- On axis_specifier shift to state 26
## Reductions:
-- On RPAREN reduce production absolute_location_path -> SLASH
-- On RBRACKET reduce production absolute_location_path -> SLASH
-- On PLUS reduce production absolute_location_path -> SLASH
-- On PIPE reduce production absolute_location_path -> SLASH
-- On OR reduce production absolute_location_path -> SLASH
-- On NOTEQUAL reduce production absolute_location_path -> SLASH
-- On MUL reduce production absolute_location_path -> SLASH
-- On MOD reduce production absolute_location_path -> SLASH
-- On MINUS reduce production absolute_location_path -> SLASH
-- On LTE reduce production absolute_location_path -> SLASH
-- On LT reduce production absolute_location_path -> SLASH
-- On GTE reduce production absolute_location_path -> SLASH
-- On GT reduce production absolute_location_path -> SLASH
-- On EQUAL reduce production absolute_location_path -> SLASH
-- On DIV reduce production absolute_location_path -> SLASH
-- On COMMA reduce production absolute_location_path -> SLASH
-- On AND reduce production absolute_location_path -> SLASH
-- On # reduce production absolute_location_path -> SLASH
** End-of-stream conflict on RPAREN RBRACKET PLUS PIPE OR NOTEQUAL NODE_TYPE NAME_TEST MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLEDOT DOT DIV COMMA AXIS AT AND
**   There is a tension between
**   (1) reducing production absolute_location_path -> SLASH
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 3:
## Known stack suffix:
## NODE_TYPE
## LR(1) items:
node_test -> NODE_TYPE . RPAREN [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
node_test -> NODE_TYPE . LITERAL RPAREN [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On RPAREN shift to state 4
-- On LITERAL shift to state 5
## Reductions:

State 4:
## Known stack suffix:
## NODE_TYPE RPAREN
## LR(1) items:
node_test -> NODE_TYPE RPAREN . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production node_test -> NODE_TYPE RPAREN
-- On RPAREN reduce production node_test -> NODE_TYPE RPAREN
-- On RBRACKET reduce production node_test -> NODE_TYPE RPAREN
-- On PLUS reduce production node_test -> NODE_TYPE RPAREN
-- On PIPE reduce production node_test -> NODE_TYPE RPAREN
-- On OR reduce production node_test -> NODE_TYPE RPAREN
-- On NOTEQUAL reduce production node_test -> NODE_TYPE RPAREN
-- On MUL reduce production node_test -> NODE_TYPE RPAREN
-- On MOD reduce production node_test -> NODE_TYPE RPAREN
-- On MINUS reduce production node_test -> NODE_TYPE RPAREN
-- On LTE reduce production node_test -> NODE_TYPE RPAREN
-- On LT reduce production node_test -> NODE_TYPE RPAREN
-- On LBRACKET reduce production node_test -> NODE_TYPE RPAREN
-- On GTE reduce production node_test -> NODE_TYPE RPAREN
-- On GT reduce production node_test -> NODE_TYPE RPAREN
-- On EQUAL reduce production node_test -> NODE_TYPE RPAREN
-- On DOUBLESLASH reduce production node_test -> NODE_TYPE RPAREN
-- On DIV reduce production node_test -> NODE_TYPE RPAREN
-- On COMMA reduce production node_test -> NODE_TYPE RPAREN
-- On AND reduce production node_test -> NODE_TYPE RPAREN
-- On # reduce production node_test -> NODE_TYPE RPAREN
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production node_test -> NODE_TYPE RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 5:
## Known stack suffix:
## NODE_TYPE LITERAL
## LR(1) items:
node_test -> NODE_TYPE LITERAL . RPAREN [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On RPAREN shift to state 6
## Reductions:

State 6:
## Known stack suffix:
## NODE_TYPE LITERAL RPAREN
## LR(1) items:
node_test -> NODE_TYPE LITERAL RPAREN . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On RPAREN reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On RBRACKET reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On PLUS reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On PIPE reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On OR reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On NOTEQUAL reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On MUL reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On MOD reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On MINUS reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On LTE reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On LT reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On LBRACKET reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On GTE reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On GT reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On EQUAL reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On DOUBLESLASH reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On DIV reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On COMMA reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On AND reduce production node_test -> NODE_TYPE LITERAL RPAREN
-- On # reduce production node_test -> NODE_TYPE LITERAL RPAREN
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production node_test -> NODE_TYPE LITERAL RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 7:
## Known stack suffix:
## NAME_TEST
## LR(1) items:
node_test -> NAME_TEST . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production node_test -> NAME_TEST
-- On RPAREN reduce production node_test -> NAME_TEST
-- On RBRACKET reduce production node_test -> NAME_TEST
-- On PLUS reduce production node_test -> NAME_TEST
-- On PIPE reduce production node_test -> NAME_TEST
-- On OR reduce production node_test -> NAME_TEST
-- On NOTEQUAL reduce production node_test -> NAME_TEST
-- On MUL reduce production node_test -> NAME_TEST
-- On MOD reduce production node_test -> NAME_TEST
-- On MINUS reduce production node_test -> NAME_TEST
-- On LTE reduce production node_test -> NAME_TEST
-- On LT reduce production node_test -> NAME_TEST
-- On LBRACKET reduce production node_test -> NAME_TEST
-- On GTE reduce production node_test -> NAME_TEST
-- On GT reduce production node_test -> NAME_TEST
-- On EQUAL reduce production node_test -> NAME_TEST
-- On DOUBLESLASH reduce production node_test -> NAME_TEST
-- On DIV reduce production node_test -> NAME_TEST
-- On COMMA reduce production node_test -> NAME_TEST
-- On AND reduce production node_test -> NAME_TEST
-- On # reduce production node_test -> NAME_TEST
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production node_test -> NAME_TEST
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 8:
## Known stack suffix:
## DOUBLEDOT
## LR(1) items:
step -> DOUBLEDOT . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production step -> DOUBLEDOT
-- On RPAREN reduce production step -> DOUBLEDOT
-- On RBRACKET reduce production step -> DOUBLEDOT
-- On PLUS reduce production step -> DOUBLEDOT
-- On PIPE reduce production step -> DOUBLEDOT
-- On OR reduce production step -> DOUBLEDOT
-- On NOTEQUAL reduce production step -> DOUBLEDOT
-- On MUL reduce production step -> DOUBLEDOT
-- On MOD reduce production step -> DOUBLEDOT
-- On MINUS reduce production step -> DOUBLEDOT
-- On LTE reduce production step -> DOUBLEDOT
-- On LT reduce production step -> DOUBLEDOT
-- On GTE reduce production step -> DOUBLEDOT
-- On GT reduce production step -> DOUBLEDOT
-- On EQUAL reduce production step -> DOUBLEDOT
-- On DOUBLESLASH reduce production step -> DOUBLEDOT
-- On DIV reduce production step -> DOUBLEDOT
-- On COMMA reduce production step -> DOUBLEDOT
-- On AND reduce production step -> DOUBLEDOT
-- On # reduce production step -> DOUBLEDOT
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production step -> DOUBLEDOT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 9:
## Known stack suffix:
## DOT
## LR(1) items:
step -> DOT . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production step -> DOT
-- On RPAREN reduce production step -> DOT
-- On RBRACKET reduce production step -> DOT
-- On PLUS reduce production step -> DOT
-- On PIPE reduce production step -> DOT
-- On OR reduce production step -> DOT
-- On NOTEQUAL reduce production step -> DOT
-- On MUL reduce production step -> DOT
-- On MOD reduce production step -> DOT
-- On MINUS reduce production step -> DOT
-- On LTE reduce production step -> DOT
-- On LT reduce production step -> DOT
-- On GTE reduce production step -> DOT
-- On GT reduce production step -> DOT
-- On EQUAL reduce production step -> DOT
-- On DOUBLESLASH reduce production step -> DOT
-- On DIV reduce production step -> DOT
-- On COMMA reduce production step -> DOT
-- On AND reduce production step -> DOT
-- On # reduce production step -> DOT
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production step -> DOT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 10:
## Known stack suffix:
## AXIS
## LR(1) items:
axis_specifier -> AXIS . [ NODE_TYPE NAME_TEST ]
## Transitions:
## Reductions:
-- On NODE_TYPE reduce production axis_specifier -> AXIS
-- On NAME_TEST reduce production axis_specifier -> AXIS

State 11:
## Known stack suffix:
## AT
## LR(1) items:
axis_specifier -> AT . [ NODE_TYPE NAME_TEST ]
## Transitions:
## Reductions:
-- On NODE_TYPE reduce production axis_specifier -> AT
-- On NAME_TEST reduce production axis_specifier -> AT

State 12:
## Known stack suffix:
## step2
## LR(1) items:
step -> step2 . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
step2 -> step2 . LBRACKET expr RBRACKET [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On LBRACKET shift to state 13
## Reductions:
-- On SLASH reduce production step -> step2
-- On RPAREN reduce production step -> step2
-- On RBRACKET reduce production step -> step2
-- On PLUS reduce production step -> step2
-- On PIPE reduce production step -> step2
-- On OR reduce production step -> step2
-- On NOTEQUAL reduce production step -> step2
-- On MUL reduce production step -> step2
-- On MOD reduce production step -> step2
-- On MINUS reduce production step -> step2
-- On LTE reduce production step -> step2
-- On LT reduce production step -> step2
-- On GTE reduce production step -> step2
-- On GT reduce production step -> step2
-- On EQUAL reduce production step -> step2
-- On DOUBLESLASH reduce production step -> step2
-- On DIV reduce production step -> step2
-- On COMMA reduce production step -> step2
-- On AND reduce production step -> step2
-- On # reduce production step -> step2
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production step -> step2
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 13:
## Known stack suffix:
## step2 LBRACKET
## LR(1) items:
step2 -> step2 LBRACKET . expr RBRACKET [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On relational_expr shift to state 42
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On or_expr shift to state 64
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On expr shift to state 88
-- On equality_expr shift to state 66
-- On axis_specifier shift to state 26
-- On and_expr shift to state 77
-- On additive_expr shift to state 69
-- On absolute_location_path shift to state 48
## Reductions:

State 14:
## Known stack suffix:
## NUMBER
## LR(1) items:
primary_expr -> NUMBER . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production primary_expr -> NUMBER
-- On RPAREN reduce production primary_expr -> NUMBER
-- On RBRACKET reduce production primary_expr -> NUMBER
-- On PLUS reduce production primary_expr -> NUMBER
-- On PIPE reduce production primary_expr -> NUMBER
-- On OR reduce production primary_expr -> NUMBER
-- On NOTEQUAL reduce production primary_expr -> NUMBER
-- On MUL reduce production primary_expr -> NUMBER
-- On MOD reduce production primary_expr -> NUMBER
-- On MINUS reduce production primary_expr -> NUMBER
-- On LTE reduce production primary_expr -> NUMBER
-- On LT reduce production primary_expr -> NUMBER
-- On LBRACKET reduce production primary_expr -> NUMBER
-- On GTE reduce production primary_expr -> NUMBER
-- On GT reduce production primary_expr -> NUMBER
-- On EQUAL reduce production primary_expr -> NUMBER
-- On DOUBLESLASH reduce production primary_expr -> NUMBER
-- On DIV reduce production primary_expr -> NUMBER
-- On COMMA reduce production primary_expr -> NUMBER
-- On AND reduce production primary_expr -> NUMBER
-- On # reduce production primary_expr -> NUMBER
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production primary_expr -> NUMBER
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 15:
## Known stack suffix:
## MINUS
## LR(1) items:
unary_expr -> MINUS . unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 87
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On absolute_location_path shift to state 48
## Reductions:

State 16:
## Known stack suffix:
## LPAREN
## LR(1) items:
primary_expr -> LPAREN . expr RPAREN [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On relational_expr shift to state 42
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On or_expr shift to state 64
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On expr shift to state 85
-- On equality_expr shift to state 66
-- On axis_specifier shift to state 26
-- On and_expr shift to state 77
-- On additive_expr shift to state 69
-- On absolute_location_path shift to state 48
## Reductions:

State 17:
## Known stack suffix:
## LITERAL
## LR(1) items:
primary_expr -> LITERAL . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production primary_expr -> LITERAL
-- On RPAREN reduce production primary_expr -> LITERAL
-- On RBRACKET reduce production primary_expr -> LITERAL
-- On PLUS reduce production primary_expr -> LITERAL
-- On PIPE reduce production primary_expr -> LITERAL
-- On OR reduce production primary_expr -> LITERAL
-- On NOTEQUAL reduce production primary_expr -> LITERAL
-- On MUL reduce production primary_expr -> LITERAL
-- On MOD reduce production primary_expr -> LITERAL
-- On MINUS reduce production primary_expr -> LITERAL
-- On LTE reduce production primary_expr -> LITERAL
-- On LT reduce production primary_expr -> LITERAL
-- On LBRACKET reduce production primary_expr -> LITERAL
-- On GTE reduce production primary_expr -> LITERAL
-- On GT reduce production primary_expr -> LITERAL
-- On EQUAL reduce production primary_expr -> LITERAL
-- On DOUBLESLASH reduce production primary_expr -> LITERAL
-- On DIV reduce production primary_expr -> LITERAL
-- On COMMA reduce production primary_expr -> LITERAL
-- On AND reduce production primary_expr -> LITERAL
-- On # reduce production primary_expr -> LITERAL
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production primary_expr -> LITERAL
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 18:
## Known stack suffix:
## FUNCTION_NAME
## LR(1) items:
function_call -> FUNCTION_NAME . RPAREN [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
function_call -> FUNCTION_NAME . arguments RPAREN [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On RPAREN shift to state 19
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On relational_expr shift to state 42
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On or_expr shift to state 64
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On expr shift to state 80
-- On equality_expr shift to state 66
-- On axis_specifier shift to state 26
-- On arguments shift to state 81
-- On and_expr shift to state 77
-- On additive_expr shift to state 69
-- On absolute_location_path shift to state 48
## Reductions:

State 19:
## Known stack suffix:
## FUNCTION_NAME RPAREN
## LR(1) items:
function_call -> FUNCTION_NAME RPAREN . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production function_call -> FUNCTION_NAME RPAREN
-- On RPAREN reduce production function_call -> FUNCTION_NAME RPAREN
-- On RBRACKET reduce production function_call -> FUNCTION_NAME RPAREN
-- On PLUS reduce production function_call -> FUNCTION_NAME RPAREN
-- On PIPE reduce production function_call -> FUNCTION_NAME RPAREN
-- On OR reduce production function_call -> FUNCTION_NAME RPAREN
-- On NOTEQUAL reduce production function_call -> FUNCTION_NAME RPAREN
-- On MUL reduce production function_call -> FUNCTION_NAME RPAREN
-- On MOD reduce production function_call -> FUNCTION_NAME RPAREN
-- On MINUS reduce production function_call -> FUNCTION_NAME RPAREN
-- On LTE reduce production function_call -> FUNCTION_NAME RPAREN
-- On LT reduce production function_call -> FUNCTION_NAME RPAREN
-- On LBRACKET reduce production function_call -> FUNCTION_NAME RPAREN
-- On GTE reduce production function_call -> FUNCTION_NAME RPAREN
-- On GT reduce production function_call -> FUNCTION_NAME RPAREN
-- On EQUAL reduce production function_call -> FUNCTION_NAME RPAREN
-- On DOUBLESLASH reduce production function_call -> FUNCTION_NAME RPAREN
-- On DIV reduce production function_call -> FUNCTION_NAME RPAREN
-- On COMMA reduce production function_call -> FUNCTION_NAME RPAREN
-- On AND reduce production function_call -> FUNCTION_NAME RPAREN
-- On # reduce production function_call -> FUNCTION_NAME RPAREN
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production function_call -> FUNCTION_NAME RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 20:
## Known stack suffix:
## DOUBLESLASH
## LR(1) items:
absolute_location_path -> DOUBLESLASH . relative_location_path [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 22
-- On node_test shift to state 25
-- On axis_specifier shift to state 26
## Reductions:

State 21:
## Known stack suffix:
## step
## LR(1) items:
relative_location_path -> step . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production relative_location_path -> step
-- On RPAREN reduce production relative_location_path -> step
-- On RBRACKET reduce production relative_location_path -> step
-- On PLUS reduce production relative_location_path -> step
-- On PIPE reduce production relative_location_path -> step
-- On OR reduce production relative_location_path -> step
-- On NOTEQUAL reduce production relative_location_path -> step
-- On MUL reduce production relative_location_path -> step
-- On MOD reduce production relative_location_path -> step
-- On MINUS reduce production relative_location_path -> step
-- On LTE reduce production relative_location_path -> step
-- On LT reduce production relative_location_path -> step
-- On GTE reduce production relative_location_path -> step
-- On GT reduce production relative_location_path -> step
-- On EQUAL reduce production relative_location_path -> step
-- On DOUBLESLASH reduce production relative_location_path -> step
-- On DIV reduce production relative_location_path -> step
-- On COMMA reduce production relative_location_path -> step
-- On AND reduce production relative_location_path -> step
-- On # reduce production relative_location_path -> step
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production relative_location_path -> step
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 22:
## Known stack suffix:
## DOUBLESLASH relative_location_path
## LR(1) items:
absolute_location_path -> DOUBLESLASH relative_location_path . [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
relative_location_path -> relative_location_path . SLASH step [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
relative_location_path -> relative_location_path . DOUBLESLASH step [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On SLASH shift to state 23
-- On DOUBLESLASH shift to state 28
## Reductions:
-- On RPAREN reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On RBRACKET reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On PLUS reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On PIPE reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On OR reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On NOTEQUAL reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On MUL reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On MOD reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On MINUS reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On LTE reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On LT reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On GTE reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On GT reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On EQUAL reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On DIV reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On COMMA reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On AND reduce production absolute_location_path -> DOUBLESLASH relative_location_path
-- On # reduce production absolute_location_path -> DOUBLESLASH relative_location_path
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production absolute_location_path -> DOUBLESLASH relative_location_path
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 23:
## Known stack suffix:
## relative_location_path SLASH
## LR(1) items:
relative_location_path -> relative_location_path SLASH . step [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On step2 shift to state 12
-- On step shift to state 24
-- On node_test shift to state 25
-- On axis_specifier shift to state 26
## Reductions:

State 24:
## Known stack suffix:
## relative_location_path SLASH step
## LR(1) items:
relative_location_path -> relative_location_path SLASH step . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production relative_location_path -> relative_location_path SLASH step
-- On RPAREN reduce production relative_location_path -> relative_location_path SLASH step
-- On RBRACKET reduce production relative_location_path -> relative_location_path SLASH step
-- On PLUS reduce production relative_location_path -> relative_location_path SLASH step
-- On PIPE reduce production relative_location_path -> relative_location_path SLASH step
-- On OR reduce production relative_location_path -> relative_location_path SLASH step
-- On NOTEQUAL reduce production relative_location_path -> relative_location_path SLASH step
-- On MUL reduce production relative_location_path -> relative_location_path SLASH step
-- On MOD reduce production relative_location_path -> relative_location_path SLASH step
-- On MINUS reduce production relative_location_path -> relative_location_path SLASH step
-- On LTE reduce production relative_location_path -> relative_location_path SLASH step
-- On LT reduce production relative_location_path -> relative_location_path SLASH step
-- On GTE reduce production relative_location_path -> relative_location_path SLASH step
-- On GT reduce production relative_location_path -> relative_location_path SLASH step
-- On EQUAL reduce production relative_location_path -> relative_location_path SLASH step
-- On DOUBLESLASH reduce production relative_location_path -> relative_location_path SLASH step
-- On DIV reduce production relative_location_path -> relative_location_path SLASH step
-- On COMMA reduce production relative_location_path -> relative_location_path SLASH step
-- On AND reduce production relative_location_path -> relative_location_path SLASH step
-- On # reduce production relative_location_path -> relative_location_path SLASH step
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production relative_location_path -> relative_location_path SLASH step
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 25:
## Known stack suffix:
## node_test
## LR(1) items:
step2 -> node_test . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production step2 -> node_test
-- On RPAREN reduce production step2 -> node_test
-- On RBRACKET reduce production step2 -> node_test
-- On PLUS reduce production step2 -> node_test
-- On PIPE reduce production step2 -> node_test
-- On OR reduce production step2 -> node_test
-- On NOTEQUAL reduce production step2 -> node_test
-- On MUL reduce production step2 -> node_test
-- On MOD reduce production step2 -> node_test
-- On MINUS reduce production step2 -> node_test
-- On LTE reduce production step2 -> node_test
-- On LT reduce production step2 -> node_test
-- On LBRACKET reduce production step2 -> node_test
-- On GTE reduce production step2 -> node_test
-- On GT reduce production step2 -> node_test
-- On EQUAL reduce production step2 -> node_test
-- On DOUBLESLASH reduce production step2 -> node_test
-- On DIV reduce production step2 -> node_test
-- On COMMA reduce production step2 -> node_test
-- On AND reduce production step2 -> node_test
-- On # reduce production step2 -> node_test
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production step2 -> node_test
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 26:
## Known stack suffix:
## axis_specifier
## LR(1) items:
step -> axis_specifier . step2 [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On step2 shift to state 27
-- On node_test shift to state 25
## Reductions:

State 27:
## Known stack suffix:
## axis_specifier step2
## LR(1) items:
step -> axis_specifier step2 . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
step2 -> step2 . LBRACKET expr RBRACKET [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On LBRACKET shift to state 13
## Reductions:
-- On SLASH reduce production step -> axis_specifier step2
-- On RPAREN reduce production step -> axis_specifier step2
-- On RBRACKET reduce production step -> axis_specifier step2
-- On PLUS reduce production step -> axis_specifier step2
-- On PIPE reduce production step -> axis_specifier step2
-- On OR reduce production step -> axis_specifier step2
-- On NOTEQUAL reduce production step -> axis_specifier step2
-- On MUL reduce production step -> axis_specifier step2
-- On MOD reduce production step -> axis_specifier step2
-- On MINUS reduce production step -> axis_specifier step2
-- On LTE reduce production step -> axis_specifier step2
-- On LT reduce production step -> axis_specifier step2
-- On GTE reduce production step -> axis_specifier step2
-- On GT reduce production step -> axis_specifier step2
-- On EQUAL reduce production step -> axis_specifier step2
-- On DOUBLESLASH reduce production step -> axis_specifier step2
-- On DIV reduce production step -> axis_specifier step2
-- On COMMA reduce production step -> axis_specifier step2
-- On AND reduce production step -> axis_specifier step2
-- On # reduce production step -> axis_specifier step2
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production step -> axis_specifier step2
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 28:
## Known stack suffix:
## relative_location_path DOUBLESLASH
## LR(1) items:
relative_location_path -> relative_location_path DOUBLESLASH . step [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On step2 shift to state 12
-- On step shift to state 29
-- On node_test shift to state 25
-- On axis_specifier shift to state 26
## Reductions:

State 29:
## Known stack suffix:
## relative_location_path DOUBLESLASH step
## LR(1) items:
relative_location_path -> relative_location_path DOUBLESLASH step . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On RPAREN reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On RBRACKET reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On PLUS reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On PIPE reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On OR reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On NOTEQUAL reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On MUL reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On MOD reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On MINUS reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On LTE reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On LT reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On GTE reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On GT reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On EQUAL reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On DOUBLESLASH reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On DIV reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On COMMA reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On AND reduce production relative_location_path -> relative_location_path DOUBLESLASH step
-- On # reduce production relative_location_path -> relative_location_path DOUBLESLASH step
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production relative_location_path -> relative_location_path DOUBLESLASH step
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 30:
## Known stack suffix:
## union_expr
## LR(1) items:
unary_expr -> union_expr . [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
union_expr -> union_expr . PIPE path_expr [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On PIPE shift to state 31
## Reductions:
-- On RPAREN reduce production unary_expr -> union_expr
-- On RBRACKET reduce production unary_expr -> union_expr
-- On PLUS reduce production unary_expr -> union_expr
-- On OR reduce production unary_expr -> union_expr
-- On NOTEQUAL reduce production unary_expr -> union_expr
-- On MUL reduce production unary_expr -> union_expr
-- On MOD reduce production unary_expr -> union_expr
-- On MINUS reduce production unary_expr -> union_expr
-- On LTE reduce production unary_expr -> union_expr
-- On LT reduce production unary_expr -> union_expr
-- On GTE reduce production unary_expr -> union_expr
-- On GT reduce production unary_expr -> union_expr
-- On EQUAL reduce production unary_expr -> union_expr
-- On DIV reduce production unary_expr -> union_expr
-- On COMMA reduce production unary_expr -> union_expr
-- On AND reduce production unary_expr -> union_expr
-- On # reduce production unary_expr -> union_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production unary_expr -> union_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 31:
## Known stack suffix:
## union_expr PIPE
## LR(1) items:
union_expr -> union_expr PIPE . path_expr [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On primary_expr shift to state 33
-- On path_expr shift to state 34
-- On node_test shift to state 25
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On absolute_location_path shift to state 48
## Reductions:

State 32:
## Known stack suffix:
## relative_location_path
## LR(1) items:
location_path -> relative_location_path . [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
relative_location_path -> relative_location_path . SLASH step [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
relative_location_path -> relative_location_path . DOUBLESLASH step [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On SLASH shift to state 23
-- On DOUBLESLASH shift to state 28
## Reductions:
-- On RPAREN reduce production location_path -> relative_location_path
-- On RBRACKET reduce production location_path -> relative_location_path
-- On PLUS reduce production location_path -> relative_location_path
-- On PIPE reduce production location_path -> relative_location_path
-- On OR reduce production location_path -> relative_location_path
-- On NOTEQUAL reduce production location_path -> relative_location_path
-- On MUL reduce production location_path -> relative_location_path
-- On MOD reduce production location_path -> relative_location_path
-- On MINUS reduce production location_path -> relative_location_path
-- On LTE reduce production location_path -> relative_location_path
-- On LT reduce production location_path -> relative_location_path
-- On GTE reduce production location_path -> relative_location_path
-- On GT reduce production location_path -> relative_location_path
-- On EQUAL reduce production location_path -> relative_location_path
-- On DIV reduce production location_path -> relative_location_path
-- On COMMA reduce production location_path -> relative_location_path
-- On AND reduce production location_path -> relative_location_path
-- On # reduce production location_path -> relative_location_path
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production location_path -> relative_location_path
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 33:
## Known stack suffix:
## primary_expr
## LR(1) items:
filter_expr -> primary_expr . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production filter_expr -> primary_expr
-- On RPAREN reduce production filter_expr -> primary_expr
-- On RBRACKET reduce production filter_expr -> primary_expr
-- On PLUS reduce production filter_expr -> primary_expr
-- On PIPE reduce production filter_expr -> primary_expr
-- On OR reduce production filter_expr -> primary_expr
-- On NOTEQUAL reduce production filter_expr -> primary_expr
-- On MUL reduce production filter_expr -> primary_expr
-- On MOD reduce production filter_expr -> primary_expr
-- On MINUS reduce production filter_expr -> primary_expr
-- On LTE reduce production filter_expr -> primary_expr
-- On LT reduce production filter_expr -> primary_expr
-- On LBRACKET reduce production filter_expr -> primary_expr
-- On GTE reduce production filter_expr -> primary_expr
-- On GT reduce production filter_expr -> primary_expr
-- On EQUAL reduce production filter_expr -> primary_expr
-- On DOUBLESLASH reduce production filter_expr -> primary_expr
-- On DIV reduce production filter_expr -> primary_expr
-- On COMMA reduce production filter_expr -> primary_expr
-- On AND reduce production filter_expr -> primary_expr
-- On # reduce production filter_expr -> primary_expr
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production filter_expr -> primary_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 34:
## Known stack suffix:
## union_expr PIPE path_expr
## LR(1) items:
union_expr -> union_expr PIPE path_expr . [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On RPAREN reduce production union_expr -> union_expr PIPE path_expr
-- On RBRACKET reduce production union_expr -> union_expr PIPE path_expr
-- On PLUS reduce production union_expr -> union_expr PIPE path_expr
-- On PIPE reduce production union_expr -> union_expr PIPE path_expr
-- On OR reduce production union_expr -> union_expr PIPE path_expr
-- On NOTEQUAL reduce production union_expr -> union_expr PIPE path_expr
-- On MUL reduce production union_expr -> union_expr PIPE path_expr
-- On MOD reduce production union_expr -> union_expr PIPE path_expr
-- On MINUS reduce production union_expr -> union_expr PIPE path_expr
-- On LTE reduce production union_expr -> union_expr PIPE path_expr
-- On LT reduce production union_expr -> union_expr PIPE path_expr
-- On GTE reduce production union_expr -> union_expr PIPE path_expr
-- On GT reduce production union_expr -> union_expr PIPE path_expr
-- On EQUAL reduce production union_expr -> union_expr PIPE path_expr
-- On DIV reduce production union_expr -> union_expr PIPE path_expr
-- On COMMA reduce production union_expr -> union_expr PIPE path_expr
-- On AND reduce production union_expr -> union_expr PIPE path_expr
-- On # reduce production union_expr -> union_expr PIPE path_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production union_expr -> union_expr PIPE path_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 35:
## Known stack suffix:
## location_path
## LR(1) items:
path_expr -> location_path . [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On RPAREN reduce production path_expr -> location_path
-- On RBRACKET reduce production path_expr -> location_path
-- On PLUS reduce production path_expr -> location_path
-- On PIPE reduce production path_expr -> location_path
-- On OR reduce production path_expr -> location_path
-- On NOTEQUAL reduce production path_expr -> location_path
-- On MUL reduce production path_expr -> location_path
-- On MOD reduce production path_expr -> location_path
-- On MINUS reduce production path_expr -> location_path
-- On LTE reduce production path_expr -> location_path
-- On LT reduce production path_expr -> location_path
-- On GTE reduce production path_expr -> location_path
-- On GT reduce production path_expr -> location_path
-- On EQUAL reduce production path_expr -> location_path
-- On DIV reduce production path_expr -> location_path
-- On COMMA reduce production path_expr -> location_path
-- On AND reduce production path_expr -> location_path
-- On # reduce production path_expr -> location_path
** End-of-stream conflict on RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production path_expr -> location_path
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 36:
## Known stack suffix:
## function_call
## LR(1) items:
primary_expr -> function_call . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production primary_expr -> function_call
-- On RPAREN reduce production primary_expr -> function_call
-- On RBRACKET reduce production primary_expr -> function_call
-- On PLUS reduce production primary_expr -> function_call
-- On PIPE reduce production primary_expr -> function_call
-- On OR reduce production primary_expr -> function_call
-- On NOTEQUAL reduce production primary_expr -> function_call
-- On MUL reduce production primary_expr -> function_call
-- On MOD reduce production primary_expr -> function_call
-- On MINUS reduce production primary_expr -> function_call
-- On LTE reduce production primary_expr -> function_call
-- On LT reduce production primary_expr -> function_call
-- On LBRACKET reduce production primary_expr -> function_call
-- On GTE reduce production primary_expr -> function_call
-- On GT reduce production primary_expr -> function_call
-- On EQUAL reduce production primary_expr -> function_call
-- On DOUBLESLASH reduce production primary_expr -> function_call
-- On DIV reduce production primary_expr -> function_call
-- On COMMA reduce production primary_expr -> function_call
-- On AND reduce production primary_expr -> function_call
-- On # reduce production primary_expr -> function_call
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production primary_expr -> function_call
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 37:
## Known stack suffix:
## filter_expr
## LR(1) items:
filter_expr -> filter_expr . LBRACKET expr RBRACKET [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
path_expr -> filter_expr . [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
path_expr -> filter_expr . SLASH relative_location_path [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
path_expr -> filter_expr . DOUBLESLASH relative_location_path [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On SLASH shift to state 38
-- On LBRACKET shift to state 40
-- On DOUBLESLASH shift to state 78
## Reductions:
-- On RPAREN reduce production path_expr -> filter_expr
-- On RBRACKET reduce production path_expr -> filter_expr
-- On PLUS reduce production path_expr -> filter_expr
-- On PIPE reduce production path_expr -> filter_expr
-- On OR reduce production path_expr -> filter_expr
-- On NOTEQUAL reduce production path_expr -> filter_expr
-- On MUL reduce production path_expr -> filter_expr
-- On MOD reduce production path_expr -> filter_expr
-- On MINUS reduce production path_expr -> filter_expr
-- On LTE reduce production path_expr -> filter_expr
-- On LT reduce production path_expr -> filter_expr
-- On GTE reduce production path_expr -> filter_expr
-- On GT reduce production path_expr -> filter_expr
-- On EQUAL reduce production path_expr -> filter_expr
-- On DIV reduce production path_expr -> filter_expr
-- On COMMA reduce production path_expr -> filter_expr
-- On AND reduce production path_expr -> filter_expr
-- On # reduce production path_expr -> filter_expr
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production path_expr -> filter_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 38:
## Known stack suffix:
## filter_expr SLASH
## LR(1) items:
path_expr -> filter_expr SLASH . relative_location_path [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 39
-- On node_test shift to state 25
-- On axis_specifier shift to state 26
## Reductions:

State 39:
## Known stack suffix:
## filter_expr SLASH relative_location_path
## LR(1) items:
path_expr -> filter_expr SLASH relative_location_path . [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
relative_location_path -> relative_location_path . SLASH step [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
relative_location_path -> relative_location_path . DOUBLESLASH step [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On SLASH shift to state 23
-- On DOUBLESLASH shift to state 28
## Reductions:
-- On RPAREN reduce production path_expr -> filter_expr SLASH relative_location_path
-- On RBRACKET reduce production path_expr -> filter_expr SLASH relative_location_path
-- On PLUS reduce production path_expr -> filter_expr SLASH relative_location_path
-- On PIPE reduce production path_expr -> filter_expr SLASH relative_location_path
-- On OR reduce production path_expr -> filter_expr SLASH relative_location_path
-- On NOTEQUAL reduce production path_expr -> filter_expr SLASH relative_location_path
-- On MUL reduce production path_expr -> filter_expr SLASH relative_location_path
-- On MOD reduce production path_expr -> filter_expr SLASH relative_location_path
-- On MINUS reduce production path_expr -> filter_expr SLASH relative_location_path
-- On LTE reduce production path_expr -> filter_expr SLASH relative_location_path
-- On LT reduce production path_expr -> filter_expr SLASH relative_location_path
-- On GTE reduce production path_expr -> filter_expr SLASH relative_location_path
-- On GT reduce production path_expr -> filter_expr SLASH relative_location_path
-- On EQUAL reduce production path_expr -> filter_expr SLASH relative_location_path
-- On DIV reduce production path_expr -> filter_expr SLASH relative_location_path
-- On COMMA reduce production path_expr -> filter_expr SLASH relative_location_path
-- On AND reduce production path_expr -> filter_expr SLASH relative_location_path
-- On # reduce production path_expr -> filter_expr SLASH relative_location_path
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production path_expr -> filter_expr SLASH relative_location_path
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 40:
## Known stack suffix:
## filter_expr LBRACKET
## LR(1) items:
filter_expr -> filter_expr LBRACKET . expr RBRACKET [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On relational_expr shift to state 42
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On or_expr shift to state 64
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On expr shift to state 75
-- On equality_expr shift to state 66
-- On axis_specifier shift to state 26
-- On and_expr shift to state 77
-- On additive_expr shift to state 69
-- On absolute_location_path shift to state 48
## Reductions:

State 41:
## Known stack suffix:
## unary_expr
## LR(1) items:
multiplicative_expr -> unary_expr . [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On RPAREN reduce production multiplicative_expr -> unary_expr
-- On RBRACKET reduce production multiplicative_expr -> unary_expr
-- On PLUS reduce production multiplicative_expr -> unary_expr
-- On OR reduce production multiplicative_expr -> unary_expr
-- On NOTEQUAL reduce production multiplicative_expr -> unary_expr
-- On MUL reduce production multiplicative_expr -> unary_expr
-- On MOD reduce production multiplicative_expr -> unary_expr
-- On MINUS reduce production multiplicative_expr -> unary_expr
-- On LTE reduce production multiplicative_expr -> unary_expr
-- On LT reduce production multiplicative_expr -> unary_expr
-- On GTE reduce production multiplicative_expr -> unary_expr
-- On GT reduce production multiplicative_expr -> unary_expr
-- On EQUAL reduce production multiplicative_expr -> unary_expr
-- On DIV reduce production multiplicative_expr -> unary_expr
-- On COMMA reduce production multiplicative_expr -> unary_expr
-- On AND reduce production multiplicative_expr -> unary_expr
-- On # reduce production multiplicative_expr -> unary_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production multiplicative_expr -> unary_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 42:
## Known stack suffix:
## relational_expr
## LR(1) items:
equality_expr -> relational_expr . [ RPAREN RBRACKET OR NOTEQUAL EQUAL COMMA AND # ]
relational_expr -> relational_expr . LT additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr . GT additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr . LTE additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr . GTE additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On LTE shift to state 43
-- On LT shift to state 58
-- On GTE shift to state 60
-- On GT shift to state 62
## Reductions:
-- On RPAREN reduce production equality_expr -> relational_expr
-- On RBRACKET reduce production equality_expr -> relational_expr
-- On OR reduce production equality_expr -> relational_expr
-- On NOTEQUAL reduce production equality_expr -> relational_expr
-- On EQUAL reduce production equality_expr -> relational_expr
-- On COMMA reduce production equality_expr -> relational_expr
-- On AND reduce production equality_expr -> relational_expr
-- On # reduce production equality_expr -> relational_expr
** End-of-stream conflict on RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND
**   There is a tension between
**   (1) reducing production equality_expr -> relational_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 43:
## Known stack suffix:
## relational_expr LTE
## LR(1) items:
relational_expr -> relational_expr LTE . additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On additive_expr shift to state 53
-- On absolute_location_path shift to state 48
## Reductions:

State 44:
## Known stack suffix:
## path_expr
## LR(1) items:
union_expr -> path_expr . [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On RPAREN reduce production union_expr -> path_expr
-- On RBRACKET reduce production union_expr -> path_expr
-- On PLUS reduce production union_expr -> path_expr
-- On PIPE reduce production union_expr -> path_expr
-- On OR reduce production union_expr -> path_expr
-- On NOTEQUAL reduce production union_expr -> path_expr
-- On MUL reduce production union_expr -> path_expr
-- On MOD reduce production union_expr -> path_expr
-- On MINUS reduce production union_expr -> path_expr
-- On LTE reduce production union_expr -> path_expr
-- On LT reduce production union_expr -> path_expr
-- On GTE reduce production union_expr -> path_expr
-- On GT reduce production union_expr -> path_expr
-- On EQUAL reduce production union_expr -> path_expr
-- On DIV reduce production union_expr -> path_expr
-- On COMMA reduce production union_expr -> path_expr
-- On AND reduce production union_expr -> path_expr
-- On # reduce production union_expr -> path_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production union_expr -> path_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 45:
## Known stack suffix:
## multiplicative_expr
## LR(1) items:
additive_expr -> multiplicative_expr . [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
multiplicative_expr -> multiplicative_expr . MUL unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
multiplicative_expr -> multiplicative_expr . DIV unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
multiplicative_expr -> multiplicative_expr . MOD unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On MUL shift to state 46
-- On MOD shift to state 49
-- On DIV shift to state 51
## Reductions:
-- On RPAREN reduce production additive_expr -> multiplicative_expr
-- On RBRACKET reduce production additive_expr -> multiplicative_expr
-- On PLUS reduce production additive_expr -> multiplicative_expr
-- On OR reduce production additive_expr -> multiplicative_expr
-- On NOTEQUAL reduce production additive_expr -> multiplicative_expr
-- On MINUS reduce production additive_expr -> multiplicative_expr
-- On LTE reduce production additive_expr -> multiplicative_expr
-- On LT reduce production additive_expr -> multiplicative_expr
-- On GTE reduce production additive_expr -> multiplicative_expr
-- On GT reduce production additive_expr -> multiplicative_expr
-- On EQUAL reduce production additive_expr -> multiplicative_expr
-- On COMMA reduce production additive_expr -> multiplicative_expr
-- On AND reduce production additive_expr -> multiplicative_expr
-- On # reduce production additive_expr -> multiplicative_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production additive_expr -> multiplicative_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 46:
## Known stack suffix:
## multiplicative_expr MUL
## LR(1) items:
multiplicative_expr -> multiplicative_expr MUL . unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 47
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On absolute_location_path shift to state 48
## Reductions:

State 47:
## Known stack suffix:
## multiplicative_expr MUL unary_expr
## LR(1) items:
multiplicative_expr -> multiplicative_expr MUL unary_expr . [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On RPAREN reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On RBRACKET reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On PLUS reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On OR reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On NOTEQUAL reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On MUL reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On MOD reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On MINUS reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On LTE reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On LT reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On GTE reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On GT reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On EQUAL reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On DIV reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On COMMA reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On AND reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
-- On # reduce production multiplicative_expr -> multiplicative_expr MUL unary_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production multiplicative_expr -> multiplicative_expr MUL unary_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 48:
## Known stack suffix:
## absolute_location_path
## LR(1) items:
location_path -> absolute_location_path . [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On RPAREN reduce production location_path -> absolute_location_path
-- On RBRACKET reduce production location_path -> absolute_location_path
-- On PLUS reduce production location_path -> absolute_location_path
-- On PIPE reduce production location_path -> absolute_location_path
-- On OR reduce production location_path -> absolute_location_path
-- On NOTEQUAL reduce production location_path -> absolute_location_path
-- On MUL reduce production location_path -> absolute_location_path
-- On MOD reduce production location_path -> absolute_location_path
-- On MINUS reduce production location_path -> absolute_location_path
-- On LTE reduce production location_path -> absolute_location_path
-- On LT reduce production location_path -> absolute_location_path
-- On GTE reduce production location_path -> absolute_location_path
-- On GT reduce production location_path -> absolute_location_path
-- On EQUAL reduce production location_path -> absolute_location_path
-- On DIV reduce production location_path -> absolute_location_path
-- On COMMA reduce production location_path -> absolute_location_path
-- On AND reduce production location_path -> absolute_location_path
-- On # reduce production location_path -> absolute_location_path
** End-of-stream conflict on RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production location_path -> absolute_location_path
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 49:
## Known stack suffix:
## multiplicative_expr MOD
## LR(1) items:
multiplicative_expr -> multiplicative_expr MOD . unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 50
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On absolute_location_path shift to state 48
## Reductions:

State 50:
## Known stack suffix:
## multiplicative_expr MOD unary_expr
## LR(1) items:
multiplicative_expr -> multiplicative_expr MOD unary_expr . [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On RPAREN reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On RBRACKET reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On PLUS reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On OR reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On NOTEQUAL reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On MUL reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On MOD reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On MINUS reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On LTE reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On LT reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On GTE reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On GT reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On EQUAL reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On DIV reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On COMMA reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On AND reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
-- On # reduce production multiplicative_expr -> multiplicative_expr MOD unary_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production multiplicative_expr -> multiplicative_expr MOD unary_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 51:
## Known stack suffix:
## multiplicative_expr DIV
## LR(1) items:
multiplicative_expr -> multiplicative_expr DIV . unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 52
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On absolute_location_path shift to state 48
## Reductions:

State 52:
## Known stack suffix:
## multiplicative_expr DIV unary_expr
## LR(1) items:
multiplicative_expr -> multiplicative_expr DIV unary_expr . [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On RPAREN reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On RBRACKET reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On PLUS reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On OR reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On NOTEQUAL reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On MUL reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On MOD reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On MINUS reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On LTE reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On LT reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On GTE reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On GT reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On EQUAL reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On DIV reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On COMMA reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On AND reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
-- On # reduce production multiplicative_expr -> multiplicative_expr DIV unary_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production multiplicative_expr -> multiplicative_expr DIV unary_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 53:
## Known stack suffix:
## relational_expr LTE additive_expr
## LR(1) items:
additive_expr -> additive_expr . PLUS multiplicative_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
additive_expr -> additive_expr . MINUS multiplicative_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr LTE additive_expr . [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On PLUS shift to state 54
-- On MINUS shift to state 56
## Reductions:
-- On RPAREN reduce production relational_expr -> relational_expr LTE additive_expr
-- On RBRACKET reduce production relational_expr -> relational_expr LTE additive_expr
-- On OR reduce production relational_expr -> relational_expr LTE additive_expr
-- On NOTEQUAL reduce production relational_expr -> relational_expr LTE additive_expr
-- On LTE reduce production relational_expr -> relational_expr LTE additive_expr
-- On LT reduce production relational_expr -> relational_expr LTE additive_expr
-- On GTE reduce production relational_expr -> relational_expr LTE additive_expr
-- On GT reduce production relational_expr -> relational_expr LTE additive_expr
-- On EQUAL reduce production relational_expr -> relational_expr LTE additive_expr
-- On COMMA reduce production relational_expr -> relational_expr LTE additive_expr
-- On AND reduce production relational_expr -> relational_expr LTE additive_expr
-- On # reduce production relational_expr -> relational_expr LTE additive_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND
**   There is a tension between
**   (1) reducing production relational_expr -> relational_expr LTE additive_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 54:
## Known stack suffix:
## additive_expr PLUS
## LR(1) items:
additive_expr -> additive_expr PLUS . multiplicative_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 55
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On absolute_location_path shift to state 48
## Reductions:

State 55:
## Known stack suffix:
## additive_expr PLUS multiplicative_expr
## LR(1) items:
additive_expr -> additive_expr PLUS multiplicative_expr . [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
multiplicative_expr -> multiplicative_expr . MUL unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
multiplicative_expr -> multiplicative_expr . DIV unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
multiplicative_expr -> multiplicative_expr . MOD unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On MUL shift to state 46
-- On MOD shift to state 49
-- On DIV shift to state 51
## Reductions:
-- On RPAREN reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On RBRACKET reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On PLUS reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On OR reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On NOTEQUAL reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On MINUS reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On LTE reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On LT reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On GTE reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On GT reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On EQUAL reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On COMMA reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On AND reduce production additive_expr -> additive_expr PLUS multiplicative_expr
-- On # reduce production additive_expr -> additive_expr PLUS multiplicative_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production additive_expr -> additive_expr PLUS multiplicative_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 56:
## Known stack suffix:
## additive_expr MINUS
## LR(1) items:
additive_expr -> additive_expr MINUS . multiplicative_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 57
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On absolute_location_path shift to state 48
## Reductions:

State 57:
## Known stack suffix:
## additive_expr MINUS multiplicative_expr
## LR(1) items:
additive_expr -> additive_expr MINUS multiplicative_expr . [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
multiplicative_expr -> multiplicative_expr . MUL unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
multiplicative_expr -> multiplicative_expr . DIV unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
multiplicative_expr -> multiplicative_expr . MOD unary_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On MUL shift to state 46
-- On MOD shift to state 49
-- On DIV shift to state 51
## Reductions:
-- On RPAREN reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On RBRACKET reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On PLUS reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On OR reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On NOTEQUAL reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On MINUS reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On LTE reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On LT reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On GTE reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On GT reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On EQUAL reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On COMMA reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On AND reduce production additive_expr -> additive_expr MINUS multiplicative_expr
-- On # reduce production additive_expr -> additive_expr MINUS multiplicative_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production additive_expr -> additive_expr MINUS multiplicative_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 58:
## Known stack suffix:
## relational_expr LT
## LR(1) items:
relational_expr -> relational_expr LT . additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On additive_expr shift to state 59
-- On absolute_location_path shift to state 48
## Reductions:

State 59:
## Known stack suffix:
## relational_expr LT additive_expr
## LR(1) items:
additive_expr -> additive_expr . PLUS multiplicative_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
additive_expr -> additive_expr . MINUS multiplicative_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr LT additive_expr . [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On PLUS shift to state 54
-- On MINUS shift to state 56
## Reductions:
-- On RPAREN reduce production relational_expr -> relational_expr LT additive_expr
-- On RBRACKET reduce production relational_expr -> relational_expr LT additive_expr
-- On OR reduce production relational_expr -> relational_expr LT additive_expr
-- On NOTEQUAL reduce production relational_expr -> relational_expr LT additive_expr
-- On LTE reduce production relational_expr -> relational_expr LT additive_expr
-- On LT reduce production relational_expr -> relational_expr LT additive_expr
-- On GTE reduce production relational_expr -> relational_expr LT additive_expr
-- On GT reduce production relational_expr -> relational_expr LT additive_expr
-- On EQUAL reduce production relational_expr -> relational_expr LT additive_expr
-- On COMMA reduce production relational_expr -> relational_expr LT additive_expr
-- On AND reduce production relational_expr -> relational_expr LT additive_expr
-- On # reduce production relational_expr -> relational_expr LT additive_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND
**   There is a tension between
**   (1) reducing production relational_expr -> relational_expr LT additive_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 60:
## Known stack suffix:
## relational_expr GTE
## LR(1) items:
relational_expr -> relational_expr GTE . additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On additive_expr shift to state 61
-- On absolute_location_path shift to state 48
## Reductions:

State 61:
## Known stack suffix:
## relational_expr GTE additive_expr
## LR(1) items:
additive_expr -> additive_expr . PLUS multiplicative_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
additive_expr -> additive_expr . MINUS multiplicative_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr GTE additive_expr . [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On PLUS shift to state 54
-- On MINUS shift to state 56
## Reductions:
-- On RPAREN reduce production relational_expr -> relational_expr GTE additive_expr
-- On RBRACKET reduce production relational_expr -> relational_expr GTE additive_expr
-- On OR reduce production relational_expr -> relational_expr GTE additive_expr
-- On NOTEQUAL reduce production relational_expr -> relational_expr GTE additive_expr
-- On LTE reduce production relational_expr -> relational_expr GTE additive_expr
-- On LT reduce production relational_expr -> relational_expr GTE additive_expr
-- On GTE reduce production relational_expr -> relational_expr GTE additive_expr
-- On GT reduce production relational_expr -> relational_expr GTE additive_expr
-- On EQUAL reduce production relational_expr -> relational_expr GTE additive_expr
-- On COMMA reduce production relational_expr -> relational_expr GTE additive_expr
-- On AND reduce production relational_expr -> relational_expr GTE additive_expr
-- On # reduce production relational_expr -> relational_expr GTE additive_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND
**   There is a tension between
**   (1) reducing production relational_expr -> relational_expr GTE additive_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 62:
## Known stack suffix:
## relational_expr GT
## LR(1) items:
relational_expr -> relational_expr GT . additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On additive_expr shift to state 63
-- On absolute_location_path shift to state 48
## Reductions:

State 63:
## Known stack suffix:
## relational_expr GT additive_expr
## LR(1) items:
additive_expr -> additive_expr . PLUS multiplicative_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
additive_expr -> additive_expr . MINUS multiplicative_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr GT additive_expr . [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On PLUS shift to state 54
-- On MINUS shift to state 56
## Reductions:
-- On RPAREN reduce production relational_expr -> relational_expr GT additive_expr
-- On RBRACKET reduce production relational_expr -> relational_expr GT additive_expr
-- On OR reduce production relational_expr -> relational_expr GT additive_expr
-- On NOTEQUAL reduce production relational_expr -> relational_expr GT additive_expr
-- On LTE reduce production relational_expr -> relational_expr GT additive_expr
-- On LT reduce production relational_expr -> relational_expr GT additive_expr
-- On GTE reduce production relational_expr -> relational_expr GT additive_expr
-- On GT reduce production relational_expr -> relational_expr GT additive_expr
-- On EQUAL reduce production relational_expr -> relational_expr GT additive_expr
-- On COMMA reduce production relational_expr -> relational_expr GT additive_expr
-- On AND reduce production relational_expr -> relational_expr GT additive_expr
-- On # reduce production relational_expr -> relational_expr GT additive_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND
**   There is a tension between
**   (1) reducing production relational_expr -> relational_expr GT additive_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 64:
## Known stack suffix:
## or_expr
## LR(1) items:
expr -> or_expr . [ RPAREN RBRACKET COMMA ]
or_expr -> or_expr . OR and_expr [ RPAREN RBRACKET OR COMMA ]
## Transitions:
-- On OR shift to state 65
## Reductions:
-- On RPAREN reduce production expr -> or_expr
-- On RBRACKET reduce production expr -> or_expr
-- On COMMA reduce production expr -> or_expr

State 65:
## Known stack suffix:
## or_expr OR
## LR(1) items:
or_expr -> or_expr OR . and_expr [ RPAREN RBRACKET OR COMMA # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On relational_expr shift to state 42
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On equality_expr shift to state 66
-- On axis_specifier shift to state 26
-- On and_expr shift to state 72
-- On additive_expr shift to state 69
-- On absolute_location_path shift to state 48
## Reductions:

State 66:
## Known stack suffix:
## equality_expr
## LR(1) items:
and_expr -> equality_expr . [ RPAREN RBRACKET OR COMMA AND # ]
equality_expr -> equality_expr . EQUAL relational_expr [ RPAREN RBRACKET OR NOTEQUAL EQUAL COMMA AND # ]
equality_expr -> equality_expr . NOTEQUAL relational_expr [ RPAREN RBRACKET OR NOTEQUAL EQUAL COMMA AND # ]
## Transitions:
-- On NOTEQUAL shift to state 67
-- On EQUAL shift to state 70
## Reductions:
-- On RPAREN reduce production and_expr -> equality_expr
-- On RBRACKET reduce production and_expr -> equality_expr
-- On OR reduce production and_expr -> equality_expr
-- On COMMA reduce production and_expr -> equality_expr
-- On AND reduce production and_expr -> equality_expr
-- On # reduce production and_expr -> equality_expr
** End-of-stream conflict on RPAREN RBRACKET OR NOTEQUAL EQUAL COMMA AND
**   There is a tension between
**   (1) reducing production and_expr -> equality_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 67:
## Known stack suffix:
## equality_expr NOTEQUAL
## LR(1) items:
equality_expr -> equality_expr NOTEQUAL . relational_expr [ RPAREN RBRACKET OR NOTEQUAL EQUAL COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On relational_expr shift to state 68
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On additive_expr shift to state 69
-- On absolute_location_path shift to state 48
## Reductions:

State 68:
## Known stack suffix:
## equality_expr NOTEQUAL relational_expr
## LR(1) items:
equality_expr -> equality_expr NOTEQUAL relational_expr . [ RPAREN RBRACKET OR NOTEQUAL EQUAL COMMA AND # ]
relational_expr -> relational_expr . LT additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr . GT additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr . LTE additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr . GTE additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On LTE shift to state 43
-- On LT shift to state 58
-- On GTE shift to state 60
-- On GT shift to state 62
## Reductions:
-- On RPAREN reduce production equality_expr -> equality_expr NOTEQUAL relational_expr
-- On RBRACKET reduce production equality_expr -> equality_expr NOTEQUAL relational_expr
-- On OR reduce production equality_expr -> equality_expr NOTEQUAL relational_expr
-- On NOTEQUAL reduce production equality_expr -> equality_expr NOTEQUAL relational_expr
-- On EQUAL reduce production equality_expr -> equality_expr NOTEQUAL relational_expr
-- On COMMA reduce production equality_expr -> equality_expr NOTEQUAL relational_expr
-- On AND reduce production equality_expr -> equality_expr NOTEQUAL relational_expr
-- On # reduce production equality_expr -> equality_expr NOTEQUAL relational_expr
** End-of-stream conflict on RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND
**   There is a tension between
**   (1) reducing production equality_expr -> equality_expr NOTEQUAL relational_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 69:
## Known stack suffix:
## additive_expr
## LR(1) items:
additive_expr -> additive_expr . PLUS multiplicative_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
additive_expr -> additive_expr . MINUS multiplicative_expr [ RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> additive_expr . [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On PLUS shift to state 54
-- On MINUS shift to state 56
## Reductions:
-- On RPAREN reduce production relational_expr -> additive_expr
-- On RBRACKET reduce production relational_expr -> additive_expr
-- On OR reduce production relational_expr -> additive_expr
-- On NOTEQUAL reduce production relational_expr -> additive_expr
-- On LTE reduce production relational_expr -> additive_expr
-- On LT reduce production relational_expr -> additive_expr
-- On GTE reduce production relational_expr -> additive_expr
-- On GT reduce production relational_expr -> additive_expr
-- On EQUAL reduce production relational_expr -> additive_expr
-- On COMMA reduce production relational_expr -> additive_expr
-- On AND reduce production relational_expr -> additive_expr
-- On # reduce production relational_expr -> additive_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MINUS LTE LT GTE GT EQUAL COMMA AND
**   There is a tension between
**   (1) reducing production relational_expr -> additive_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 70:
## Known stack suffix:
## equality_expr EQUAL
## LR(1) items:
equality_expr -> equality_expr EQUAL . relational_expr [ RPAREN RBRACKET OR NOTEQUAL EQUAL COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On relational_expr shift to state 71
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On axis_specifier shift to state 26
-- On additive_expr shift to state 69
-- On absolute_location_path shift to state 48
## Reductions:

State 71:
## Known stack suffix:
## equality_expr EQUAL relational_expr
## LR(1) items:
equality_expr -> equality_expr EQUAL relational_expr . [ RPAREN RBRACKET OR NOTEQUAL EQUAL COMMA AND # ]
relational_expr -> relational_expr . LT additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr . GT additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr . LTE additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
relational_expr -> relational_expr . GTE additive_expr [ RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND # ]
## Transitions:
-- On LTE shift to state 43
-- On LT shift to state 58
-- On GTE shift to state 60
-- On GT shift to state 62
## Reductions:
-- On RPAREN reduce production equality_expr -> equality_expr EQUAL relational_expr
-- On RBRACKET reduce production equality_expr -> equality_expr EQUAL relational_expr
-- On OR reduce production equality_expr -> equality_expr EQUAL relational_expr
-- On NOTEQUAL reduce production equality_expr -> equality_expr EQUAL relational_expr
-- On EQUAL reduce production equality_expr -> equality_expr EQUAL relational_expr
-- On COMMA reduce production equality_expr -> equality_expr EQUAL relational_expr
-- On AND reduce production equality_expr -> equality_expr EQUAL relational_expr
-- On # reduce production equality_expr -> equality_expr EQUAL relational_expr
** End-of-stream conflict on RPAREN RBRACKET OR NOTEQUAL LTE LT GTE GT EQUAL COMMA AND
**   There is a tension between
**   (1) reducing production equality_expr -> equality_expr EQUAL relational_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 72:
## Known stack suffix:
## or_expr OR and_expr
## LR(1) items:
and_expr -> and_expr . AND equality_expr [ RPAREN RBRACKET OR COMMA AND # ]
or_expr -> or_expr OR and_expr . [ RPAREN RBRACKET OR COMMA # ]
## Transitions:
-- On AND shift to state 73
## Reductions:
-- On RPAREN reduce production or_expr -> or_expr OR and_expr
-- On RBRACKET reduce production or_expr -> or_expr OR and_expr
-- On OR reduce production or_expr -> or_expr OR and_expr
-- On COMMA reduce production or_expr -> or_expr OR and_expr
-- On # reduce production or_expr -> or_expr OR and_expr
** End-of-stream conflict on RPAREN RBRACKET OR COMMA AND
**   There is a tension between
**   (1) reducing production or_expr -> or_expr OR and_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 73:
## Known stack suffix:
## and_expr AND
## LR(1) items:
and_expr -> and_expr AND . equality_expr [ RPAREN RBRACKET OR COMMA AND # ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On relational_expr shift to state 42
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On equality_expr shift to state 74
-- On axis_specifier shift to state 26
-- On additive_expr shift to state 69
-- On absolute_location_path shift to state 48
## Reductions:

State 74:
## Known stack suffix:
## and_expr AND equality_expr
## LR(1) items:
and_expr -> and_expr AND equality_expr . [ RPAREN RBRACKET OR COMMA AND # ]
equality_expr -> equality_expr . EQUAL relational_expr [ RPAREN RBRACKET OR NOTEQUAL EQUAL COMMA AND # ]
equality_expr -> equality_expr . NOTEQUAL relational_expr [ RPAREN RBRACKET OR NOTEQUAL EQUAL COMMA AND # ]
## Transitions:
-- On NOTEQUAL shift to state 67
-- On EQUAL shift to state 70
## Reductions:
-- On RPAREN reduce production and_expr -> and_expr AND equality_expr
-- On RBRACKET reduce production and_expr -> and_expr AND equality_expr
-- On OR reduce production and_expr -> and_expr AND equality_expr
-- On COMMA reduce production and_expr -> and_expr AND equality_expr
-- On AND reduce production and_expr -> and_expr AND equality_expr
-- On # reduce production and_expr -> and_expr AND equality_expr
** End-of-stream conflict on RPAREN RBRACKET OR NOTEQUAL EQUAL COMMA AND
**   There is a tension between
**   (1) reducing production and_expr -> and_expr AND equality_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 75:
## Known stack suffix:
## filter_expr LBRACKET expr
## LR(1) items:
filter_expr -> filter_expr LBRACKET expr . RBRACKET [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On RBRACKET shift to state 76
## Reductions:

State 76:
## Known stack suffix:
## filter_expr LBRACKET expr RBRACKET
## LR(1) items:
filter_expr -> filter_expr LBRACKET expr RBRACKET . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On RPAREN reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On RBRACKET reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On PLUS reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On PIPE reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On OR reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On NOTEQUAL reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On MUL reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On MOD reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On MINUS reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On LTE reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On LT reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On LBRACKET reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On GTE reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On GT reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On EQUAL reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On DOUBLESLASH reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On DIV reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On COMMA reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On AND reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
-- On # reduce production filter_expr -> filter_expr LBRACKET expr RBRACKET
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production filter_expr -> filter_expr LBRACKET expr RBRACKET
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 77:
## Known stack suffix:
## and_expr
## LR(1) items:
and_expr -> and_expr . AND equality_expr [ RPAREN RBRACKET OR COMMA AND # ]
or_expr -> and_expr . [ RPAREN RBRACKET OR COMMA # ]
## Transitions:
-- On AND shift to state 73
## Reductions:
-- On RPAREN reduce production or_expr -> and_expr
-- On RBRACKET reduce production or_expr -> and_expr
-- On OR reduce production or_expr -> and_expr
-- On COMMA reduce production or_expr -> and_expr
-- On # reduce production or_expr -> and_expr
** End-of-stream conflict on RPAREN RBRACKET OR COMMA AND
**   There is a tension between
**   (1) reducing production or_expr -> and_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 78:
## Known stack suffix:
## filter_expr DOUBLESLASH
## LR(1) items:
path_expr -> filter_expr DOUBLESLASH . relative_location_path [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 79
-- On node_test shift to state 25
-- On axis_specifier shift to state 26
## Reductions:

State 79:
## Known stack suffix:
## filter_expr DOUBLESLASH relative_location_path
## LR(1) items:
path_expr -> filter_expr DOUBLESLASH relative_location_path . [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
relative_location_path -> relative_location_path . SLASH step [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
relative_location_path -> relative_location_path . DOUBLESLASH step [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On SLASH shift to state 23
-- On DOUBLESLASH shift to state 28
## Reductions:
-- On RPAREN reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On RBRACKET reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On PLUS reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On PIPE reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On OR reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On NOTEQUAL reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On MUL reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On MOD reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On MINUS reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On LTE reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On LT reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On GTE reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On GT reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On EQUAL reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On DIV reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On COMMA reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On AND reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
-- On # reduce production path_expr -> filter_expr DOUBLESLASH relative_location_path
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production path_expr -> filter_expr DOUBLESLASH relative_location_path
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 80:
## Known stack suffix:
## expr
## LR(1) items:
arguments -> expr . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN reduce production arguments -> expr
-- On COMMA reduce production arguments -> expr

State 81:
## Known stack suffix:
## FUNCTION_NAME arguments
## LR(1) items:
arguments -> arguments . COMMA expr [ RPAREN COMMA ]
function_call -> FUNCTION_NAME arguments . RPAREN [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On RPAREN shift to state 82
-- On COMMA shift to state 83
## Reductions:

State 82:
## Known stack suffix:
## FUNCTION_NAME arguments RPAREN
## LR(1) items:
function_call -> FUNCTION_NAME arguments RPAREN . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On RPAREN reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On RBRACKET reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On PLUS reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On PIPE reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On OR reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On NOTEQUAL reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On MUL reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On MOD reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On MINUS reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On LTE reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On LT reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On LBRACKET reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On GTE reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On GT reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On EQUAL reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On DOUBLESLASH reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On DIV reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On COMMA reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On AND reduce production function_call -> FUNCTION_NAME arguments RPAREN
-- On # reduce production function_call -> FUNCTION_NAME arguments RPAREN
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production function_call -> FUNCTION_NAME arguments RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 83:
## Known stack suffix:
## arguments COMMA
## LR(1) items:
arguments -> arguments COMMA . expr [ RPAREN COMMA ]
## Transitions:
-- On VAR shift to state 1
-- On SLASH shift to state 2
-- On NUMBER shift to state 14
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On MINUS shift to state 15
-- On LPAREN shift to state 16
-- On LITERAL shift to state 17
-- On FUNCTION_NAME shift to state 18
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On union_expr shift to state 30
-- On unary_expr shift to state 41
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On relational_expr shift to state 42
-- On primary_expr shift to state 33
-- On path_expr shift to state 44
-- On or_expr shift to state 64
-- On node_test shift to state 25
-- On multiplicative_expr shift to state 45
-- On location_path shift to state 35
-- On function_call shift to state 36
-- On filter_expr shift to state 37
-- On expr shift to state 84
-- On equality_expr shift to state 66
-- On axis_specifier shift to state 26
-- On and_expr shift to state 77
-- On additive_expr shift to state 69
-- On absolute_location_path shift to state 48
## Reductions:

State 84:
## Known stack suffix:
## arguments COMMA expr
## LR(1) items:
arguments -> arguments COMMA expr . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN reduce production arguments -> arguments COMMA expr
-- On COMMA reduce production arguments -> arguments COMMA expr

State 85:
## Known stack suffix:
## LPAREN expr
## LR(1) items:
primary_expr -> LPAREN expr . RPAREN [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On RPAREN shift to state 86
## Reductions:

State 86:
## Known stack suffix:
## LPAREN expr RPAREN
## LR(1) items:
primary_expr -> LPAREN expr RPAREN . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production primary_expr -> LPAREN expr RPAREN
-- On RPAREN reduce production primary_expr -> LPAREN expr RPAREN
-- On RBRACKET reduce production primary_expr -> LPAREN expr RPAREN
-- On PLUS reduce production primary_expr -> LPAREN expr RPAREN
-- On PIPE reduce production primary_expr -> LPAREN expr RPAREN
-- On OR reduce production primary_expr -> LPAREN expr RPAREN
-- On NOTEQUAL reduce production primary_expr -> LPAREN expr RPAREN
-- On MUL reduce production primary_expr -> LPAREN expr RPAREN
-- On MOD reduce production primary_expr -> LPAREN expr RPAREN
-- On MINUS reduce production primary_expr -> LPAREN expr RPAREN
-- On LTE reduce production primary_expr -> LPAREN expr RPAREN
-- On LT reduce production primary_expr -> LPAREN expr RPAREN
-- On LBRACKET reduce production primary_expr -> LPAREN expr RPAREN
-- On GTE reduce production primary_expr -> LPAREN expr RPAREN
-- On GT reduce production primary_expr -> LPAREN expr RPAREN
-- On EQUAL reduce production primary_expr -> LPAREN expr RPAREN
-- On DOUBLESLASH reduce production primary_expr -> LPAREN expr RPAREN
-- On DIV reduce production primary_expr -> LPAREN expr RPAREN
-- On COMMA reduce production primary_expr -> LPAREN expr RPAREN
-- On AND reduce production primary_expr -> LPAREN expr RPAREN
-- On # reduce production primary_expr -> LPAREN expr RPAREN
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production primary_expr -> LPAREN expr RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 87:
## Known stack suffix:
## MINUS unary_expr
## LR(1) items:
unary_expr -> MINUS unary_expr . [ RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On RPAREN reduce production unary_expr -> MINUS unary_expr
-- On RBRACKET reduce production unary_expr -> MINUS unary_expr
-- On PLUS reduce production unary_expr -> MINUS unary_expr
-- On OR reduce production unary_expr -> MINUS unary_expr
-- On NOTEQUAL reduce production unary_expr -> MINUS unary_expr
-- On MUL reduce production unary_expr -> MINUS unary_expr
-- On MOD reduce production unary_expr -> MINUS unary_expr
-- On MINUS reduce production unary_expr -> MINUS unary_expr
-- On LTE reduce production unary_expr -> MINUS unary_expr
-- On LT reduce production unary_expr -> MINUS unary_expr
-- On GTE reduce production unary_expr -> MINUS unary_expr
-- On GT reduce production unary_expr -> MINUS unary_expr
-- On EQUAL reduce production unary_expr -> MINUS unary_expr
-- On DIV reduce production unary_expr -> MINUS unary_expr
-- On COMMA reduce production unary_expr -> MINUS unary_expr
-- On AND reduce production unary_expr -> MINUS unary_expr
-- On # reduce production unary_expr -> MINUS unary_expr
** End-of-stream conflict on RPAREN RBRACKET PLUS OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND
**   There is a tension between
**   (1) reducing production unary_expr -> MINUS unary_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 88:
## Known stack suffix:
## step2 LBRACKET expr
## LR(1) items:
step2 -> step2 LBRACKET expr . RBRACKET [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On RBRACKET shift to state 89
## Reductions:

State 89:
## Known stack suffix:
## step2 LBRACKET expr RBRACKET
## LR(1) items:
step2 -> step2 LBRACKET expr RBRACKET . [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
## Reductions:
-- On SLASH reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On RPAREN reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On RBRACKET reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On PLUS reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On PIPE reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On OR reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On NOTEQUAL reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On MUL reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On MOD reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On MINUS reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On LTE reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On LT reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On LBRACKET reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On GTE reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On GT reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On EQUAL reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On DOUBLESLASH reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On DIV reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On COMMA reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On AND reduce production step2 -> step2 LBRACKET expr RBRACKET
-- On # reduce production step2 -> step2 LBRACKET expr RBRACKET
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT LBRACKET GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production step2 -> step2 LBRACKET expr RBRACKET
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 90:
## Known stack suffix:
## SLASH relative_location_path
## LR(1) items:
absolute_location_path -> SLASH relative_location_path . [ RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DIV COMMA AND # ]
relative_location_path -> relative_location_path . SLASH step [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
relative_location_path -> relative_location_path . DOUBLESLASH step [ SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND # ]
## Transitions:
-- On SLASH shift to state 23
-- On DOUBLESLASH shift to state 28
## Reductions:
-- On RPAREN reduce production absolute_location_path -> SLASH relative_location_path
-- On RBRACKET reduce production absolute_location_path -> SLASH relative_location_path
-- On PLUS reduce production absolute_location_path -> SLASH relative_location_path
-- On PIPE reduce production absolute_location_path -> SLASH relative_location_path
-- On OR reduce production absolute_location_path -> SLASH relative_location_path
-- On NOTEQUAL reduce production absolute_location_path -> SLASH relative_location_path
-- On MUL reduce production absolute_location_path -> SLASH relative_location_path
-- On MOD reduce production absolute_location_path -> SLASH relative_location_path
-- On MINUS reduce production absolute_location_path -> SLASH relative_location_path
-- On LTE reduce production absolute_location_path -> SLASH relative_location_path
-- On LT reduce production absolute_location_path -> SLASH relative_location_path
-- On GTE reduce production absolute_location_path -> SLASH relative_location_path
-- On GT reduce production absolute_location_path -> SLASH relative_location_path
-- On EQUAL reduce production absolute_location_path -> SLASH relative_location_path
-- On DIV reduce production absolute_location_path -> SLASH relative_location_path
-- On COMMA reduce production absolute_location_path -> SLASH relative_location_path
-- On AND reduce production absolute_location_path -> SLASH relative_location_path
-- On # reduce production absolute_location_path -> SLASH relative_location_path
** End-of-stream conflict on SLASH RPAREN RBRACKET PLUS PIPE OR NOTEQUAL MUL MOD MINUS LTE LT GTE GT EQUAL DOUBLESLASH DIV COMMA AND
**   There is a tension between
**   (1) reducing production absolute_location_path -> SLASH relative_location_path
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 91:
## Known stack suffix:
## or_expr
## LR(1) items:
expr -> or_expr . [ # ]
or_expr -> or_expr . OR and_expr [ OR # ]
## Transitions:
-- On OR shift to state 65
## Reductions:
-- On # reduce production expr -> or_expr
** End-of-stream conflict on OR
**   There is a tension between
**   (1) reducing production expr -> or_expr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 92:
## Known stack suffix:
## expr
## LR(1) items:
expr' -> expr . [ # ]
## Transitions:
## Reductions:
-- On # accept expr

State 93:
## Known stack suffix:
##
## LR(1) items:
location_path' -> . location_path [ # ]
## Transitions:
-- On SLASH shift to state 2
-- On NODE_TYPE shift to state 3
-- On NAME_TEST shift to state 7
-- On DOUBLESLASH shift to state 20
-- On DOUBLEDOT shift to state 8
-- On DOT shift to state 9
-- On AXIS shift to state 10
-- On AT shift to state 11
-- On step2 shift to state 12
-- On step shift to state 21
-- On relative_location_path shift to state 32
-- On node_test shift to state 25
-- On location_path shift to state 94
-- On axis_specifier shift to state 26
-- On absolute_location_path shift to state 48
## Reductions:

State 94:
## Known stack suffix:
## location_path
## LR(1) items:
location_path' -> location_path . [ # ]
## Transitions:
## Reductions:
-- On # accept location_path

