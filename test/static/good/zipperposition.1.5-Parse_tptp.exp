Grammar has 82 nonterminal symbols, among which 5 start symbols.
Grammar has 47 terminal symbols.
Grammar has 175 productions.
nullable(variable) = false
nullable(unitary_infix_formula) = false
nullable(unitary_formula) = false
nullable(unitary_atomic_formula) = false
nullable(unary_formula) = false
nullable(typed_vars) = false
nullable(typed_var) = false
nullable(type_decl) = false
nullable(type_const) = false
nullable(tff_type) = false
nullable(tff_ty_vars) = false
nullable(tff_ty_var) = false
nullable(tff_ty_star_list) = false
nullable(tff_toplevel_type) = false
nullable(tff_quantified_type) = false
nullable(tff_atomic_type) = false
nullable(tff_app_type) = false
nullable(term_arguments) = false
nullable(term) = false
nullable(system_term) = false
nullable(system_functor) = false
nullable(system_constant) = false
nullable(separated_nonempty_list(VLINE,unary_formula)) = false
nullable(separated_nonempty_list(VLINE,literal)) = false
nullable(separated_nonempty_list(VLINE,answer_tuple)) = false
nullable(separated_nonempty_list(STAR,tff_app_type)) = false
nullable(separated_nonempty_list(COMMA,typed_var)) = false
nullable(separated_nonempty_list(COMMA,tff_type)) = false
nullable(separated_nonempty_list(COMMA,tff_ty_var)) = false
nullable(separated_nonempty_list(COMMA,term)) = false
nullable(separated_nonempty_list(COMMA,name)) = false
nullable(separated_nonempty_list(COMMA,general_term)) = false
nullable(separated_nonempty_list(COMMA,formula)) = false
nullable(separated_nonempty_list(AND,unary_formula)) = false
nullable(role) = false
nullable(quantified_formula) = false
nullable(plain_term) = false
nullable(parse_term) = false
nullable(parse_formula) = false
nullable(parse_declarations) = false
nullable(parse_declaration) = false
nullable(parse_answer_tuple) = false
nullable(or_formula) = false
nullable(nonassoc_binary_formula) = false
nullable(name_list) = true
nullable(name) = false
nullable(loption(separated_nonempty_list(COMMA,name))) = true
nullable(loption(separated_nonempty_list(COMMA,general_term))) = true
nullable(literal_atom) = false
nullable(literal) = false
nullable(list(declaration)) = true
nullable(general_term) = false
nullable(general_list) = false
nullable(general_function) = false
nullable(general_data) = false
nullable(functor_) = false
nullable(function_term) = false
nullable(formula) = false
nullable(disjunction) = false
nullable(defined_ty) = false
nullable(defined_term) = false
nullable(defined_plain_term) = false
nullable(defined_functor) = false
nullable(defined_atomic_term) = false
nullable(defined_atom) = false
nullable(declarations) = true
nullable(declaration) = false
nullable(cnf_formula) = false
nullable(binary_formula) = false
nullable(atomic_word) = false
nullable(atomic_term) = false
nullable(atomic_system_word) = false
nullable(atomic_formula) = false
nullable(atomic_defined_word) = false
nullable(assoc_binary_formula_aux(VLINE)) = false
nullable(assoc_binary_formula_aux(AND)) = false
nullable(assoc_binary_formula) = false
nullable(app_formula) = false
nullable(answer_tuples) = false
nullable(answer_tuple) = false
nullable(annotations) = true
nullable(and_formula) = false
first(variable) = UPPER_WORD
first(unitary_infix_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL LOWER_WORD LEFT_PAREN LAMBDA INTEGER FORALLCONST FORALL FALSE EXISTSCONST EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(unitary_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL LOWER_WORD LEFT_PAREN LAMBDA INTEGER FORALLCONST FORALL FALSE EXISTSCONST EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(unitary_atomic_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL LOWER_WORD LEFT_PAREN INTEGER FORALLCONST FALSE EXISTSCONST DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(unary_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LAMBDA INTEGER FORALLCONST FORALL FALSE EXISTSCONST EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(typed_vars) = UPPER_WORD
first(typed_var) = UPPER_WORD
first(type_decl) = SINGLE_QUOTED LOWER_WORD LEFT_PAREN
first(type_const) = WILDCARD SINGLE_QUOTED LOWER_WORD
first(tff_type) = WILDCARD UPPER_WORD TYPE_TY SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_ty_vars) = UPPER_WORD
first(tff_ty_var) = UPPER_WORD
first(tff_ty_star_list) = WILDCARD UPPER_WORD TYPE_TY SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_toplevel_type) = WILDCARD UPPER_WORD TYPE_TY SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_quantified_type) = WILDCARD UPPER_WORD TYPE_TY SINGLE_QUOTED LOWER_WORD LEFT_PAREN FORALL_TY DOLLAR_WORD
first(tff_atomic_type) = WILDCARD UPPER_WORD TYPE_TY SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_app_type) = WILDCARD UPPER_WORD TYPE_TY SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(term_arguments) = XOR WILDCARD VLINE UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOTVLINE NOTAND NOT LOWER_WORD LEFT_PAREN LEFT_IMPLY LAMBDA INTEGER IMPLY FORALLCONST FORALL FALSE EXISTSCONST EXISTS EQUIV DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT ARROW AND
first(term) = WILDCARD UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(system_term) = DOLLAR_DOLLAR_WORD
first(system_functor) = DOLLAR_DOLLAR_WORD
first(system_constant) = DOLLAR_DOLLAR_WORD
first(separated_nonempty_list(VLINE,unary_formula)) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LAMBDA INTEGER FORALLCONST FORALL FALSE EXISTSCONST EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(separated_nonempty_list(VLINE,literal)) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD INTEGER FORALLCONST FALSE EXISTSCONST DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(separated_nonempty_list(VLINE,answer_tuple)) = UNDERSCORE LEFT_BRACKET
first(separated_nonempty_list(STAR,tff_app_type)) = WILDCARD UPPER_WORD TYPE_TY SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(separated_nonempty_list(COMMA,typed_var)) = UPPER_WORD
first(separated_nonempty_list(COMMA,tff_type)) = WILDCARD UPPER_WORD TYPE_TY SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(separated_nonempty_list(COMMA,tff_ty_var)) = UPPER_WORD
first(separated_nonempty_list(COMMA,term)) = WILDCARD UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(separated_nonempty_list(COMMA,name)) = SINGLE_QUOTED LOWER_WORD INTEGER
first(separated_nonempty_list(COMMA,general_term)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_BRACKET INTEGER DISTINCT_OBJECT
first(separated_nonempty_list(COMMA,formula)) = XOR WILDCARD VLINE UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOTVLINE NOTAND NOT LOWER_WORD LEFT_PAREN LEFT_IMPLY LAMBDA INTEGER IMPLY FORALLCONST FORALL FALSE EXISTSCONST EXISTS EQUIV DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT ARROW AND
first(separated_nonempty_list(AND,unary_formula)) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LAMBDA INTEGER FORALLCONST FORALL FALSE EXISTSCONST EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(role) = LOWER_WORD
first(quantified_formula) = LAMBDA FORALL EXISTS
first(plain_term) = SINGLE_QUOTED LOWER_WORD
first(parse_term) = WILDCARD UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(parse_formula) = XOR WILDCARD VLINE UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOTVLINE NOTAND NOT LOWER_WORD LEFT_PAREN LEFT_IMPLY LAMBDA INTEGER IMPLY FORALLCONST FORALL FALSE EXISTSCONST EXISTS EQUIV DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT ARROW AND
first(parse_declarations) = error THF TFF INCLUDE FOF EOI CNF
first(parse_declaration) = error THF TFF INCLUDE FOF CNF
first(parse_answer_tuple) = LEFT_BRACKET
first(or_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LAMBDA INTEGER FORALLCONST FORALL FALSE EXISTSCONST EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(nonassoc_binary_formula) = XOR WILDCARD VLINE UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOTVLINE NOTAND NOT LOWER_WORD LEFT_PAREN LEFT_IMPLY LAMBDA INTEGER IMPLY FORALLCONST FORALL FALSE EXISTSCONST EXISTS EQUIV DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT ARROW AND
first(name_list) = SINGLE_QUOTED LOWER_WORD INTEGER
first(name) = SINGLE_QUOTED LOWER_WORD INTEGER
first(loption(separated_nonempty_list(COMMA,name))) = SINGLE_QUOTED LOWER_WORD INTEGER
first(loption(separated_nonempty_list(COMMA,general_term))) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_BRACKET INTEGER DISTINCT_OBJECT
first(literal_atom) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER FORALLCONST FALSE EXISTSCONST DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(literal) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD INTEGER FORALLCONST FALSE EXISTSCONST DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(list(declaration)) = error THF TFF INCLUDE FOF CNF
first(general_term) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_BRACKET INTEGER DISTINCT_OBJECT
first(general_list) = LEFT_BRACKET
first(general_function) = SINGLE_QUOTED LOWER_WORD
first(general_data) = UPPER_WORD SINGLE_QUOTED LOWER_WORD INTEGER DISTINCT_OBJECT
first(functor_) = SINGLE_QUOTED LOWER_WORD
first(function_term) = WILDCARD SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(formula) = XOR WILDCARD VLINE UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOTVLINE NOTAND NOT LOWER_WORD LEFT_PAREN LEFT_IMPLY LAMBDA INTEGER IMPLY FORALLCONST FORALL FALSE EXISTSCONST EXISTS EQUIV DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT ARROW AND
first(disjunction) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD INTEGER FORALLCONST FALSE EXISTSCONST DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(defined_ty) = DOLLAR_WORD
first(defined_term) = WILDCARD REAL RATIONAL INTEGER DOLLAR_WORD DISTINCT_OBJECT
first(defined_plain_term) = WILDCARD DOLLAR_WORD
first(defined_functor) = WILDCARD
first(defined_atomic_term) = WILDCARD DOLLAR_WORD
first(defined_atom) = REAL RATIONAL INTEGER DISTINCT_OBJECT
first(declarations) = error THF TFF INCLUDE FOF CNF
first(declaration) = error THF TFF INCLUDE FOF CNF
first(cnf_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN INTEGER FORALLCONST FALSE EXISTSCONST DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(binary_formula) = XOR WILDCARD VLINE UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOTVLINE NOTAND NOT LOWER_WORD LEFT_PAREN LEFT_IMPLY LAMBDA INTEGER IMPLY FORALLCONST FORALL FALSE EXISTSCONST EXISTS EQUIV DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT ARROW AND
first(atomic_word) = SINGLE_QUOTED LOWER_WORD
first(atomic_term) = SINGLE_QUOTED LOWER_WORD
first(atomic_system_word) = DOLLAR_DOLLAR_WORD
first(atomic_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER FORALLCONST FALSE EXISTSCONST DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(atomic_defined_word) = WILDCARD
first(assoc_binary_formula_aux(VLINE)) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LAMBDA INTEGER FORALLCONST FORALL FALSE EXISTSCONST EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(assoc_binary_formula_aux(AND)) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LAMBDA INTEGER FORALLCONST FORALL FALSE EXISTSCONST EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(assoc_binary_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LAMBDA INTEGER FORALLCONST FORALL FALSE EXISTSCONST EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(app_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL LOWER_WORD LEFT_PAREN LAMBDA INTEGER FORALLCONST FORALL FALSE EXISTSCONST EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(answer_tuples) = LEFT_BRACKET
first(answer_tuple) = UNDERSCORE LEFT_BRACKET
first(annotations) = COMMA
first(and_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LAMBDA INTEGER FORALLCONST FORALL FALSE EXISTSCONST EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
minimal(variable) = (* 1 *) UPPER_WORD
minimal(unitary_infix_formula) = (* 1 *) TRUE
minimal(unitary_formula) = (* 1 *) TRUE
minimal(unitary_atomic_formula) = (* 1 *) TRUE
minimal(unary_formula) = (* 1 *) TRUE
minimal(typed_vars) = (* 1 *) UPPER_WORD
minimal(typed_var) = (* 1 *) UPPER_WORD
minimal(type_decl) = (* 3 *) SINGLE_QUOTED COLUMN UPPER_WORD
minimal(type_const) = (* 1 *) WILDCARD
minimal(tff_type) = (* 1 *) UPPER_WORD
minimal(tff_ty_vars) = (* 3 *) UPPER_WORD COLUMN TYPE_TY
minimal(tff_ty_var) = (* 3 *) UPPER_WORD COLUMN TYPE_TY
minimal(tff_ty_star_list) = (* 3 *) UPPER_WORD STAR UPPER_WORD
minimal(tff_toplevel_type) = (* 1 *) UPPER_WORD
minimal(tff_quantified_type) = (* 1 *) UPPER_WORD
minimal(tff_atomic_type) = (* 1 *) UPPER_WORD
minimal(tff_app_type) = (* 1 *) UPPER_WORD
minimal(term_arguments) = (* 1 *) TRUE
minimal(term) = (* 1 *) SINGLE_QUOTED
minimal(system_term) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(system_functor) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(system_constant) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(separated_nonempty_list(VLINE,unary_formula)) = (* 1 *) TRUE
minimal(separated_nonempty_list(VLINE,literal)) = (* 1 *) TRUE
minimal(separated_nonempty_list(VLINE,answer_tuple)) = (* 1 *) UNDERSCORE
minimal(separated_nonempty_list(STAR,tff_app_type)) = (* 1 *) UPPER_WORD
minimal(separated_nonempty_list(COMMA,typed_var)) = (* 1 *) UPPER_WORD
minimal(separated_nonempty_list(COMMA,tff_type)) = (* 1 *) UPPER_WORD
minimal(separated_nonempty_list(COMMA,tff_ty_var)) = (* 3 *) UPPER_WORD COLUMN TYPE_TY
minimal(separated_nonempty_list(COMMA,term)) = (* 1 *) SINGLE_QUOTED
minimal(separated_nonempty_list(COMMA,name)) = (* 1 *) SINGLE_QUOTED
minimal(separated_nonempty_list(COMMA,general_term)) = (* 1 *) SINGLE_QUOTED
minimal(separated_nonempty_list(COMMA,formula)) = (* 1 *) TRUE
minimal(separated_nonempty_list(AND,unary_formula)) = (* 1 *) TRUE
minimal(role) = (* 1 *) LOWER_WORD
minimal(quantified_formula) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLUMN TRUE
minimal(plain_term) = (* 1 *) SINGLE_QUOTED
minimal(parse_term) = (* 2 *) SINGLE_QUOTED EOI
minimal(parse_formula) = (* 2 *) TRUE EOI
minimal(parse_declarations) = (* 1 *) EOI
minimal(parse_declaration) = (* 2 *) error EOI
minimal(parse_answer_tuple) = (* 4 *) LEFT_BRACKET UNDERSCORE RIGHT_BRACKET EOI
minimal(or_formula) = (* 3 *) TRUE VLINE TRUE
minimal(nonassoc_binary_formula) = (* 3 *) TRUE EQUIV TRUE
minimal(name_list) = (* 0 *)
minimal(name) = (* 1 *) SINGLE_QUOTED
minimal(loption(separated_nonempty_list(COMMA,name))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,general_term))) = (* 0 *)
minimal(literal_atom) = (* 1 *) TRUE
minimal(literal) = (* 1 *) TRUE
minimal(list(declaration)) = (* 0 *)
minimal(general_term) = (* 1 *) SINGLE_QUOTED
minimal(general_list) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(general_function) = (* 4 *) SINGLE_QUOTED LEFT_PAREN SINGLE_QUOTED RIGHT_PAREN
minimal(general_data) = (* 1 *) SINGLE_QUOTED
minimal(functor_) = (* 1 *) SINGLE_QUOTED
minimal(function_term) = (* 1 *) SINGLE_QUOTED
minimal(formula) = (* 1 *) TRUE
minimal(disjunction) = (* 1 *) TRUE
minimal(defined_ty) = (* 1 *) DOLLAR_WORD
minimal(defined_term) = (* 1 *) INTEGER
minimal(defined_plain_term) = (* 1 *) WILDCARD
minimal(defined_functor) = (* 1 *) WILDCARD
minimal(defined_atomic_term) = (* 1 *) WILDCARD
minimal(defined_atom) = (* 1 *) INTEGER
minimal(declarations) = (* 0 *)
minimal(declaration) = (* 1 *) error
minimal(cnf_formula) = (* 1 *) TRUE
minimal(binary_formula) = (* 3 *) TRUE EQUIV TRUE
minimal(atomic_word) = (* 1 *) SINGLE_QUOTED
minimal(atomic_term) = (* 1 *) SINGLE_QUOTED
minimal(atomic_system_word) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(atomic_formula) = (* 1 *) TRUE
minimal(atomic_defined_word) = (* 1 *) WILDCARD
minimal(assoc_binary_formula_aux(VLINE)) = (* 3 *) TRUE VLINE TRUE
minimal(assoc_binary_formula_aux(AND)) = (* 3 *) TRUE AND TRUE
minimal(assoc_binary_formula) = (* 3 *) TRUE AND TRUE
minimal(app_formula) = (* 3 *) TRUE AT TRUE
minimal(answer_tuples) = (* 3 *) LEFT_BRACKET UNDERSCORE RIGHT_BRACKET
minimal(answer_tuple) = (* 1 *) UNDERSCORE
minimal(annotations) = (* 0 *)
minimal(and_formula) = (* 3 *) TRUE AND TRUE
maximal(variable) = 1
maximal(unitary_infix_formula) = infinity
maximal(unitary_formula) = infinity
maximal(unitary_atomic_formula) = infinity
maximal(unary_formula) = infinity
maximal(typed_vars) = infinity
maximal(typed_var) = infinity
maximal(type_decl) = infinity
maximal(type_const) = 1
maximal(tff_type) = infinity
maximal(tff_ty_vars) = infinity
maximal(tff_ty_var) = 3
maximal(tff_ty_star_list) = infinity
maximal(tff_toplevel_type) = infinity
maximal(tff_quantified_type) = infinity
maximal(tff_atomic_type) = infinity
maximal(tff_app_type) = infinity
maximal(term_arguments) = infinity
maximal(term) = infinity
maximal(system_term) = infinity
maximal(system_functor) = 1
maximal(system_constant) = 1
maximal(separated_nonempty_list(VLINE,unary_formula)) = infinity
maximal(separated_nonempty_list(VLINE,literal)) = infinity
maximal(separated_nonempty_list(VLINE,answer_tuple)) = infinity
maximal(separated_nonempty_list(STAR,tff_app_type)) = infinity
maximal(separated_nonempty_list(COMMA,typed_var)) = infinity
maximal(separated_nonempty_list(COMMA,tff_type)) = infinity
maximal(separated_nonempty_list(COMMA,tff_ty_var)) = infinity
maximal(separated_nonempty_list(COMMA,term)) = infinity
maximal(separated_nonempty_list(COMMA,name)) = infinity
maximal(separated_nonempty_list(COMMA,general_term)) = infinity
maximal(separated_nonempty_list(COMMA,formula)) = infinity
maximal(separated_nonempty_list(AND,unary_formula)) = infinity
maximal(role) = 1
maximal(quantified_formula) = infinity
maximal(plain_term) = infinity
maximal(parse_term) = infinity
maximal(parse_formula) = infinity
maximal(parse_declarations) = infinity
maximal(parse_declaration) = infinity
maximal(parse_answer_tuple) = infinity
maximal(or_formula) = infinity
maximal(nonassoc_binary_formula) = infinity
maximal(name_list) = infinity
maximal(name) = 1
maximal(loption(separated_nonempty_list(COMMA,name))) = infinity
maximal(loption(separated_nonempty_list(COMMA,general_term))) = infinity
maximal(literal_atom) = infinity
maximal(literal) = infinity
maximal(list(declaration)) = infinity
maximal(general_term) = infinity
maximal(general_list) = infinity
maximal(general_function) = infinity
maximal(general_data) = infinity
maximal(functor_) = 1
maximal(function_term) = infinity
maximal(formula) = infinity
maximal(disjunction) = infinity
maximal(defined_ty) = 1
maximal(defined_term) = infinity
maximal(defined_plain_term) = infinity
maximal(defined_functor) = 1
maximal(defined_atomic_term) = infinity
maximal(defined_atom) = 1
maximal(declarations) = infinity
maximal(declaration) = infinity
maximal(cnf_formula) = infinity
maximal(binary_formula) = infinity
maximal(atomic_word) = 1
maximal(atomic_term) = 1
maximal(atomic_system_word) = 1
maximal(atomic_formula) = infinity
maximal(atomic_defined_word) = 1
maximal(assoc_binary_formula_aux(VLINE)) = infinity
maximal(assoc_binary_formula_aux(AND)) = infinity
maximal(assoc_binary_formula) = infinity
maximal(app_formula) = infinity
maximal(answer_tuples) = infinity
maximal(answer_tuple) = infinity
maximal(annotations) = infinity
maximal(and_formula) = infinity
follow(variable) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(unitary_infix_formula) = XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EOI COMMA AT ARROW AND
follow(unitary_formula) = XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EOI COMMA AT ARROW AND
follow(unitary_atomic_formula) = XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(unary_formula) = XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EOI COMMA AT ARROW AND
follow(typed_vars) = RIGHT_BRACKET
follow(typed_var) = RIGHT_BRACKET COMMA
follow(type_decl) = RIGHT_PAREN COMMA
follow(type_const) = STAR RIGHT_PAREN RIGHT_BRACKET LEFT_PAREN COMMA AT ARROW
follow(tff_type) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(tff_ty_vars) = RIGHT_BRACKET
follow(tff_ty_var) = RIGHT_BRACKET COMMA
follow(tff_ty_star_list) = RIGHT_PAREN
follow(tff_toplevel_type) = RIGHT_PAREN COMMA
follow(tff_quantified_type) = RIGHT_PAREN COMMA
follow(tff_atomic_type) = STAR RIGHT_PAREN RIGHT_BRACKET COMMA AT ARROW
follow(tff_app_type) = STAR RIGHT_PAREN RIGHT_BRACKET COMMA AT ARROW
follow(term_arguments) = RIGHT_PAREN
follow(term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(system_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(system_functor) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(system_constant) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(separated_nonempty_list(VLINE,unary_formula)) = RIGHT_PAREN EOI COMMA
follow(separated_nonempty_list(VLINE,literal)) = RIGHT_PAREN COMMA
follow(separated_nonempty_list(VLINE,answer_tuple)) = RIGHT_BRACKET
follow(separated_nonempty_list(STAR,tff_app_type)) = RIGHT_PAREN
follow(separated_nonempty_list(COMMA,typed_var)) = RIGHT_BRACKET
follow(separated_nonempty_list(COMMA,tff_type)) = RIGHT_PAREN
follow(separated_nonempty_list(COMMA,tff_ty_var)) = RIGHT_BRACKET
follow(separated_nonempty_list(COMMA,term)) = RIGHT_BRACKET
follow(separated_nonempty_list(COMMA,name)) = RIGHT_PAREN
follow(separated_nonempty_list(COMMA,general_term)) = RIGHT_PAREN RIGHT_BRACKET
follow(separated_nonempty_list(COMMA,formula)) = RIGHT_PAREN
follow(separated_nonempty_list(AND,unary_formula)) = RIGHT_PAREN EOI COMMA
follow(role) = COMMA
follow(quantified_formula) = XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EOI COMMA AT ARROW AND
follow(plain_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(parse_term) = #
follow(parse_formula) = #
follow(parse_declarations) = #
follow(parse_declaration) = #
follow(parse_answer_tuple) = #
follow(or_formula) = RIGHT_PAREN EOI COMMA
follow(nonassoc_binary_formula) = RIGHT_PAREN EOI COMMA
follow(name_list) = RIGHT_PAREN
follow(name) = RIGHT_PAREN COMMA
follow(loption(separated_nonempty_list(COMMA,name))) = RIGHT_PAREN
follow(loption(separated_nonempty_list(COMMA,general_term))) = RIGHT_PAREN RIGHT_BRACKET
follow(literal_atom) = VLINE RIGHT_PAREN COMMA
follow(literal) = VLINE RIGHT_PAREN COMMA
follow(list(declaration)) = EOI
follow(general_term) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(general_list) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(general_function) = RIGHT_PAREN RIGHT_BRACKET COMMA COLUMN
follow(general_data) = RIGHT_PAREN RIGHT_BRACKET COMMA COLUMN
follow(functor_) = LEFT_PAREN
follow(function_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(formula) = RIGHT_PAREN EOI COMMA
follow(disjunction) = RIGHT_PAREN COMMA
follow(defined_ty) = STAR RIGHT_PAREN RIGHT_BRACKET COMMA AT ARROW
follow(defined_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(defined_plain_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(defined_functor) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(defined_atomic_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(defined_atom) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(declarations) = EOI
follow(declaration) = error THF TFF INCLUDE FOF EOI CNF
follow(cnf_formula) = RIGHT_PAREN COMMA
follow(binary_formula) = RIGHT_PAREN EOI COMMA
follow(atomic_word) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA COLUMN AT ARROW AND
follow(atomic_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(atomic_system_word) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(atomic_formula) = XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(atomic_defined_word) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT ARROW AND
follow(assoc_binary_formula_aux(VLINE)) = RIGHT_PAREN EOI COMMA
follow(assoc_binary_formula_aux(AND)) = RIGHT_PAREN EOI COMMA
follow(assoc_binary_formula) = RIGHT_PAREN EOI COMMA
follow(app_formula) = RIGHT_PAREN EOI COMMA AT
follow(answer_tuples) = EOI
follow(answer_tuple) = VLINE RIGHT_BRACKET
follow(annotations) = RIGHT_PAREN
follow(and_formula) = RIGHT_PAREN EOI COMMA
Built an LR(0) automaton with 365 states.
The grammar is not SLR(1) -- 1 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 423 states.
159 out of 423 states have a default reduction.
121 out of 423 states are represented.
53 out of 136 symbols keep track of their start position.
39 out of 136 symbols keep track of their end position.
106 out of 180 productions exploit shiftreduce optimization.
2 out of 423 states can peek at an error.
1117 functions before inlining, 134 functions after inlining.
