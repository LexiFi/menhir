State 0:
parse_statement' -> . parse_statement [ # ]
-- On error shift to state 1
-- On VAL shift to state 2
-- On REWRITE shift to state 156
-- On LEMMA shift to state 163
-- On INCLUDE shift to state 167
-- On GOAL shift to state 170
-- On DEF shift to state 174
-- On DATA shift to state 203
-- On ASSERT shift to state 233
-- On statement shift to state 237
-- On parse_statement shift to state 239

State 1:
statement -> error . [ EOI ]
-- On EOI reduce production statement -> error 

State 2:
statement -> VAL . attrs raw_var COLON term DOT [ EOI ]
-- On LEFT_BRACKET shift to state 3
-- On attrs shift to state 27
-- On UPPER_WORD reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 

State 3:
attrs -> LEFT_BRACKET . separated_nonempty_list(COMMA,attr) RIGHT_BRACKET [ UPPER_WORD SINGLE_QUOTED LOWER_WORD ]
-- On error shift to state 4
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On separated_nonempty_list(COMMA,attr) shift to state 25
-- On raw_var shift to state 12
-- On attr shift to state 19
-- On atomic_attr shift to state 22

State 4:
attr -> error . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
-- On RIGHT_PAREN reduce production attr -> error 
-- On RIGHT_BRACKET reduce production attr -> error 
-- On COMMA reduce production attr -> error 

State 5:
raw_var -> UPPER_WORD . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN RIGHT_BRACKET QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET INTEGER INT IN EQDEF EOI END ELSE DOT COMMA COLON ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production raw_var -> UPPER_WORD 
-- On WILDCARD reduce production raw_var -> UPPER_WORD 
-- On WHERE reduce production raw_var -> UPPER_WORD 
-- On VERTICAL_BAR reduce production raw_var -> UPPER_WORD 
-- On UPPER_WORD reduce production raw_var -> UPPER_WORD 
-- On TYPE reduce production raw_var -> UPPER_WORD 
-- On THEN reduce production raw_var -> UPPER_WORD 
-- On SINGLE_QUOTED reduce production raw_var -> UPPER_WORD 
-- On SEMI_COLON reduce production raw_var -> UPPER_WORD 
-- On RIGHT_PAREN reduce production raw_var -> UPPER_WORD 
-- On RIGHT_BRACKET reduce production raw_var -> UPPER_WORD 
-- On QUOTED reduce production raw_var -> UPPER_WORD 
-- On PROP reduce production raw_var -> UPPER_WORD 
-- On MATCH reduce production raw_var -> UPPER_WORD 
-- On LOWER_WORD reduce production raw_var -> UPPER_WORD 
-- On LOGIC_TRUE reduce production raw_var -> UPPER_WORD 
-- On LOGIC_OR reduce production raw_var -> UPPER_WORD 
-- On LOGIC_NEQ reduce production raw_var -> UPPER_WORD 
-- On LOGIC_IMPLY reduce production raw_var -> UPPER_WORD 
-- On LOGIC_FALSE reduce production raw_var -> UPPER_WORD 
-- On LOGIC_EQUIV reduce production raw_var -> UPPER_WORD 
-- On LOGIC_EQ reduce production raw_var -> UPPER_WORD 
-- On LOGIC_AND reduce production raw_var -> UPPER_WORD 
-- On LEFT_PAREN reduce production raw_var -> UPPER_WORD 
-- On LEFT_BRACKET reduce production raw_var -> UPPER_WORD 
-- On INTEGER reduce production raw_var -> UPPER_WORD 
-- On INT reduce production raw_var -> UPPER_WORD 
-- On IN reduce production raw_var -> UPPER_WORD 
-- On EQDEF reduce production raw_var -> UPPER_WORD 
-- On EOI reduce production raw_var -> UPPER_WORD 
-- On END reduce production raw_var -> UPPER_WORD 
-- On ELSE reduce production raw_var -> UPPER_WORD 
-- On DOT reduce production raw_var -> UPPER_WORD 
-- On COMMA reduce production raw_var -> UPPER_WORD 
-- On COLON reduce production raw_var -> UPPER_WORD 
-- On ARROW reduce production raw_var -> UPPER_WORD 
-- On ARITH_PRODUCT reduce production raw_var -> UPPER_WORD 
-- On ARITH_PLUS reduce production raw_var -> UPPER_WORD 
-- On ARITH_MINUS reduce production raw_var -> UPPER_WORD 
-- On ARITH_LT reduce production raw_var -> UPPER_WORD 
-- On ARITH_LEQ reduce production raw_var -> UPPER_WORD 
-- On ARITH_GT reduce production raw_var -> UPPER_WORD 
-- On ARITH_GEQ reduce production raw_var -> UPPER_WORD 
-- On AND reduce production raw_var -> UPPER_WORD 

State 6:
raw_var -> SINGLE_QUOTED . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN RIGHT_BRACKET QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET INTEGER INT IN EQDEF EOI END ELSE DOT COMMA COLON ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production raw_var -> SINGLE_QUOTED 
-- On WILDCARD reduce production raw_var -> SINGLE_QUOTED 
-- On WHERE reduce production raw_var -> SINGLE_QUOTED 
-- On VERTICAL_BAR reduce production raw_var -> SINGLE_QUOTED 
-- On UPPER_WORD reduce production raw_var -> SINGLE_QUOTED 
-- On TYPE reduce production raw_var -> SINGLE_QUOTED 
-- On THEN reduce production raw_var -> SINGLE_QUOTED 
-- On SINGLE_QUOTED reduce production raw_var -> SINGLE_QUOTED 
-- On SEMI_COLON reduce production raw_var -> SINGLE_QUOTED 
-- On RIGHT_PAREN reduce production raw_var -> SINGLE_QUOTED 
-- On RIGHT_BRACKET reduce production raw_var -> SINGLE_QUOTED 
-- On QUOTED reduce production raw_var -> SINGLE_QUOTED 
-- On PROP reduce production raw_var -> SINGLE_QUOTED 
-- On MATCH reduce production raw_var -> SINGLE_QUOTED 
-- On LOWER_WORD reduce production raw_var -> SINGLE_QUOTED 
-- On LOGIC_TRUE reduce production raw_var -> SINGLE_QUOTED 
-- On LOGIC_OR reduce production raw_var -> SINGLE_QUOTED 
-- On LOGIC_NEQ reduce production raw_var -> SINGLE_QUOTED 
-- On LOGIC_IMPLY reduce production raw_var -> SINGLE_QUOTED 
-- On LOGIC_FALSE reduce production raw_var -> SINGLE_QUOTED 
-- On LOGIC_EQUIV reduce production raw_var -> SINGLE_QUOTED 
-- On LOGIC_EQ reduce production raw_var -> SINGLE_QUOTED 
-- On LOGIC_AND reduce production raw_var -> SINGLE_QUOTED 
-- On LEFT_PAREN reduce production raw_var -> SINGLE_QUOTED 
-- On LEFT_BRACKET reduce production raw_var -> SINGLE_QUOTED 
-- On INTEGER reduce production raw_var -> SINGLE_QUOTED 
-- On INT reduce production raw_var -> SINGLE_QUOTED 
-- On IN reduce production raw_var -> SINGLE_QUOTED 
-- On EQDEF reduce production raw_var -> SINGLE_QUOTED 
-- On EOI reduce production raw_var -> SINGLE_QUOTED 
-- On END reduce production raw_var -> SINGLE_QUOTED 
-- On ELSE reduce production raw_var -> SINGLE_QUOTED 
-- On DOT reduce production raw_var -> SINGLE_QUOTED 
-- On COMMA reduce production raw_var -> SINGLE_QUOTED 
-- On COLON reduce production raw_var -> SINGLE_QUOTED 
-- On ARROW reduce production raw_var -> SINGLE_QUOTED 
-- On ARITH_PRODUCT reduce production raw_var -> SINGLE_QUOTED 
-- On ARITH_PLUS reduce production raw_var -> SINGLE_QUOTED 
-- On ARITH_MINUS reduce production raw_var -> SINGLE_QUOTED 
-- On ARITH_LT reduce production raw_var -> SINGLE_QUOTED 
-- On ARITH_LEQ reduce production raw_var -> SINGLE_QUOTED 
-- On ARITH_GT reduce production raw_var -> SINGLE_QUOTED 
-- On ARITH_GEQ reduce production raw_var -> SINGLE_QUOTED 
-- On AND reduce production raw_var -> SINGLE_QUOTED 

State 7:
atomic_attr -> QUOTED . [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
-- On UPPER_WORD reduce production atomic_attr -> QUOTED 
-- On SINGLE_QUOTED reduce production atomic_attr -> QUOTED 
-- On RIGHT_PAREN reduce production atomic_attr -> QUOTED 
-- On RIGHT_BRACKET reduce production atomic_attr -> QUOTED 
-- On QUOTED reduce production atomic_attr -> QUOTED 
-- On LOWER_WORD reduce production atomic_attr -> QUOTED 
-- On LEFT_PAREN reduce production atomic_attr -> QUOTED 
-- On LEFT_BRACKET reduce production atomic_attr -> QUOTED 
-- On COMMA reduce production atomic_attr -> QUOTED 

State 8:
raw_var -> LOWER_WORD . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN RIGHT_BRACKET QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET INTEGER INT IN EQDEF EOI END ELSE DOT COMMA COLON ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production raw_var -> LOWER_WORD 
-- On WILDCARD reduce production raw_var -> LOWER_WORD 
-- On WHERE reduce production raw_var -> LOWER_WORD 
-- On VERTICAL_BAR reduce production raw_var -> LOWER_WORD 
-- On UPPER_WORD reduce production raw_var -> LOWER_WORD 
-- On TYPE reduce production raw_var -> LOWER_WORD 
-- On THEN reduce production raw_var -> LOWER_WORD 
-- On SINGLE_QUOTED reduce production raw_var -> LOWER_WORD 
-- On SEMI_COLON reduce production raw_var -> LOWER_WORD 
-- On RIGHT_PAREN reduce production raw_var -> LOWER_WORD 
-- On RIGHT_BRACKET reduce production raw_var -> LOWER_WORD 
-- On QUOTED reduce production raw_var -> LOWER_WORD 
-- On PROP reduce production raw_var -> LOWER_WORD 
-- On MATCH reduce production raw_var -> LOWER_WORD 
-- On LOWER_WORD reduce production raw_var -> LOWER_WORD 
-- On LOGIC_TRUE reduce production raw_var -> LOWER_WORD 
-- On LOGIC_OR reduce production raw_var -> LOWER_WORD 
-- On LOGIC_NEQ reduce production raw_var -> LOWER_WORD 
-- On LOGIC_IMPLY reduce production raw_var -> LOWER_WORD 
-- On LOGIC_FALSE reduce production raw_var -> LOWER_WORD 
-- On LOGIC_EQUIV reduce production raw_var -> LOWER_WORD 
-- On LOGIC_EQ reduce production raw_var -> LOWER_WORD 
-- On LOGIC_AND reduce production raw_var -> LOWER_WORD 
-- On LEFT_PAREN reduce production raw_var -> LOWER_WORD 
-- On LEFT_BRACKET reduce production raw_var -> LOWER_WORD 
-- On INTEGER reduce production raw_var -> LOWER_WORD 
-- On INT reduce production raw_var -> LOWER_WORD 
-- On IN reduce production raw_var -> LOWER_WORD 
-- On EQDEF reduce production raw_var -> LOWER_WORD 
-- On EOI reduce production raw_var -> LOWER_WORD 
-- On END reduce production raw_var -> LOWER_WORD 
-- On ELSE reduce production raw_var -> LOWER_WORD 
-- On DOT reduce production raw_var -> LOWER_WORD 
-- On COMMA reduce production raw_var -> LOWER_WORD 
-- On COLON reduce production raw_var -> LOWER_WORD 
-- On ARROW reduce production raw_var -> LOWER_WORD 
-- On ARITH_PRODUCT reduce production raw_var -> LOWER_WORD 
-- On ARITH_PLUS reduce production raw_var -> LOWER_WORD 
-- On ARITH_MINUS reduce production raw_var -> LOWER_WORD 
-- On ARITH_LT reduce production raw_var -> LOWER_WORD 
-- On ARITH_LEQ reduce production raw_var -> LOWER_WORD 
-- On ARITH_GT reduce production raw_var -> LOWER_WORD 
-- On ARITH_GEQ reduce production raw_var -> LOWER_WORD 
-- On AND reduce production raw_var -> LOWER_WORD 

State 9:
atomic_attr -> LEFT_PAREN . attr RIGHT_PAREN [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
-- On error shift to state 4
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On raw_var shift to state 12
-- On attr shift to state 23
-- On atomic_attr shift to state 22

State 10:
atomic_attr -> LEFT_BRACKET . loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
-- On error shift to state 4
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On separated_nonempty_list(COMMA,attr) shift to state 11
-- On raw_var shift to state 12
-- On loption(separated_nonempty_list(COMMA,attr)) shift to state 17
-- On attr shift to state 19
-- On atomic_attr shift to state 22
-- On RIGHT_BRACKET reduce production loption(separated_nonempty_list(COMMA,attr)) -> 

State 11:
loption(separated_nonempty_list(COMMA,attr)) -> separated_nonempty_list(COMMA,attr) . [ RIGHT_BRACKET ]
-- On RIGHT_BRACKET reduce production loption(separated_nonempty_list(COMMA,attr)) -> separated_nonempty_list(COMMA,attr) 

State 12:
atomic_attr -> raw_var . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
attr -> raw_var . nonempty_list(atomic_attr) [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On raw_var shift to state 13
-- On nonempty_list(atomic_attr) shift to state 14
-- On atomic_attr shift to state 15
-- On RIGHT_PAREN reduce production atomic_attr -> raw_var 
-- On RIGHT_BRACKET reduce production atomic_attr -> raw_var 
-- On COMMA reduce production atomic_attr -> raw_var 

State 13:
atomic_attr -> raw_var . [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
-- On UPPER_WORD reduce production atomic_attr -> raw_var 
-- On SINGLE_QUOTED reduce production atomic_attr -> raw_var 
-- On RIGHT_PAREN reduce production atomic_attr -> raw_var 
-- On RIGHT_BRACKET reduce production atomic_attr -> raw_var 
-- On QUOTED reduce production atomic_attr -> raw_var 
-- On LOWER_WORD reduce production atomic_attr -> raw_var 
-- On LEFT_PAREN reduce production atomic_attr -> raw_var 
-- On LEFT_BRACKET reduce production atomic_attr -> raw_var 
-- On COMMA reduce production atomic_attr -> raw_var 

State 14:
attr -> raw_var nonempty_list(atomic_attr) . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
-- On RIGHT_PAREN reduce production attr -> raw_var nonempty_list(atomic_attr) 
-- On RIGHT_BRACKET reduce production attr -> raw_var nonempty_list(atomic_attr) 
-- On COMMA reduce production attr -> raw_var nonempty_list(atomic_attr) 

State 15:
nonempty_list(atomic_attr) -> atomic_attr . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
nonempty_list(atomic_attr) -> atomic_attr . nonempty_list(atomic_attr) [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On raw_var shift to state 13
-- On nonempty_list(atomic_attr) shift to state 16
-- On atomic_attr shift to state 15
-- On RIGHT_PAREN reduce production nonempty_list(atomic_attr) -> atomic_attr 
-- On RIGHT_BRACKET reduce production nonempty_list(atomic_attr) -> atomic_attr 
-- On COMMA reduce production nonempty_list(atomic_attr) -> atomic_attr 

State 16:
nonempty_list(atomic_attr) -> atomic_attr nonempty_list(atomic_attr) . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
-- On RIGHT_PAREN reduce production nonempty_list(atomic_attr) -> atomic_attr nonempty_list(atomic_attr) 
-- On RIGHT_BRACKET reduce production nonempty_list(atomic_attr) -> atomic_attr nonempty_list(atomic_attr) 
-- On COMMA reduce production nonempty_list(atomic_attr) -> atomic_attr nonempty_list(atomic_attr) 

State 17:
atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) . RIGHT_BRACKET [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
-- On RIGHT_BRACKET shift to state 18

State 18:
atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET . [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
-- On UPPER_WORD reduce production atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET 
-- On SINGLE_QUOTED reduce production atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET 
-- On RIGHT_PAREN reduce production atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET 
-- On RIGHT_BRACKET reduce production atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET 
-- On QUOTED reduce production atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET 
-- On LOWER_WORD reduce production atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET 
-- On LEFT_PAREN reduce production atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET 
-- On LEFT_BRACKET reduce production atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET 
-- On COMMA reduce production atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET 

State 19:
separated_nonempty_list(COMMA,attr) -> attr . [ RIGHT_BRACKET ]
separated_nonempty_list(COMMA,attr) -> attr . COMMA separated_nonempty_list(COMMA,attr) [ RIGHT_BRACKET ]
-- On COMMA shift to state 20
-- On RIGHT_BRACKET reduce production separated_nonempty_list(COMMA,attr) -> attr 

State 20:
separated_nonempty_list(COMMA,attr) -> attr COMMA . separated_nonempty_list(COMMA,attr) [ RIGHT_BRACKET ]
-- On error shift to state 4
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On separated_nonempty_list(COMMA,attr) shift to state 21
-- On raw_var shift to state 12
-- On attr shift to state 19
-- On atomic_attr shift to state 22

State 21:
separated_nonempty_list(COMMA,attr) -> attr COMMA separated_nonempty_list(COMMA,attr) . [ RIGHT_BRACKET ]
-- On RIGHT_BRACKET reduce production separated_nonempty_list(COMMA,attr) -> attr COMMA separated_nonempty_list(COMMA,attr) 

State 22:
attr -> atomic_attr . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
-- On RIGHT_PAREN reduce production attr -> atomic_attr 
-- On RIGHT_BRACKET reduce production attr -> atomic_attr 
-- On COMMA reduce production attr -> atomic_attr 

State 23:
atomic_attr -> LEFT_PAREN attr . RIGHT_PAREN [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
-- On RIGHT_PAREN shift to state 24

State 24:
atomic_attr -> LEFT_PAREN attr RIGHT_PAREN . [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
-- On UPPER_WORD reduce production atomic_attr -> LEFT_PAREN attr RIGHT_PAREN 
-- On SINGLE_QUOTED reduce production atomic_attr -> LEFT_PAREN attr RIGHT_PAREN 
-- On RIGHT_PAREN reduce production atomic_attr -> LEFT_PAREN attr RIGHT_PAREN 
-- On RIGHT_BRACKET reduce production atomic_attr -> LEFT_PAREN attr RIGHT_PAREN 
-- On QUOTED reduce production atomic_attr -> LEFT_PAREN attr RIGHT_PAREN 
-- On LOWER_WORD reduce production atomic_attr -> LEFT_PAREN attr RIGHT_PAREN 
-- On LEFT_PAREN reduce production atomic_attr -> LEFT_PAREN attr RIGHT_PAREN 
-- On LEFT_BRACKET reduce production atomic_attr -> LEFT_PAREN attr RIGHT_PAREN 
-- On COMMA reduce production atomic_attr -> LEFT_PAREN attr RIGHT_PAREN 

State 25:
attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) . RIGHT_BRACKET [ UPPER_WORD SINGLE_QUOTED LOWER_WORD ]
-- On RIGHT_BRACKET shift to state 26

State 26:
attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET . [ UPPER_WORD SINGLE_QUOTED LOWER_WORD ]
-- On UPPER_WORD reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On SINGLE_QUOTED reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On LOWER_WORD reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 

State 27:
statement -> VAL attrs . raw_var COLON term DOT [ EOI ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 28

State 28:
statement -> VAL attrs raw_var . COLON term DOT [ EOI ]
-- On COLON shift to state 29

State 29:
statement -> VAL attrs raw_var COLON . term DOT [ EOI ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 154
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 30:
term -> error . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production term -> error 
-- On WHERE reduce production term -> error 
-- On VERTICAL_BAR reduce production term -> error 
-- On THEN reduce production term -> error 
-- On SEMI_COLON reduce production term -> error 
-- On RIGHT_PAREN reduce production term -> error 
-- On IN reduce production term -> error 
-- On EQDEF reduce production term -> error 
-- On EOI reduce production term -> error 
-- On END reduce production term -> error 
-- On ELSE reduce production term -> error 
-- On DOT reduce production term -> error 
-- On AND reduce production term -> error 

State 31:
var -> WILDCARD . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production var -> WILDCARD 
-- On WILDCARD reduce production var -> WILDCARD 
-- On WHERE reduce production var -> WILDCARD 
-- On VERTICAL_BAR reduce production var -> WILDCARD 
-- On UPPER_WORD reduce production var -> WILDCARD 
-- On TYPE reduce production var -> WILDCARD 
-- On THEN reduce production var -> WILDCARD 
-- On SINGLE_QUOTED reduce production var -> WILDCARD 
-- On SEMI_COLON reduce production var -> WILDCARD 
-- On RIGHT_PAREN reduce production var -> WILDCARD 
-- On PROP reduce production var -> WILDCARD 
-- On MATCH reduce production var -> WILDCARD 
-- On LOWER_WORD reduce production var -> WILDCARD 
-- On LOGIC_TRUE reduce production var -> WILDCARD 
-- On LOGIC_OR reduce production var -> WILDCARD 
-- On LOGIC_NEQ reduce production var -> WILDCARD 
-- On LOGIC_IMPLY reduce production var -> WILDCARD 
-- On LOGIC_FALSE reduce production var -> WILDCARD 
-- On LOGIC_EQUIV reduce production var -> WILDCARD 
-- On LOGIC_EQ reduce production var -> WILDCARD 
-- On LOGIC_AND reduce production var -> WILDCARD 
-- On LEFT_PAREN reduce production var -> WILDCARD 
-- On INTEGER reduce production var -> WILDCARD 
-- On INT reduce production var -> WILDCARD 
-- On IN reduce production var -> WILDCARD 
-- On EQDEF reduce production var -> WILDCARD 
-- On EOI reduce production var -> WILDCARD 
-- On END reduce production var -> WILDCARD 
-- On ELSE reduce production var -> WILDCARD 
-- On DOT reduce production var -> WILDCARD 
-- On ARROW reduce production var -> WILDCARD 
-- On ARITH_PRODUCT reduce production var -> WILDCARD 
-- On ARITH_PLUS reduce production var -> WILDCARD 
-- On ARITH_MINUS reduce production var -> WILDCARD 
-- On ARITH_LT reduce production var -> WILDCARD 
-- On ARITH_LEQ reduce production var -> WILDCARD 
-- On ARITH_GT reduce production var -> WILDCARD 
-- On ARITH_GEQ reduce production var -> WILDCARD 
-- On AND reduce production var -> WILDCARD 

State 32:
const -> TYPE . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production const -> TYPE 
-- On WILDCARD reduce production const -> TYPE 
-- On WHERE reduce production const -> TYPE 
-- On VERTICAL_BAR reduce production const -> TYPE 
-- On UPPER_WORD reduce production const -> TYPE 
-- On TYPE reduce production const -> TYPE 
-- On THEN reduce production const -> TYPE 
-- On SINGLE_QUOTED reduce production const -> TYPE 
-- On SEMI_COLON reduce production const -> TYPE 
-- On RIGHT_PAREN reduce production const -> TYPE 
-- On PROP reduce production const -> TYPE 
-- On MATCH reduce production const -> TYPE 
-- On LOWER_WORD reduce production const -> TYPE 
-- On LOGIC_TRUE reduce production const -> TYPE 
-- On LOGIC_OR reduce production const -> TYPE 
-- On LOGIC_NEQ reduce production const -> TYPE 
-- On LOGIC_IMPLY reduce production const -> TYPE 
-- On LOGIC_FALSE reduce production const -> TYPE 
-- On LOGIC_EQUIV reduce production const -> TYPE 
-- On LOGIC_EQ reduce production const -> TYPE 
-- On LOGIC_AND reduce production const -> TYPE 
-- On LEFT_PAREN reduce production const -> TYPE 
-- On INTEGER reduce production const -> TYPE 
-- On INT reduce production const -> TYPE 
-- On IN reduce production const -> TYPE 
-- On EQDEF reduce production const -> TYPE 
-- On EOI reduce production const -> TYPE 
-- On END reduce production const -> TYPE 
-- On ELSE reduce production const -> TYPE 
-- On DOT reduce production const -> TYPE 
-- On ARROW reduce production const -> TYPE 
-- On ARITH_PRODUCT reduce production const -> TYPE 
-- On ARITH_PLUS reduce production const -> TYPE 
-- On ARITH_MINUS reduce production const -> TYPE 
-- On ARITH_LT reduce production const -> TYPE 
-- On ARITH_LEQ reduce production const -> TYPE 
-- On ARITH_GT reduce production const -> TYPE 
-- On ARITH_GEQ reduce production const -> TYPE 
-- On AND reduce production const -> TYPE 

State 33:
const -> PROP . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production const -> PROP 
-- On WILDCARD reduce production const -> PROP 
-- On WHERE reduce production const -> PROP 
-- On VERTICAL_BAR reduce production const -> PROP 
-- On UPPER_WORD reduce production const -> PROP 
-- On TYPE reduce production const -> PROP 
-- On THEN reduce production const -> PROP 
-- On SINGLE_QUOTED reduce production const -> PROP 
-- On SEMI_COLON reduce production const -> PROP 
-- On RIGHT_PAREN reduce production const -> PROP 
-- On PROP reduce production const -> PROP 
-- On MATCH reduce production const -> PROP 
-- On LOWER_WORD reduce production const -> PROP 
-- On LOGIC_TRUE reduce production const -> PROP 
-- On LOGIC_OR reduce production const -> PROP 
-- On LOGIC_NEQ reduce production const -> PROP 
-- On LOGIC_IMPLY reduce production const -> PROP 
-- On LOGIC_FALSE reduce production const -> PROP 
-- On LOGIC_EQUIV reduce production const -> PROP 
-- On LOGIC_EQ reduce production const -> PROP 
-- On LOGIC_AND reduce production const -> PROP 
-- On LEFT_PAREN reduce production const -> PROP 
-- On INTEGER reduce production const -> PROP 
-- On INT reduce production const -> PROP 
-- On IN reduce production const -> PROP 
-- On EQDEF reduce production const -> PROP 
-- On EOI reduce production const -> PROP 
-- On END reduce production const -> PROP 
-- On ELSE reduce production const -> PROP 
-- On DOT reduce production const -> PROP 
-- On ARROW reduce production const -> PROP 
-- On ARITH_PRODUCT reduce production const -> PROP 
-- On ARITH_PLUS reduce production const -> PROP 
-- On ARITH_MINUS reduce production const -> PROP 
-- On ARITH_LT reduce production const -> PROP 
-- On ARITH_LEQ reduce production const -> PROP 
-- On ARITH_GT reduce production const -> PROP 
-- On ARITH_GEQ reduce production const -> PROP 
-- On AND reduce production const -> PROP 

State 34:
term -> PI . typed_ty_var_list DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 35
-- On typed_ty_var_list shift to state 42
-- On typed_ty_var_block shift to state 149
-- On raw_var shift to state 151

State 35:
typed_ty_var_block -> LEFT_PAREN . nonempty_list(raw_var) COLON TYPE RIGHT_PAREN [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 36
-- On nonempty_list(raw_var) shift to state 38

State 36:
nonempty_list(raw_var) -> raw_var . [ COLON ]
nonempty_list(raw_var) -> raw_var . nonempty_list(raw_var) [ COLON ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 36
-- On nonempty_list(raw_var) shift to state 37
-- On COLON reduce production nonempty_list(raw_var) -> raw_var 

State 37:
nonempty_list(raw_var) -> raw_var nonempty_list(raw_var) . [ COLON ]
-- On COLON reduce production nonempty_list(raw_var) -> raw_var nonempty_list(raw_var) 

State 38:
typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) . COLON TYPE RIGHT_PAREN [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On COLON shift to state 39

State 39:
typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON . TYPE RIGHT_PAREN [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On TYPE shift to state 40

State 40:
typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON TYPE . RIGHT_PAREN [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On RIGHT_PAREN shift to state 41

State 41:
typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON TYPE RIGHT_PAREN . [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On UPPER_WORD reduce production typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON TYPE RIGHT_PAREN 
-- On SINGLE_QUOTED reduce production typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON TYPE RIGHT_PAREN 
-- On LOWER_WORD reduce production typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON TYPE RIGHT_PAREN 
-- On LEFT_PAREN reduce production typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON TYPE RIGHT_PAREN 
-- On DOT reduce production typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON TYPE RIGHT_PAREN 

State 42:
term -> PI typed_ty_var_list . DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On DOT shift to state 43

State 43:
term -> PI typed_ty_var_list DOT . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 148
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 44:
atomic_term -> MATCH . term WITH nonempty_list(match_branch) END [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 133
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 45:
const -> LOGIC_TRUE . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production const -> LOGIC_TRUE 
-- On WILDCARD reduce production const -> LOGIC_TRUE 
-- On WHERE reduce production const -> LOGIC_TRUE 
-- On VERTICAL_BAR reduce production const -> LOGIC_TRUE 
-- On UPPER_WORD reduce production const -> LOGIC_TRUE 
-- On TYPE reduce production const -> LOGIC_TRUE 
-- On THEN reduce production const -> LOGIC_TRUE 
-- On SINGLE_QUOTED reduce production const -> LOGIC_TRUE 
-- On SEMI_COLON reduce production const -> LOGIC_TRUE 
-- On RIGHT_PAREN reduce production const -> LOGIC_TRUE 
-- On PROP reduce production const -> LOGIC_TRUE 
-- On MATCH reduce production const -> LOGIC_TRUE 
-- On LOWER_WORD reduce production const -> LOGIC_TRUE 
-- On LOGIC_TRUE reduce production const -> LOGIC_TRUE 
-- On LOGIC_OR reduce production const -> LOGIC_TRUE 
-- On LOGIC_NEQ reduce production const -> LOGIC_TRUE 
-- On LOGIC_IMPLY reduce production const -> LOGIC_TRUE 
-- On LOGIC_FALSE reduce production const -> LOGIC_TRUE 
-- On LOGIC_EQUIV reduce production const -> LOGIC_TRUE 
-- On LOGIC_EQ reduce production const -> LOGIC_TRUE 
-- On LOGIC_AND reduce production const -> LOGIC_TRUE 
-- On LEFT_PAREN reduce production const -> LOGIC_TRUE 
-- On INTEGER reduce production const -> LOGIC_TRUE 
-- On INT reduce production const -> LOGIC_TRUE 
-- On IN reduce production const -> LOGIC_TRUE 
-- On EQDEF reduce production const -> LOGIC_TRUE 
-- On EOI reduce production const -> LOGIC_TRUE 
-- On END reduce production const -> LOGIC_TRUE 
-- On ELSE reduce production const -> LOGIC_TRUE 
-- On DOT reduce production const -> LOGIC_TRUE 
-- On ARROW reduce production const -> LOGIC_TRUE 
-- On ARITH_PRODUCT reduce production const -> LOGIC_TRUE 
-- On ARITH_PLUS reduce production const -> LOGIC_TRUE 
-- On ARITH_MINUS reduce production const -> LOGIC_TRUE 
-- On ARITH_LT reduce production const -> LOGIC_TRUE 
-- On ARITH_LEQ reduce production const -> LOGIC_TRUE 
-- On ARITH_GT reduce production const -> LOGIC_TRUE 
-- On ARITH_GEQ reduce production const -> LOGIC_TRUE 
-- On AND reduce production const -> LOGIC_TRUE 

State 46:
not_term -> LOGIC_NOT . arith_op_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 132
-- On apply_term shift to state 82

State 47:
const -> LOGIC_FALSE . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production const -> LOGIC_FALSE 
-- On WILDCARD reduce production const -> LOGIC_FALSE 
-- On WHERE reduce production const -> LOGIC_FALSE 
-- On VERTICAL_BAR reduce production const -> LOGIC_FALSE 
-- On UPPER_WORD reduce production const -> LOGIC_FALSE 
-- On TYPE reduce production const -> LOGIC_FALSE 
-- On THEN reduce production const -> LOGIC_FALSE 
-- On SINGLE_QUOTED reduce production const -> LOGIC_FALSE 
-- On SEMI_COLON reduce production const -> LOGIC_FALSE 
-- On RIGHT_PAREN reduce production const -> LOGIC_FALSE 
-- On PROP reduce production const -> LOGIC_FALSE 
-- On MATCH reduce production const -> LOGIC_FALSE 
-- On LOWER_WORD reduce production const -> LOGIC_FALSE 
-- On LOGIC_TRUE reduce production const -> LOGIC_FALSE 
-- On LOGIC_OR reduce production const -> LOGIC_FALSE 
-- On LOGIC_NEQ reduce production const -> LOGIC_FALSE 
-- On LOGIC_IMPLY reduce production const -> LOGIC_FALSE 
-- On LOGIC_FALSE reduce production const -> LOGIC_FALSE 
-- On LOGIC_EQUIV reduce production const -> LOGIC_FALSE 
-- On LOGIC_EQ reduce production const -> LOGIC_FALSE 
-- On LOGIC_AND reduce production const -> LOGIC_FALSE 
-- On LEFT_PAREN reduce production const -> LOGIC_FALSE 
-- On INTEGER reduce production const -> LOGIC_FALSE 
-- On INT reduce production const -> LOGIC_FALSE 
-- On IN reduce production const -> LOGIC_FALSE 
-- On EQDEF reduce production const -> LOGIC_FALSE 
-- On EOI reduce production const -> LOGIC_FALSE 
-- On END reduce production const -> LOGIC_FALSE 
-- On ELSE reduce production const -> LOGIC_FALSE 
-- On DOT reduce production const -> LOGIC_FALSE 
-- On ARROW reduce production const -> LOGIC_FALSE 
-- On ARITH_PRODUCT reduce production const -> LOGIC_FALSE 
-- On ARITH_PLUS reduce production const -> LOGIC_FALSE 
-- On ARITH_MINUS reduce production const -> LOGIC_FALSE 
-- On ARITH_LT reduce production const -> LOGIC_FALSE 
-- On ARITH_LEQ reduce production const -> LOGIC_FALSE 
-- On ARITH_GT reduce production const -> LOGIC_FALSE 
-- On ARITH_GEQ reduce production const -> LOGIC_FALSE 
-- On AND reduce production const -> LOGIC_FALSE 

State 48:
atomic_term -> LEFT_PAREN . term RIGHT_PAREN [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 130
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 49:
term -> LOGIC_FORALL . typed_var_list DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 50
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 51
-- On typed_var_list shift to state 127
-- On typed_var_block shift to state 113
-- On raw_var shift to state 115

State 50:
typed_var_block -> WILDCARD . [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On WILDCARD reduce production typed_var_block -> WILDCARD 
-- On UPPER_WORD reduce production typed_var_block -> WILDCARD 
-- On SINGLE_QUOTED reduce production typed_var_block -> WILDCARD 
-- On LOWER_WORD reduce production typed_var_block -> WILDCARD 
-- On LEFT_PAREN reduce production typed_var_block -> WILDCARD 
-- On DOT reduce production typed_var_block -> WILDCARD 

State 51:
typed_var_block -> LEFT_PAREN . nonempty_list(raw_var) COLON term RIGHT_PAREN [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 36
-- On nonempty_list(raw_var) shift to state 52

State 52:
typed_var_block -> LEFT_PAREN nonempty_list(raw_var) . COLON term RIGHT_PAREN [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On COLON shift to state 53

State 53:
typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON . term RIGHT_PAREN [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 125
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 54:
term -> LOGIC_EXISTS . typed_var_list DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 50
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 51
-- On typed_var_list shift to state 55
-- On typed_var_block shift to state 113
-- On raw_var shift to state 115

State 55:
term -> LOGIC_EXISTS typed_var_list . DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On DOT shift to state 56

State 56:
term -> LOGIC_EXISTS typed_var_list DOT . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 124
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 57:
term -> LET . raw_var EQDEF term IN term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 58

State 58:
term -> LET raw_var . EQDEF term IN term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On EQDEF shift to state 59

State 59:
term -> LET raw_var EQDEF . term IN term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 121
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 60:
atomic_term -> INTEGER . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production atomic_term -> INTEGER 
-- On WILDCARD reduce production atomic_term -> INTEGER 
-- On WHERE reduce production atomic_term -> INTEGER 
-- On VERTICAL_BAR reduce production atomic_term -> INTEGER 
-- On UPPER_WORD reduce production atomic_term -> INTEGER 
-- On TYPE reduce production atomic_term -> INTEGER 
-- On THEN reduce production atomic_term -> INTEGER 
-- On SINGLE_QUOTED reduce production atomic_term -> INTEGER 
-- On SEMI_COLON reduce production atomic_term -> INTEGER 
-- On RIGHT_PAREN reduce production atomic_term -> INTEGER 
-- On PROP reduce production atomic_term -> INTEGER 
-- On MATCH reduce production atomic_term -> INTEGER 
-- On LOWER_WORD reduce production atomic_term -> INTEGER 
-- On LOGIC_TRUE reduce production atomic_term -> INTEGER 
-- On LOGIC_OR reduce production atomic_term -> INTEGER 
-- On LOGIC_NEQ reduce production atomic_term -> INTEGER 
-- On LOGIC_IMPLY reduce production atomic_term -> INTEGER 
-- On LOGIC_FALSE reduce production atomic_term -> INTEGER 
-- On LOGIC_EQUIV reduce production atomic_term -> INTEGER 
-- On LOGIC_EQ reduce production atomic_term -> INTEGER 
-- On LOGIC_AND reduce production atomic_term -> INTEGER 
-- On LEFT_PAREN reduce production atomic_term -> INTEGER 
-- On INTEGER reduce production atomic_term -> INTEGER 
-- On INT reduce production atomic_term -> INTEGER 
-- On IN reduce production atomic_term -> INTEGER 
-- On EQDEF reduce production atomic_term -> INTEGER 
-- On EOI reduce production atomic_term -> INTEGER 
-- On END reduce production atomic_term -> INTEGER 
-- On ELSE reduce production atomic_term -> INTEGER 
-- On DOT reduce production atomic_term -> INTEGER 
-- On ARROW reduce production atomic_term -> INTEGER 
-- On ARITH_PRODUCT reduce production atomic_term -> INTEGER 
-- On ARITH_PLUS reduce production atomic_term -> INTEGER 
-- On ARITH_MINUS reduce production atomic_term -> INTEGER 
-- On ARITH_LT reduce production atomic_term -> INTEGER 
-- On ARITH_LEQ reduce production atomic_term -> INTEGER 
-- On ARITH_GT reduce production atomic_term -> INTEGER 
-- On ARITH_GEQ reduce production atomic_term -> INTEGER 
-- On AND reduce production atomic_term -> INTEGER 

State 61:
const -> INT . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production const -> INT 
-- On WILDCARD reduce production const -> INT 
-- On WHERE reduce production const -> INT 
-- On VERTICAL_BAR reduce production const -> INT 
-- On UPPER_WORD reduce production const -> INT 
-- On TYPE reduce production const -> INT 
-- On THEN reduce production const -> INT 
-- On SINGLE_QUOTED reduce production const -> INT 
-- On SEMI_COLON reduce production const -> INT 
-- On RIGHT_PAREN reduce production const -> INT 
-- On PROP reduce production const -> INT 
-- On MATCH reduce production const -> INT 
-- On LOWER_WORD reduce production const -> INT 
-- On LOGIC_TRUE reduce production const -> INT 
-- On LOGIC_OR reduce production const -> INT 
-- On LOGIC_NEQ reduce production const -> INT 
-- On LOGIC_IMPLY reduce production const -> INT 
-- On LOGIC_FALSE reduce production const -> INT 
-- On LOGIC_EQUIV reduce production const -> INT 
-- On LOGIC_EQ reduce production const -> INT 
-- On LOGIC_AND reduce production const -> INT 
-- On LEFT_PAREN reduce production const -> INT 
-- On INTEGER reduce production const -> INT 
-- On INT reduce production const -> INT 
-- On IN reduce production const -> INT 
-- On EQDEF reduce production const -> INT 
-- On EOI reduce production const -> INT 
-- On END reduce production const -> INT 
-- On ELSE reduce production const -> INT 
-- On DOT reduce production const -> INT 
-- On ARROW reduce production const -> INT 
-- On ARITH_PRODUCT reduce production const -> INT 
-- On ARITH_PLUS reduce production const -> INT 
-- On ARITH_MINUS reduce production const -> INT 
-- On ARITH_LT reduce production const -> INT 
-- On ARITH_LEQ reduce production const -> INT 
-- On ARITH_GT reduce production const -> INT 
-- On ARITH_GEQ reduce production const -> INT 
-- On AND reduce production const -> INT 

State 62:
term -> IF . term THEN term ELSE term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 116
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 63:
term -> FUN . typed_var_list DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 50
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 51
-- On typed_var_list shift to state 64
-- On typed_var_block shift to state 113
-- On raw_var shift to state 115

State 64:
term -> FUN typed_var_list . DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On DOT shift to state 65

State 65:
term -> FUN typed_var_list DOT . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 75
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 66:
apply_term -> ARITH_MINUS . apply_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 74

State 67:
atomic_term -> var . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production atomic_term -> var 
-- On WILDCARD reduce production atomic_term -> var 
-- On WHERE reduce production atomic_term -> var 
-- On VERTICAL_BAR reduce production atomic_term -> var 
-- On UPPER_WORD reduce production atomic_term -> var 
-- On TYPE reduce production atomic_term -> var 
-- On THEN reduce production atomic_term -> var 
-- On SINGLE_QUOTED reduce production atomic_term -> var 
-- On SEMI_COLON reduce production atomic_term -> var 
-- On RIGHT_PAREN reduce production atomic_term -> var 
-- On PROP reduce production atomic_term -> var 
-- On MATCH reduce production atomic_term -> var 
-- On LOWER_WORD reduce production atomic_term -> var 
-- On LOGIC_TRUE reduce production atomic_term -> var 
-- On LOGIC_OR reduce production atomic_term -> var 
-- On LOGIC_NEQ reduce production atomic_term -> var 
-- On LOGIC_IMPLY reduce production atomic_term -> var 
-- On LOGIC_FALSE reduce production atomic_term -> var 
-- On LOGIC_EQUIV reduce production atomic_term -> var 
-- On LOGIC_EQ reduce production atomic_term -> var 
-- On LOGIC_AND reduce production atomic_term -> var 
-- On LEFT_PAREN reduce production atomic_term -> var 
-- On INTEGER reduce production atomic_term -> var 
-- On INT reduce production atomic_term -> var 
-- On IN reduce production atomic_term -> var 
-- On EQDEF reduce production atomic_term -> var 
-- On EOI reduce production atomic_term -> var 
-- On END reduce production atomic_term -> var 
-- On ELSE reduce production atomic_term -> var 
-- On DOT reduce production atomic_term -> var 
-- On ARROW reduce production atomic_term -> var 
-- On ARITH_PRODUCT reduce production atomic_term -> var 
-- On ARITH_PLUS reduce production atomic_term -> var 
-- On ARITH_MINUS reduce production atomic_term -> var 
-- On ARITH_LT reduce production atomic_term -> var 
-- On ARITH_LEQ reduce production atomic_term -> var 
-- On ARITH_GT reduce production atomic_term -> var 
-- On ARITH_GEQ reduce production atomic_term -> var 
-- On AND reduce production atomic_term -> var 

State 68:
var -> raw_var . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production var -> raw_var 
-- On WILDCARD reduce production var -> raw_var 
-- On WHERE reduce production var -> raw_var 
-- On VERTICAL_BAR reduce production var -> raw_var 
-- On UPPER_WORD reduce production var -> raw_var 
-- On TYPE reduce production var -> raw_var 
-- On THEN reduce production var -> raw_var 
-- On SINGLE_QUOTED reduce production var -> raw_var 
-- On SEMI_COLON reduce production var -> raw_var 
-- On RIGHT_PAREN reduce production var -> raw_var 
-- On PROP reduce production var -> raw_var 
-- On MATCH reduce production var -> raw_var 
-- On LOWER_WORD reduce production var -> raw_var 
-- On LOGIC_TRUE reduce production var -> raw_var 
-- On LOGIC_OR reduce production var -> raw_var 
-- On LOGIC_NEQ reduce production var -> raw_var 
-- On LOGIC_IMPLY reduce production var -> raw_var 
-- On LOGIC_FALSE reduce production var -> raw_var 
-- On LOGIC_EQUIV reduce production var -> raw_var 
-- On LOGIC_EQ reduce production var -> raw_var 
-- On LOGIC_AND reduce production var -> raw_var 
-- On LEFT_PAREN reduce production var -> raw_var 
-- On INTEGER reduce production var -> raw_var 
-- On INT reduce production var -> raw_var 
-- On IN reduce production var -> raw_var 
-- On EQDEF reduce production var -> raw_var 
-- On EOI reduce production var -> raw_var 
-- On END reduce production var -> raw_var 
-- On ELSE reduce production var -> raw_var 
-- On DOT reduce production var -> raw_var 
-- On ARROW reduce production var -> raw_var 
-- On ARITH_PRODUCT reduce production var -> raw_var 
-- On ARITH_PLUS reduce production var -> raw_var 
-- On ARITH_MINUS reduce production var -> raw_var 
-- On ARITH_LT reduce production var -> raw_var 
-- On ARITH_LEQ reduce production var -> raw_var 
-- On ARITH_GT reduce production var -> raw_var 
-- On ARITH_GEQ reduce production var -> raw_var 
-- On AND reduce production var -> raw_var 

State 69:
atomic_term -> const . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production atomic_term -> const 
-- On WILDCARD reduce production atomic_term -> const 
-- On WHERE reduce production atomic_term -> const 
-- On VERTICAL_BAR reduce production atomic_term -> const 
-- On UPPER_WORD reduce production atomic_term -> const 
-- On TYPE reduce production atomic_term -> const 
-- On THEN reduce production atomic_term -> const 
-- On SINGLE_QUOTED reduce production atomic_term -> const 
-- On SEMI_COLON reduce production atomic_term -> const 
-- On RIGHT_PAREN reduce production atomic_term -> const 
-- On PROP reduce production atomic_term -> const 
-- On MATCH reduce production atomic_term -> const 
-- On LOWER_WORD reduce production atomic_term -> const 
-- On LOGIC_TRUE reduce production atomic_term -> const 
-- On LOGIC_OR reduce production atomic_term -> const 
-- On LOGIC_NEQ reduce production atomic_term -> const 
-- On LOGIC_IMPLY reduce production atomic_term -> const 
-- On LOGIC_FALSE reduce production atomic_term -> const 
-- On LOGIC_EQUIV reduce production atomic_term -> const 
-- On LOGIC_EQ reduce production atomic_term -> const 
-- On LOGIC_AND reduce production atomic_term -> const 
-- On LEFT_PAREN reduce production atomic_term -> const 
-- On INTEGER reduce production atomic_term -> const 
-- On INT reduce production atomic_term -> const 
-- On IN reduce production atomic_term -> const 
-- On EQDEF reduce production atomic_term -> const 
-- On EOI reduce production atomic_term -> const 
-- On END reduce production atomic_term -> const 
-- On ELSE reduce production atomic_term -> const 
-- On DOT reduce production atomic_term -> const 
-- On ARROW reduce production atomic_term -> const 
-- On ARITH_PRODUCT reduce production atomic_term -> const 
-- On ARITH_PLUS reduce production atomic_term -> const 
-- On ARITH_MINUS reduce production atomic_term -> const 
-- On ARITH_LT reduce production atomic_term -> const 
-- On ARITH_LEQ reduce production atomic_term -> const 
-- On ARITH_GT reduce production atomic_term -> const 
-- On ARITH_GEQ reduce production atomic_term -> const 
-- On AND reduce production atomic_term -> const 

State 70:
apply_term -> atomic_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
apply_term -> atomic_term . nonempty_list(atomic_term) [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On var shift to state 67
-- On raw_var shift to state 68
-- On nonempty_list(atomic_term) shift to state 71
-- On const shift to state 69
-- On atomic_term shift to state 72
-- On WITH reduce production apply_term -> atomic_term 
-- On WHERE reduce production apply_term -> atomic_term 
-- On VERTICAL_BAR reduce production apply_term -> atomic_term 
-- On THEN reduce production apply_term -> atomic_term 
-- On SEMI_COLON reduce production apply_term -> atomic_term 
-- On RIGHT_PAREN reduce production apply_term -> atomic_term 
-- On LOGIC_OR reduce production apply_term -> atomic_term 
-- On LOGIC_NEQ reduce production apply_term -> atomic_term 
-- On LOGIC_IMPLY reduce production apply_term -> atomic_term 
-- On LOGIC_EQUIV reduce production apply_term -> atomic_term 
-- On LOGIC_EQ reduce production apply_term -> atomic_term 
-- On LOGIC_AND reduce production apply_term -> atomic_term 
-- On IN reduce production apply_term -> atomic_term 
-- On EQDEF reduce production apply_term -> atomic_term 
-- On EOI reduce production apply_term -> atomic_term 
-- On END reduce production apply_term -> atomic_term 
-- On ELSE reduce production apply_term -> atomic_term 
-- On DOT reduce production apply_term -> atomic_term 
-- On ARROW reduce production apply_term -> atomic_term 
-- On ARITH_PRODUCT reduce production apply_term -> atomic_term 
-- On ARITH_PLUS reduce production apply_term -> atomic_term 
-- On ARITH_MINUS reduce production apply_term -> atomic_term 
-- On ARITH_LT reduce production apply_term -> atomic_term 
-- On ARITH_LEQ reduce production apply_term -> atomic_term 
-- On ARITH_GT reduce production apply_term -> atomic_term 
-- On ARITH_GEQ reduce production apply_term -> atomic_term 
-- On AND reduce production apply_term -> atomic_term 

State 71:
apply_term -> atomic_term nonempty_list(atomic_term) . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On WHERE reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On VERTICAL_BAR reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On THEN reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On SEMI_COLON reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On RIGHT_PAREN reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On LOGIC_OR reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On LOGIC_NEQ reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On LOGIC_IMPLY reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On LOGIC_EQUIV reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On LOGIC_EQ reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On LOGIC_AND reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On IN reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On EQDEF reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On EOI reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On END reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On ELSE reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On DOT reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On ARROW reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_PRODUCT reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_PLUS reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_MINUS reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_LT reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_LEQ reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_GT reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_GEQ reduce production apply_term -> atomic_term nonempty_list(atomic_term) 
-- On AND reduce production apply_term -> atomic_term nonempty_list(atomic_term) 

State 72:
nonempty_list(atomic_term) -> atomic_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
nonempty_list(atomic_term) -> atomic_term . nonempty_list(atomic_term) [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On var shift to state 67
-- On raw_var shift to state 68
-- On nonempty_list(atomic_term) shift to state 73
-- On const shift to state 69
-- On atomic_term shift to state 72
-- On WITH reduce production nonempty_list(atomic_term) -> atomic_term 
-- On WHERE reduce production nonempty_list(atomic_term) -> atomic_term 
-- On VERTICAL_BAR reduce production nonempty_list(atomic_term) -> atomic_term 
-- On THEN reduce production nonempty_list(atomic_term) -> atomic_term 
-- On SEMI_COLON reduce production nonempty_list(atomic_term) -> atomic_term 
-- On RIGHT_PAREN reduce production nonempty_list(atomic_term) -> atomic_term 
-- On LOGIC_OR reduce production nonempty_list(atomic_term) -> atomic_term 
-- On LOGIC_NEQ reduce production nonempty_list(atomic_term) -> atomic_term 
-- On LOGIC_IMPLY reduce production nonempty_list(atomic_term) -> atomic_term 
-- On LOGIC_EQUIV reduce production nonempty_list(atomic_term) -> atomic_term 
-- On LOGIC_EQ reduce production nonempty_list(atomic_term) -> atomic_term 
-- On LOGIC_AND reduce production nonempty_list(atomic_term) -> atomic_term 
-- On IN reduce production nonempty_list(atomic_term) -> atomic_term 
-- On EQDEF reduce production nonempty_list(atomic_term) -> atomic_term 
-- On EOI reduce production nonempty_list(atomic_term) -> atomic_term 
-- On END reduce production nonempty_list(atomic_term) -> atomic_term 
-- On ELSE reduce production nonempty_list(atomic_term) -> atomic_term 
-- On DOT reduce production nonempty_list(atomic_term) -> atomic_term 
-- On ARROW reduce production nonempty_list(atomic_term) -> atomic_term 
-- On ARITH_PRODUCT reduce production nonempty_list(atomic_term) -> atomic_term 
-- On ARITH_PLUS reduce production nonempty_list(atomic_term) -> atomic_term 
-- On ARITH_MINUS reduce production nonempty_list(atomic_term) -> atomic_term 
-- On ARITH_LT reduce production nonempty_list(atomic_term) -> atomic_term 
-- On ARITH_LEQ reduce production nonempty_list(atomic_term) -> atomic_term 
-- On ARITH_GT reduce production nonempty_list(atomic_term) -> atomic_term 
-- On ARITH_GEQ reduce production nonempty_list(atomic_term) -> atomic_term 
-- On AND reduce production nonempty_list(atomic_term) -> atomic_term 

State 73:
nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On WHERE reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On VERTICAL_BAR reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On THEN reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On SEMI_COLON reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On RIGHT_PAREN reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On LOGIC_OR reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On LOGIC_NEQ reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On LOGIC_IMPLY reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On LOGIC_EQUIV reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On LOGIC_EQ reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On LOGIC_AND reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On IN reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On EQDEF reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On EOI reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On END reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On ELSE reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On DOT reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On ARROW reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_PRODUCT reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_PLUS reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_MINUS reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_LT reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_LEQ reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_GT reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On ARITH_GEQ reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 
-- On AND reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) 

State 74:
apply_term -> ARITH_MINUS apply_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production apply_term -> ARITH_MINUS apply_term 
-- On WHERE reduce production apply_term -> ARITH_MINUS apply_term 
-- On VERTICAL_BAR reduce production apply_term -> ARITH_MINUS apply_term 
-- On THEN reduce production apply_term -> ARITH_MINUS apply_term 
-- On SEMI_COLON reduce production apply_term -> ARITH_MINUS apply_term 
-- On RIGHT_PAREN reduce production apply_term -> ARITH_MINUS apply_term 
-- On LOGIC_OR reduce production apply_term -> ARITH_MINUS apply_term 
-- On LOGIC_NEQ reduce production apply_term -> ARITH_MINUS apply_term 
-- On LOGIC_IMPLY reduce production apply_term -> ARITH_MINUS apply_term 
-- On LOGIC_EQUIV reduce production apply_term -> ARITH_MINUS apply_term 
-- On LOGIC_EQ reduce production apply_term -> ARITH_MINUS apply_term 
-- On LOGIC_AND reduce production apply_term -> ARITH_MINUS apply_term 
-- On IN reduce production apply_term -> ARITH_MINUS apply_term 
-- On EQDEF reduce production apply_term -> ARITH_MINUS apply_term 
-- On EOI reduce production apply_term -> ARITH_MINUS apply_term 
-- On END reduce production apply_term -> ARITH_MINUS apply_term 
-- On ELSE reduce production apply_term -> ARITH_MINUS apply_term 
-- On DOT reduce production apply_term -> ARITH_MINUS apply_term 
-- On ARROW reduce production apply_term -> ARITH_MINUS apply_term 
-- On ARITH_PRODUCT reduce production apply_term -> ARITH_MINUS apply_term 
-- On ARITH_PLUS reduce production apply_term -> ARITH_MINUS apply_term 
-- On ARITH_MINUS reduce production apply_term -> ARITH_MINUS apply_term 
-- On ARITH_LT reduce production apply_term -> ARITH_MINUS apply_term 
-- On ARITH_LEQ reduce production apply_term -> ARITH_MINUS apply_term 
-- On ARITH_GT reduce production apply_term -> ARITH_MINUS apply_term 
-- On ARITH_GEQ reduce production apply_term -> ARITH_MINUS apply_term 
-- On AND reduce production apply_term -> ARITH_MINUS apply_term 

State 75:
term -> FUN typed_var_list DOT term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production term -> FUN typed_var_list DOT term 
-- On WHERE reduce production term -> FUN typed_var_list DOT term 
-- On VERTICAL_BAR reduce production term -> FUN typed_var_list DOT term 
-- On THEN reduce production term -> FUN typed_var_list DOT term 
-- On SEMI_COLON reduce production term -> FUN typed_var_list DOT term 
-- On RIGHT_PAREN reduce production term -> FUN typed_var_list DOT term 
-- On IN reduce production term -> FUN typed_var_list DOT term 
-- On EQDEF reduce production term -> FUN typed_var_list DOT term 
-- On EOI reduce production term -> FUN typed_var_list DOT term 
-- On END reduce production term -> FUN typed_var_list DOT term 
-- On ELSE reduce production term -> FUN typed_var_list DOT term 
-- On DOT reduce production term -> FUN typed_var_list DOT term 
-- On AND reduce production term -> FUN typed_var_list DOT term 

State 76:
arith_op_term -> plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
arith_op_term -> plus_term . ARITH_LT plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
arith_op_term -> plus_term . ARITH_LEQ plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
arith_op_term -> plus_term . ARITH_GT plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
arith_op_term -> plus_term . ARITH_GEQ plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On ARITH_LT shift to state 77
-- On ARITH_LEQ shift to state 87
-- On ARITH_GT shift to state 89
-- On ARITH_GEQ shift to state 91
-- On WITH reduce production arith_op_term -> plus_term 
-- On WHERE reduce production arith_op_term -> plus_term 
-- On VERTICAL_BAR reduce production arith_op_term -> plus_term 
-- On THEN reduce production arith_op_term -> plus_term 
-- On SEMI_COLON reduce production arith_op_term -> plus_term 
-- On RIGHT_PAREN reduce production arith_op_term -> plus_term 
-- On LOGIC_OR reduce production arith_op_term -> plus_term 
-- On LOGIC_NEQ reduce production arith_op_term -> plus_term 
-- On LOGIC_IMPLY reduce production arith_op_term -> plus_term 
-- On LOGIC_EQUIV reduce production arith_op_term -> plus_term 
-- On LOGIC_EQ reduce production arith_op_term -> plus_term 
-- On LOGIC_AND reduce production arith_op_term -> plus_term 
-- On IN reduce production arith_op_term -> plus_term 
-- On EQDEF reduce production arith_op_term -> plus_term 
-- On EOI reduce production arith_op_term -> plus_term 
-- On END reduce production arith_op_term -> plus_term 
-- On ELSE reduce production arith_op_term -> plus_term 
-- On DOT reduce production arith_op_term -> plus_term 
-- On AND reduce production arith_op_term -> plus_term 

State 77:
arith_op_term -> plus_term ARITH_LT . plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 78
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82

State 78:
arith_op_term -> plus_term ARITH_LT plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On WHERE reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On VERTICAL_BAR reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On THEN reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On SEMI_COLON reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On RIGHT_PAREN reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On LOGIC_OR reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On LOGIC_NEQ reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On LOGIC_IMPLY reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On LOGIC_EQUIV reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On LOGIC_EQ reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On LOGIC_AND reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On IN reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On EQDEF reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On EOI reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On END reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On ELSE reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On DOT reduce production arith_op_term -> plus_term ARITH_LT plus_term 
-- On AND reduce production arith_op_term -> plus_term ARITH_LT plus_term 

State 79:
plus_term -> mult_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
plus_term -> mult_term . ARITH_PLUS plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
plus_term -> mult_term . ARITH_MINUS plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On ARITH_PLUS shift to state 80
-- On ARITH_MINUS shift to state 85
-- On WITH reduce production plus_term -> mult_term 
-- On WHERE reduce production plus_term -> mult_term 
-- On VERTICAL_BAR reduce production plus_term -> mult_term 
-- On THEN reduce production plus_term -> mult_term 
-- On SEMI_COLON reduce production plus_term -> mult_term 
-- On RIGHT_PAREN reduce production plus_term -> mult_term 
-- On LOGIC_OR reduce production plus_term -> mult_term 
-- On LOGIC_NEQ reduce production plus_term -> mult_term 
-- On LOGIC_IMPLY reduce production plus_term -> mult_term 
-- On LOGIC_EQUIV reduce production plus_term -> mult_term 
-- On LOGIC_EQ reduce production plus_term -> mult_term 
-- On LOGIC_AND reduce production plus_term -> mult_term 
-- On IN reduce production plus_term -> mult_term 
-- On EQDEF reduce production plus_term -> mult_term 
-- On EOI reduce production plus_term -> mult_term 
-- On END reduce production plus_term -> mult_term 
-- On ELSE reduce production plus_term -> mult_term 
-- On DOT reduce production plus_term -> mult_term 
-- On ARITH_LT reduce production plus_term -> mult_term 
-- On ARITH_LEQ reduce production plus_term -> mult_term 
-- On ARITH_GT reduce production plus_term -> mult_term 
-- On ARITH_GEQ reduce production plus_term -> mult_term 
-- On AND reduce production plus_term -> mult_term 

State 80:
plus_term -> mult_term ARITH_PLUS . plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 81
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82

State 81:
plus_term -> mult_term ARITH_PLUS plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On WHERE reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On VERTICAL_BAR reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On THEN reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On SEMI_COLON reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On RIGHT_PAREN reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On LOGIC_OR reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On LOGIC_NEQ reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On LOGIC_IMPLY reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On LOGIC_EQUIV reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On LOGIC_EQ reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On LOGIC_AND reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On IN reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On EQDEF reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On EOI reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On END reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On ELSE reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On DOT reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On ARITH_LT reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On ARITH_LEQ reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On ARITH_GT reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On ARITH_GEQ reduce production plus_term -> mult_term ARITH_PLUS plus_term 
-- On AND reduce production plus_term -> mult_term ARITH_PLUS plus_term 

State 82:
mult_term -> apply_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
mult_term -> apply_term . ARITH_PRODUCT mult_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On ARITH_PRODUCT shift to state 83
-- On WITH reduce production mult_term -> apply_term 
-- On WHERE reduce production mult_term -> apply_term 
-- On VERTICAL_BAR reduce production mult_term -> apply_term 
-- On THEN reduce production mult_term -> apply_term 
-- On SEMI_COLON reduce production mult_term -> apply_term 
-- On RIGHT_PAREN reduce production mult_term -> apply_term 
-- On LOGIC_OR reduce production mult_term -> apply_term 
-- On LOGIC_NEQ reduce production mult_term -> apply_term 
-- On LOGIC_IMPLY reduce production mult_term -> apply_term 
-- On LOGIC_EQUIV reduce production mult_term -> apply_term 
-- On LOGIC_EQ reduce production mult_term -> apply_term 
-- On LOGIC_AND reduce production mult_term -> apply_term 
-- On IN reduce production mult_term -> apply_term 
-- On EQDEF reduce production mult_term -> apply_term 
-- On EOI reduce production mult_term -> apply_term 
-- On END reduce production mult_term -> apply_term 
-- On ELSE reduce production mult_term -> apply_term 
-- On DOT reduce production mult_term -> apply_term 
-- On ARITH_PLUS reduce production mult_term -> apply_term 
-- On ARITH_MINUS reduce production mult_term -> apply_term 
-- On ARITH_LT reduce production mult_term -> apply_term 
-- On ARITH_LEQ reduce production mult_term -> apply_term 
-- On ARITH_GT reduce production mult_term -> apply_term 
-- On ARITH_GEQ reduce production mult_term -> apply_term 
-- On AND reduce production mult_term -> apply_term 

State 83:
mult_term -> apply_term ARITH_PRODUCT . mult_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On mult_term shift to state 84
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82

State 84:
mult_term -> apply_term ARITH_PRODUCT mult_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On WHERE reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On VERTICAL_BAR reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On THEN reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On SEMI_COLON reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On RIGHT_PAREN reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On LOGIC_OR reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On LOGIC_NEQ reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On LOGIC_IMPLY reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On LOGIC_EQUIV reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On LOGIC_EQ reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On LOGIC_AND reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On IN reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On EQDEF reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On EOI reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On END reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On ELSE reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On DOT reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On ARITH_PLUS reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On ARITH_MINUS reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On ARITH_LT reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On ARITH_LEQ reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On ARITH_GT reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On ARITH_GEQ reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 
-- On AND reduce production mult_term -> apply_term ARITH_PRODUCT mult_term 

State 85:
plus_term -> mult_term ARITH_MINUS . plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 86
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82

State 86:
plus_term -> mult_term ARITH_MINUS plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On WHERE reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On VERTICAL_BAR reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On THEN reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On SEMI_COLON reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On RIGHT_PAREN reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On LOGIC_OR reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On LOGIC_NEQ reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On LOGIC_IMPLY reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On LOGIC_EQUIV reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On LOGIC_EQ reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On LOGIC_AND reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On IN reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On EQDEF reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On EOI reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On END reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On ELSE reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On DOT reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On ARITH_LT reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On ARITH_LEQ reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On ARITH_GT reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On ARITH_GEQ reduce production plus_term -> mult_term ARITH_MINUS plus_term 
-- On AND reduce production plus_term -> mult_term ARITH_MINUS plus_term 

State 87:
arith_op_term -> plus_term ARITH_LEQ . plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 88
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82

State 88:
arith_op_term -> plus_term ARITH_LEQ plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On WHERE reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On VERTICAL_BAR reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On THEN reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On SEMI_COLON reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On RIGHT_PAREN reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On LOGIC_OR reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On LOGIC_NEQ reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On LOGIC_IMPLY reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On LOGIC_EQUIV reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On LOGIC_EQ reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On LOGIC_AND reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On IN reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On EQDEF reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On EOI reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On END reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On ELSE reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On DOT reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 
-- On AND reduce production arith_op_term -> plus_term ARITH_LEQ plus_term 

State 89:
arith_op_term -> plus_term ARITH_GT . plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 90
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82

State 90:
arith_op_term -> plus_term ARITH_GT plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On WHERE reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On VERTICAL_BAR reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On THEN reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On SEMI_COLON reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On RIGHT_PAREN reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On LOGIC_OR reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On LOGIC_NEQ reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On LOGIC_IMPLY reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On LOGIC_EQUIV reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On LOGIC_EQ reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On LOGIC_AND reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On IN reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On EQDEF reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On EOI reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On END reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On ELSE reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On DOT reduce production arith_op_term -> plus_term ARITH_GT plus_term 
-- On AND reduce production arith_op_term -> plus_term ARITH_GT plus_term 

State 91:
arith_op_term -> plus_term ARITH_GEQ . plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 92
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82

State 92:
arith_op_term -> plus_term ARITH_GEQ plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On WHERE reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On VERTICAL_BAR reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On THEN reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On SEMI_COLON reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On RIGHT_PAREN reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On LOGIC_OR reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On LOGIC_NEQ reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On LOGIC_IMPLY reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On LOGIC_EQUIV reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On LOGIC_EQ reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On LOGIC_AND reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On IN reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On EQDEF reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On EOI reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On END reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On ELSE reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On DOT reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 
-- On AND reduce production arith_op_term -> plus_term ARITH_GEQ plus_term 

State 93:
term -> or_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production term -> or_term 
-- On WHERE reduce production term -> or_term 
-- On VERTICAL_BAR reduce production term -> or_term 
-- On THEN reduce production term -> or_term 
-- On SEMI_COLON reduce production term -> or_term 
-- On RIGHT_PAREN reduce production term -> or_term 
-- On IN reduce production term -> or_term 
-- On EQDEF reduce production term -> or_term 
-- On EOI reduce production term -> or_term 
-- On END reduce production term -> or_term 
-- On ELSE reduce production term -> or_term 
-- On DOT reduce production term -> or_term 
-- On AND reduce production term -> or_term 

State 94:
eq_term -> not_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
eq_term -> not_term . LOGIC_EQ not_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
eq_term -> not_term . LOGIC_NEQ not_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On LOGIC_NEQ shift to state 95
-- On LOGIC_EQ shift to state 98
-- On WITH reduce production eq_term -> not_term 
-- On WHERE reduce production eq_term -> not_term 
-- On VERTICAL_BAR reduce production eq_term -> not_term 
-- On THEN reduce production eq_term -> not_term 
-- On SEMI_COLON reduce production eq_term -> not_term 
-- On RIGHT_PAREN reduce production eq_term -> not_term 
-- On LOGIC_OR reduce production eq_term -> not_term 
-- On LOGIC_IMPLY reduce production eq_term -> not_term 
-- On LOGIC_EQUIV reduce production eq_term -> not_term 
-- On LOGIC_AND reduce production eq_term -> not_term 
-- On IN reduce production eq_term -> not_term 
-- On EQDEF reduce production eq_term -> not_term 
-- On EOI reduce production eq_term -> not_term 
-- On END reduce production eq_term -> not_term 
-- On ELSE reduce production eq_term -> not_term 
-- On DOT reduce production eq_term -> not_term 
-- On AND reduce production eq_term -> not_term 

State 95:
eq_term -> not_term LOGIC_NEQ . not_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On not_term shift to state 96
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 82

State 96:
eq_term -> not_term LOGIC_NEQ not_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On WHERE reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On VERTICAL_BAR reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On THEN reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On SEMI_COLON reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On RIGHT_PAREN reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On LOGIC_OR reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On LOGIC_IMPLY reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On LOGIC_EQUIV reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On LOGIC_AND reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On IN reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On EQDEF reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On EOI reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On END reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On ELSE reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On DOT reduce production eq_term -> not_term LOGIC_NEQ not_term 
-- On AND reduce production eq_term -> not_term LOGIC_NEQ not_term 

State 97:
not_term -> arith_op_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production not_term -> arith_op_term 
-- On WHERE reduce production not_term -> arith_op_term 
-- On VERTICAL_BAR reduce production not_term -> arith_op_term 
-- On THEN reduce production not_term -> arith_op_term 
-- On SEMI_COLON reduce production not_term -> arith_op_term 
-- On RIGHT_PAREN reduce production not_term -> arith_op_term 
-- On LOGIC_OR reduce production not_term -> arith_op_term 
-- On LOGIC_NEQ reduce production not_term -> arith_op_term 
-- On LOGIC_IMPLY reduce production not_term -> arith_op_term 
-- On LOGIC_EQUIV reduce production not_term -> arith_op_term 
-- On LOGIC_EQ reduce production not_term -> arith_op_term 
-- On LOGIC_AND reduce production not_term -> arith_op_term 
-- On IN reduce production not_term -> arith_op_term 
-- On EQDEF reduce production not_term -> arith_op_term 
-- On EOI reduce production not_term -> arith_op_term 
-- On END reduce production not_term -> arith_op_term 
-- On ELSE reduce production not_term -> arith_op_term 
-- On DOT reduce production not_term -> arith_op_term 
-- On AND reduce production not_term -> arith_op_term 

State 98:
eq_term -> not_term LOGIC_EQ . not_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On not_term shift to state 99
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 82

State 99:
eq_term -> not_term LOGIC_EQ not_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On WHERE reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On VERTICAL_BAR reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On THEN reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On SEMI_COLON reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On RIGHT_PAREN reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On LOGIC_OR reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On LOGIC_IMPLY reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On LOGIC_EQUIV reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On LOGIC_AND reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On IN reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On EQDEF reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On EOI reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On END reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On ELSE reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On DOT reduce production eq_term -> not_term LOGIC_EQ not_term 
-- On AND reduce production eq_term -> not_term LOGIC_EQ not_term 

State 100:
and_term -> eq_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV IN EQDEF EOI END ELSE DOT AND ]
and_term -> eq_term . LOGIC_AND and_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV IN EQDEF EOI END ELSE DOT AND ]
-- On LOGIC_AND shift to state 101
-- On WITH reduce production and_term -> eq_term 
-- On WHERE reduce production and_term -> eq_term 
-- On VERTICAL_BAR reduce production and_term -> eq_term 
-- On THEN reduce production and_term -> eq_term 
-- On SEMI_COLON reduce production and_term -> eq_term 
-- On RIGHT_PAREN reduce production and_term -> eq_term 
-- On LOGIC_OR reduce production and_term -> eq_term 
-- On LOGIC_IMPLY reduce production and_term -> eq_term 
-- On LOGIC_EQUIV reduce production and_term -> eq_term 
-- On IN reduce production and_term -> eq_term 
-- On EQDEF reduce production and_term -> eq_term 
-- On EOI reduce production and_term -> eq_term 
-- On END reduce production and_term -> eq_term 
-- On ELSE reduce production and_term -> eq_term 
-- On DOT reduce production and_term -> eq_term 
-- On AND reduce production and_term -> eq_term 

State 101:
and_term -> eq_term LOGIC_AND . and_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 82
-- On and_term shift to state 102

State 102:
and_term -> eq_term LOGIC_AND and_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production and_term -> eq_term LOGIC_AND and_term 
-- On WHERE reduce production and_term -> eq_term LOGIC_AND and_term 
-- On VERTICAL_BAR reduce production and_term -> eq_term LOGIC_AND and_term 
-- On THEN reduce production and_term -> eq_term LOGIC_AND and_term 
-- On SEMI_COLON reduce production and_term -> eq_term LOGIC_AND and_term 
-- On RIGHT_PAREN reduce production and_term -> eq_term LOGIC_AND and_term 
-- On LOGIC_OR reduce production and_term -> eq_term LOGIC_AND and_term 
-- On LOGIC_IMPLY reduce production and_term -> eq_term LOGIC_AND and_term 
-- On LOGIC_EQUIV reduce production and_term -> eq_term LOGIC_AND and_term 
-- On IN reduce production and_term -> eq_term LOGIC_AND and_term 
-- On EQDEF reduce production and_term -> eq_term LOGIC_AND and_term 
-- On EOI reduce production and_term -> eq_term LOGIC_AND and_term 
-- On END reduce production and_term -> eq_term LOGIC_AND and_term 
-- On ELSE reduce production and_term -> eq_term LOGIC_AND and_term 
-- On DOT reduce production and_term -> eq_term LOGIC_AND and_term 
-- On AND reduce production and_term -> eq_term LOGIC_AND and_term 

State 103:
mult_term -> apply_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
mult_term -> apply_term . ARITH_PRODUCT mult_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
term -> apply_term . ARROW term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On ARROW shift to state 104
-- On ARITH_PRODUCT shift to state 83
-- On WITH reduce production mult_term -> apply_term 
-- On WHERE reduce production mult_term -> apply_term 
-- On VERTICAL_BAR reduce production mult_term -> apply_term 
-- On THEN reduce production mult_term -> apply_term 
-- On SEMI_COLON reduce production mult_term -> apply_term 
-- On RIGHT_PAREN reduce production mult_term -> apply_term 
-- On LOGIC_OR reduce production mult_term -> apply_term 
-- On LOGIC_NEQ reduce production mult_term -> apply_term 
-- On LOGIC_IMPLY reduce production mult_term -> apply_term 
-- On LOGIC_EQUIV reduce production mult_term -> apply_term 
-- On LOGIC_EQ reduce production mult_term -> apply_term 
-- On LOGIC_AND reduce production mult_term -> apply_term 
-- On IN reduce production mult_term -> apply_term 
-- On EQDEF reduce production mult_term -> apply_term 
-- On EOI reduce production mult_term -> apply_term 
-- On END reduce production mult_term -> apply_term 
-- On ELSE reduce production mult_term -> apply_term 
-- On DOT reduce production mult_term -> apply_term 
-- On ARITH_PLUS reduce production mult_term -> apply_term 
-- On ARITH_MINUS reduce production mult_term -> apply_term 
-- On ARITH_LT reduce production mult_term -> apply_term 
-- On ARITH_LEQ reduce production mult_term -> apply_term 
-- On ARITH_GT reduce production mult_term -> apply_term 
-- On ARITH_GEQ reduce production mult_term -> apply_term 
-- On AND reduce production mult_term -> apply_term 

State 104:
term -> apply_term ARROW . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 105
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 105:
term -> apply_term ARROW term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production term -> apply_term ARROW term 
-- On WHERE reduce production term -> apply_term ARROW term 
-- On VERTICAL_BAR reduce production term -> apply_term ARROW term 
-- On THEN reduce production term -> apply_term ARROW term 
-- On SEMI_COLON reduce production term -> apply_term ARROW term 
-- On RIGHT_PAREN reduce production term -> apply_term ARROW term 
-- On IN reduce production term -> apply_term ARROW term 
-- On EQDEF reduce production term -> apply_term ARROW term 
-- On EOI reduce production term -> apply_term ARROW term 
-- On END reduce production term -> apply_term ARROW term 
-- On ELSE reduce production term -> apply_term ARROW term 
-- On DOT reduce production term -> apply_term ARROW term 
-- On AND reduce production term -> apply_term ARROW term 

State 106:
or_term -> and_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
or_term -> and_term . LOGIC_OR or_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
or_term -> and_term . LOGIC_IMPLY or_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
or_term -> and_term . LOGIC_EQUIV or_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On LOGIC_OR shift to state 107
-- On LOGIC_IMPLY shift to state 109
-- On LOGIC_EQUIV shift to state 111
-- On WITH reduce production or_term -> and_term 
-- On WHERE reduce production or_term -> and_term 
-- On VERTICAL_BAR reduce production or_term -> and_term 
-- On THEN reduce production or_term -> and_term 
-- On SEMI_COLON reduce production or_term -> and_term 
-- On RIGHT_PAREN reduce production or_term -> and_term 
-- On IN reduce production or_term -> and_term 
-- On EQDEF reduce production or_term -> and_term 
-- On EOI reduce production or_term -> and_term 
-- On END reduce production or_term -> and_term 
-- On ELSE reduce production or_term -> and_term 
-- On DOT reduce production or_term -> and_term 
-- On AND reduce production or_term -> and_term 

State 107:
or_term -> and_term LOGIC_OR . or_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 108
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 82
-- On and_term shift to state 106

State 108:
or_term -> and_term LOGIC_OR or_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production or_term -> and_term LOGIC_OR or_term 
-- On WHERE reduce production or_term -> and_term LOGIC_OR or_term 
-- On VERTICAL_BAR reduce production or_term -> and_term LOGIC_OR or_term 
-- On THEN reduce production or_term -> and_term LOGIC_OR or_term 
-- On SEMI_COLON reduce production or_term -> and_term LOGIC_OR or_term 
-- On RIGHT_PAREN reduce production or_term -> and_term LOGIC_OR or_term 
-- On IN reduce production or_term -> and_term LOGIC_OR or_term 
-- On EQDEF reduce production or_term -> and_term LOGIC_OR or_term 
-- On EOI reduce production or_term -> and_term LOGIC_OR or_term 
-- On END reduce production or_term -> and_term LOGIC_OR or_term 
-- On ELSE reduce production or_term -> and_term LOGIC_OR or_term 
-- On DOT reduce production or_term -> and_term LOGIC_OR or_term 
-- On AND reduce production or_term -> and_term LOGIC_OR or_term 

State 109:
or_term -> and_term LOGIC_IMPLY . or_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 110
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 82
-- On and_term shift to state 106

State 110:
or_term -> and_term LOGIC_IMPLY or_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production or_term -> and_term LOGIC_IMPLY or_term 
-- On WHERE reduce production or_term -> and_term LOGIC_IMPLY or_term 
-- On VERTICAL_BAR reduce production or_term -> and_term LOGIC_IMPLY or_term 
-- On THEN reduce production or_term -> and_term LOGIC_IMPLY or_term 
-- On SEMI_COLON reduce production or_term -> and_term LOGIC_IMPLY or_term 
-- On RIGHT_PAREN reduce production or_term -> and_term LOGIC_IMPLY or_term 
-- On IN reduce production or_term -> and_term LOGIC_IMPLY or_term 
-- On EQDEF reduce production or_term -> and_term LOGIC_IMPLY or_term 
-- On EOI reduce production or_term -> and_term LOGIC_IMPLY or_term 
-- On END reduce production or_term -> and_term LOGIC_IMPLY or_term 
-- On ELSE reduce production or_term -> and_term LOGIC_IMPLY or_term 
-- On DOT reduce production or_term -> and_term LOGIC_IMPLY or_term 
-- On AND reduce production or_term -> and_term LOGIC_IMPLY or_term 

State 111:
or_term -> and_term LOGIC_EQUIV . or_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 112
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 82
-- On and_term shift to state 106

State 112:
or_term -> and_term LOGIC_EQUIV or_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production or_term -> and_term LOGIC_EQUIV or_term 
-- On WHERE reduce production or_term -> and_term LOGIC_EQUIV or_term 
-- On VERTICAL_BAR reduce production or_term -> and_term LOGIC_EQUIV or_term 
-- On THEN reduce production or_term -> and_term LOGIC_EQUIV or_term 
-- On SEMI_COLON reduce production or_term -> and_term LOGIC_EQUIV or_term 
-- On RIGHT_PAREN reduce production or_term -> and_term LOGIC_EQUIV or_term 
-- On IN reduce production or_term -> and_term LOGIC_EQUIV or_term 
-- On EQDEF reduce production or_term -> and_term LOGIC_EQUIV or_term 
-- On EOI reduce production or_term -> and_term LOGIC_EQUIV or_term 
-- On END reduce production or_term -> and_term LOGIC_EQUIV or_term 
-- On ELSE reduce production or_term -> and_term LOGIC_EQUIV or_term 
-- On DOT reduce production or_term -> and_term LOGIC_EQUIV or_term 
-- On AND reduce production or_term -> and_term LOGIC_EQUIV or_term 

State 113:
typed_var_list -> typed_var_block . [ DOT ]
typed_var_list -> typed_var_block . typed_var_list [ DOT ]
-- On WILDCARD shift to state 50
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 51
-- On typed_var_list shift to state 114
-- On typed_var_block shift to state 113
-- On raw_var shift to state 115
-- On DOT reduce production typed_var_list -> typed_var_block 

State 114:
typed_var_list -> typed_var_block typed_var_list . [ DOT ]
-- On DOT reduce production typed_var_list -> typed_var_block typed_var_list 

State 115:
typed_var_block -> raw_var . [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On WILDCARD reduce production typed_var_block -> raw_var 
-- On UPPER_WORD reduce production typed_var_block -> raw_var 
-- On SINGLE_QUOTED reduce production typed_var_block -> raw_var 
-- On LOWER_WORD reduce production typed_var_block -> raw_var 
-- On LEFT_PAREN reduce production typed_var_block -> raw_var 
-- On DOT reduce production typed_var_block -> raw_var 

State 116:
term -> IF term . THEN term ELSE term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On THEN shift to state 117

State 117:
term -> IF term THEN . term ELSE term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 118
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 118:
term -> IF term THEN term . ELSE term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On ELSE shift to state 119

State 119:
term -> IF term THEN term ELSE . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 120
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 120:
term -> IF term THEN term ELSE term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production term -> IF term THEN term ELSE term 
-- On WHERE reduce production term -> IF term THEN term ELSE term 
-- On VERTICAL_BAR reduce production term -> IF term THEN term ELSE term 
-- On THEN reduce production term -> IF term THEN term ELSE term 
-- On SEMI_COLON reduce production term -> IF term THEN term ELSE term 
-- On RIGHT_PAREN reduce production term -> IF term THEN term ELSE term 
-- On IN reduce production term -> IF term THEN term ELSE term 
-- On EQDEF reduce production term -> IF term THEN term ELSE term 
-- On EOI reduce production term -> IF term THEN term ELSE term 
-- On END reduce production term -> IF term THEN term ELSE term 
-- On ELSE reduce production term -> IF term THEN term ELSE term 
-- On DOT reduce production term -> IF term THEN term ELSE term 
-- On AND reduce production term -> IF term THEN term ELSE term 

State 121:
term -> LET raw_var EQDEF term . IN term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On IN shift to state 122

State 122:
term -> LET raw_var EQDEF term IN . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 123
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 123:
term -> LET raw_var EQDEF term IN term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production term -> LET raw_var EQDEF term IN term 
-- On WHERE reduce production term -> LET raw_var EQDEF term IN term 
-- On VERTICAL_BAR reduce production term -> LET raw_var EQDEF term IN term 
-- On THEN reduce production term -> LET raw_var EQDEF term IN term 
-- On SEMI_COLON reduce production term -> LET raw_var EQDEF term IN term 
-- On RIGHT_PAREN reduce production term -> LET raw_var EQDEF term IN term 
-- On IN reduce production term -> LET raw_var EQDEF term IN term 
-- On EQDEF reduce production term -> LET raw_var EQDEF term IN term 
-- On EOI reduce production term -> LET raw_var EQDEF term IN term 
-- On END reduce production term -> LET raw_var EQDEF term IN term 
-- On ELSE reduce production term -> LET raw_var EQDEF term IN term 
-- On DOT reduce production term -> LET raw_var EQDEF term IN term 
-- On AND reduce production term -> LET raw_var EQDEF term IN term 

State 124:
term -> LOGIC_EXISTS typed_var_list DOT term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production term -> LOGIC_EXISTS typed_var_list DOT term 
-- On WHERE reduce production term -> LOGIC_EXISTS typed_var_list DOT term 
-- On VERTICAL_BAR reduce production term -> LOGIC_EXISTS typed_var_list DOT term 
-- On THEN reduce production term -> LOGIC_EXISTS typed_var_list DOT term 
-- On SEMI_COLON reduce production term -> LOGIC_EXISTS typed_var_list DOT term 
-- On RIGHT_PAREN reduce production term -> LOGIC_EXISTS typed_var_list DOT term 
-- On IN reduce production term -> LOGIC_EXISTS typed_var_list DOT term 
-- On EQDEF reduce production term -> LOGIC_EXISTS typed_var_list DOT term 
-- On EOI reduce production term -> LOGIC_EXISTS typed_var_list DOT term 
-- On END reduce production term -> LOGIC_EXISTS typed_var_list DOT term 
-- On ELSE reduce production term -> LOGIC_EXISTS typed_var_list DOT term 
-- On DOT reduce production term -> LOGIC_EXISTS typed_var_list DOT term 
-- On AND reduce production term -> LOGIC_EXISTS typed_var_list DOT term 

State 125:
typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term . RIGHT_PAREN [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On RIGHT_PAREN shift to state 126

State 126:
typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN . [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On WILDCARD reduce production typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN 
-- On UPPER_WORD reduce production typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN 
-- On SINGLE_QUOTED reduce production typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN 
-- On LOWER_WORD reduce production typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN 
-- On LEFT_PAREN reduce production typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN 
-- On DOT reduce production typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN 

State 127:
term -> LOGIC_FORALL typed_var_list . DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On DOT shift to state 128

State 128:
term -> LOGIC_FORALL typed_var_list DOT . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 129
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 129:
term -> LOGIC_FORALL typed_var_list DOT term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production term -> LOGIC_FORALL typed_var_list DOT term 
-- On WHERE reduce production term -> LOGIC_FORALL typed_var_list DOT term 
-- On VERTICAL_BAR reduce production term -> LOGIC_FORALL typed_var_list DOT term 
-- On THEN reduce production term -> LOGIC_FORALL typed_var_list DOT term 
-- On SEMI_COLON reduce production term -> LOGIC_FORALL typed_var_list DOT term 
-- On RIGHT_PAREN reduce production term -> LOGIC_FORALL typed_var_list DOT term 
-- On IN reduce production term -> LOGIC_FORALL typed_var_list DOT term 
-- On EQDEF reduce production term -> LOGIC_FORALL typed_var_list DOT term 
-- On EOI reduce production term -> LOGIC_FORALL typed_var_list DOT term 
-- On END reduce production term -> LOGIC_FORALL typed_var_list DOT term 
-- On ELSE reduce production term -> LOGIC_FORALL typed_var_list DOT term 
-- On DOT reduce production term -> LOGIC_FORALL typed_var_list DOT term 
-- On AND reduce production term -> LOGIC_FORALL typed_var_list DOT term 

State 130:
atomic_term -> LEFT_PAREN term . RIGHT_PAREN [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On RIGHT_PAREN shift to state 131

State 131:
atomic_term -> LEFT_PAREN term RIGHT_PAREN . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On WILDCARD reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On WHERE reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On VERTICAL_BAR reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On UPPER_WORD reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On TYPE reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On THEN reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On SINGLE_QUOTED reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On SEMI_COLON reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On RIGHT_PAREN reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On PROP reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On MATCH reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On LOWER_WORD reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On LOGIC_TRUE reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On LOGIC_OR reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On LOGIC_NEQ reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On LOGIC_IMPLY reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On LOGIC_FALSE reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On LOGIC_EQUIV reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On LOGIC_EQ reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On LOGIC_AND reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On LEFT_PAREN reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On INTEGER reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On INT reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On IN reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On EQDEF reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On EOI reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On END reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On ELSE reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On DOT reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On ARROW reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On ARITH_PRODUCT reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On ARITH_PLUS reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On ARITH_MINUS reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On ARITH_LT reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On ARITH_LEQ reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On ARITH_GT reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On ARITH_GEQ reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 
-- On AND reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN 

State 132:
not_term -> LOGIC_NOT arith_op_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production not_term -> LOGIC_NOT arith_op_term 
-- On WHERE reduce production not_term -> LOGIC_NOT arith_op_term 
-- On VERTICAL_BAR reduce production not_term -> LOGIC_NOT arith_op_term 
-- On THEN reduce production not_term -> LOGIC_NOT arith_op_term 
-- On SEMI_COLON reduce production not_term -> LOGIC_NOT arith_op_term 
-- On RIGHT_PAREN reduce production not_term -> LOGIC_NOT arith_op_term 
-- On LOGIC_OR reduce production not_term -> LOGIC_NOT arith_op_term 
-- On LOGIC_NEQ reduce production not_term -> LOGIC_NOT arith_op_term 
-- On LOGIC_IMPLY reduce production not_term -> LOGIC_NOT arith_op_term 
-- On LOGIC_EQUIV reduce production not_term -> LOGIC_NOT arith_op_term 
-- On LOGIC_EQ reduce production not_term -> LOGIC_NOT arith_op_term 
-- On LOGIC_AND reduce production not_term -> LOGIC_NOT arith_op_term 
-- On IN reduce production not_term -> LOGIC_NOT arith_op_term 
-- On EQDEF reduce production not_term -> LOGIC_NOT arith_op_term 
-- On EOI reduce production not_term -> LOGIC_NOT arith_op_term 
-- On END reduce production not_term -> LOGIC_NOT arith_op_term 
-- On ELSE reduce production not_term -> LOGIC_NOT arith_op_term 
-- On DOT reduce production not_term -> LOGIC_NOT arith_op_term 
-- On AND reduce production not_term -> LOGIC_NOT arith_op_term 

State 133:
atomic_term -> MATCH term . WITH nonempty_list(match_branch) END [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH shift to state 134

State 134:
atomic_term -> MATCH term WITH . nonempty_list(match_branch) END [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On VERTICAL_BAR shift to state 135
-- On nonempty_list(match_branch) shift to state 144
-- On match_branch shift to state 146

State 135:
match_branch -> VERTICAL_BAR . raw_var list(var_or_wildcard) ARROW term [ VERTICAL_BAR END ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 136

State 136:
match_branch -> VERTICAL_BAR raw_var . list(var_or_wildcard) ARROW term [ VERTICAL_BAR END ]
-- On WILDCARD shift to state 137
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On var_or_wildcard shift to state 138
-- On raw_var shift to state 139
-- On list(var_or_wildcard) shift to state 141
-- On ARROW reduce production list(var_or_wildcard) -> 

State 137:
var_or_wildcard -> WILDCARD . [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD ARROW ]
-- On WILDCARD reduce production var_or_wildcard -> WILDCARD 
-- On UPPER_WORD reduce production var_or_wildcard -> WILDCARD 
-- On SINGLE_QUOTED reduce production var_or_wildcard -> WILDCARD 
-- On LOWER_WORD reduce production var_or_wildcard -> WILDCARD 
-- On ARROW reduce production var_or_wildcard -> WILDCARD 

State 138:
list(var_or_wildcard) -> var_or_wildcard . list(var_or_wildcard) [ ARROW ]
-- On WILDCARD shift to state 137
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On var_or_wildcard shift to state 138
-- On raw_var shift to state 139
-- On list(var_or_wildcard) shift to state 140
-- On ARROW reduce production list(var_or_wildcard) -> 

State 139:
var_or_wildcard -> raw_var . [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD ARROW ]
-- On WILDCARD reduce production var_or_wildcard -> raw_var 
-- On UPPER_WORD reduce production var_or_wildcard -> raw_var 
-- On SINGLE_QUOTED reduce production var_or_wildcard -> raw_var 
-- On LOWER_WORD reduce production var_or_wildcard -> raw_var 
-- On ARROW reduce production var_or_wildcard -> raw_var 

State 140:
list(var_or_wildcard) -> var_or_wildcard list(var_or_wildcard) . [ ARROW ]
-- On ARROW reduce production list(var_or_wildcard) -> var_or_wildcard list(var_or_wildcard) 

State 141:
match_branch -> VERTICAL_BAR raw_var list(var_or_wildcard) . ARROW term [ VERTICAL_BAR END ]
-- On ARROW shift to state 142

State 142:
match_branch -> VERTICAL_BAR raw_var list(var_or_wildcard) ARROW . term [ VERTICAL_BAR END ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 143
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 143:
match_branch -> VERTICAL_BAR raw_var list(var_or_wildcard) ARROW term . [ VERTICAL_BAR END ]
-- On VERTICAL_BAR reduce production match_branch -> VERTICAL_BAR raw_var list(var_or_wildcard) ARROW term 
-- On END reduce production match_branch -> VERTICAL_BAR raw_var list(var_or_wildcard) ARROW term 

State 144:
atomic_term -> MATCH term WITH nonempty_list(match_branch) . END [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On END shift to state 145

State 145:
atomic_term -> MATCH term WITH nonempty_list(match_branch) END . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
-- On WITH reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On WILDCARD reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On WHERE reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On VERTICAL_BAR reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On UPPER_WORD reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On TYPE reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On THEN reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On SINGLE_QUOTED reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On SEMI_COLON reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On RIGHT_PAREN reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On PROP reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On MATCH reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On LOWER_WORD reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On LOGIC_TRUE reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On LOGIC_OR reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On LOGIC_NEQ reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On LOGIC_IMPLY reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On LOGIC_FALSE reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On LOGIC_EQUIV reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On LOGIC_EQ reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On LOGIC_AND reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On LEFT_PAREN reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On INTEGER reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On INT reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On IN reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On EQDEF reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On EOI reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On END reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On ELSE reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On DOT reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On ARROW reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On ARITH_PRODUCT reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On ARITH_PLUS reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On ARITH_MINUS reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On ARITH_LT reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On ARITH_LEQ reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On ARITH_GT reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On ARITH_GEQ reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 
-- On AND reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END 

State 146:
nonempty_list(match_branch) -> match_branch . [ END ]
nonempty_list(match_branch) -> match_branch . nonempty_list(match_branch) [ END ]
-- On VERTICAL_BAR shift to state 135
-- On nonempty_list(match_branch) shift to state 147
-- On match_branch shift to state 146
-- On END reduce production nonempty_list(match_branch) -> match_branch 

State 147:
nonempty_list(match_branch) -> match_branch nonempty_list(match_branch) . [ END ]
-- On END reduce production nonempty_list(match_branch) -> match_branch nonempty_list(match_branch) 

State 148:
term -> PI typed_ty_var_list DOT term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
-- On WITH reduce production term -> PI typed_ty_var_list DOT term 
-- On WHERE reduce production term -> PI typed_ty_var_list DOT term 
-- On VERTICAL_BAR reduce production term -> PI typed_ty_var_list DOT term 
-- On THEN reduce production term -> PI typed_ty_var_list DOT term 
-- On SEMI_COLON reduce production term -> PI typed_ty_var_list DOT term 
-- On RIGHT_PAREN reduce production term -> PI typed_ty_var_list DOT term 
-- On IN reduce production term -> PI typed_ty_var_list DOT term 
-- On EQDEF reduce production term -> PI typed_ty_var_list DOT term 
-- On EOI reduce production term -> PI typed_ty_var_list DOT term 
-- On END reduce production term -> PI typed_ty_var_list DOT term 
-- On ELSE reduce production term -> PI typed_ty_var_list DOT term 
-- On DOT reduce production term -> PI typed_ty_var_list DOT term 
-- On AND reduce production term -> PI typed_ty_var_list DOT term 

State 149:
typed_ty_var_list -> typed_ty_var_block . [ DOT ]
typed_ty_var_list -> typed_ty_var_block . typed_ty_var_list [ DOT ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 35
-- On typed_ty_var_list shift to state 150
-- On typed_ty_var_block shift to state 149
-- On raw_var shift to state 151
-- On DOT reduce production typed_ty_var_list -> typed_ty_var_block 

State 150:
typed_ty_var_list -> typed_ty_var_block typed_ty_var_list . [ DOT ]
-- On DOT reduce production typed_ty_var_list -> typed_ty_var_block typed_ty_var_list 

State 151:
typed_ty_var_block -> raw_var . [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
typed_ty_var_block -> raw_var . COLON TYPE [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On COLON shift to state 152
-- On UPPER_WORD reduce production typed_ty_var_block -> raw_var 
-- On SINGLE_QUOTED reduce production typed_ty_var_block -> raw_var 
-- On LOWER_WORD reduce production typed_ty_var_block -> raw_var 
-- On LEFT_PAREN reduce production typed_ty_var_block -> raw_var 
-- On DOT reduce production typed_ty_var_block -> raw_var 

State 152:
typed_ty_var_block -> raw_var COLON . TYPE [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On TYPE shift to state 153

State 153:
typed_ty_var_block -> raw_var COLON TYPE . [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
-- On UPPER_WORD reduce production typed_ty_var_block -> raw_var COLON TYPE 
-- On SINGLE_QUOTED reduce production typed_ty_var_block -> raw_var COLON TYPE 
-- On LOWER_WORD reduce production typed_ty_var_block -> raw_var COLON TYPE 
-- On LEFT_PAREN reduce production typed_ty_var_block -> raw_var COLON TYPE 
-- On DOT reduce production typed_ty_var_block -> raw_var COLON TYPE 

State 154:
statement -> VAL attrs raw_var COLON term . DOT [ EOI ]
-- On DOT shift to state 155

State 155:
statement -> VAL attrs raw_var COLON term DOT . [ EOI ]
-- On EOI reduce production statement -> VAL attrs raw_var COLON term DOT 

State 156:
statement -> REWRITE . attrs term DOT [ EOI ]
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 160
-- On error reduce production attrs -> 
-- On WILDCARD reduce production attrs -> 
-- On UPPER_WORD reduce production attrs -> 
-- On TYPE reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On PROP reduce production attrs -> 
-- On PI reduce production attrs -> 
-- On MATCH reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 
-- On LOGIC_TRUE reduce production attrs -> 
-- On LOGIC_NOT reduce production attrs -> 
-- On LOGIC_FORALL reduce production attrs -> 
-- On LOGIC_FALSE reduce production attrs -> 
-- On LOGIC_EXISTS reduce production attrs -> 
-- On LET reduce production attrs -> 
-- On LEFT_PAREN reduce production attrs -> 
-- On INTEGER reduce production attrs -> 
-- On INT reduce production attrs -> 
-- On IF reduce production attrs -> 
-- On FUN reduce production attrs -> 
-- On ARITH_MINUS reduce production attrs -> 

State 157:
attrs -> LEFT_BRACKET . separated_nonempty_list(COMMA,attr) RIGHT_BRACKET [ error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS ]
-- On error shift to state 4
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On separated_nonempty_list(COMMA,attr) shift to state 158
-- On raw_var shift to state 12
-- On attr shift to state 19
-- On atomic_attr shift to state 22

State 158:
attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) . RIGHT_BRACKET [ error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS ]
-- On RIGHT_BRACKET shift to state 159

State 159:
attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET . [ error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS ]
-- On error reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On WILDCARD reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On UPPER_WORD reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On TYPE reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On SINGLE_QUOTED reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On PROP reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On PI reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On MATCH reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On LOWER_WORD reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On LOGIC_TRUE reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On LOGIC_NOT reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On LOGIC_FORALL reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On LOGIC_FALSE reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On LOGIC_EXISTS reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On LET reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On LEFT_PAREN reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On INTEGER reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On INT reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On IF reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On FUN reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 
-- On ARITH_MINUS reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET 

State 160:
statement -> REWRITE attrs . term DOT [ EOI ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 161
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 161:
statement -> REWRITE attrs term . DOT [ EOI ]
-- On DOT shift to state 162

State 162:
statement -> REWRITE attrs term DOT . [ EOI ]
-- On EOI reduce production statement -> REWRITE attrs term DOT 

State 163:
statement -> LEMMA . attrs term DOT [ EOI ]
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 164
-- On error reduce production attrs -> 
-- On WILDCARD reduce production attrs -> 
-- On UPPER_WORD reduce production attrs -> 
-- On TYPE reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On PROP reduce production attrs -> 
-- On PI reduce production attrs -> 
-- On MATCH reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 
-- On LOGIC_TRUE reduce production attrs -> 
-- On LOGIC_NOT reduce production attrs -> 
-- On LOGIC_FORALL reduce production attrs -> 
-- On LOGIC_FALSE reduce production attrs -> 
-- On LOGIC_EXISTS reduce production attrs -> 
-- On LET reduce production attrs -> 
-- On LEFT_PAREN reduce production attrs -> 
-- On INTEGER reduce production attrs -> 
-- On INT reduce production attrs -> 
-- On IF reduce production attrs -> 
-- On FUN reduce production attrs -> 
-- On ARITH_MINUS reduce production attrs -> 

State 164:
statement -> LEMMA attrs . term DOT [ EOI ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 165
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 165:
statement -> LEMMA attrs term . DOT [ EOI ]
-- On DOT shift to state 166

State 166:
statement -> LEMMA attrs term DOT . [ EOI ]
-- On EOI reduce production statement -> LEMMA attrs term DOT 

State 167:
statement -> INCLUDE . QUOTED DOT [ EOI ]
-- On QUOTED shift to state 168

State 168:
statement -> INCLUDE QUOTED . DOT [ EOI ]
-- On DOT shift to state 169

State 169:
statement -> INCLUDE QUOTED DOT . [ EOI ]
-- On EOI reduce production statement -> INCLUDE QUOTED DOT 

State 170:
statement -> GOAL . attrs term DOT [ EOI ]
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 171
-- On error reduce production attrs -> 
-- On WILDCARD reduce production attrs -> 
-- On UPPER_WORD reduce production attrs -> 
-- On TYPE reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On PROP reduce production attrs -> 
-- On PI reduce production attrs -> 
-- On MATCH reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 
-- On LOGIC_TRUE reduce production attrs -> 
-- On LOGIC_NOT reduce production attrs -> 
-- On LOGIC_FORALL reduce production attrs -> 
-- On LOGIC_FALSE reduce production attrs -> 
-- On LOGIC_EXISTS reduce production attrs -> 
-- On LET reduce production attrs -> 
-- On LEFT_PAREN reduce production attrs -> 
-- On INTEGER reduce production attrs -> 
-- On INT reduce production attrs -> 
-- On IF reduce production attrs -> 
-- On FUN reduce production attrs -> 
-- On ARITH_MINUS reduce production attrs -> 

State 171:
statement -> GOAL attrs . term DOT [ EOI ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 172
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 172:
statement -> GOAL attrs term . DOT [ EOI ]
-- On DOT shift to state 173

State 173:
statement -> GOAL attrs term DOT . [ EOI ]
-- On EOI reduce production statement -> GOAL attrs term DOT 

State 174:
statement -> DEF . attrs separated_nonempty_list(AND,def) DOT [ EOI ]
-- On LEFT_BRACKET shift to state 3
-- On attrs shift to state 175
-- On UPPER_WORD reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 

State 175:
statement -> DEF attrs . separated_nonempty_list(AND,def) DOT [ EOI ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On separated_nonempty_list(AND,def) shift to state 176
-- On raw_var shift to state 178
-- On def shift to state 200

State 176:
statement -> DEF attrs separated_nonempty_list(AND,def) . DOT [ EOI ]
-- On DOT shift to state 177

State 177:
statement -> DEF attrs separated_nonempty_list(AND,def) DOT . [ EOI ]
-- On EOI reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT 

State 178:
def -> raw_var . COLON term EQDEF term [ DOT AND ]
def -> raw_var . COLON term WHERE separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
def -> raw_var . mandatory_typed_var_list COLON term EQDEF term [ DOT AND ]
-- On LEFT_PAREN shift to state 179
-- On COLON shift to state 184
-- On mandatory_typed_var_list shift to state 193
-- On mandatory_typed_var_block shift to state 198

State 179:
mandatory_typed_var_block -> LEFT_PAREN . nonempty_list(raw_var) COLON term RIGHT_PAREN [ LEFT_PAREN COLON ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 36
-- On nonempty_list(raw_var) shift to state 180

State 180:
mandatory_typed_var_block -> LEFT_PAREN nonempty_list(raw_var) . COLON term RIGHT_PAREN [ LEFT_PAREN COLON ]
-- On COLON shift to state 181

State 181:
mandatory_typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON . term RIGHT_PAREN [ LEFT_PAREN COLON ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 182
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 182:
mandatory_typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term . RIGHT_PAREN [ LEFT_PAREN COLON ]
-- On RIGHT_PAREN shift to state 183

State 183:
mandatory_typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN . [ LEFT_PAREN COLON ]
-- On LEFT_PAREN reduce production mandatory_typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN 
-- On COLON reduce production mandatory_typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN 

State 184:
def -> raw_var COLON . term EQDEF term [ DOT AND ]
def -> raw_var COLON . term WHERE separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 185
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 185:
def -> raw_var COLON term . EQDEF term [ DOT AND ]
def -> raw_var COLON term . WHERE separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On WHERE shift to state 186
-- On EQDEF shift to state 191

State 186:
def -> raw_var COLON term WHERE . separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 187
-- On separated_nonempty_list(SEMI_COLON,term) shift to state 190
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 187:
separated_nonempty_list(SEMI_COLON,term) -> term . [ DOT AND ]
separated_nonempty_list(SEMI_COLON,term) -> term . SEMI_COLON separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On SEMI_COLON shift to state 188
-- On DOT reduce production separated_nonempty_list(SEMI_COLON,term) -> term 
-- On AND reduce production separated_nonempty_list(SEMI_COLON,term) -> term 

State 188:
separated_nonempty_list(SEMI_COLON,term) -> term SEMI_COLON . separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 187
-- On separated_nonempty_list(SEMI_COLON,term) shift to state 189
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 189:
separated_nonempty_list(SEMI_COLON,term) -> term SEMI_COLON separated_nonempty_list(SEMI_COLON,term) . [ DOT AND ]
-- On DOT reduce production separated_nonempty_list(SEMI_COLON,term) -> term SEMI_COLON separated_nonempty_list(SEMI_COLON,term) 
-- On AND reduce production separated_nonempty_list(SEMI_COLON,term) -> term SEMI_COLON separated_nonempty_list(SEMI_COLON,term) 

State 190:
def -> raw_var COLON term WHERE separated_nonempty_list(SEMI_COLON,term) . [ DOT AND ]
-- On DOT reduce production def -> raw_var COLON term WHERE separated_nonempty_list(SEMI_COLON,term) 
-- On AND reduce production def -> raw_var COLON term WHERE separated_nonempty_list(SEMI_COLON,term) 

State 191:
def -> raw_var COLON term EQDEF . term [ DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 192
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 192:
def -> raw_var COLON term EQDEF term . [ DOT AND ]
-- On DOT reduce production def -> raw_var COLON term EQDEF term 
-- On AND reduce production def -> raw_var COLON term EQDEF term 

State 193:
def -> raw_var mandatory_typed_var_list . COLON term EQDEF term [ DOT AND ]
-- On COLON shift to state 194

State 194:
def -> raw_var mandatory_typed_var_list COLON . term EQDEF term [ DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 195
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 195:
def -> raw_var mandatory_typed_var_list COLON term . EQDEF term [ DOT AND ]
-- On EQDEF shift to state 196

State 196:
def -> raw_var mandatory_typed_var_list COLON term EQDEF . term [ DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 197
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 197:
def -> raw_var mandatory_typed_var_list COLON term EQDEF term . [ DOT AND ]
-- On DOT reduce production def -> raw_var mandatory_typed_var_list COLON term EQDEF term 
-- On AND reduce production def -> raw_var mandatory_typed_var_list COLON term EQDEF term 

State 198:
mandatory_typed_var_list -> mandatory_typed_var_block . [ COLON ]
mandatory_typed_var_list -> mandatory_typed_var_block . mandatory_typed_var_list [ COLON ]
-- On LEFT_PAREN shift to state 179
-- On mandatory_typed_var_list shift to state 199
-- On mandatory_typed_var_block shift to state 198
-- On COLON reduce production mandatory_typed_var_list -> mandatory_typed_var_block 

State 199:
mandatory_typed_var_list -> mandatory_typed_var_block mandatory_typed_var_list . [ COLON ]
-- On COLON reduce production mandatory_typed_var_list -> mandatory_typed_var_block mandatory_typed_var_list 

State 200:
separated_nonempty_list(AND,def) -> def . [ DOT ]
separated_nonempty_list(AND,def) -> def . AND separated_nonempty_list(AND,def) [ DOT ]
-- On AND shift to state 201
-- On DOT reduce production separated_nonempty_list(AND,def) -> def 

State 201:
separated_nonempty_list(AND,def) -> def AND . separated_nonempty_list(AND,def) [ DOT ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On separated_nonempty_list(AND,def) shift to state 202
-- On raw_var shift to state 178
-- On def shift to state 200

State 202:
separated_nonempty_list(AND,def) -> def AND separated_nonempty_list(AND,def) . [ DOT ]
-- On DOT reduce production separated_nonempty_list(AND,def) -> def AND separated_nonempty_list(AND,def) 

State 203:
statement -> DATA . attrs mutual_types DOT [ EOI ]
-- On LEFT_BRACKET shift to state 3
-- On attrs shift to state 204
-- On UPPER_WORD reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 

State 204:
statement -> DATA attrs . mutual_types DOT [ EOI ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On type_def shift to state 205
-- On separated_nonempty_list(AND,type_def) shift to state 230
-- On raw_var shift to state 208
-- On mutual_types shift to state 231

State 205:
separated_nonempty_list(AND,type_def) -> type_def . [ DOT ]
separated_nonempty_list(AND,type_def) -> type_def . AND separated_nonempty_list(AND,type_def) [ DOT ]
-- On AND shift to state 206
-- On DOT reduce production separated_nonempty_list(AND,type_def) -> type_def 

State 206:
separated_nonempty_list(AND,type_def) -> type_def AND . separated_nonempty_list(AND,type_def) [ DOT ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On type_def shift to state 205
-- On separated_nonempty_list(AND,type_def) shift to state 207
-- On raw_var shift to state 208

State 207:
separated_nonempty_list(AND,type_def) -> type_def AND separated_nonempty_list(AND,type_def) . [ DOT ]
-- On DOT reduce production separated_nonempty_list(AND,type_def) -> type_def AND separated_nonempty_list(AND,type_def) 

State 208:
type_def -> raw_var . list(raw_var) EQDEF constructors [ DOT AND ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 209
-- On list(raw_var) shift to state 211
-- On EQDEF reduce production list(raw_var) -> 

State 209:
list(raw_var) -> raw_var . list(raw_var) [ EQDEF ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 209
-- On list(raw_var) shift to state 210
-- On EQDEF reduce production list(raw_var) -> 

State 210:
list(raw_var) -> raw_var list(raw_var) . [ EQDEF ]
-- On EQDEF reduce production list(raw_var) -> raw_var list(raw_var) 

State 211:
type_def -> raw_var list(raw_var) . EQDEF constructors [ DOT AND ]
-- On EQDEF shift to state 212

State 212:
type_def -> raw_var list(raw_var) EQDEF . constructors [ DOT AND ]
-- On VERTICAL_BAR shift to state 213
-- On option(VERTICAL_BAR) shift to state 214
-- On constructors shift to state 229
-- On UPPER_WORD reduce production option(VERTICAL_BAR) -> 
-- On SINGLE_QUOTED reduce production option(VERTICAL_BAR) -> 
-- On LOWER_WORD reduce production option(VERTICAL_BAR) -> 

State 213:
option(VERTICAL_BAR) -> VERTICAL_BAR . [ UPPER_WORD SINGLE_QUOTED LOWER_WORD ]
-- On UPPER_WORD reduce production option(VERTICAL_BAR) -> VERTICAL_BAR 
-- On SINGLE_QUOTED reduce production option(VERTICAL_BAR) -> VERTICAL_BAR 
-- On LOWER_WORD reduce production option(VERTICAL_BAR) -> VERTICAL_BAR 

State 214:
constructors -> option(VERTICAL_BAR) . separated_nonempty_list(VERTICAL_BAR,constructor) [ DOT AND ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On separated_nonempty_list(VERTICAL_BAR,constructor) shift to state 215
-- On raw_var shift to state 216
-- On constructor shift to state 226

State 215:
constructors -> option(VERTICAL_BAR) separated_nonempty_list(VERTICAL_BAR,constructor) . [ DOT AND ]
-- On DOT reduce production constructors -> option(VERTICAL_BAR) separated_nonempty_list(VERTICAL_BAR,constructor) 
-- On AND reduce production constructors -> option(VERTICAL_BAR) separated_nonempty_list(VERTICAL_BAR,constructor) 

State 216:
constructor -> raw_var . list(constructor_arg) [ VERTICAL_BAR DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 217
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On var shift to state 67
-- On raw_var shift to state 68
-- On list(constructor_arg) shift to state 222
-- On constructor_arg shift to state 223
-- On const shift to state 69
-- On atomic_term shift to state 225
-- On VERTICAL_BAR reduce production list(constructor_arg) -> 
-- On DOT reduce production list(constructor_arg) -> 
-- On AND reduce production list(constructor_arg) -> 

State 217:
atomic_term -> LEFT_PAREN . term RIGHT_PAREN [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
constructor_arg -> LEFT_PAREN . raw_var COLON atomic_term RIGHT_PAREN [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 130
-- On raw_var shift to state 218
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 218:
constructor_arg -> LEFT_PAREN raw_var . COLON atomic_term RIGHT_PAREN [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
var -> raw_var . [ WILDCARD UPPER_WORD TYPE SINGLE_QUOTED RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ ]
-- On COLON shift to state 219
-- On WILDCARD reduce production var -> raw_var 
-- On UPPER_WORD reduce production var -> raw_var 
-- On TYPE reduce production var -> raw_var 
-- On SINGLE_QUOTED reduce production var -> raw_var 
-- On RIGHT_PAREN reduce production var -> raw_var 
-- On PROP reduce production var -> raw_var 
-- On MATCH reduce production var -> raw_var 
-- On LOWER_WORD reduce production var -> raw_var 
-- On LOGIC_TRUE reduce production var -> raw_var 
-- On LOGIC_OR reduce production var -> raw_var 
-- On LOGIC_NEQ reduce production var -> raw_var 
-- On LOGIC_IMPLY reduce production var -> raw_var 
-- On LOGIC_FALSE reduce production var -> raw_var 
-- On LOGIC_EQUIV reduce production var -> raw_var 
-- On LOGIC_EQ reduce production var -> raw_var 
-- On LOGIC_AND reduce production var -> raw_var 
-- On LEFT_PAREN reduce production var -> raw_var 
-- On INTEGER reduce production var -> raw_var 
-- On INT reduce production var -> raw_var 
-- On ARROW reduce production var -> raw_var 
-- On ARITH_PRODUCT reduce production var -> raw_var 
-- On ARITH_PLUS reduce production var -> raw_var 
-- On ARITH_MINUS reduce production var -> raw_var 
-- On ARITH_LT reduce production var -> raw_var 
-- On ARITH_LEQ reduce production var -> raw_var 
-- On ARITH_GT reduce production var -> raw_var 
-- On ARITH_GEQ reduce production var -> raw_var 

State 219:
constructor_arg -> LEFT_PAREN raw_var COLON . atomic_term RIGHT_PAREN [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On var shift to state 67
-- On raw_var shift to state 68
-- On const shift to state 69
-- On atomic_term shift to state 220

State 220:
constructor_arg -> LEFT_PAREN raw_var COLON atomic_term . RIGHT_PAREN [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
-- On RIGHT_PAREN shift to state 221

State 221:
constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN . [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
-- On WILDCARD reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On VERTICAL_BAR reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On UPPER_WORD reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On TYPE reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On SINGLE_QUOTED reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On PROP reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On MATCH reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On LOWER_WORD reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On LOGIC_TRUE reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On LOGIC_FALSE reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On LEFT_PAREN reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On INTEGER reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On INT reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On DOT reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 
-- On AND reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN 

State 222:
constructor -> raw_var list(constructor_arg) . [ VERTICAL_BAR DOT AND ]
-- On VERTICAL_BAR reduce production constructor -> raw_var list(constructor_arg) 
-- On DOT reduce production constructor -> raw_var list(constructor_arg) 
-- On AND reduce production constructor -> raw_var list(constructor_arg) 

State 223:
list(constructor_arg) -> constructor_arg . list(constructor_arg) [ VERTICAL_BAR DOT AND ]
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 217
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On var shift to state 67
-- On raw_var shift to state 68
-- On list(constructor_arg) shift to state 224
-- On constructor_arg shift to state 223
-- On const shift to state 69
-- On atomic_term shift to state 225
-- On VERTICAL_BAR reduce production list(constructor_arg) -> 
-- On DOT reduce production list(constructor_arg) -> 
-- On AND reduce production list(constructor_arg) -> 

State 224:
list(constructor_arg) -> constructor_arg list(constructor_arg) . [ VERTICAL_BAR DOT AND ]
-- On VERTICAL_BAR reduce production list(constructor_arg) -> constructor_arg list(constructor_arg) 
-- On DOT reduce production list(constructor_arg) -> constructor_arg list(constructor_arg) 
-- On AND reduce production list(constructor_arg) -> constructor_arg list(constructor_arg) 

State 225:
constructor_arg -> atomic_term . [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
-- On WILDCARD reduce production constructor_arg -> atomic_term 
-- On VERTICAL_BAR reduce production constructor_arg -> atomic_term 
-- On UPPER_WORD reduce production constructor_arg -> atomic_term 
-- On TYPE reduce production constructor_arg -> atomic_term 
-- On SINGLE_QUOTED reduce production constructor_arg -> atomic_term 
-- On PROP reduce production constructor_arg -> atomic_term 
-- On MATCH reduce production constructor_arg -> atomic_term 
-- On LOWER_WORD reduce production constructor_arg -> atomic_term 
-- On LOGIC_TRUE reduce production constructor_arg -> atomic_term 
-- On LOGIC_FALSE reduce production constructor_arg -> atomic_term 
-- On LEFT_PAREN reduce production constructor_arg -> atomic_term 
-- On INTEGER reduce production constructor_arg -> atomic_term 
-- On INT reduce production constructor_arg -> atomic_term 
-- On DOT reduce production constructor_arg -> atomic_term 
-- On AND reduce production constructor_arg -> atomic_term 

State 226:
separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor . [ DOT AND ]
separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor . VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,constructor) [ DOT AND ]
-- On VERTICAL_BAR shift to state 227
-- On DOT reduce production separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor 
-- On AND reduce production separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor 

State 227:
separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor VERTICAL_BAR . separated_nonempty_list(VERTICAL_BAR,constructor) [ DOT AND ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On separated_nonempty_list(VERTICAL_BAR,constructor) shift to state 228
-- On raw_var shift to state 216
-- On constructor shift to state 226

State 228:
separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,constructor) . [ DOT AND ]
-- On DOT reduce production separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,constructor) 
-- On AND reduce production separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,constructor) 

State 229:
type_def -> raw_var list(raw_var) EQDEF constructors . [ DOT AND ]
-- On DOT reduce production type_def -> raw_var list(raw_var) EQDEF constructors 
-- On AND reduce production type_def -> raw_var list(raw_var) EQDEF constructors 

State 230:
mutual_types -> separated_nonempty_list(AND,type_def) . [ DOT ]
-- On DOT reduce production mutual_types -> separated_nonempty_list(AND,type_def) 

State 231:
statement -> DATA attrs mutual_types . DOT [ EOI ]
-- On DOT shift to state 232

State 232:
statement -> DATA attrs mutual_types DOT . [ EOI ]
-- On EOI reduce production statement -> DATA attrs mutual_types DOT 

State 233:
statement -> ASSERT . attrs term DOT [ EOI ]
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 234
-- On error reduce production attrs -> 
-- On WILDCARD reduce production attrs -> 
-- On UPPER_WORD reduce production attrs -> 
-- On TYPE reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On PROP reduce production attrs -> 
-- On PI reduce production attrs -> 
-- On MATCH reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 
-- On LOGIC_TRUE reduce production attrs -> 
-- On LOGIC_NOT reduce production attrs -> 
-- On LOGIC_FORALL reduce production attrs -> 
-- On LOGIC_FALSE reduce production attrs -> 
-- On LOGIC_EXISTS reduce production attrs -> 
-- On LET reduce production attrs -> 
-- On LEFT_PAREN reduce production attrs -> 
-- On INTEGER reduce production attrs -> 
-- On INT reduce production attrs -> 
-- On IF reduce production attrs -> 
-- On FUN reduce production attrs -> 
-- On ARITH_MINUS reduce production attrs -> 

State 234:
statement -> ASSERT attrs . term DOT [ EOI ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 235
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 235:
statement -> ASSERT attrs term . DOT [ EOI ]
-- On DOT shift to state 236

State 236:
statement -> ASSERT attrs term DOT . [ EOI ]
-- On EOI reduce production statement -> ASSERT attrs term DOT 

State 237:
parse_statement -> statement . EOI [ # ]
-- On EOI shift to state 238

State 238:
parse_statement -> statement EOI . [ # ]
-- On # reduce production parse_statement -> statement EOI 

State 239:
parse_statement' -> parse_statement . [ # ]
-- On # accept parse_statement

State 240:
parse_statement_list' -> . parse_statement_list [ # ]
-- On error shift to state 241
-- On VAL shift to state 242
-- On REWRITE shift to state 248
-- On LEMMA shift to state 252
-- On INCLUDE shift to state 256
-- On GOAL shift to state 259
-- On DEF shift to state 263
-- On DATA shift to state 267
-- On ASSERT shift to state 271
-- On statement shift to state 275
-- On parse_statement_list shift to state 277
-- On list(statement) shift to state 278
-- On EOI reduce production list(statement) -> 

State 241:
statement -> error . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error reduce production statement -> error 
-- On VAL reduce production statement -> error 
-- On REWRITE reduce production statement -> error 
-- On LEMMA reduce production statement -> error 
-- On INCLUDE reduce production statement -> error 
-- On GOAL reduce production statement -> error 
-- On EOI reduce production statement -> error 
-- On DEF reduce production statement -> error 
-- On DATA reduce production statement -> error 
-- On ASSERT reduce production statement -> error 

State 242:
statement -> VAL . attrs raw_var COLON term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On LEFT_BRACKET shift to state 3
-- On attrs shift to state 243
-- On UPPER_WORD reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 

State 243:
statement -> VAL attrs . raw_var COLON term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 244

State 244:
statement -> VAL attrs raw_var . COLON term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On COLON shift to state 245

State 245:
statement -> VAL attrs raw_var COLON . term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 246
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 246:
statement -> VAL attrs raw_var COLON term . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On DOT shift to state 247

State 247:
statement -> VAL attrs raw_var COLON term DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error reduce production statement -> VAL attrs raw_var COLON term DOT 
-- On VAL reduce production statement -> VAL attrs raw_var COLON term DOT 
-- On REWRITE reduce production statement -> VAL attrs raw_var COLON term DOT 
-- On LEMMA reduce production statement -> VAL attrs raw_var COLON term DOT 
-- On INCLUDE reduce production statement -> VAL attrs raw_var COLON term DOT 
-- On GOAL reduce production statement -> VAL attrs raw_var COLON term DOT 
-- On EOI reduce production statement -> VAL attrs raw_var COLON term DOT 
-- On DEF reduce production statement -> VAL attrs raw_var COLON term DOT 
-- On DATA reduce production statement -> VAL attrs raw_var COLON term DOT 
-- On ASSERT reduce production statement -> VAL attrs raw_var COLON term DOT 

State 248:
statement -> REWRITE . attrs term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 249
-- On error reduce production attrs -> 
-- On WILDCARD reduce production attrs -> 
-- On UPPER_WORD reduce production attrs -> 
-- On TYPE reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On PROP reduce production attrs -> 
-- On PI reduce production attrs -> 
-- On MATCH reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 
-- On LOGIC_TRUE reduce production attrs -> 
-- On LOGIC_NOT reduce production attrs -> 
-- On LOGIC_FORALL reduce production attrs -> 
-- On LOGIC_FALSE reduce production attrs -> 
-- On LOGIC_EXISTS reduce production attrs -> 
-- On LET reduce production attrs -> 
-- On LEFT_PAREN reduce production attrs -> 
-- On INTEGER reduce production attrs -> 
-- On INT reduce production attrs -> 
-- On IF reduce production attrs -> 
-- On FUN reduce production attrs -> 
-- On ARITH_MINUS reduce production attrs -> 

State 249:
statement -> REWRITE attrs . term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 250
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 250:
statement -> REWRITE attrs term . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On DOT shift to state 251

State 251:
statement -> REWRITE attrs term DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error reduce production statement -> REWRITE attrs term DOT 
-- On VAL reduce production statement -> REWRITE attrs term DOT 
-- On REWRITE reduce production statement -> REWRITE attrs term DOT 
-- On LEMMA reduce production statement -> REWRITE attrs term DOT 
-- On INCLUDE reduce production statement -> REWRITE attrs term DOT 
-- On GOAL reduce production statement -> REWRITE attrs term DOT 
-- On EOI reduce production statement -> REWRITE attrs term DOT 
-- On DEF reduce production statement -> REWRITE attrs term DOT 
-- On DATA reduce production statement -> REWRITE attrs term DOT 
-- On ASSERT reduce production statement -> REWRITE attrs term DOT 

State 252:
statement -> LEMMA . attrs term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 253
-- On error reduce production attrs -> 
-- On WILDCARD reduce production attrs -> 
-- On UPPER_WORD reduce production attrs -> 
-- On TYPE reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On PROP reduce production attrs -> 
-- On PI reduce production attrs -> 
-- On MATCH reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 
-- On LOGIC_TRUE reduce production attrs -> 
-- On LOGIC_NOT reduce production attrs -> 
-- On LOGIC_FORALL reduce production attrs -> 
-- On LOGIC_FALSE reduce production attrs -> 
-- On LOGIC_EXISTS reduce production attrs -> 
-- On LET reduce production attrs -> 
-- On LEFT_PAREN reduce production attrs -> 
-- On INTEGER reduce production attrs -> 
-- On INT reduce production attrs -> 
-- On IF reduce production attrs -> 
-- On FUN reduce production attrs -> 
-- On ARITH_MINUS reduce production attrs -> 

State 253:
statement -> LEMMA attrs . term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 254
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 254:
statement -> LEMMA attrs term . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On DOT shift to state 255

State 255:
statement -> LEMMA attrs term DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error reduce production statement -> LEMMA attrs term DOT 
-- On VAL reduce production statement -> LEMMA attrs term DOT 
-- On REWRITE reduce production statement -> LEMMA attrs term DOT 
-- On LEMMA reduce production statement -> LEMMA attrs term DOT 
-- On INCLUDE reduce production statement -> LEMMA attrs term DOT 
-- On GOAL reduce production statement -> LEMMA attrs term DOT 
-- On EOI reduce production statement -> LEMMA attrs term DOT 
-- On DEF reduce production statement -> LEMMA attrs term DOT 
-- On DATA reduce production statement -> LEMMA attrs term DOT 
-- On ASSERT reduce production statement -> LEMMA attrs term DOT 

State 256:
statement -> INCLUDE . QUOTED DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On QUOTED shift to state 257

State 257:
statement -> INCLUDE QUOTED . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On DOT shift to state 258

State 258:
statement -> INCLUDE QUOTED DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error reduce production statement -> INCLUDE QUOTED DOT 
-- On VAL reduce production statement -> INCLUDE QUOTED DOT 
-- On REWRITE reduce production statement -> INCLUDE QUOTED DOT 
-- On LEMMA reduce production statement -> INCLUDE QUOTED DOT 
-- On INCLUDE reduce production statement -> INCLUDE QUOTED DOT 
-- On GOAL reduce production statement -> INCLUDE QUOTED DOT 
-- On EOI reduce production statement -> INCLUDE QUOTED DOT 
-- On DEF reduce production statement -> INCLUDE QUOTED DOT 
-- On DATA reduce production statement -> INCLUDE QUOTED DOT 
-- On ASSERT reduce production statement -> INCLUDE QUOTED DOT 

State 259:
statement -> GOAL . attrs term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 260
-- On error reduce production attrs -> 
-- On WILDCARD reduce production attrs -> 
-- On UPPER_WORD reduce production attrs -> 
-- On TYPE reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On PROP reduce production attrs -> 
-- On PI reduce production attrs -> 
-- On MATCH reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 
-- On LOGIC_TRUE reduce production attrs -> 
-- On LOGIC_NOT reduce production attrs -> 
-- On LOGIC_FORALL reduce production attrs -> 
-- On LOGIC_FALSE reduce production attrs -> 
-- On LOGIC_EXISTS reduce production attrs -> 
-- On LET reduce production attrs -> 
-- On LEFT_PAREN reduce production attrs -> 
-- On INTEGER reduce production attrs -> 
-- On INT reduce production attrs -> 
-- On IF reduce production attrs -> 
-- On FUN reduce production attrs -> 
-- On ARITH_MINUS reduce production attrs -> 

State 260:
statement -> GOAL attrs . term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 261
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 261:
statement -> GOAL attrs term . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On DOT shift to state 262

State 262:
statement -> GOAL attrs term DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error reduce production statement -> GOAL attrs term DOT 
-- On VAL reduce production statement -> GOAL attrs term DOT 
-- On REWRITE reduce production statement -> GOAL attrs term DOT 
-- On LEMMA reduce production statement -> GOAL attrs term DOT 
-- On INCLUDE reduce production statement -> GOAL attrs term DOT 
-- On GOAL reduce production statement -> GOAL attrs term DOT 
-- On EOI reduce production statement -> GOAL attrs term DOT 
-- On DEF reduce production statement -> GOAL attrs term DOT 
-- On DATA reduce production statement -> GOAL attrs term DOT 
-- On ASSERT reduce production statement -> GOAL attrs term DOT 

State 263:
statement -> DEF . attrs separated_nonempty_list(AND,def) DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On LEFT_BRACKET shift to state 3
-- On attrs shift to state 264
-- On UPPER_WORD reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 

State 264:
statement -> DEF attrs . separated_nonempty_list(AND,def) DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On separated_nonempty_list(AND,def) shift to state 265
-- On raw_var shift to state 178
-- On def shift to state 200

State 265:
statement -> DEF attrs separated_nonempty_list(AND,def) . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On DOT shift to state 266

State 266:
statement -> DEF attrs separated_nonempty_list(AND,def) DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT 
-- On VAL reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT 
-- On REWRITE reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT 
-- On LEMMA reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT 
-- On INCLUDE reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT 
-- On GOAL reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT 
-- On EOI reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT 
-- On DEF reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT 
-- On DATA reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT 
-- On ASSERT reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT 

State 267:
statement -> DATA . attrs mutual_types DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On LEFT_BRACKET shift to state 3
-- On attrs shift to state 268
-- On UPPER_WORD reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 

State 268:
statement -> DATA attrs . mutual_types DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On type_def shift to state 205
-- On separated_nonempty_list(AND,type_def) shift to state 230
-- On raw_var shift to state 208
-- On mutual_types shift to state 269

State 269:
statement -> DATA attrs mutual_types . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On DOT shift to state 270

State 270:
statement -> DATA attrs mutual_types DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error reduce production statement -> DATA attrs mutual_types DOT 
-- On VAL reduce production statement -> DATA attrs mutual_types DOT 
-- On REWRITE reduce production statement -> DATA attrs mutual_types DOT 
-- On LEMMA reduce production statement -> DATA attrs mutual_types DOT 
-- On INCLUDE reduce production statement -> DATA attrs mutual_types DOT 
-- On GOAL reduce production statement -> DATA attrs mutual_types DOT 
-- On EOI reduce production statement -> DATA attrs mutual_types DOT 
-- On DEF reduce production statement -> DATA attrs mutual_types DOT 
-- On DATA reduce production statement -> DATA attrs mutual_types DOT 
-- On ASSERT reduce production statement -> DATA attrs mutual_types DOT 

State 271:
statement -> ASSERT . attrs term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 272
-- On error reduce production attrs -> 
-- On WILDCARD reduce production attrs -> 
-- On UPPER_WORD reduce production attrs -> 
-- On TYPE reduce production attrs -> 
-- On SINGLE_QUOTED reduce production attrs -> 
-- On PROP reduce production attrs -> 
-- On PI reduce production attrs -> 
-- On MATCH reduce production attrs -> 
-- On LOWER_WORD reduce production attrs -> 
-- On LOGIC_TRUE reduce production attrs -> 
-- On LOGIC_NOT reduce production attrs -> 
-- On LOGIC_FORALL reduce production attrs -> 
-- On LOGIC_FALSE reduce production attrs -> 
-- On LOGIC_EXISTS reduce production attrs -> 
-- On LET reduce production attrs -> 
-- On LEFT_PAREN reduce production attrs -> 
-- On INTEGER reduce production attrs -> 
-- On INT reduce production attrs -> 
-- On IF reduce production attrs -> 
-- On FUN reduce production attrs -> 
-- On ARITH_MINUS reduce production attrs -> 

State 272:
statement -> ASSERT attrs . term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 273
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 273:
statement -> ASSERT attrs term . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On DOT shift to state 274

State 274:
statement -> ASSERT attrs term DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
-- On error reduce production statement -> ASSERT attrs term DOT 
-- On VAL reduce production statement -> ASSERT attrs term DOT 
-- On REWRITE reduce production statement -> ASSERT attrs term DOT 
-- On LEMMA reduce production statement -> ASSERT attrs term DOT 
-- On INCLUDE reduce production statement -> ASSERT attrs term DOT 
-- On GOAL reduce production statement -> ASSERT attrs term DOT 
-- On EOI reduce production statement -> ASSERT attrs term DOT 
-- On DEF reduce production statement -> ASSERT attrs term DOT 
-- On DATA reduce production statement -> ASSERT attrs term DOT 
-- On ASSERT reduce production statement -> ASSERT attrs term DOT 

State 275:
list(statement) -> statement . list(statement) [ EOI ]
-- On error shift to state 241
-- On VAL shift to state 242
-- On REWRITE shift to state 248
-- On LEMMA shift to state 252
-- On INCLUDE shift to state 256
-- On GOAL shift to state 259
-- On DEF shift to state 263
-- On DATA shift to state 267
-- On ASSERT shift to state 271
-- On statement shift to state 275
-- On list(statement) shift to state 276
-- On EOI reduce production list(statement) -> 

State 276:
list(statement) -> statement list(statement) . [ EOI ]
-- On EOI reduce production list(statement) -> statement list(statement) 

State 277:
parse_statement_list' -> parse_statement_list . [ # ]
-- On # accept parse_statement_list

State 278:
parse_statement_list -> list(statement) . EOI [ # ]
-- On EOI shift to state 279

State 279:
parse_statement_list -> list(statement) EOI . [ # ]
-- On # reduce production parse_statement_list -> list(statement) EOI 

State 280:
parse_term' -> . parse_term [ # ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 281
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On parse_term shift to state 283
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 281:
parse_term -> term . EOI [ # ]
-- On EOI shift to state 282

State 282:
parse_term -> term EOI . [ # ]
-- On # reduce production parse_term -> term EOI 

State 283:
parse_term' -> parse_term . [ # ]
-- On # accept parse_term

State 284:
parse_ty' -> . parse_ty [ # ]
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 285
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On parse_ty shift to state 287
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106

State 285:
parse_ty -> term . EOI [ # ]
-- On EOI shift to state 286

State 286:
parse_ty -> term EOI . [ # ]
-- On # reduce production parse_ty -> term EOI 

State 287:
parse_ty' -> parse_ty . [ # ]
-- On # accept parse_ty

