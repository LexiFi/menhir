State 0:
## Known stack suffix:
##
## LR(1) items:
parse_statement' -> . parse_statement [ # ]
## Transitions:
-- On error shift to state 1
-- On VAL shift to state 2
-- On REWRITE shift to state 156
-- On LEMMA shift to state 163
-- On INCLUDE shift to state 167
-- On GOAL shift to state 170
-- On DEF shift to state 174
-- On DATA shift to state 203
-- On ASSERT shift to state 233
-- On statement shift to state 237
-- On parse_statement shift to state 239
## Reductions:

State 1:
## Known stack suffix:
## error
## LR(1) items:
statement -> error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> error

State 2:
## Known stack suffix:
## VAL
## LR(1) items:
statement -> VAL . attrs raw_var COLON term DOT [ EOI ]
## Transitions:
-- On LEFT_BRACKET shift to state 3
-- On attrs shift to state 27
## Reductions:
-- On UPPER_WORD reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->

State 3:
## Known stack suffix:
## LEFT_BRACKET
## LR(1) items:
attrs -> LEFT_BRACKET . separated_nonempty_list(COMMA,attr) RIGHT_BRACKET [ UPPER_WORD SINGLE_QUOTED LOWER_WORD ]
## Transitions:
-- On error shift to state 4
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On separated_nonempty_list(COMMA,attr) shift to state 25
-- On raw_var shift to state 12
-- On attr shift to state 19
-- On atomic_attr shift to state 22
## Reductions:

State 4:
## Known stack suffix:
## error
## LR(1) items:
attr -> error . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production attr -> error

State 5:
## Known stack suffix:
## UPPER_WORD
## LR(1) items:
raw_var -> UPPER_WORD . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN RIGHT_BRACKET QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET INTEGER INT IN EQDEF EOI END ELSE DOT COMMA COLON ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production raw_var -> UPPER_WORD

State 6:
## Known stack suffix:
## SINGLE_QUOTED
## LR(1) items:
raw_var -> SINGLE_QUOTED . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN RIGHT_BRACKET QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET INTEGER INT IN EQDEF EOI END ELSE DOT COMMA COLON ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production raw_var -> SINGLE_QUOTED

State 7:
## Known stack suffix:
## QUOTED
## LR(1) items:
atomic_attr -> QUOTED . [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_attr -> QUOTED

State 8:
## Known stack suffix:
## LOWER_WORD
## LR(1) items:
raw_var -> LOWER_WORD . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN RIGHT_BRACKET QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET INTEGER INT IN EQDEF EOI END ELSE DOT COMMA COLON ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production raw_var -> LOWER_WORD

State 9:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
atomic_attr -> LEFT_PAREN . attr RIGHT_PAREN [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
## Transitions:
-- On error shift to state 4
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On raw_var shift to state 12
-- On attr shift to state 23
-- On atomic_attr shift to state 22
## Reductions:

State 10:
## Known stack suffix:
## LEFT_BRACKET
## LR(1) items:
atomic_attr -> LEFT_BRACKET . loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
## Transitions:
-- On error shift to state 4
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On separated_nonempty_list(COMMA,attr) shift to state 11
-- On raw_var shift to state 12
-- On loption(separated_nonempty_list(COMMA,attr)) shift to state 17
-- On attr shift to state 19
-- On atomic_attr shift to state 22
## Reductions:
-- On RIGHT_BRACKET reduce production loption(separated_nonempty_list(COMMA,attr)) ->

State 11:
## Known stack suffix:
## separated_nonempty_list(COMMA,attr)
## LR(1) items:
loption(separated_nonempty_list(COMMA,attr)) -> separated_nonempty_list(COMMA,attr) . [ RIGHT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production loption(separated_nonempty_list(COMMA,attr)) -> separated_nonempty_list(COMMA,attr)

State 12:
## Known stack suffix:
## raw_var
## LR(1) items:
atomic_attr -> raw_var . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
attr -> raw_var . nonempty_list(atomic_attr) [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On raw_var shift to state 13
-- On nonempty_list(atomic_attr) shift to state 14
-- On atomic_attr shift to state 15
## Reductions:
-- On RIGHT_PAREN reduce production atomic_attr -> raw_var
-- On RIGHT_BRACKET reduce production atomic_attr -> raw_var
-- On COMMA reduce production atomic_attr -> raw_var

State 13:
## Known stack suffix:
## raw_var
## LR(1) items:
atomic_attr -> raw_var . [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_attr -> raw_var

State 14:
## Known stack suffix:
## raw_var nonempty_list(atomic_attr)
## LR(1) items:
attr -> raw_var nonempty_list(atomic_attr) . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production attr -> raw_var nonempty_list(atomic_attr)

State 15:
## Known stack suffix:
## atomic_attr
## LR(1) items:
nonempty_list(atomic_attr) -> atomic_attr . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
nonempty_list(atomic_attr) -> atomic_attr . nonempty_list(atomic_attr) [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On raw_var shift to state 13
-- On nonempty_list(atomic_attr) shift to state 16
-- On atomic_attr shift to state 15
## Reductions:
-- On RIGHT_PAREN reduce production nonempty_list(atomic_attr) -> atomic_attr
-- On RIGHT_BRACKET reduce production nonempty_list(atomic_attr) -> atomic_attr
-- On COMMA reduce production nonempty_list(atomic_attr) -> atomic_attr

State 16:
## Known stack suffix:
## atomic_attr nonempty_list(atomic_attr)
## LR(1) items:
nonempty_list(atomic_attr) -> atomic_attr nonempty_list(atomic_attr) . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(atomic_attr) -> atomic_attr nonempty_list(atomic_attr)

State 17:
## Known stack suffix:
## LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr))
## LR(1) items:
atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) . RIGHT_BRACKET [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
## Transitions:
-- On RIGHT_BRACKET shift to state 18
## Reductions:

State 18:
## Known stack suffix:
## LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET
## LR(1) items:
atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET . [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_attr -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,attr)) RIGHT_BRACKET

State 19:
## Known stack suffix:
## attr
## LR(1) items:
separated_nonempty_list(COMMA,attr) -> attr . [ RIGHT_BRACKET ]
separated_nonempty_list(COMMA,attr) -> attr . COMMA separated_nonempty_list(COMMA,attr) [ RIGHT_BRACKET ]
## Transitions:
-- On COMMA shift to state 20
## Reductions:
-- On RIGHT_BRACKET reduce production separated_nonempty_list(COMMA,attr) -> attr

State 20:
## Known stack suffix:
## attr COMMA
## LR(1) items:
separated_nonempty_list(COMMA,attr) -> attr COMMA . separated_nonempty_list(COMMA,attr) [ RIGHT_BRACKET ]
## Transitions:
-- On error shift to state 4
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On separated_nonempty_list(COMMA,attr) shift to state 21
-- On raw_var shift to state 12
-- On attr shift to state 19
-- On atomic_attr shift to state 22
## Reductions:

State 21:
## Known stack suffix:
## attr COMMA separated_nonempty_list(COMMA,attr)
## LR(1) items:
separated_nonempty_list(COMMA,attr) -> attr COMMA separated_nonempty_list(COMMA,attr) . [ RIGHT_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,attr) -> attr COMMA separated_nonempty_list(COMMA,attr)

State 22:
## Known stack suffix:
## atomic_attr
## LR(1) items:
attr -> atomic_attr . [ RIGHT_PAREN RIGHT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production attr -> atomic_attr

State 23:
## Known stack suffix:
## LEFT_PAREN attr
## LR(1) items:
atomic_attr -> LEFT_PAREN attr . RIGHT_PAREN [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
## Transitions:
-- On RIGHT_PAREN shift to state 24
## Reductions:

State 24:
## Known stack suffix:
## LEFT_PAREN attr RIGHT_PAREN
## LR(1) items:
atomic_attr -> LEFT_PAREN attr RIGHT_PAREN . [ UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_attr -> LEFT_PAREN attr RIGHT_PAREN

State 25:
## Known stack suffix:
## LEFT_BRACKET separated_nonempty_list(COMMA,attr)
## LR(1) items:
attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) . RIGHT_BRACKET [ UPPER_WORD SINGLE_QUOTED LOWER_WORD ]
## Transitions:
-- On RIGHT_BRACKET shift to state 26
## Reductions:

State 26:
## Known stack suffix:
## LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET
## LR(1) items:
attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET . [ UPPER_WORD SINGLE_QUOTED LOWER_WORD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET

State 27:
## Known stack suffix:
## VAL attrs
## LR(1) items:
statement -> VAL attrs . raw_var COLON term DOT [ EOI ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 28
## Reductions:

State 28:
## Known stack suffix:
## VAL attrs raw_var
## LR(1) items:
statement -> VAL attrs raw_var . COLON term DOT [ EOI ]
## Transitions:
-- On COLON shift to state 29
## Reductions:

State 29:
## Known stack suffix:
## VAL attrs raw_var COLON
## LR(1) items:
statement -> VAL attrs raw_var COLON . term DOT [ EOI ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 154
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 30:
## Known stack suffix:
## error
## LR(1) items:
term -> error . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> error

State 31:
## Known stack suffix:
## WILDCARD
## LR(1) items:
var -> WILDCARD . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production var -> WILDCARD

State 32:
## Known stack suffix:
## TYPE
## LR(1) items:
const -> TYPE . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production const -> TYPE

State 33:
## Known stack suffix:
## PROP
## LR(1) items:
const -> PROP . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production const -> PROP

State 34:
## Known stack suffix:
## PI
## LR(1) items:
term -> PI . typed_ty_var_list DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 35
-- On typed_ty_var_list shift to state 42
-- On typed_ty_var_block shift to state 149
-- On raw_var shift to state 151
## Reductions:

State 35:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
typed_ty_var_block -> LEFT_PAREN . nonempty_list(raw_var) COLON TYPE RIGHT_PAREN [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 36
-- On nonempty_list(raw_var) shift to state 38
## Reductions:

State 36:
## Known stack suffix:
## raw_var
## LR(1) items:
nonempty_list(raw_var) -> raw_var . [ COLON ]
nonempty_list(raw_var) -> raw_var . nonempty_list(raw_var) [ COLON ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 36
-- On nonempty_list(raw_var) shift to state 37
## Reductions:
-- On COLON reduce production nonempty_list(raw_var) -> raw_var

State 37:
## Known stack suffix:
## raw_var nonempty_list(raw_var)
## LR(1) items:
nonempty_list(raw_var) -> raw_var nonempty_list(raw_var) . [ COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(raw_var) -> raw_var nonempty_list(raw_var)

State 38:
## Known stack suffix:
## LEFT_PAREN nonempty_list(raw_var)
## LR(1) items:
typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) . COLON TYPE RIGHT_PAREN [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
-- On COLON shift to state 39
## Reductions:

State 39:
## Known stack suffix:
## LEFT_PAREN nonempty_list(raw_var) COLON
## LR(1) items:
typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON . TYPE RIGHT_PAREN [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
-- On TYPE shift to state 40
## Reductions:

State 40:
## Known stack suffix:
## LEFT_PAREN nonempty_list(raw_var) COLON TYPE
## LR(1) items:
typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON TYPE . RIGHT_PAREN [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
-- On RIGHT_PAREN shift to state 41
## Reductions:

State 41:
## Known stack suffix:
## LEFT_PAREN nonempty_list(raw_var) COLON TYPE RIGHT_PAREN
## LR(1) items:
typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON TYPE RIGHT_PAREN . [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typed_ty_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON TYPE RIGHT_PAREN

State 42:
## Known stack suffix:
## PI typed_ty_var_list
## LR(1) items:
term -> PI typed_ty_var_list . DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On DOT shift to state 43
## Reductions:

State 43:
## Known stack suffix:
## PI typed_ty_var_list DOT
## LR(1) items:
term -> PI typed_ty_var_list DOT . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 148
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 44:
## Known stack suffix:
## MATCH
## LR(1) items:
atomic_term -> MATCH . term WITH nonempty_list(match_branch) END [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 133
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 45:
## Known stack suffix:
## LOGIC_TRUE
## LR(1) items:
const -> LOGIC_TRUE . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production const -> LOGIC_TRUE

State 46:
## Known stack suffix:
## LOGIC_NOT
## LR(1) items:
not_term -> LOGIC_NOT . arith_op_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 132
-- On apply_term shift to state 82
## Reductions:

State 47:
## Known stack suffix:
## LOGIC_FALSE
## LR(1) items:
const -> LOGIC_FALSE . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production const -> LOGIC_FALSE

State 48:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
atomic_term -> LEFT_PAREN . term RIGHT_PAREN [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 130
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 49:
## Known stack suffix:
## LOGIC_FORALL
## LR(1) items:
term -> LOGIC_FORALL . typed_var_list DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 50
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 51
-- On typed_var_list shift to state 127
-- On typed_var_block shift to state 113
-- On raw_var shift to state 115
## Reductions:

State 50:
## Known stack suffix:
## WILDCARD
## LR(1) items:
typed_var_block -> WILDCARD . [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typed_var_block -> WILDCARD

State 51:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
typed_var_block -> LEFT_PAREN . nonempty_list(raw_var) COLON term RIGHT_PAREN [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 36
-- On nonempty_list(raw_var) shift to state 52
## Reductions:

State 52:
## Known stack suffix:
## LEFT_PAREN nonempty_list(raw_var)
## LR(1) items:
typed_var_block -> LEFT_PAREN nonempty_list(raw_var) . COLON term RIGHT_PAREN [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
-- On COLON shift to state 53
## Reductions:

State 53:
## Known stack suffix:
## LEFT_PAREN nonempty_list(raw_var) COLON
## LR(1) items:
typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON . term RIGHT_PAREN [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 125
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 54:
## Known stack suffix:
## LOGIC_EXISTS
## LR(1) items:
term -> LOGIC_EXISTS . typed_var_list DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 50
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 51
-- On typed_var_list shift to state 55
-- On typed_var_block shift to state 113
-- On raw_var shift to state 115
## Reductions:

State 55:
## Known stack suffix:
## LOGIC_EXISTS typed_var_list
## LR(1) items:
term -> LOGIC_EXISTS typed_var_list . DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On DOT shift to state 56
## Reductions:

State 56:
## Known stack suffix:
## LOGIC_EXISTS typed_var_list DOT
## LR(1) items:
term -> LOGIC_EXISTS typed_var_list DOT . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 124
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 57:
## Known stack suffix:
## LET
## LR(1) items:
term -> LET . raw_var EQDEF term IN term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 58
## Reductions:

State 58:
## Known stack suffix:
## LET raw_var
## LR(1) items:
term -> LET raw_var . EQDEF term IN term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On EQDEF shift to state 59
## Reductions:

State 59:
## Known stack suffix:
## LET raw_var EQDEF
## LR(1) items:
term -> LET raw_var EQDEF . term IN term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 121
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 60:
## Known stack suffix:
## INTEGER
## LR(1) items:
atomic_term -> INTEGER . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_term -> INTEGER

State 61:
## Known stack suffix:
## INT
## LR(1) items:
const -> INT . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production const -> INT

State 62:
## Known stack suffix:
## IF
## LR(1) items:
term -> IF . term THEN term ELSE term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 116
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 63:
## Known stack suffix:
## FUN
## LR(1) items:
term -> FUN . typed_var_list DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 50
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 51
-- On typed_var_list shift to state 64
-- On typed_var_block shift to state 113
-- On raw_var shift to state 115
## Reductions:

State 64:
## Known stack suffix:
## FUN typed_var_list
## LR(1) items:
term -> FUN typed_var_list . DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On DOT shift to state 65
## Reductions:

State 65:
## Known stack suffix:
## FUN typed_var_list DOT
## LR(1) items:
term -> FUN typed_var_list DOT . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 75
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 66:
## Known stack suffix:
## ARITH_MINUS
## LR(1) items:
apply_term -> ARITH_MINUS . apply_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 74
## Reductions:

State 67:
## Known stack suffix:
## var
## LR(1) items:
atomic_term -> var . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_term -> var

State 68:
## Known stack suffix:
## raw_var
## LR(1) items:
var -> raw_var . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production var -> raw_var

State 69:
## Known stack suffix:
## const
## LR(1) items:
atomic_term -> const . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_term -> const

State 70:
## Known stack suffix:
## atomic_term
## LR(1) items:
apply_term -> atomic_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
apply_term -> atomic_term . nonempty_list(atomic_term) [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On var shift to state 67
-- On raw_var shift to state 68
-- On nonempty_list(atomic_term) shift to state 71
-- On const shift to state 69
-- On atomic_term shift to state 72
## Reductions:
-- On WITH reduce production apply_term -> atomic_term
-- On WHERE reduce production apply_term -> atomic_term
-- On VERTICAL_BAR reduce production apply_term -> atomic_term
-- On THEN reduce production apply_term -> atomic_term
-- On SEMI_COLON reduce production apply_term -> atomic_term
-- On RIGHT_PAREN reduce production apply_term -> atomic_term
-- On LOGIC_OR reduce production apply_term -> atomic_term
-- On LOGIC_NEQ reduce production apply_term -> atomic_term
-- On LOGIC_IMPLY reduce production apply_term -> atomic_term
-- On LOGIC_EQUIV reduce production apply_term -> atomic_term
-- On LOGIC_EQ reduce production apply_term -> atomic_term
-- On LOGIC_AND reduce production apply_term -> atomic_term
-- On IN reduce production apply_term -> atomic_term
-- On EQDEF reduce production apply_term -> atomic_term
-- On EOI reduce production apply_term -> atomic_term
-- On END reduce production apply_term -> atomic_term
-- On ELSE reduce production apply_term -> atomic_term
-- On DOT reduce production apply_term -> atomic_term
-- On ARROW reduce production apply_term -> atomic_term
-- On ARITH_PRODUCT reduce production apply_term -> atomic_term
-- On ARITH_PLUS reduce production apply_term -> atomic_term
-- On ARITH_MINUS reduce production apply_term -> atomic_term
-- On ARITH_LT reduce production apply_term -> atomic_term
-- On ARITH_LEQ reduce production apply_term -> atomic_term
-- On ARITH_GT reduce production apply_term -> atomic_term
-- On ARITH_GEQ reduce production apply_term -> atomic_term
-- On AND reduce production apply_term -> atomic_term

State 71:
## Known stack suffix:
## atomic_term nonempty_list(atomic_term)
## LR(1) items:
apply_term -> atomic_term nonempty_list(atomic_term) . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production apply_term -> atomic_term nonempty_list(atomic_term)

State 72:
## Known stack suffix:
## atomic_term
## LR(1) items:
nonempty_list(atomic_term) -> atomic_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
nonempty_list(atomic_term) -> atomic_term . nonempty_list(atomic_term) [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On var shift to state 67
-- On raw_var shift to state 68
-- On nonempty_list(atomic_term) shift to state 73
-- On const shift to state 69
-- On atomic_term shift to state 72
## Reductions:
-- On WITH reduce production nonempty_list(atomic_term) -> atomic_term
-- On WHERE reduce production nonempty_list(atomic_term) -> atomic_term
-- On VERTICAL_BAR reduce production nonempty_list(atomic_term) -> atomic_term
-- On THEN reduce production nonempty_list(atomic_term) -> atomic_term
-- On SEMI_COLON reduce production nonempty_list(atomic_term) -> atomic_term
-- On RIGHT_PAREN reduce production nonempty_list(atomic_term) -> atomic_term
-- On LOGIC_OR reduce production nonempty_list(atomic_term) -> atomic_term
-- On LOGIC_NEQ reduce production nonempty_list(atomic_term) -> atomic_term
-- On LOGIC_IMPLY reduce production nonempty_list(atomic_term) -> atomic_term
-- On LOGIC_EQUIV reduce production nonempty_list(atomic_term) -> atomic_term
-- On LOGIC_EQ reduce production nonempty_list(atomic_term) -> atomic_term
-- On LOGIC_AND reduce production nonempty_list(atomic_term) -> atomic_term
-- On IN reduce production nonempty_list(atomic_term) -> atomic_term
-- On EQDEF reduce production nonempty_list(atomic_term) -> atomic_term
-- On EOI reduce production nonempty_list(atomic_term) -> atomic_term
-- On END reduce production nonempty_list(atomic_term) -> atomic_term
-- On ELSE reduce production nonempty_list(atomic_term) -> atomic_term
-- On DOT reduce production nonempty_list(atomic_term) -> atomic_term
-- On ARROW reduce production nonempty_list(atomic_term) -> atomic_term
-- On ARITH_PRODUCT reduce production nonempty_list(atomic_term) -> atomic_term
-- On ARITH_PLUS reduce production nonempty_list(atomic_term) -> atomic_term
-- On ARITH_MINUS reduce production nonempty_list(atomic_term) -> atomic_term
-- On ARITH_LT reduce production nonempty_list(atomic_term) -> atomic_term
-- On ARITH_LEQ reduce production nonempty_list(atomic_term) -> atomic_term
-- On ARITH_GT reduce production nonempty_list(atomic_term) -> atomic_term
-- On ARITH_GEQ reduce production nonempty_list(atomic_term) -> atomic_term
-- On AND reduce production nonempty_list(atomic_term) -> atomic_term

State 73:
## Known stack suffix:
## atomic_term nonempty_list(atomic_term)
## LR(1) items:
nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)

State 74:
## Known stack suffix:
## ARITH_MINUS apply_term
## LR(1) items:
apply_term -> ARITH_MINUS apply_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production apply_term -> ARITH_MINUS apply_term

State 75:
## Known stack suffix:
## FUN typed_var_list DOT term
## LR(1) items:
term -> FUN typed_var_list DOT term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> FUN typed_var_list DOT term

State 76:
## Known stack suffix:
## plus_term
## LR(1) items:
arith_op_term -> plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
arith_op_term -> plus_term . ARITH_LT plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
arith_op_term -> plus_term . ARITH_LEQ plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
arith_op_term -> plus_term . ARITH_GT plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
arith_op_term -> plus_term . ARITH_GEQ plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On ARITH_LT shift to state 77
-- On ARITH_LEQ shift to state 87
-- On ARITH_GT shift to state 89
-- On ARITH_GEQ shift to state 91
## Reductions:
-- On WITH reduce production arith_op_term -> plus_term
-- On WHERE reduce production arith_op_term -> plus_term
-- On VERTICAL_BAR reduce production arith_op_term -> plus_term
-- On THEN reduce production arith_op_term -> plus_term
-- On SEMI_COLON reduce production arith_op_term -> plus_term
-- On RIGHT_PAREN reduce production arith_op_term -> plus_term
-- On LOGIC_OR reduce production arith_op_term -> plus_term
-- On LOGIC_NEQ reduce production arith_op_term -> plus_term
-- On LOGIC_IMPLY reduce production arith_op_term -> plus_term
-- On LOGIC_EQUIV reduce production arith_op_term -> plus_term
-- On LOGIC_EQ reduce production arith_op_term -> plus_term
-- On LOGIC_AND reduce production arith_op_term -> plus_term
-- On IN reduce production arith_op_term -> plus_term
-- On EQDEF reduce production arith_op_term -> plus_term
-- On EOI reduce production arith_op_term -> plus_term
-- On END reduce production arith_op_term -> plus_term
-- On ELSE reduce production arith_op_term -> plus_term
-- On DOT reduce production arith_op_term -> plus_term
-- On AND reduce production arith_op_term -> plus_term

State 77:
## Known stack suffix:
## plus_term ARITH_LT
## LR(1) items:
arith_op_term -> plus_term ARITH_LT . plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 78
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82
## Reductions:

State 78:
## Known stack suffix:
## plus_term ARITH_LT plus_term
## LR(1) items:
arith_op_term -> plus_term ARITH_LT plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_op_term -> plus_term ARITH_LT plus_term

State 79:
## Known stack suffix:
## mult_term
## LR(1) items:
plus_term -> mult_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
plus_term -> mult_term . ARITH_PLUS plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
plus_term -> mult_term . ARITH_MINUS plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On ARITH_PLUS shift to state 80
-- On ARITH_MINUS shift to state 85
## Reductions:
-- On WITH reduce production plus_term -> mult_term
-- On WHERE reduce production plus_term -> mult_term
-- On VERTICAL_BAR reduce production plus_term -> mult_term
-- On THEN reduce production plus_term -> mult_term
-- On SEMI_COLON reduce production plus_term -> mult_term
-- On RIGHT_PAREN reduce production plus_term -> mult_term
-- On LOGIC_OR reduce production plus_term -> mult_term
-- On LOGIC_NEQ reduce production plus_term -> mult_term
-- On LOGIC_IMPLY reduce production plus_term -> mult_term
-- On LOGIC_EQUIV reduce production plus_term -> mult_term
-- On LOGIC_EQ reduce production plus_term -> mult_term
-- On LOGIC_AND reduce production plus_term -> mult_term
-- On IN reduce production plus_term -> mult_term
-- On EQDEF reduce production plus_term -> mult_term
-- On EOI reduce production plus_term -> mult_term
-- On END reduce production plus_term -> mult_term
-- On ELSE reduce production plus_term -> mult_term
-- On DOT reduce production plus_term -> mult_term
-- On ARITH_LT reduce production plus_term -> mult_term
-- On ARITH_LEQ reduce production plus_term -> mult_term
-- On ARITH_GT reduce production plus_term -> mult_term
-- On ARITH_GEQ reduce production plus_term -> mult_term
-- On AND reduce production plus_term -> mult_term

State 80:
## Known stack suffix:
## mult_term ARITH_PLUS
## LR(1) items:
plus_term -> mult_term ARITH_PLUS . plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 81
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82
## Reductions:

State 81:
## Known stack suffix:
## mult_term ARITH_PLUS plus_term
## LR(1) items:
plus_term -> mult_term ARITH_PLUS plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production plus_term -> mult_term ARITH_PLUS plus_term

State 82:
## Known stack suffix:
## apply_term
## LR(1) items:
mult_term -> apply_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
mult_term -> apply_term . ARITH_PRODUCT mult_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On ARITH_PRODUCT shift to state 83
## Reductions:
-- On WITH reduce production mult_term -> apply_term
-- On WHERE reduce production mult_term -> apply_term
-- On VERTICAL_BAR reduce production mult_term -> apply_term
-- On THEN reduce production mult_term -> apply_term
-- On SEMI_COLON reduce production mult_term -> apply_term
-- On RIGHT_PAREN reduce production mult_term -> apply_term
-- On LOGIC_OR reduce production mult_term -> apply_term
-- On LOGIC_NEQ reduce production mult_term -> apply_term
-- On LOGIC_IMPLY reduce production mult_term -> apply_term
-- On LOGIC_EQUIV reduce production mult_term -> apply_term
-- On LOGIC_EQ reduce production mult_term -> apply_term
-- On LOGIC_AND reduce production mult_term -> apply_term
-- On IN reduce production mult_term -> apply_term
-- On EQDEF reduce production mult_term -> apply_term
-- On EOI reduce production mult_term -> apply_term
-- On END reduce production mult_term -> apply_term
-- On ELSE reduce production mult_term -> apply_term
-- On DOT reduce production mult_term -> apply_term
-- On ARITH_PLUS reduce production mult_term -> apply_term
-- On ARITH_MINUS reduce production mult_term -> apply_term
-- On ARITH_LT reduce production mult_term -> apply_term
-- On ARITH_LEQ reduce production mult_term -> apply_term
-- On ARITH_GT reduce production mult_term -> apply_term
-- On ARITH_GEQ reduce production mult_term -> apply_term
-- On AND reduce production mult_term -> apply_term

State 83:
## Known stack suffix:
## apply_term ARITH_PRODUCT
## LR(1) items:
mult_term -> apply_term ARITH_PRODUCT . mult_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On mult_term shift to state 84
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82
## Reductions:

State 84:
## Known stack suffix:
## apply_term ARITH_PRODUCT mult_term
## LR(1) items:
mult_term -> apply_term ARITH_PRODUCT mult_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mult_term -> apply_term ARITH_PRODUCT mult_term

State 85:
## Known stack suffix:
## mult_term ARITH_MINUS
## LR(1) items:
plus_term -> mult_term ARITH_MINUS . plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 86
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82
## Reductions:

State 86:
## Known stack suffix:
## mult_term ARITH_MINUS plus_term
## LR(1) items:
plus_term -> mult_term ARITH_MINUS plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production plus_term -> mult_term ARITH_MINUS plus_term

State 87:
## Known stack suffix:
## plus_term ARITH_LEQ
## LR(1) items:
arith_op_term -> plus_term ARITH_LEQ . plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 88
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82
## Reductions:

State 88:
## Known stack suffix:
## plus_term ARITH_LEQ plus_term
## LR(1) items:
arith_op_term -> plus_term ARITH_LEQ plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_op_term -> plus_term ARITH_LEQ plus_term

State 89:
## Known stack suffix:
## plus_term ARITH_GT
## LR(1) items:
arith_op_term -> plus_term ARITH_GT . plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 90
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82
## Reductions:

State 90:
## Known stack suffix:
## plus_term ARITH_GT plus_term
## LR(1) items:
arith_op_term -> plus_term ARITH_GT plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_op_term -> plus_term ARITH_GT plus_term

State 91:
## Known stack suffix:
## plus_term ARITH_GEQ
## LR(1) items:
arith_op_term -> plus_term ARITH_GEQ . plus_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 92
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On apply_term shift to state 82
## Reductions:

State 92:
## Known stack suffix:
## plus_term ARITH_GEQ plus_term
## LR(1) items:
arith_op_term -> plus_term ARITH_GEQ plus_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arith_op_term -> plus_term ARITH_GEQ plus_term

State 93:
## Known stack suffix:
## or_term
## LR(1) items:
term -> or_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> or_term

State 94:
## Known stack suffix:
## not_term
## LR(1) items:
eq_term -> not_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
eq_term -> not_term . LOGIC_EQ not_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
eq_term -> not_term . LOGIC_NEQ not_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On LOGIC_NEQ shift to state 95
-- On LOGIC_EQ shift to state 98
## Reductions:
-- On WITH reduce production eq_term -> not_term
-- On WHERE reduce production eq_term -> not_term
-- On VERTICAL_BAR reduce production eq_term -> not_term
-- On THEN reduce production eq_term -> not_term
-- On SEMI_COLON reduce production eq_term -> not_term
-- On RIGHT_PAREN reduce production eq_term -> not_term
-- On LOGIC_OR reduce production eq_term -> not_term
-- On LOGIC_IMPLY reduce production eq_term -> not_term
-- On LOGIC_EQUIV reduce production eq_term -> not_term
-- On LOGIC_AND reduce production eq_term -> not_term
-- On IN reduce production eq_term -> not_term
-- On EQDEF reduce production eq_term -> not_term
-- On EOI reduce production eq_term -> not_term
-- On END reduce production eq_term -> not_term
-- On ELSE reduce production eq_term -> not_term
-- On DOT reduce production eq_term -> not_term
-- On AND reduce production eq_term -> not_term

State 95:
## Known stack suffix:
## not_term LOGIC_NEQ
## LR(1) items:
eq_term -> not_term LOGIC_NEQ . not_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On not_term shift to state 96
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 82
## Reductions:

State 96:
## Known stack suffix:
## not_term LOGIC_NEQ not_term
## LR(1) items:
eq_term -> not_term LOGIC_NEQ not_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production eq_term -> not_term LOGIC_NEQ not_term

State 97:
## Known stack suffix:
## arith_op_term
## LR(1) items:
not_term -> arith_op_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production not_term -> arith_op_term

State 98:
## Known stack suffix:
## not_term LOGIC_EQ
## LR(1) items:
eq_term -> not_term LOGIC_EQ . not_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On not_term shift to state 99
-- On mult_term shift to state 79
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 82
## Reductions:

State 99:
## Known stack suffix:
## not_term LOGIC_EQ not_term
## LR(1) items:
eq_term -> not_term LOGIC_EQ not_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production eq_term -> not_term LOGIC_EQ not_term

State 100:
## Known stack suffix:
## eq_term
## LR(1) items:
and_term -> eq_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV IN EQDEF EOI END ELSE DOT AND ]
and_term -> eq_term . LOGIC_AND and_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On LOGIC_AND shift to state 101
## Reductions:
-- On WITH reduce production and_term -> eq_term
-- On WHERE reduce production and_term -> eq_term
-- On VERTICAL_BAR reduce production and_term -> eq_term
-- On THEN reduce production and_term -> eq_term
-- On SEMI_COLON reduce production and_term -> eq_term
-- On RIGHT_PAREN reduce production and_term -> eq_term
-- On LOGIC_OR reduce production and_term -> eq_term
-- On LOGIC_IMPLY reduce production and_term -> eq_term
-- On LOGIC_EQUIV reduce production and_term -> eq_term
-- On IN reduce production and_term -> eq_term
-- On EQDEF reduce production and_term -> eq_term
-- On EOI reduce production and_term -> eq_term
-- On END reduce production and_term -> eq_term
-- On ELSE reduce production and_term -> eq_term
-- On DOT reduce production and_term -> eq_term
-- On AND reduce production and_term -> eq_term

State 101:
## Known stack suffix:
## eq_term LOGIC_AND
## LR(1) items:
and_term -> eq_term LOGIC_AND . and_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 82
-- On and_term shift to state 102
## Reductions:

State 102:
## Known stack suffix:
## eq_term LOGIC_AND and_term
## LR(1) items:
and_term -> eq_term LOGIC_AND and_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production and_term -> eq_term LOGIC_AND and_term

State 103:
## Known stack suffix:
## apply_term
## LR(1) items:
mult_term -> apply_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
mult_term -> apply_term . ARITH_PRODUCT mult_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
term -> apply_term . ARROW term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On ARROW shift to state 104
-- On ARITH_PRODUCT shift to state 83
## Reductions:
-- On WITH reduce production mult_term -> apply_term
-- On WHERE reduce production mult_term -> apply_term
-- On VERTICAL_BAR reduce production mult_term -> apply_term
-- On THEN reduce production mult_term -> apply_term
-- On SEMI_COLON reduce production mult_term -> apply_term
-- On RIGHT_PAREN reduce production mult_term -> apply_term
-- On LOGIC_OR reduce production mult_term -> apply_term
-- On LOGIC_NEQ reduce production mult_term -> apply_term
-- On LOGIC_IMPLY reduce production mult_term -> apply_term
-- On LOGIC_EQUIV reduce production mult_term -> apply_term
-- On LOGIC_EQ reduce production mult_term -> apply_term
-- On LOGIC_AND reduce production mult_term -> apply_term
-- On IN reduce production mult_term -> apply_term
-- On EQDEF reduce production mult_term -> apply_term
-- On EOI reduce production mult_term -> apply_term
-- On END reduce production mult_term -> apply_term
-- On ELSE reduce production mult_term -> apply_term
-- On DOT reduce production mult_term -> apply_term
-- On ARITH_PLUS reduce production mult_term -> apply_term
-- On ARITH_MINUS reduce production mult_term -> apply_term
-- On ARITH_LT reduce production mult_term -> apply_term
-- On ARITH_LEQ reduce production mult_term -> apply_term
-- On ARITH_GT reduce production mult_term -> apply_term
-- On ARITH_GEQ reduce production mult_term -> apply_term
-- On AND reduce production mult_term -> apply_term

State 104:
## Known stack suffix:
## apply_term ARROW
## LR(1) items:
term -> apply_term ARROW . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 105
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 105:
## Known stack suffix:
## apply_term ARROW term
## LR(1) items:
term -> apply_term ARROW term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> apply_term ARROW term

State 106:
## Known stack suffix:
## and_term
## LR(1) items:
or_term -> and_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
or_term -> and_term . LOGIC_OR or_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
or_term -> and_term . LOGIC_IMPLY or_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
or_term -> and_term . LOGIC_EQUIV or_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On LOGIC_OR shift to state 107
-- On LOGIC_IMPLY shift to state 109
-- On LOGIC_EQUIV shift to state 111
## Reductions:
-- On WITH reduce production or_term -> and_term
-- On WHERE reduce production or_term -> and_term
-- On VERTICAL_BAR reduce production or_term -> and_term
-- On THEN reduce production or_term -> and_term
-- On SEMI_COLON reduce production or_term -> and_term
-- On RIGHT_PAREN reduce production or_term -> and_term
-- On IN reduce production or_term -> and_term
-- On EQDEF reduce production or_term -> and_term
-- On EOI reduce production or_term -> and_term
-- On END reduce production or_term -> and_term
-- On ELSE reduce production or_term -> and_term
-- On DOT reduce production or_term -> and_term
-- On AND reduce production or_term -> and_term

State 107:
## Known stack suffix:
## and_term LOGIC_OR
## LR(1) items:
or_term -> and_term LOGIC_OR . or_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 108
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 82
-- On and_term shift to state 106
## Reductions:

State 108:
## Known stack suffix:
## and_term LOGIC_OR or_term
## LR(1) items:
or_term -> and_term LOGIC_OR or_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production or_term -> and_term LOGIC_OR or_term

State 109:
## Known stack suffix:
## and_term LOGIC_IMPLY
## LR(1) items:
or_term -> and_term LOGIC_IMPLY . or_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 110
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 82
-- On and_term shift to state 106
## Reductions:

State 110:
## Known stack suffix:
## and_term LOGIC_IMPLY or_term
## LR(1) items:
or_term -> and_term LOGIC_IMPLY or_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production or_term -> and_term LOGIC_IMPLY or_term

State 111:
## Known stack suffix:
## and_term LOGIC_EQUIV
## LR(1) items:
or_term -> and_term LOGIC_EQUIV . or_term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 112
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 82
-- On and_term shift to state 106
## Reductions:

State 112:
## Known stack suffix:
## and_term LOGIC_EQUIV or_term
## LR(1) items:
or_term -> and_term LOGIC_EQUIV or_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production or_term -> and_term LOGIC_EQUIV or_term

State 113:
## Known stack suffix:
## typed_var_block
## LR(1) items:
typed_var_list -> typed_var_block . [ DOT ]
typed_var_list -> typed_var_block . typed_var_list [ DOT ]
## Transitions:
-- On WILDCARD shift to state 50
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 51
-- On typed_var_list shift to state 114
-- On typed_var_block shift to state 113
-- On raw_var shift to state 115
## Reductions:
-- On DOT reduce production typed_var_list -> typed_var_block

State 114:
## Known stack suffix:
## typed_var_block typed_var_list
## LR(1) items:
typed_var_list -> typed_var_block typed_var_list . [ DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typed_var_list -> typed_var_block typed_var_list

State 115:
## Known stack suffix:
## raw_var
## LR(1) items:
typed_var_block -> raw_var . [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typed_var_block -> raw_var

State 116:
## Known stack suffix:
## IF term
## LR(1) items:
term -> IF term . THEN term ELSE term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On THEN shift to state 117
## Reductions:

State 117:
## Known stack suffix:
## IF term THEN
## LR(1) items:
term -> IF term THEN . term ELSE term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 118
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 118:
## Known stack suffix:
## IF term THEN term
## LR(1) items:
term -> IF term THEN term . ELSE term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On ELSE shift to state 119
## Reductions:

State 119:
## Known stack suffix:
## IF term THEN term ELSE
## LR(1) items:
term -> IF term THEN term ELSE . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 120
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 120:
## Known stack suffix:
## IF term THEN term ELSE term
## LR(1) items:
term -> IF term THEN term ELSE term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> IF term THEN term ELSE term

State 121:
## Known stack suffix:
## LET raw_var EQDEF term
## LR(1) items:
term -> LET raw_var EQDEF term . IN term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On IN shift to state 122
## Reductions:

State 122:
## Known stack suffix:
## LET raw_var EQDEF term IN
## LR(1) items:
term -> LET raw_var EQDEF term IN . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 123
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 123:
## Known stack suffix:
## LET raw_var EQDEF term IN term
## LR(1) items:
term -> LET raw_var EQDEF term IN term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> LET raw_var EQDEF term IN term

State 124:
## Known stack suffix:
## LOGIC_EXISTS typed_var_list DOT term
## LR(1) items:
term -> LOGIC_EXISTS typed_var_list DOT term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> LOGIC_EXISTS typed_var_list DOT term

State 125:
## Known stack suffix:
## LEFT_PAREN nonempty_list(raw_var) COLON term
## LR(1) items:
typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term . RIGHT_PAREN [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
-- On RIGHT_PAREN shift to state 126
## Reductions:

State 126:
## Known stack suffix:
## LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN
## LR(1) items:
typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN . [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN

State 127:
## Known stack suffix:
## LOGIC_FORALL typed_var_list
## LR(1) items:
term -> LOGIC_FORALL typed_var_list . DOT term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On DOT shift to state 128
## Reductions:

State 128:
## Known stack suffix:
## LOGIC_FORALL typed_var_list DOT
## LR(1) items:
term -> LOGIC_FORALL typed_var_list DOT . term [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 129
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 129:
## Known stack suffix:
## LOGIC_FORALL typed_var_list DOT term
## LR(1) items:
term -> LOGIC_FORALL typed_var_list DOT term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> LOGIC_FORALL typed_var_list DOT term

State 130:
## Known stack suffix:
## LEFT_PAREN term
## LR(1) items:
atomic_term -> LEFT_PAREN term . RIGHT_PAREN [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 131
## Reductions:

State 131:
## Known stack suffix:
## LEFT_PAREN term RIGHT_PAREN
## LR(1) items:
atomic_term -> LEFT_PAREN term RIGHT_PAREN . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN

State 132:
## Known stack suffix:
## LOGIC_NOT arith_op_term
## LR(1) items:
not_term -> LOGIC_NOT arith_op_term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production not_term -> LOGIC_NOT arith_op_term

State 133:
## Known stack suffix:
## MATCH term
## LR(1) items:
atomic_term -> MATCH term . WITH nonempty_list(match_branch) END [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On WITH shift to state 134
## Reductions:

State 134:
## Known stack suffix:
## MATCH term WITH
## LR(1) items:
atomic_term -> MATCH term WITH . nonempty_list(match_branch) END [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On VERTICAL_BAR shift to state 135
-- On nonempty_list(match_branch) shift to state 144
-- On match_branch shift to state 146
## Reductions:

State 135:
## Known stack suffix:
## VERTICAL_BAR
## LR(1) items:
match_branch -> VERTICAL_BAR . raw_var list(var_or_wildcard) ARROW term [ VERTICAL_BAR END ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 136
## Reductions:

State 136:
## Known stack suffix:
## VERTICAL_BAR raw_var
## LR(1) items:
match_branch -> VERTICAL_BAR raw_var . list(var_or_wildcard) ARROW term [ VERTICAL_BAR END ]
## Transitions:
-- On WILDCARD shift to state 137
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On var_or_wildcard shift to state 138
-- On raw_var shift to state 139
-- On list(var_or_wildcard) shift to state 141
## Reductions:
-- On ARROW reduce production list(var_or_wildcard) ->

State 137:
## Known stack suffix:
## WILDCARD
## LR(1) items:
var_or_wildcard -> WILDCARD . [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD ARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production var_or_wildcard -> WILDCARD

State 138:
## Known stack suffix:
## var_or_wildcard
## LR(1) items:
list(var_or_wildcard) -> var_or_wildcard . list(var_or_wildcard) [ ARROW ]
## Transitions:
-- On WILDCARD shift to state 137
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On var_or_wildcard shift to state 138
-- On raw_var shift to state 139
-- On list(var_or_wildcard) shift to state 140
## Reductions:
-- On ARROW reduce production list(var_or_wildcard) ->

State 139:
## Known stack suffix:
## raw_var
## LR(1) items:
var_or_wildcard -> raw_var . [ WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD ARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production var_or_wildcard -> raw_var

State 140:
## Known stack suffix:
## var_or_wildcard list(var_or_wildcard)
## LR(1) items:
list(var_or_wildcard) -> var_or_wildcard list(var_or_wildcard) . [ ARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(var_or_wildcard) -> var_or_wildcard list(var_or_wildcard)

State 141:
## Known stack suffix:
## VERTICAL_BAR raw_var list(var_or_wildcard)
## LR(1) items:
match_branch -> VERTICAL_BAR raw_var list(var_or_wildcard) . ARROW term [ VERTICAL_BAR END ]
## Transitions:
-- On ARROW shift to state 142
## Reductions:

State 142:
## Known stack suffix:
## VERTICAL_BAR raw_var list(var_or_wildcard) ARROW
## LR(1) items:
match_branch -> VERTICAL_BAR raw_var list(var_or_wildcard) ARROW . term [ VERTICAL_BAR END ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 143
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 143:
## Known stack suffix:
## VERTICAL_BAR raw_var list(var_or_wildcard) ARROW term
## LR(1) items:
match_branch -> VERTICAL_BAR raw_var list(var_or_wildcard) ARROW term . [ VERTICAL_BAR END ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production match_branch -> VERTICAL_BAR raw_var list(var_or_wildcard) ARROW term

State 144:
## Known stack suffix:
## MATCH term WITH nonempty_list(match_branch)
## LR(1) items:
atomic_term -> MATCH term WITH nonempty_list(match_branch) . END [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
-- On END shift to state 145
## Reductions:

State 145:
## Known stack suffix:
## MATCH term WITH nonempty_list(match_branch) END
## LR(1) items:
atomic_term -> MATCH term WITH nonempty_list(match_branch) END . [ WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_term -> MATCH term WITH nonempty_list(match_branch) END

State 146:
## Known stack suffix:
## match_branch
## LR(1) items:
nonempty_list(match_branch) -> match_branch . [ END ]
nonempty_list(match_branch) -> match_branch . nonempty_list(match_branch) [ END ]
## Transitions:
-- On VERTICAL_BAR shift to state 135
-- On nonempty_list(match_branch) shift to state 147
-- On match_branch shift to state 146
## Reductions:
-- On END reduce production nonempty_list(match_branch) -> match_branch

State 147:
## Known stack suffix:
## match_branch nonempty_list(match_branch)
## LR(1) items:
nonempty_list(match_branch) -> match_branch nonempty_list(match_branch) . [ END ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(match_branch) -> match_branch nonempty_list(match_branch)

State 148:
## Known stack suffix:
## PI typed_ty_var_list DOT term
## LR(1) items:
term -> PI typed_ty_var_list DOT term . [ WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> PI typed_ty_var_list DOT term

State 149:
## Known stack suffix:
## typed_ty_var_block
## LR(1) items:
typed_ty_var_list -> typed_ty_var_block . [ DOT ]
typed_ty_var_list -> typed_ty_var_block . typed_ty_var_list [ DOT ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 35
-- On typed_ty_var_list shift to state 150
-- On typed_ty_var_block shift to state 149
-- On raw_var shift to state 151
## Reductions:
-- On DOT reduce production typed_ty_var_list -> typed_ty_var_block

State 150:
## Known stack suffix:
## typed_ty_var_block typed_ty_var_list
## LR(1) items:
typed_ty_var_list -> typed_ty_var_block typed_ty_var_list . [ DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typed_ty_var_list -> typed_ty_var_block typed_ty_var_list

State 151:
## Known stack suffix:
## raw_var
## LR(1) items:
typed_ty_var_block -> raw_var . [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
typed_ty_var_block -> raw_var . COLON TYPE [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
-- On COLON shift to state 152
## Reductions:
-- On UPPER_WORD reduce production typed_ty_var_block -> raw_var
-- On SINGLE_QUOTED reduce production typed_ty_var_block -> raw_var
-- On LOWER_WORD reduce production typed_ty_var_block -> raw_var
-- On LEFT_PAREN reduce production typed_ty_var_block -> raw_var
-- On DOT reduce production typed_ty_var_block -> raw_var

State 152:
## Known stack suffix:
## raw_var COLON
## LR(1) items:
typed_ty_var_block -> raw_var COLON . TYPE [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
-- On TYPE shift to state 153
## Reductions:

State 153:
## Known stack suffix:
## raw_var COLON TYPE
## LR(1) items:
typed_ty_var_block -> raw_var COLON TYPE . [ UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typed_ty_var_block -> raw_var COLON TYPE

State 154:
## Known stack suffix:
## VAL attrs raw_var COLON term
## LR(1) items:
statement -> VAL attrs raw_var COLON term . DOT [ EOI ]
## Transitions:
-- On DOT shift to state 155
## Reductions:

State 155:
## Known stack suffix:
## VAL attrs raw_var COLON term DOT
## LR(1) items:
statement -> VAL attrs raw_var COLON term DOT . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> VAL attrs raw_var COLON term DOT

State 156:
## Known stack suffix:
## REWRITE
## LR(1) items:
statement -> REWRITE . attrs term DOT [ EOI ]
## Transitions:
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 160
## Reductions:
-- On error reduce production attrs ->
-- On WILDCARD reduce production attrs ->
-- On UPPER_WORD reduce production attrs ->
-- On TYPE reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On PROP reduce production attrs ->
-- On PI reduce production attrs ->
-- On MATCH reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->
-- On LOGIC_TRUE reduce production attrs ->
-- On LOGIC_NOT reduce production attrs ->
-- On LOGIC_FORALL reduce production attrs ->
-- On LOGIC_FALSE reduce production attrs ->
-- On LOGIC_EXISTS reduce production attrs ->
-- On LET reduce production attrs ->
-- On LEFT_PAREN reduce production attrs ->
-- On INTEGER reduce production attrs ->
-- On INT reduce production attrs ->
-- On IF reduce production attrs ->
-- On FUN reduce production attrs ->
-- On ARITH_MINUS reduce production attrs ->

State 157:
## Known stack suffix:
## LEFT_BRACKET
## LR(1) items:
attrs -> LEFT_BRACKET . separated_nonempty_list(COMMA,attr) RIGHT_BRACKET [ error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS ]
## Transitions:
-- On error shift to state 4
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On QUOTED shift to state 7
-- On LOWER_WORD shift to state 8
-- On LEFT_PAREN shift to state 9
-- On LEFT_BRACKET shift to state 10
-- On separated_nonempty_list(COMMA,attr) shift to state 158
-- On raw_var shift to state 12
-- On attr shift to state 19
-- On atomic_attr shift to state 22
## Reductions:

State 158:
## Known stack suffix:
## LEFT_BRACKET separated_nonempty_list(COMMA,attr)
## LR(1) items:
attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) . RIGHT_BRACKET [ error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS ]
## Transitions:
-- On RIGHT_BRACKET shift to state 159
## Reductions:

State 159:
## Known stack suffix:
## LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET
## LR(1) items:
attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET . [ error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production attrs -> LEFT_BRACKET separated_nonempty_list(COMMA,attr) RIGHT_BRACKET

State 160:
## Known stack suffix:
## REWRITE attrs
## LR(1) items:
statement -> REWRITE attrs . term DOT [ EOI ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 161
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 161:
## Known stack suffix:
## REWRITE attrs term
## LR(1) items:
statement -> REWRITE attrs term . DOT [ EOI ]
## Transitions:
-- On DOT shift to state 162
## Reductions:

State 162:
## Known stack suffix:
## REWRITE attrs term DOT
## LR(1) items:
statement -> REWRITE attrs term DOT . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> REWRITE attrs term DOT

State 163:
## Known stack suffix:
## LEMMA
## LR(1) items:
statement -> LEMMA . attrs term DOT [ EOI ]
## Transitions:
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 164
## Reductions:
-- On error reduce production attrs ->
-- On WILDCARD reduce production attrs ->
-- On UPPER_WORD reduce production attrs ->
-- On TYPE reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On PROP reduce production attrs ->
-- On PI reduce production attrs ->
-- On MATCH reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->
-- On LOGIC_TRUE reduce production attrs ->
-- On LOGIC_NOT reduce production attrs ->
-- On LOGIC_FORALL reduce production attrs ->
-- On LOGIC_FALSE reduce production attrs ->
-- On LOGIC_EXISTS reduce production attrs ->
-- On LET reduce production attrs ->
-- On LEFT_PAREN reduce production attrs ->
-- On INTEGER reduce production attrs ->
-- On INT reduce production attrs ->
-- On IF reduce production attrs ->
-- On FUN reduce production attrs ->
-- On ARITH_MINUS reduce production attrs ->

State 164:
## Known stack suffix:
## LEMMA attrs
## LR(1) items:
statement -> LEMMA attrs . term DOT [ EOI ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 165
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 165:
## Known stack suffix:
## LEMMA attrs term
## LR(1) items:
statement -> LEMMA attrs term . DOT [ EOI ]
## Transitions:
-- On DOT shift to state 166
## Reductions:

State 166:
## Known stack suffix:
## LEMMA attrs term DOT
## LR(1) items:
statement -> LEMMA attrs term DOT . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> LEMMA attrs term DOT

State 167:
## Known stack suffix:
## INCLUDE
## LR(1) items:
statement -> INCLUDE . QUOTED DOT [ EOI ]
## Transitions:
-- On QUOTED shift to state 168
## Reductions:

State 168:
## Known stack suffix:
## INCLUDE QUOTED
## LR(1) items:
statement -> INCLUDE QUOTED . DOT [ EOI ]
## Transitions:
-- On DOT shift to state 169
## Reductions:

State 169:
## Known stack suffix:
## INCLUDE QUOTED DOT
## LR(1) items:
statement -> INCLUDE QUOTED DOT . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> INCLUDE QUOTED DOT

State 170:
## Known stack suffix:
## GOAL
## LR(1) items:
statement -> GOAL . attrs term DOT [ EOI ]
## Transitions:
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 171
## Reductions:
-- On error reduce production attrs ->
-- On WILDCARD reduce production attrs ->
-- On UPPER_WORD reduce production attrs ->
-- On TYPE reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On PROP reduce production attrs ->
-- On PI reduce production attrs ->
-- On MATCH reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->
-- On LOGIC_TRUE reduce production attrs ->
-- On LOGIC_NOT reduce production attrs ->
-- On LOGIC_FORALL reduce production attrs ->
-- On LOGIC_FALSE reduce production attrs ->
-- On LOGIC_EXISTS reduce production attrs ->
-- On LET reduce production attrs ->
-- On LEFT_PAREN reduce production attrs ->
-- On INTEGER reduce production attrs ->
-- On INT reduce production attrs ->
-- On IF reduce production attrs ->
-- On FUN reduce production attrs ->
-- On ARITH_MINUS reduce production attrs ->

State 171:
## Known stack suffix:
## GOAL attrs
## LR(1) items:
statement -> GOAL attrs . term DOT [ EOI ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 172
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 172:
## Known stack suffix:
## GOAL attrs term
## LR(1) items:
statement -> GOAL attrs term . DOT [ EOI ]
## Transitions:
-- On DOT shift to state 173
## Reductions:

State 173:
## Known stack suffix:
## GOAL attrs term DOT
## LR(1) items:
statement -> GOAL attrs term DOT . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> GOAL attrs term DOT

State 174:
## Known stack suffix:
## DEF
## LR(1) items:
statement -> DEF . attrs separated_nonempty_list(AND,def) DOT [ EOI ]
## Transitions:
-- On LEFT_BRACKET shift to state 3
-- On attrs shift to state 175
## Reductions:
-- On UPPER_WORD reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->

State 175:
## Known stack suffix:
## DEF attrs
## LR(1) items:
statement -> DEF attrs . separated_nonempty_list(AND,def) DOT [ EOI ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On separated_nonempty_list(AND,def) shift to state 176
-- On raw_var shift to state 178
-- On def shift to state 200
## Reductions:

State 176:
## Known stack suffix:
## DEF attrs separated_nonempty_list(AND,def)
## LR(1) items:
statement -> DEF attrs separated_nonempty_list(AND,def) . DOT [ EOI ]
## Transitions:
-- On DOT shift to state 177
## Reductions:

State 177:
## Known stack suffix:
## DEF attrs separated_nonempty_list(AND,def) DOT
## LR(1) items:
statement -> DEF attrs separated_nonempty_list(AND,def) DOT . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT

State 178:
## Known stack suffix:
## raw_var
## LR(1) items:
def -> raw_var . COLON term EQDEF term [ DOT AND ]
def -> raw_var . COLON term WHERE separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
def -> raw_var . mandatory_typed_var_list COLON term EQDEF term [ DOT AND ]
## Transitions:
-- On LEFT_PAREN shift to state 179
-- On COLON shift to state 184
-- On mandatory_typed_var_list shift to state 193
-- On mandatory_typed_var_block shift to state 198
## Reductions:

State 179:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
mandatory_typed_var_block -> LEFT_PAREN . nonempty_list(raw_var) COLON term RIGHT_PAREN [ LEFT_PAREN COLON ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 36
-- On nonempty_list(raw_var) shift to state 180
## Reductions:

State 180:
## Known stack suffix:
## LEFT_PAREN nonempty_list(raw_var)
## LR(1) items:
mandatory_typed_var_block -> LEFT_PAREN nonempty_list(raw_var) . COLON term RIGHT_PAREN [ LEFT_PAREN COLON ]
## Transitions:
-- On COLON shift to state 181
## Reductions:

State 181:
## Known stack suffix:
## LEFT_PAREN nonempty_list(raw_var) COLON
## LR(1) items:
mandatory_typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON . term RIGHT_PAREN [ LEFT_PAREN COLON ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 182
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 182:
## Known stack suffix:
## LEFT_PAREN nonempty_list(raw_var) COLON term
## LR(1) items:
mandatory_typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term . RIGHT_PAREN [ LEFT_PAREN COLON ]
## Transitions:
-- On RIGHT_PAREN shift to state 183
## Reductions:

State 183:
## Known stack suffix:
## LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN
## LR(1) items:
mandatory_typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN . [ LEFT_PAREN COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mandatory_typed_var_block -> LEFT_PAREN nonempty_list(raw_var) COLON term RIGHT_PAREN

State 184:
## Known stack suffix:
## raw_var COLON
## LR(1) items:
def -> raw_var COLON . term EQDEF term [ DOT AND ]
def -> raw_var COLON . term WHERE separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 185
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 185:
## Known stack suffix:
## raw_var COLON term
## LR(1) items:
def -> raw_var COLON term . EQDEF term [ DOT AND ]
def -> raw_var COLON term . WHERE separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
## Transitions:
-- On WHERE shift to state 186
-- On EQDEF shift to state 191
## Reductions:

State 186:
## Known stack suffix:
## raw_var COLON term WHERE
## LR(1) items:
def -> raw_var COLON term WHERE . separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 187
-- On separated_nonempty_list(SEMI_COLON,term) shift to state 190
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 187:
## Known stack suffix:
## term
## LR(1) items:
separated_nonempty_list(SEMI_COLON,term) -> term . [ DOT AND ]
separated_nonempty_list(SEMI_COLON,term) -> term . SEMI_COLON separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
## Transitions:
-- On SEMI_COLON shift to state 188
## Reductions:
-- On DOT reduce production separated_nonempty_list(SEMI_COLON,term) -> term
-- On AND reduce production separated_nonempty_list(SEMI_COLON,term) -> term

State 188:
## Known stack suffix:
## term SEMI_COLON
## LR(1) items:
separated_nonempty_list(SEMI_COLON,term) -> term SEMI_COLON . separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 187
-- On separated_nonempty_list(SEMI_COLON,term) shift to state 189
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 189:
## Known stack suffix:
## term SEMI_COLON separated_nonempty_list(SEMI_COLON,term)
## LR(1) items:
separated_nonempty_list(SEMI_COLON,term) -> term SEMI_COLON separated_nonempty_list(SEMI_COLON,term) . [ DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(SEMI_COLON,term) -> term SEMI_COLON separated_nonempty_list(SEMI_COLON,term)

State 190:
## Known stack suffix:
## raw_var COLON term WHERE separated_nonempty_list(SEMI_COLON,term)
## LR(1) items:
def -> raw_var COLON term WHERE separated_nonempty_list(SEMI_COLON,term) . [ DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production def -> raw_var COLON term WHERE separated_nonempty_list(SEMI_COLON,term)

State 191:
## Known stack suffix:
## raw_var COLON term EQDEF
## LR(1) items:
def -> raw_var COLON term EQDEF . term [ DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 192
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 192:
## Known stack suffix:
## raw_var COLON term EQDEF term
## LR(1) items:
def -> raw_var COLON term EQDEF term . [ DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production def -> raw_var COLON term EQDEF term

State 193:
## Known stack suffix:
## raw_var mandatory_typed_var_list
## LR(1) items:
def -> raw_var mandatory_typed_var_list . COLON term EQDEF term [ DOT AND ]
## Transitions:
-- On COLON shift to state 194
## Reductions:

State 194:
## Known stack suffix:
## raw_var mandatory_typed_var_list COLON
## LR(1) items:
def -> raw_var mandatory_typed_var_list COLON . term EQDEF term [ DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 195
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 195:
## Known stack suffix:
## raw_var mandatory_typed_var_list COLON term
## LR(1) items:
def -> raw_var mandatory_typed_var_list COLON term . EQDEF term [ DOT AND ]
## Transitions:
-- On EQDEF shift to state 196
## Reductions:

State 196:
## Known stack suffix:
## raw_var mandatory_typed_var_list COLON term EQDEF
## LR(1) items:
def -> raw_var mandatory_typed_var_list COLON term EQDEF . term [ DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 197
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 197:
## Known stack suffix:
## raw_var mandatory_typed_var_list COLON term EQDEF term
## LR(1) items:
def -> raw_var mandatory_typed_var_list COLON term EQDEF term . [ DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production def -> raw_var mandatory_typed_var_list COLON term EQDEF term

State 198:
## Known stack suffix:
## mandatory_typed_var_block
## LR(1) items:
mandatory_typed_var_list -> mandatory_typed_var_block . [ COLON ]
mandatory_typed_var_list -> mandatory_typed_var_block . mandatory_typed_var_list [ COLON ]
## Transitions:
-- On LEFT_PAREN shift to state 179
-- On mandatory_typed_var_list shift to state 199
-- On mandatory_typed_var_block shift to state 198
## Reductions:
-- On COLON reduce production mandatory_typed_var_list -> mandatory_typed_var_block

State 199:
## Known stack suffix:
## mandatory_typed_var_block mandatory_typed_var_list
## LR(1) items:
mandatory_typed_var_list -> mandatory_typed_var_block mandatory_typed_var_list . [ COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mandatory_typed_var_list -> mandatory_typed_var_block mandatory_typed_var_list

State 200:
## Known stack suffix:
## def
## LR(1) items:
separated_nonempty_list(AND,def) -> def . [ DOT ]
separated_nonempty_list(AND,def) -> def . AND separated_nonempty_list(AND,def) [ DOT ]
## Transitions:
-- On AND shift to state 201
## Reductions:
-- On DOT reduce production separated_nonempty_list(AND,def) -> def

State 201:
## Known stack suffix:
## def AND
## LR(1) items:
separated_nonempty_list(AND,def) -> def AND . separated_nonempty_list(AND,def) [ DOT ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On separated_nonempty_list(AND,def) shift to state 202
-- On raw_var shift to state 178
-- On def shift to state 200
## Reductions:

State 202:
## Known stack suffix:
## def AND separated_nonempty_list(AND,def)
## LR(1) items:
separated_nonempty_list(AND,def) -> def AND separated_nonempty_list(AND,def) . [ DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(AND,def) -> def AND separated_nonempty_list(AND,def)

State 203:
## Known stack suffix:
## DATA
## LR(1) items:
statement -> DATA . attrs mutual_types DOT [ EOI ]
## Transitions:
-- On LEFT_BRACKET shift to state 3
-- On attrs shift to state 204
## Reductions:
-- On UPPER_WORD reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->

State 204:
## Known stack suffix:
## DATA attrs
## LR(1) items:
statement -> DATA attrs . mutual_types DOT [ EOI ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On type_def shift to state 205
-- On separated_nonempty_list(AND,type_def) shift to state 230
-- On raw_var shift to state 208
-- On mutual_types shift to state 231
## Reductions:

State 205:
## Known stack suffix:
## type_def
## LR(1) items:
separated_nonempty_list(AND,type_def) -> type_def . [ DOT ]
separated_nonempty_list(AND,type_def) -> type_def . AND separated_nonempty_list(AND,type_def) [ DOT ]
## Transitions:
-- On AND shift to state 206
## Reductions:
-- On DOT reduce production separated_nonempty_list(AND,type_def) -> type_def

State 206:
## Known stack suffix:
## type_def AND
## LR(1) items:
separated_nonempty_list(AND,type_def) -> type_def AND . separated_nonempty_list(AND,type_def) [ DOT ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On type_def shift to state 205
-- On separated_nonempty_list(AND,type_def) shift to state 207
-- On raw_var shift to state 208
## Reductions:

State 207:
## Known stack suffix:
## type_def AND separated_nonempty_list(AND,type_def)
## LR(1) items:
separated_nonempty_list(AND,type_def) -> type_def AND separated_nonempty_list(AND,type_def) . [ DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(AND,type_def) -> type_def AND separated_nonempty_list(AND,type_def)

State 208:
## Known stack suffix:
## raw_var
## LR(1) items:
type_def -> raw_var . list(raw_var) EQDEF constructors [ DOT AND ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 209
-- On list(raw_var) shift to state 211
## Reductions:
-- On EQDEF reduce production list(raw_var) ->

State 209:
## Known stack suffix:
## raw_var
## LR(1) items:
list(raw_var) -> raw_var . list(raw_var) [ EQDEF ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 209
-- On list(raw_var) shift to state 210
## Reductions:
-- On EQDEF reduce production list(raw_var) ->

State 210:
## Known stack suffix:
## raw_var list(raw_var)
## LR(1) items:
list(raw_var) -> raw_var list(raw_var) . [ EQDEF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(raw_var) -> raw_var list(raw_var)

State 211:
## Known stack suffix:
## raw_var list(raw_var)
## LR(1) items:
type_def -> raw_var list(raw_var) . EQDEF constructors [ DOT AND ]
## Transitions:
-- On EQDEF shift to state 212
## Reductions:

State 212:
## Known stack suffix:
## raw_var list(raw_var) EQDEF
## LR(1) items:
type_def -> raw_var list(raw_var) EQDEF . constructors [ DOT AND ]
## Transitions:
-- On VERTICAL_BAR shift to state 213
-- On option(VERTICAL_BAR) shift to state 214
-- On constructors shift to state 229
## Reductions:
-- On UPPER_WORD reduce production option(VERTICAL_BAR) ->
-- On SINGLE_QUOTED reduce production option(VERTICAL_BAR) ->
-- On LOWER_WORD reduce production option(VERTICAL_BAR) ->

State 213:
## Known stack suffix:
## VERTICAL_BAR
## LR(1) items:
option(VERTICAL_BAR) -> VERTICAL_BAR . [ UPPER_WORD SINGLE_QUOTED LOWER_WORD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(VERTICAL_BAR) -> VERTICAL_BAR

State 214:
## Known stack suffix:
## option(VERTICAL_BAR)
## LR(1) items:
constructors -> option(VERTICAL_BAR) . separated_nonempty_list(VERTICAL_BAR,constructor) [ DOT AND ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On separated_nonempty_list(VERTICAL_BAR,constructor) shift to state 215
-- On raw_var shift to state 216
-- On constructor shift to state 226
## Reductions:

State 215:
## Known stack suffix:
## option(VERTICAL_BAR) separated_nonempty_list(VERTICAL_BAR,constructor)
## LR(1) items:
constructors -> option(VERTICAL_BAR) separated_nonempty_list(VERTICAL_BAR,constructor) . [ DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructors -> option(VERTICAL_BAR) separated_nonempty_list(VERTICAL_BAR,constructor)

State 216:
## Known stack suffix:
## raw_var
## LR(1) items:
constructor -> raw_var . list(constructor_arg) [ VERTICAL_BAR DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 217
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On var shift to state 67
-- On raw_var shift to state 68
-- On list(constructor_arg) shift to state 222
-- On constructor_arg shift to state 223
-- On const shift to state 69
-- On atomic_term shift to state 225
## Reductions:
-- On VERTICAL_BAR reduce production list(constructor_arg) ->
-- On DOT reduce production list(constructor_arg) ->
-- On AND reduce production list(constructor_arg) ->

State 217:
## Known stack suffix:
## LEFT_PAREN
## LR(1) items:
atomic_term -> LEFT_PAREN . term RIGHT_PAREN [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
constructor_arg -> LEFT_PAREN . raw_var COLON atomic_term RIGHT_PAREN [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 130
-- On raw_var shift to state 218
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 218:
## Known stack suffix:
## LEFT_PAREN raw_var
## LR(1) items:
constructor_arg -> LEFT_PAREN raw_var . COLON atomic_term RIGHT_PAREN [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
var -> raw_var . [ WILDCARD UPPER_WORD TYPE SINGLE_QUOTED RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ ]
## Transitions:
-- On COLON shift to state 219
## Reductions:
-- On WILDCARD reduce production var -> raw_var
-- On UPPER_WORD reduce production var -> raw_var
-- On TYPE reduce production var -> raw_var
-- On SINGLE_QUOTED reduce production var -> raw_var
-- On RIGHT_PAREN reduce production var -> raw_var
-- On PROP reduce production var -> raw_var
-- On MATCH reduce production var -> raw_var
-- On LOWER_WORD reduce production var -> raw_var
-- On LOGIC_TRUE reduce production var -> raw_var
-- On LOGIC_OR reduce production var -> raw_var
-- On LOGIC_NEQ reduce production var -> raw_var
-- On LOGIC_IMPLY reduce production var -> raw_var
-- On LOGIC_FALSE reduce production var -> raw_var
-- On LOGIC_EQUIV reduce production var -> raw_var
-- On LOGIC_EQ reduce production var -> raw_var
-- On LOGIC_AND reduce production var -> raw_var
-- On LEFT_PAREN reduce production var -> raw_var
-- On INTEGER reduce production var -> raw_var
-- On INT reduce production var -> raw_var
-- On ARROW reduce production var -> raw_var
-- On ARITH_PRODUCT reduce production var -> raw_var
-- On ARITH_PLUS reduce production var -> raw_var
-- On ARITH_MINUS reduce production var -> raw_var
-- On ARITH_LT reduce production var -> raw_var
-- On ARITH_LEQ reduce production var -> raw_var
-- On ARITH_GT reduce production var -> raw_var
-- On ARITH_GEQ reduce production var -> raw_var

State 219:
## Known stack suffix:
## LEFT_PAREN raw_var COLON
## LR(1) items:
constructor_arg -> LEFT_PAREN raw_var COLON . atomic_term RIGHT_PAREN [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On var shift to state 67
-- On raw_var shift to state 68
-- On const shift to state 69
-- On atomic_term shift to state 220
## Reductions:

State 220:
## Known stack suffix:
## LEFT_PAREN raw_var COLON atomic_term
## LR(1) items:
constructor_arg -> LEFT_PAREN raw_var COLON atomic_term . RIGHT_PAREN [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
## Transitions:
-- On RIGHT_PAREN shift to state 221
## Reductions:

State 221:
## Known stack suffix:
## LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN
## LR(1) items:
constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN . [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_arg -> LEFT_PAREN raw_var COLON atomic_term RIGHT_PAREN

State 222:
## Known stack suffix:
## raw_var list(constructor_arg)
## LR(1) items:
constructor -> raw_var list(constructor_arg) . [ VERTICAL_BAR DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor -> raw_var list(constructor_arg)

State 223:
## Known stack suffix:
## constructor_arg
## LR(1) items:
list(constructor_arg) -> constructor_arg . list(constructor_arg) [ VERTICAL_BAR DOT AND ]
## Transitions:
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_FALSE shift to state 47
-- On LEFT_PAREN shift to state 217
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On var shift to state 67
-- On raw_var shift to state 68
-- On list(constructor_arg) shift to state 224
-- On constructor_arg shift to state 223
-- On const shift to state 69
-- On atomic_term shift to state 225
## Reductions:
-- On VERTICAL_BAR reduce production list(constructor_arg) ->
-- On DOT reduce production list(constructor_arg) ->
-- On AND reduce production list(constructor_arg) ->

State 224:
## Known stack suffix:
## constructor_arg list(constructor_arg)
## LR(1) items:
list(constructor_arg) -> constructor_arg list(constructor_arg) . [ VERTICAL_BAR DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(constructor_arg) -> constructor_arg list(constructor_arg)

State 225:
## Known stack suffix:
## atomic_term
## LR(1) items:
constructor_arg -> atomic_term . [ WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructor_arg -> atomic_term

State 226:
## Known stack suffix:
## constructor
## LR(1) items:
separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor . [ DOT AND ]
separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor . VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,constructor) [ DOT AND ]
## Transitions:
-- On VERTICAL_BAR shift to state 227
## Reductions:
-- On DOT reduce production separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor
-- On AND reduce production separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor

State 227:
## Known stack suffix:
## constructor VERTICAL_BAR
## LR(1) items:
separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor VERTICAL_BAR . separated_nonempty_list(VERTICAL_BAR,constructor) [ DOT AND ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On separated_nonempty_list(VERTICAL_BAR,constructor) shift to state 228
-- On raw_var shift to state 216
-- On constructor shift to state 226
## Reductions:

State 228:
## Known stack suffix:
## constructor VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,constructor)
## LR(1) items:
separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,constructor) . [ DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,constructor)

State 229:
## Known stack suffix:
## raw_var list(raw_var) EQDEF constructors
## LR(1) items:
type_def -> raw_var list(raw_var) EQDEF constructors . [ DOT AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_def -> raw_var list(raw_var) EQDEF constructors

State 230:
## Known stack suffix:
## separated_nonempty_list(AND,type_def)
## LR(1) items:
mutual_types -> separated_nonempty_list(AND,type_def) . [ DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mutual_types -> separated_nonempty_list(AND,type_def)

State 231:
## Known stack suffix:
## DATA attrs mutual_types
## LR(1) items:
statement -> DATA attrs mutual_types . DOT [ EOI ]
## Transitions:
-- On DOT shift to state 232
## Reductions:

State 232:
## Known stack suffix:
## DATA attrs mutual_types DOT
## LR(1) items:
statement -> DATA attrs mutual_types DOT . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> DATA attrs mutual_types DOT

State 233:
## Known stack suffix:
## ASSERT
## LR(1) items:
statement -> ASSERT . attrs term DOT [ EOI ]
## Transitions:
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 234
## Reductions:
-- On error reduce production attrs ->
-- On WILDCARD reduce production attrs ->
-- On UPPER_WORD reduce production attrs ->
-- On TYPE reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On PROP reduce production attrs ->
-- On PI reduce production attrs ->
-- On MATCH reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->
-- On LOGIC_TRUE reduce production attrs ->
-- On LOGIC_NOT reduce production attrs ->
-- On LOGIC_FORALL reduce production attrs ->
-- On LOGIC_FALSE reduce production attrs ->
-- On LOGIC_EXISTS reduce production attrs ->
-- On LET reduce production attrs ->
-- On LEFT_PAREN reduce production attrs ->
-- On INTEGER reduce production attrs ->
-- On INT reduce production attrs ->
-- On IF reduce production attrs ->
-- On FUN reduce production attrs ->
-- On ARITH_MINUS reduce production attrs ->

State 234:
## Known stack suffix:
## ASSERT attrs
## LR(1) items:
statement -> ASSERT attrs . term DOT [ EOI ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 235
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 235:
## Known stack suffix:
## ASSERT attrs term
## LR(1) items:
statement -> ASSERT attrs term . DOT [ EOI ]
## Transitions:
-- On DOT shift to state 236
## Reductions:

State 236:
## Known stack suffix:
## ASSERT attrs term DOT
## LR(1) items:
statement -> ASSERT attrs term DOT . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> ASSERT attrs term DOT

State 237:
## Known stack suffix:
## statement
## LR(1) items:
parse_statement -> statement . EOI [ # ]
## Transitions:
-- On EOI shift to state 238
## Reductions:

State 238:
## Known stack suffix:
## statement EOI
## LR(1) items:
parse_statement -> statement EOI . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production parse_statement -> statement EOI

State 239:
## Known stack suffix:
## parse_statement
## LR(1) items:
parse_statement' -> parse_statement . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept parse_statement

State 240:
## Known stack suffix:
##
## LR(1) items:
parse_statement_list' -> . parse_statement_list [ # ]
## Transitions:
-- On error shift to state 241
-- On VAL shift to state 242
-- On REWRITE shift to state 248
-- On LEMMA shift to state 252
-- On INCLUDE shift to state 256
-- On GOAL shift to state 259
-- On DEF shift to state 263
-- On DATA shift to state 267
-- On ASSERT shift to state 271
-- On statement shift to state 275
-- On parse_statement_list shift to state 277
-- On list(statement) shift to state 278
## Reductions:
-- On EOI reduce production list(statement) ->

State 241:
## Known stack suffix:
## error
## LR(1) items:
statement -> error . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> error

State 242:
## Known stack suffix:
## VAL
## LR(1) items:
statement -> VAL . attrs raw_var COLON term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On LEFT_BRACKET shift to state 3
-- On attrs shift to state 243
## Reductions:
-- On UPPER_WORD reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->

State 243:
## Known stack suffix:
## VAL attrs
## LR(1) items:
statement -> VAL attrs . raw_var COLON term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On raw_var shift to state 244
## Reductions:

State 244:
## Known stack suffix:
## VAL attrs raw_var
## LR(1) items:
statement -> VAL attrs raw_var . COLON term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On COLON shift to state 245
## Reductions:

State 245:
## Known stack suffix:
## VAL attrs raw_var COLON
## LR(1) items:
statement -> VAL attrs raw_var COLON . term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 246
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 246:
## Known stack suffix:
## VAL attrs raw_var COLON term
## LR(1) items:
statement -> VAL attrs raw_var COLON term . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On DOT shift to state 247
## Reductions:

State 247:
## Known stack suffix:
## VAL attrs raw_var COLON term DOT
## LR(1) items:
statement -> VAL attrs raw_var COLON term DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> VAL attrs raw_var COLON term DOT

State 248:
## Known stack suffix:
## REWRITE
## LR(1) items:
statement -> REWRITE . attrs term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 249
## Reductions:
-- On error reduce production attrs ->
-- On WILDCARD reduce production attrs ->
-- On UPPER_WORD reduce production attrs ->
-- On TYPE reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On PROP reduce production attrs ->
-- On PI reduce production attrs ->
-- On MATCH reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->
-- On LOGIC_TRUE reduce production attrs ->
-- On LOGIC_NOT reduce production attrs ->
-- On LOGIC_FORALL reduce production attrs ->
-- On LOGIC_FALSE reduce production attrs ->
-- On LOGIC_EXISTS reduce production attrs ->
-- On LET reduce production attrs ->
-- On LEFT_PAREN reduce production attrs ->
-- On INTEGER reduce production attrs ->
-- On INT reduce production attrs ->
-- On IF reduce production attrs ->
-- On FUN reduce production attrs ->
-- On ARITH_MINUS reduce production attrs ->

State 249:
## Known stack suffix:
## REWRITE attrs
## LR(1) items:
statement -> REWRITE attrs . term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 250
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 250:
## Known stack suffix:
## REWRITE attrs term
## LR(1) items:
statement -> REWRITE attrs term . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On DOT shift to state 251
## Reductions:

State 251:
## Known stack suffix:
## REWRITE attrs term DOT
## LR(1) items:
statement -> REWRITE attrs term DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> REWRITE attrs term DOT

State 252:
## Known stack suffix:
## LEMMA
## LR(1) items:
statement -> LEMMA . attrs term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 253
## Reductions:
-- On error reduce production attrs ->
-- On WILDCARD reduce production attrs ->
-- On UPPER_WORD reduce production attrs ->
-- On TYPE reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On PROP reduce production attrs ->
-- On PI reduce production attrs ->
-- On MATCH reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->
-- On LOGIC_TRUE reduce production attrs ->
-- On LOGIC_NOT reduce production attrs ->
-- On LOGIC_FORALL reduce production attrs ->
-- On LOGIC_FALSE reduce production attrs ->
-- On LOGIC_EXISTS reduce production attrs ->
-- On LET reduce production attrs ->
-- On LEFT_PAREN reduce production attrs ->
-- On INTEGER reduce production attrs ->
-- On INT reduce production attrs ->
-- On IF reduce production attrs ->
-- On FUN reduce production attrs ->
-- On ARITH_MINUS reduce production attrs ->

State 253:
## Known stack suffix:
## LEMMA attrs
## LR(1) items:
statement -> LEMMA attrs . term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 254
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 254:
## Known stack suffix:
## LEMMA attrs term
## LR(1) items:
statement -> LEMMA attrs term . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On DOT shift to state 255
## Reductions:

State 255:
## Known stack suffix:
## LEMMA attrs term DOT
## LR(1) items:
statement -> LEMMA attrs term DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> LEMMA attrs term DOT

State 256:
## Known stack suffix:
## INCLUDE
## LR(1) items:
statement -> INCLUDE . QUOTED DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On QUOTED shift to state 257
## Reductions:

State 257:
## Known stack suffix:
## INCLUDE QUOTED
## LR(1) items:
statement -> INCLUDE QUOTED . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On DOT shift to state 258
## Reductions:

State 258:
## Known stack suffix:
## INCLUDE QUOTED DOT
## LR(1) items:
statement -> INCLUDE QUOTED DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> INCLUDE QUOTED DOT

State 259:
## Known stack suffix:
## GOAL
## LR(1) items:
statement -> GOAL . attrs term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 260
## Reductions:
-- On error reduce production attrs ->
-- On WILDCARD reduce production attrs ->
-- On UPPER_WORD reduce production attrs ->
-- On TYPE reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On PROP reduce production attrs ->
-- On PI reduce production attrs ->
-- On MATCH reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->
-- On LOGIC_TRUE reduce production attrs ->
-- On LOGIC_NOT reduce production attrs ->
-- On LOGIC_FORALL reduce production attrs ->
-- On LOGIC_FALSE reduce production attrs ->
-- On LOGIC_EXISTS reduce production attrs ->
-- On LET reduce production attrs ->
-- On LEFT_PAREN reduce production attrs ->
-- On INTEGER reduce production attrs ->
-- On INT reduce production attrs ->
-- On IF reduce production attrs ->
-- On FUN reduce production attrs ->
-- On ARITH_MINUS reduce production attrs ->

State 260:
## Known stack suffix:
## GOAL attrs
## LR(1) items:
statement -> GOAL attrs . term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 261
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 261:
## Known stack suffix:
## GOAL attrs term
## LR(1) items:
statement -> GOAL attrs term . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On DOT shift to state 262
## Reductions:

State 262:
## Known stack suffix:
## GOAL attrs term DOT
## LR(1) items:
statement -> GOAL attrs term DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> GOAL attrs term DOT

State 263:
## Known stack suffix:
## DEF
## LR(1) items:
statement -> DEF . attrs separated_nonempty_list(AND,def) DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On LEFT_BRACKET shift to state 3
-- On attrs shift to state 264
## Reductions:
-- On UPPER_WORD reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->

State 264:
## Known stack suffix:
## DEF attrs
## LR(1) items:
statement -> DEF attrs . separated_nonempty_list(AND,def) DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On separated_nonempty_list(AND,def) shift to state 265
-- On raw_var shift to state 178
-- On def shift to state 200
## Reductions:

State 265:
## Known stack suffix:
## DEF attrs separated_nonempty_list(AND,def)
## LR(1) items:
statement -> DEF attrs separated_nonempty_list(AND,def) . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On DOT shift to state 266
## Reductions:

State 266:
## Known stack suffix:
## DEF attrs separated_nonempty_list(AND,def) DOT
## LR(1) items:
statement -> DEF attrs separated_nonempty_list(AND,def) DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> DEF attrs separated_nonempty_list(AND,def) DOT

State 267:
## Known stack suffix:
## DATA
## LR(1) items:
statement -> DATA . attrs mutual_types DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On LEFT_BRACKET shift to state 3
-- On attrs shift to state 268
## Reductions:
-- On UPPER_WORD reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->

State 268:
## Known stack suffix:
## DATA attrs
## LR(1) items:
statement -> DATA attrs . mutual_types DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On UPPER_WORD shift to state 5
-- On SINGLE_QUOTED shift to state 6
-- On LOWER_WORD shift to state 8
-- On type_def shift to state 205
-- On separated_nonempty_list(AND,type_def) shift to state 230
-- On raw_var shift to state 208
-- On mutual_types shift to state 269
## Reductions:

State 269:
## Known stack suffix:
## DATA attrs mutual_types
## LR(1) items:
statement -> DATA attrs mutual_types . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On DOT shift to state 270
## Reductions:

State 270:
## Known stack suffix:
## DATA attrs mutual_types DOT
## LR(1) items:
statement -> DATA attrs mutual_types DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> DATA attrs mutual_types DOT

State 271:
## Known stack suffix:
## ASSERT
## LR(1) items:
statement -> ASSERT . attrs term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On LEFT_BRACKET shift to state 157
-- On attrs shift to state 272
## Reductions:
-- On error reduce production attrs ->
-- On WILDCARD reduce production attrs ->
-- On UPPER_WORD reduce production attrs ->
-- On TYPE reduce production attrs ->
-- On SINGLE_QUOTED reduce production attrs ->
-- On PROP reduce production attrs ->
-- On PI reduce production attrs ->
-- On MATCH reduce production attrs ->
-- On LOWER_WORD reduce production attrs ->
-- On LOGIC_TRUE reduce production attrs ->
-- On LOGIC_NOT reduce production attrs ->
-- On LOGIC_FORALL reduce production attrs ->
-- On LOGIC_FALSE reduce production attrs ->
-- On LOGIC_EXISTS reduce production attrs ->
-- On LET reduce production attrs ->
-- On LEFT_PAREN reduce production attrs ->
-- On INTEGER reduce production attrs ->
-- On INT reduce production attrs ->
-- On IF reduce production attrs ->
-- On FUN reduce production attrs ->
-- On ARITH_MINUS reduce production attrs ->

State 272:
## Known stack suffix:
## ASSERT attrs
## LR(1) items:
statement -> ASSERT attrs . term DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 273
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 273:
## Known stack suffix:
## ASSERT attrs term
## LR(1) items:
statement -> ASSERT attrs term . DOT [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
-- On DOT shift to state 274
## Reductions:

State 274:
## Known stack suffix:
## ASSERT attrs term DOT
## LR(1) items:
statement -> ASSERT attrs term DOT . [ error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> ASSERT attrs term DOT

State 275:
## Known stack suffix:
## statement
## LR(1) items:
list(statement) -> statement . list(statement) [ EOI ]
## Transitions:
-- On error shift to state 241
-- On VAL shift to state 242
-- On REWRITE shift to state 248
-- On LEMMA shift to state 252
-- On INCLUDE shift to state 256
-- On GOAL shift to state 259
-- On DEF shift to state 263
-- On DATA shift to state 267
-- On ASSERT shift to state 271
-- On statement shift to state 275
-- On list(statement) shift to state 276
## Reductions:
-- On EOI reduce production list(statement) ->

State 276:
## Known stack suffix:
## statement list(statement)
## LR(1) items:
list(statement) -> statement list(statement) . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(statement) -> statement list(statement)

State 277:
## Known stack suffix:
## parse_statement_list
## LR(1) items:
parse_statement_list' -> parse_statement_list . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept parse_statement_list

State 278:
## Known stack suffix:
## list(statement)
## LR(1) items:
parse_statement_list -> list(statement) . EOI [ # ]
## Transitions:
-- On EOI shift to state 279
## Reductions:

State 279:
## Known stack suffix:
## list(statement) EOI
## LR(1) items:
parse_statement_list -> list(statement) EOI . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production parse_statement_list -> list(statement) EOI

State 280:
## Known stack suffix:
##
## LR(1) items:
parse_term' -> . parse_term [ # ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 281
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On parse_term shift to state 283
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 281:
## Known stack suffix:
## term
## LR(1) items:
parse_term -> term . EOI [ # ]
## Transitions:
-- On EOI shift to state 282
## Reductions:

State 282:
## Known stack suffix:
## term EOI
## LR(1) items:
parse_term -> term EOI . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production parse_term -> term EOI

State 283:
## Known stack suffix:
## parse_term
## LR(1) items:
parse_term' -> parse_term . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept parse_term

State 284:
## Known stack suffix:
##
## LR(1) items:
parse_ty' -> . parse_ty [ # ]
## Transitions:
-- On error shift to state 30
-- On WILDCARD shift to state 31
-- On UPPER_WORD shift to state 5
-- On TYPE shift to state 32
-- On SINGLE_QUOTED shift to state 6
-- On PROP shift to state 33
-- On PI shift to state 34
-- On MATCH shift to state 44
-- On LOWER_WORD shift to state 8
-- On LOGIC_TRUE shift to state 45
-- On LOGIC_NOT shift to state 46
-- On LOGIC_FORALL shift to state 49
-- On LOGIC_FALSE shift to state 47
-- On LOGIC_EXISTS shift to state 54
-- On LET shift to state 57
-- On LEFT_PAREN shift to state 48
-- On INTEGER shift to state 60
-- On INT shift to state 61
-- On IF shift to state 62
-- On FUN shift to state 63
-- On ARITH_MINUS shift to state 66
-- On var shift to state 67
-- On term shift to state 285
-- On raw_var shift to state 68
-- On plus_term shift to state 76
-- On parse_ty shift to state 287
-- On or_term shift to state 93
-- On not_term shift to state 94
-- On mult_term shift to state 79
-- On eq_term shift to state 100
-- On const shift to state 69
-- On atomic_term shift to state 70
-- On arith_op_term shift to state 97
-- On apply_term shift to state 103
-- On and_term shift to state 106
## Reductions:

State 285:
## Known stack suffix:
## term
## LR(1) items:
parse_ty -> term . EOI [ # ]
## Transitions:
-- On EOI shift to state 286
## Reductions:

State 286:
## Known stack suffix:
## term EOI
## LR(1) items:
parse_ty -> term EOI . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production parse_ty -> term EOI

State 287:
## Known stack suffix:
## parse_ty
## LR(1) items:
parse_ty' -> parse_ty . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept parse_ty

