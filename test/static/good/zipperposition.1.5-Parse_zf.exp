Grammar has 50 nonterminal symbols, among which 4 start symbols.
Grammar has 59 terminal symbols.
Grammar has 125 productions.
nullable(var_or_wildcard) = false
nullable(var) = false
nullable(typed_var_list) = false
nullable(typed_var_block) = false
nullable(typed_ty_var_list) = false
nullable(typed_ty_var_block) = false
nullable(type_def) = false
nullable(term) = false
nullable(statement) = false
nullable(separated_nonempty_list(VERTICAL_BAR,constructor)) = false
nullable(separated_nonempty_list(SEMI_COLON,term)) = false
nullable(separated_nonempty_list(COMMA,attr)) = false
nullable(separated_nonempty_list(AND,type_def)) = false
nullable(separated_nonempty_list(AND,def)) = false
nullable(raw_var) = false
nullable(plus_term) = false
nullable(parse_ty) = false
nullable(parse_term) = false
nullable(parse_statement_list) = false
nullable(parse_statement) = false
nullable(or_term) = false
nullable(option(VERTICAL_BAR)) = true
nullable(not_term) = false
nullable(nonempty_list(raw_var)) = false
nullable(nonempty_list(match_branch)) = false
nullable(nonempty_list(atomic_term)) = false
nullable(nonempty_list(atomic_attr)) = false
nullable(mutual_types) = false
nullable(mult_term) = false
nullable(match_branch) = false
nullable(mandatory_typed_var_list) = false
nullable(mandatory_typed_var_block) = false
nullable(loption(separated_nonempty_list(COMMA,attr))) = true
nullable(list(var_or_wildcard)) = true
nullable(list(statement)) = true
nullable(list(raw_var)) = true
nullable(list(constructor_arg)) = true
nullable(eq_term) = false
nullable(def) = false
nullable(constructors) = false
nullable(constructor_arg) = false
nullable(constructor) = false
nullable(const) = false
nullable(attrs) = true
nullable(attr) = false
nullable(atomic_term) = false
nullable(atomic_attr) = false
nullable(arith_op_term) = false
nullable(apply_term) = false
nullable(and_term) = false
first(var_or_wildcard) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(var) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(typed_var_list) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN
first(typed_var_block) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN
first(typed_ty_var_list) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN
first(typed_ty_var_block) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN
first(type_def) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(term) = error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS
first(statement) = error VAL REWRITE LEMMA INCLUDE GOAL DEF DATA ASSERT
first(separated_nonempty_list(VERTICAL_BAR,constructor)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(separated_nonempty_list(SEMI_COLON,term)) = error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS
first(separated_nonempty_list(COMMA,attr)) = error UPPER_WORD SINGLE_QUOTED QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET
first(separated_nonempty_list(AND,type_def)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(separated_nonempty_list(AND,def)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(raw_var) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(plus_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(parse_ty) = error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS
first(parse_term) = error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS
first(parse_statement_list) = error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT
first(parse_statement) = error VAL REWRITE LEMMA INCLUDE GOAL DEF DATA ASSERT
first(or_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(option(VERTICAL_BAR)) = VERTICAL_BAR
first(not_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(nonempty_list(raw_var)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(nonempty_list(match_branch)) = VERTICAL_BAR
first(nonempty_list(atomic_term)) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT
first(nonempty_list(atomic_attr)) = UPPER_WORD SINGLE_QUOTED QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET
first(mutual_types) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(mult_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(match_branch) = VERTICAL_BAR
first(mandatory_typed_var_list) = LEFT_PAREN
first(mandatory_typed_var_block) = LEFT_PAREN
first(loption(separated_nonempty_list(COMMA,attr))) = error UPPER_WORD SINGLE_QUOTED QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET
first(list(var_or_wildcard)) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(list(statement)) = error VAL REWRITE LEMMA INCLUDE GOAL DEF DATA ASSERT
first(list(raw_var)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(list(constructor_arg)) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT
first(eq_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(def) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(constructors) = VERTICAL_BAR UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(constructor_arg) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT
first(constructor) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(const) = TYPE PROP LOGIC_TRUE LOGIC_FALSE INT
first(attrs) = LEFT_BRACKET
first(attr) = error UPPER_WORD SINGLE_QUOTED QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET
first(atomic_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT
first(atomic_attr) = UPPER_WORD SINGLE_QUOTED QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET
first(arith_op_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(apply_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(and_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
minimal(var_or_wildcard) = (* 1 *) LOWER_WORD
minimal(var) = (* 1 *) WILDCARD
minimal(typed_var_list) = (* 1 *) LOWER_WORD
minimal(typed_var_block) = (* 1 *) LOWER_WORD
minimal(typed_ty_var_list) = (* 1 *) LOWER_WORD
minimal(typed_ty_var_block) = (* 1 *) LOWER_WORD
minimal(type_def) = (* 3 *) LOWER_WORD EQDEF LOWER_WORD
minimal(term) = (* 1 *) WILDCARD
minimal(statement) = (* 3 *) INCLUDE QUOTED DOT
minimal(separated_nonempty_list(VERTICAL_BAR,constructor)) = (* 1 *) LOWER_WORD
minimal(separated_nonempty_list(SEMI_COLON,term)) = (* 1 *) WILDCARD
minimal(separated_nonempty_list(COMMA,attr)) = (* 1 *) LOWER_WORD
minimal(separated_nonempty_list(AND,type_def)) = (* 3 *) LOWER_WORD EQDEF LOWER_WORD
minimal(separated_nonempty_list(AND,def)) = (* 5 *) LOWER_WORD COLON WILDCARD EQDEF WILDCARD
minimal(raw_var) = (* 1 *) LOWER_WORD
minimal(plus_term) = (* 1 *) WILDCARD
minimal(parse_ty) = (* 2 *) WILDCARD EOI
minimal(parse_term) = (* 2 *) WILDCARD EOI
minimal(parse_statement_list) = (* 1 *) EOI
minimal(parse_statement) = (* 4 *) INCLUDE QUOTED DOT EOI
minimal(or_term) = (* 1 *) WILDCARD
minimal(option(VERTICAL_BAR)) = (* 0 *)
minimal(not_term) = (* 1 *) WILDCARD
minimal(nonempty_list(raw_var)) = (* 1 *) LOWER_WORD
minimal(nonempty_list(match_branch)) = (* 4 *) VERTICAL_BAR LOWER_WORD ARROW WILDCARD
minimal(nonempty_list(atomic_term)) = (* 1 *) WILDCARD
minimal(nonempty_list(atomic_attr)) = (* 1 *) LOWER_WORD
minimal(mutual_types) = (* 3 *) LOWER_WORD EQDEF LOWER_WORD
minimal(mult_term) = (* 1 *) WILDCARD
minimal(match_branch) = (* 4 *) VERTICAL_BAR LOWER_WORD ARROW WILDCARD
minimal(mandatory_typed_var_list) = (* 5 *) LEFT_PAREN LOWER_WORD COLON WILDCARD RIGHT_PAREN
minimal(mandatory_typed_var_block) = (* 5 *) LEFT_PAREN LOWER_WORD COLON WILDCARD RIGHT_PAREN
minimal(loption(separated_nonempty_list(COMMA,attr))) = (* 0 *)
minimal(list(var_or_wildcard)) = (* 0 *)
minimal(list(statement)) = (* 0 *)
minimal(list(raw_var)) = (* 0 *)
minimal(list(constructor_arg)) = (* 0 *)
minimal(eq_term) = (* 1 *) WILDCARD
minimal(def) = (* 5 *) LOWER_WORD COLON WILDCARD EQDEF WILDCARD
minimal(constructors) = (* 1 *) LOWER_WORD
minimal(constructor_arg) = (* 1 *) WILDCARD
minimal(constructor) = (* 1 *) LOWER_WORD
minimal(const) = (* 1 *) TYPE
minimal(attrs) = (* 0 *)
minimal(attr) = (* 1 *) LOWER_WORD
minimal(atomic_term) = (* 1 *) WILDCARD
minimal(atomic_attr) = (* 1 *) LOWER_WORD
minimal(arith_op_term) = (* 1 *) WILDCARD
minimal(apply_term) = (* 1 *) WILDCARD
minimal(and_term) = (* 1 *) WILDCARD
maximal(var_or_wildcard) = 1
maximal(var) = 1
maximal(typed_var_list) = infinity
maximal(typed_var_block) = infinity
maximal(typed_ty_var_list) = infinity
maximal(typed_ty_var_block) = infinity
maximal(type_def) = infinity
maximal(term) = infinity
maximal(statement) = infinity
maximal(separated_nonempty_list(VERTICAL_BAR,constructor)) = infinity
maximal(separated_nonempty_list(SEMI_COLON,term)) = infinity
maximal(separated_nonempty_list(COMMA,attr)) = infinity
maximal(separated_nonempty_list(AND,type_def)) = infinity
maximal(separated_nonempty_list(AND,def)) = infinity
maximal(raw_var) = 1
maximal(plus_term) = infinity
maximal(parse_ty) = infinity
maximal(parse_term) = infinity
maximal(parse_statement_list) = infinity
maximal(parse_statement) = infinity
maximal(or_term) = infinity
maximal(option(VERTICAL_BAR)) = 1
maximal(not_term) = infinity
maximal(nonempty_list(raw_var)) = infinity
maximal(nonempty_list(match_branch)) = infinity
maximal(nonempty_list(atomic_term)) = infinity
maximal(nonempty_list(atomic_attr)) = infinity
maximal(mutual_types) = infinity
maximal(mult_term) = infinity
maximal(match_branch) = infinity
maximal(mandatory_typed_var_list) = infinity
maximal(mandatory_typed_var_block) = infinity
maximal(loption(separated_nonempty_list(COMMA,attr))) = infinity
maximal(list(var_or_wildcard)) = infinity
maximal(list(statement)) = infinity
maximal(list(raw_var)) = infinity
maximal(list(constructor_arg)) = infinity
maximal(eq_term) = infinity
maximal(def) = infinity
maximal(constructors) = infinity
maximal(constructor_arg) = infinity
maximal(constructor) = infinity
maximal(const) = 1
maximal(attrs) = infinity
maximal(attr) = infinity
maximal(atomic_term) = infinity
maximal(atomic_attr) = infinity
maximal(arith_op_term) = infinity
maximal(apply_term) = infinity
maximal(and_term) = infinity
follow(var_or_wildcard) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD ARROW
follow(var) = WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(typed_var_list) = DOT
follow(typed_var_block) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT
follow(typed_ty_var_list) = DOT
follow(typed_ty_var_block) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT
follow(type_def) = DOT AND
follow(term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND
follow(statement) = error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT
follow(separated_nonempty_list(VERTICAL_BAR,constructor)) = DOT AND
follow(separated_nonempty_list(SEMI_COLON,term)) = DOT AND
follow(separated_nonempty_list(COMMA,attr)) = RIGHT_BRACKET
follow(separated_nonempty_list(AND,type_def)) = DOT
follow(separated_nonempty_list(AND,def)) = DOT
follow(raw_var) = WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN RIGHT_BRACKET QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET INTEGER INT IN EQDEF EOI END ELSE DOT COMMA COLON ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(plus_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(parse_ty) = #
follow(parse_term) = #
follow(parse_statement_list) = #
follow(parse_statement) = #
follow(or_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND
follow(option(VERTICAL_BAR)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
follow(not_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND
follow(nonempty_list(raw_var)) = COLON
follow(nonempty_list(match_branch)) = END
follow(nonempty_list(atomic_term)) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(nonempty_list(atomic_attr)) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(mutual_types) = DOT
follow(mult_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(match_branch) = VERTICAL_BAR END
follow(mandatory_typed_var_list) = COLON
follow(mandatory_typed_var_block) = LEFT_PAREN COLON
follow(loption(separated_nonempty_list(COMMA,attr))) = RIGHT_BRACKET
follow(list(var_or_wildcard)) = ARROW
follow(list(statement)) = EOI
follow(list(raw_var)) = EQDEF
follow(list(constructor_arg)) = VERTICAL_BAR DOT AND
follow(eq_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND
follow(def) = DOT AND
follow(constructors) = DOT AND
follow(constructor_arg) = WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND
follow(constructor) = VERTICAL_BAR DOT AND
follow(const) = WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(attrs) = error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS
follow(attr) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(atomic_term) = WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(atomic_attr) = UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA
follow(arith_op_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND
follow(apply_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(and_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV IN EQDEF EOI END ELSE DOT AND
Built an LR(0) automaton with 251 states.
The grammar is not SLR(1) -- 1 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 288 states.
112 out of 288 states have a default reduction.
The action table is 17280 entries; 1679 non-zero; 891 compressed.
The action table occupies roughly 1872 bytes.
The goto table is 15552 entries; 721 non-zero; 1408 compressed.
The goto table occupies roughly 2904 bytes.
The error table occupies roughly 2192 bytes.
The default_reduction table occupies roughly 320 bytes.
The lhs table occupies roughly 168 bytes.
The trace table occupies roughly 8 bytes.
