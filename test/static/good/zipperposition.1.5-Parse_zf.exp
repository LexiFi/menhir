Grammar has 50 nonterminal symbols, among which 4 start symbols.
Grammar has 59 terminal symbols.
Grammar has 125 productions.
nullable(var_or_wildcard) = false
nullable(var) = false
nullable(typed_var_list) = false
nullable(typed_var_block) = false
nullable(typed_ty_var_list) = false
nullable(typed_ty_var_block) = false
nullable(type_def) = false
nullable(term) = false
nullable(statement) = false
nullable(separated_nonempty_list(VERTICAL_BAR,constructor)) = false
nullable(separated_nonempty_list(SEMI_COLON,term)) = false
nullable(separated_nonempty_list(COMMA,attr)) = false
nullable(separated_nonempty_list(AND,type_def)) = false
nullable(separated_nonempty_list(AND,def)) = false
nullable(raw_var) = false
nullable(plus_term) = false
nullable(parse_ty) = false
nullable(parse_term) = false
nullable(parse_statement_list) = false
nullable(parse_statement) = false
nullable(or_term) = false
nullable(option(VERTICAL_BAR)) = true
nullable(not_term) = false
nullable(nonempty_list(raw_var)) = false
nullable(nonempty_list(match_branch)) = false
nullable(nonempty_list(atomic_term)) = false
nullable(nonempty_list(atomic_attr)) = false
nullable(mutual_types) = false
nullable(mult_term) = false
nullable(match_branch) = false
nullable(mandatory_typed_var_list) = false
nullable(mandatory_typed_var_block) = false
nullable(loption(separated_nonempty_list(COMMA,attr))) = true
nullable(list(var_or_wildcard)) = true
nullable(list(statement)) = true
nullable(list(raw_var)) = true
nullable(list(constructor_arg)) = true
nullable(eq_term) = false
nullable(def) = false
nullable(constructors) = false
nullable(constructor_arg) = false
nullable(constructor) = false
nullable(const) = false
nullable(attrs) = true
nullable(attr) = false
nullable(atomic_term) = false
nullable(atomic_attr) = false
nullable(arith_op_term) = false
nullable(apply_term) = false
nullable(and_term) = false
first(var_or_wildcard) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(var) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(typed_var_list) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN
first(typed_var_block) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN
first(typed_ty_var_list) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN
first(typed_ty_var_block) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN
first(type_def) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(term) = error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS
first(statement) = error VAL REWRITE LEMMA INCLUDE GOAL DEF DATA ASSERT
first(separated_nonempty_list(VERTICAL_BAR,constructor)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(separated_nonempty_list(SEMI_COLON,term)) = error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS
first(separated_nonempty_list(COMMA,attr)) = error UPPER_WORD SINGLE_QUOTED QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET
first(separated_nonempty_list(AND,type_def)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(separated_nonempty_list(AND,def)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(raw_var) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(plus_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(parse_ty) = error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS
first(parse_term) = error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS
first(parse_statement_list) = error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT
first(parse_statement) = error VAL REWRITE LEMMA INCLUDE GOAL DEF DATA ASSERT
first(or_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(option(VERTICAL_BAR)) = VERTICAL_BAR
first(not_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(nonempty_list(raw_var)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(nonempty_list(match_branch)) = VERTICAL_BAR
first(nonempty_list(atomic_term)) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT
first(nonempty_list(atomic_attr)) = UPPER_WORD SINGLE_QUOTED QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET
first(mutual_types) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(mult_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(match_branch) = VERTICAL_BAR
first(mandatory_typed_var_list) = LEFT_PAREN
first(mandatory_typed_var_block) = LEFT_PAREN
first(loption(separated_nonempty_list(COMMA,attr))) = error UPPER_WORD SINGLE_QUOTED QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET
first(list(var_or_wildcard)) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(list(statement)) = error VAL REWRITE LEMMA INCLUDE GOAL DEF DATA ASSERT
first(list(raw_var)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(list(constructor_arg)) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT
first(eq_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(def) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(constructors) = VERTICAL_BAR UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(constructor_arg) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT
first(constructor) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(const) = TYPE PROP LOGIC_TRUE LOGIC_FALSE INT
first(attrs) = LEFT_BRACKET
first(attr) = error UPPER_WORD SINGLE_QUOTED QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET
first(atomic_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT
first(atomic_attr) = UPPER_WORD SINGLE_QUOTED QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET
first(arith_op_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(apply_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
first(and_term) = WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FALSE LEFT_PAREN INTEGER INT ARITH_MINUS
minimal(var_or_wildcard) = (* 1 *) LOWER_WORD
minimal(var) = (* 1 *) WILDCARD
minimal(typed_var_list) = (* 1 *) LOWER_WORD
minimal(typed_var_block) = (* 1 *) LOWER_WORD
minimal(typed_ty_var_list) = (* 1 *) LOWER_WORD
minimal(typed_ty_var_block) = (* 1 *) LOWER_WORD
minimal(type_def) = (* 3 *) LOWER_WORD EQDEF LOWER_WORD
minimal(term) = (* 1 *) WILDCARD
minimal(statement) = (* 1 *) error
minimal(separated_nonempty_list(VERTICAL_BAR,constructor)) = (* 1 *) LOWER_WORD
minimal(separated_nonempty_list(SEMI_COLON,term)) = (* 1 *) WILDCARD
minimal(separated_nonempty_list(COMMA,attr)) = (* 1 *) LOWER_WORD
minimal(separated_nonempty_list(AND,type_def)) = (* 3 *) LOWER_WORD EQDEF LOWER_WORD
minimal(separated_nonempty_list(AND,def)) = (* 5 *) LOWER_WORD COLON WILDCARD EQDEF WILDCARD
minimal(raw_var) = (* 1 *) LOWER_WORD
minimal(plus_term) = (* 1 *) WILDCARD
minimal(parse_ty) = (* 2 *) WILDCARD EOI
minimal(parse_term) = (* 2 *) WILDCARD EOI
minimal(parse_statement_list) = (* 1 *) EOI
minimal(parse_statement) = (* 2 *) error EOI
minimal(or_term) = (* 1 *) WILDCARD
minimal(option(VERTICAL_BAR)) = (* 0 *)
minimal(not_term) = (* 1 *) WILDCARD
minimal(nonempty_list(raw_var)) = (* 1 *) LOWER_WORD
minimal(nonempty_list(match_branch)) = (* 4 *) VERTICAL_BAR LOWER_WORD ARROW WILDCARD
minimal(nonempty_list(atomic_term)) = (* 1 *) WILDCARD
minimal(nonempty_list(atomic_attr)) = (* 1 *) LOWER_WORD
minimal(mutual_types) = (* 3 *) LOWER_WORD EQDEF LOWER_WORD
minimal(mult_term) = (* 1 *) WILDCARD
minimal(match_branch) = (* 4 *) VERTICAL_BAR LOWER_WORD ARROW WILDCARD
minimal(mandatory_typed_var_list) = (* 5 *) LEFT_PAREN LOWER_WORD COLON WILDCARD RIGHT_PAREN
minimal(mandatory_typed_var_block) = (* 5 *) LEFT_PAREN LOWER_WORD COLON WILDCARD RIGHT_PAREN
minimal(loption(separated_nonempty_list(COMMA,attr))) = (* 0 *)
minimal(list(var_or_wildcard)) = (* 0 *)
minimal(list(statement)) = (* 0 *)
minimal(list(raw_var)) = (* 0 *)
minimal(list(constructor_arg)) = (* 0 *)
minimal(eq_term) = (* 1 *) WILDCARD
minimal(def) = (* 5 *) LOWER_WORD COLON WILDCARD EQDEF WILDCARD
minimal(constructors) = (* 1 *) LOWER_WORD
minimal(constructor_arg) = (* 1 *) WILDCARD
minimal(constructor) = (* 1 *) LOWER_WORD
minimal(const) = (* 1 *) TYPE
minimal(attrs) = (* 0 *)
minimal(attr) = (* 1 *) LOWER_WORD
minimal(atomic_term) = (* 1 *) WILDCARD
minimal(atomic_attr) = (* 1 *) LOWER_WORD
minimal(arith_op_term) = (* 1 *) WILDCARD
minimal(apply_term) = (* 1 *) WILDCARD
minimal(and_term) = (* 1 *) WILDCARD
follow(var_or_wildcard) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD ARROW
follow(var) = WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(typed_var_list) = DOT
follow(typed_var_block) = WILDCARD UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT
follow(typed_ty_var_list) = DOT
follow(typed_ty_var_block) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOT
follow(type_def) = DOT AND
follow(term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND
follow(statement) = error VAL REWRITE LEMMA INCLUDE GOAL EOI DEF DATA ASSERT
follow(separated_nonempty_list(VERTICAL_BAR,constructor)) = DOT AND
follow(separated_nonempty_list(SEMI_COLON,term)) = DOT AND
follow(separated_nonempty_list(COMMA,attr)) = RIGHT_BRACKET
follow(separated_nonempty_list(AND,type_def)) = DOT
follow(separated_nonempty_list(AND,def)) = DOT
follow(raw_var) = WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN RIGHT_BRACKET QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET INTEGER INT IN EQDEF EOI END ELSE DOT COMMA COLON ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(plus_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(parse_ty) = #
follow(parse_term) = #
follow(parse_statement_list) = #
follow(parse_statement) = #
follow(or_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN IN EQDEF EOI END ELSE DOT AND
follow(option(VERTICAL_BAR)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
follow(not_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND
follow(nonempty_list(raw_var)) = COLON
follow(nonempty_list(match_branch)) = END
follow(nonempty_list(atomic_term)) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(nonempty_list(atomic_attr)) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(mutual_types) = DOT
follow(mult_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(match_branch) = VERTICAL_BAR END
follow(mandatory_typed_var_list) = COLON
follow(mandatory_typed_var_block) = LEFT_PAREN COLON
follow(loption(separated_nonempty_list(COMMA,attr))) = RIGHT_BRACKET
follow(list(var_or_wildcard)) = ARROW
follow(list(statement)) = EOI
follow(list(raw_var)) = EQDEF
follow(list(constructor_arg)) = VERTICAL_BAR DOT AND
follow(eq_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV LOGIC_AND IN EQDEF EOI END ELSE DOT AND
follow(def) = DOT AND
follow(constructors) = DOT AND
follow(constructor_arg) = WILDCARD VERTICAL_BAR UPPER_WORD TYPE SINGLE_QUOTED PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN INTEGER INT DOT AND
follow(constructor) = VERTICAL_BAR DOT AND
follow(const) = WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(attrs) = error WILDCARD UPPER_WORD TYPE SINGLE_QUOTED PROP PI MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN INTEGER INT IF FUN ARITH_MINUS
follow(attr) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(atomic_term) = WITH WILDCARD WHERE VERTICAL_BAR UPPER_WORD TYPE THEN SINGLE_QUOTED SEMI_COLON RIGHT_PAREN PROP MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQUIV LOGIC_EQ LOGIC_AND LEFT_PAREN INTEGER INT IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(atomic_attr) = UPPER_WORD SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET QUOTED LOWER_WORD LEFT_PAREN LEFT_BRACKET COMMA
follow(arith_op_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT AND
follow(apply_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQUIV LOGIC_EQ LOGIC_AND IN EQDEF EOI END ELSE DOT ARROW ARITH_PRODUCT ARITH_PLUS ARITH_MINUS ARITH_LT ARITH_LEQ ARITH_GT ARITH_GEQ AND
follow(and_term) = WITH WHERE VERTICAL_BAR THEN SEMI_COLON RIGHT_PAREN LOGIC_OR LOGIC_IMPLY LOGIC_EQUIV IN EQDEF EOI END ELSE DOT AND
Built an LR(0) automaton with 251 states.
The grammar is not SLR(1) -- 1 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 288 states.
112 out of 288 states have a default reduction.
108 out of 288 states are represented.
40 out of 115 symbols keep track of their start position.
28 out of 115 symbols keep track of their end position.
64 out of 129 productions exploit shiftreduce optimization.
16 out of 288 states can peek at an error.
763 functions before inlining, 110 functions after inlining.
